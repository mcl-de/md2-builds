(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser'), require('rxjs'), require('rxjs/operators'), require('@angular/common'), require('@angular/animations'), require('@angular/forms')) :
  typeof define === 'function' && define.amd ? define('angular-md2', ['exports', '@angular/core', '@angular/platform-browser', 'rxjs', 'rxjs/operators', '@angular/common', '@angular/animations', '@angular/forms'], factory) :
  (factory((global['angular-md2'] = {}),global.ng.core,global.ng.platformBrowser,global.rxjs,global.rxjs.operators,global.ng.common,global.ng.animations,global.ng.forms));
}(this, (function (exports,core,platformBrowser,rxjs,operators,common,animations,forms) { 'use strict';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MATERIAL_COMPATIBILITY_MODE = new core.InjectionToken('md-compatibility-mode');
  /**
   * Returns an exception to be thrown if the consumer has used
   * an invalid Material prefix on a component.
   * \@docs-private
   * @param {?} prefix
   * @param {?} nodeName
   * @return {?}
   */
  function getMdCompatibilityInvalidPrefixError(prefix, nodeName) {
      return Error("The \"" + prefix + "-\" prefix cannot be used in ng-material v1 compatibility mode. " +
          ("It was used on an \"" + nodeName.toLowerCase() + "\" element."));
  }
  /** *
   * Selector that matches all elements that may have style collisions with AngularJS Material.
    @type {?} */
  var MAT_ELEMENTS_SELECTOR = "\n  [mat-button],\n  [mat-fab],\n  [mat-icon-button],\n  [mat-mini-fab],\n  [mat-raised-button],\n  [matCardSubtitle],\n  [matCardTitle],\n  [matDialogActions],\n  [matDialogClose],\n  [matDialogContent],\n  [matDialogTitle],\n  [matLine],\n  [matTabLabel],\n  [matTabLink],\n  [matTabNav],\n  [matTooltip],\n  mat-autocomplete,\n  mat-button-toggle,\n  mat-button-toggle,\n  mat-button-toggle-group,\n  mat-card,\n  mat-card-actions,\n  mat-card-content,\n  mat-card-footer,\n  mat-card-header,\n  mat-card-subtitle,\n  mat-card-title,\n  mat-card-title-group,\n  mat-checkbox,\n  mat-chip,\n  mat-dialog-actions,\n  mat-dialog-container,\n  mat-dialog-content,\n  mat-divider,\n  mat-error,\n  mat-grid-list,\n  mat-grid-tile,\n  mat-grid-tile-footer,\n  mat-grid-tile-header,\n  mat-hint,\n  mat-icon,\n  mat-list,\n  mat-list-item,\n  mat-menu,\n  mat-nav-list,\n  mat-option,\n  mat-placeholder,\n  mat-progress-bar,\n  mat-pseudo-checkbox,\n  mat-radio-button,\n  mat-radio-group,\n  mat-select,\n  mat-sidenav,\n  mat-sidenav-container,\n  mat-slider,\n  mat-spinner,\n  mat-tab,\n  mat-tab-group,\n  mat-toolbar";
  /** *
   * Selector that matches all elements that may have style collisions with AngularJS Material.
    @type {?} */
  var MD_ELEMENTS_SELECTOR = "\n  [md-button],\n  [md-fab],\n  [md-icon-button],\n  [md-mini-fab],\n  [md-raised-button],\n  [mdCardSubtitle],\n  [mdCardTitle],\n  [mdDialogActions],\n  [mdDialogClose],\n  [mdDialogContent],\n  [mdDialogTitle],\n  [mdLine],\n  [mdTabLabel],\n  [mdTabLink],\n  [mdTabNav],\n  [mdTooltip],\n  md-autocomplete,\n  md-button-toggle,\n  md-button-toggle,\n  md-button-toggle-group,\n  md-card,\n  md-card-actions,\n  md-card-content,\n  md-card-footer,\n  md-card-header,\n  md-card-subtitle,\n  md-card-title,\n  md-card-title-group,\n  md-checkbox,\n  md-chip,\n  md-dialog-actions,\n  md-dialog-container,\n  md-dialog-content,\n  md-divider,\n  md-error,\n  md-grid-list,\n  md-grid-tile,\n  md-grid-tile-footer,\n  md-grid-tile-header,\n  md-hint,\n  md-icon,\n  md-list,\n  md-list-item,\n  md-menu,\n  md-nav-list,\n  md-option,\n  md-placeholder,\n  md-progress-bar,\n  md-pseudo-checkbox,\n  md-radio-button,\n  md-radio-group,\n  md-select,\n  md-sidenav,\n  md-sidenav-container,\n  md-slider,\n  md-spinner,\n  md-tab,\n  md-tab-group,\n  md-toolbar";
  /**
   * Directive that enforces that the `mat-` prefix cannot be used.
   */
  var MatPrefixRejector = /** @class */ (function () {
      function MatPrefixRejector(isCompatibilityMode, elementRef) {
          if (!isCompatibilityMode) {
              throw getMdCompatibilityInvalidPrefixError('mat', elementRef.nativeElement.nodeName);
          }
      }
      MatPrefixRejector.decorators = [
          { type: core.Directive, args: [{ selector: MAT_ELEMENTS_SELECTOR },] }
      ];
      /** @nocollapse */
      MatPrefixRejector.ctorParameters = function () {
          return [
              { type: Boolean, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_COMPATIBILITY_MODE,] }] },
              { type: core.ElementRef }
          ];
      };
      return MatPrefixRejector;
  }());
  /**
   * Directive that enforces that the `md-` prefix cannot be used.
   */
  var MdPrefixRejector = /** @class */ (function () {
      function MdPrefixRejector(isCompatibilityMode, elementRef) {
          if (isCompatibilityMode) {
              throw getMdCompatibilityInvalidPrefixError('md', elementRef.nativeElement.nodeName);
          }
      }
      MdPrefixRejector.decorators = [
          { type: core.Directive, args: [{ selector: MD_ELEMENTS_SELECTOR },] }
      ];
      /** @nocollapse */
      MdPrefixRejector.ctorParameters = function () {
          return [
              { type: Boolean, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_COMPATIBILITY_MODE,] }] },
              { type: core.ElementRef }
          ];
      };
      return MdPrefixRejector;
  }());
  /**
   * Module that enforces the default compatibility mode settings. When this module is loaded
   * without NoConflictStyleCompatibilityMode also being imported, it will throw an error if
   * there are any uses of the `mat-` prefix.
   */
  var CompatibilityModule = /** @class */ (function () {
      function CompatibilityModule() {
      }
      CompatibilityModule.decorators = [
          { type: core.NgModule, args: [{
                      declarations: [MatPrefixRejector, MdPrefixRejector],
                      exports: [MatPrefixRejector, MdPrefixRejector],
                  },] }
      ];
      return CompatibilityModule;
  }());
  /**
   * Module that enforces "no-conflict" compatibility mode settings. When this module is loaded,
   * it will throw an error if there are any uses of the `md-` prefix.
   */
  var NoConflictStyleCompatibilityMode = /** @class */ (function () {
      function NoConflictStyleCompatibilityMode() {
      }
      NoConflictStyleCompatibilityMode.decorators = [
          { type: core.NgModule, args: [{
                      providers: [{
                              provide: MATERIAL_COMPATIBILITY_MODE, useValue: true,
                          }],
                  },] }
      ];
      return NoConflictStyleCompatibilityMode;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Injection token that configures whether the Material sanity checks are enabled.
    @type {?} */
  var MATERIAL_SANITY_CHECKS = new core.InjectionToken('md-sanity-checks');
  /**
   * Module that captures anything that should be loaded and/or run for *all* Angular Material
   * components. This includes Bidi, compatibility mode, etc.
   *
   * This module should be imported to each top-level component module (e.g., MdTabsModule).
   */
  var MdCommonModule = /** @class */ (function () {
      function MdCommonModule(_document, _sanityChecksEnabled) {
          this._document = _document;
          /**
           * Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype).
           */
          this._hasDoneGlobalChecks = false;
          if (_sanityChecksEnabled && !this._hasDoneGlobalChecks && _document && core.isDevMode()) {
              this._checkDoctype();
              this._checkTheme();
              this._hasDoneGlobalChecks = true;
          }
      }
      /**
       * @return {?}
       */
      MdCommonModule.prototype._checkDoctype = /**
       * @return {?}
       */
          function () {
              if (!this._document.doctype) {
                  console.warn('Current document does not have a doctype. This may cause ' +
                      'some Angular Material components not to behave as expected.');
              }
          };
      /**
       * @return {?}
       */
      MdCommonModule.prototype._checkTheme = /**
       * @return {?}
       */
          function () {
              if (typeof getComputedStyle === 'function') {
                  /** @type {?} */
                  var testElement = this._document.createElement('div');
                  testElement.classList.add('mat-theme-loaded-marker');
                  this._document.body.appendChild(testElement);
                  if (getComputedStyle(testElement).display !== 'none') {
                      console.warn('Could not find Angular Material core theme. Most Material ' +
                          'components may not work as expected. For more info refer ' +
                          'to the theming guide: https://material.angular.io/guide/theming');
                  }
                  this._document.body.removeChild(testElement);
              }
          };
      MdCommonModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [CompatibilityModule],
                      exports: [CompatibilityModule],
                      providers: [{
                              provide: MATERIAL_SANITY_CHECKS, useValue: true,
                          }],
                  },] }
      ];
      /** @nocollapse */
      MdCommonModule.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.DOCUMENT,] }] },
              { type: Boolean, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_SANITY_CHECKS,] }] }
          ];
      };
      return MdCommonModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Shared directive to count lines inside a text area, such as a list item.
   * Line elements can be extracted with a \@ContentChildren(MdLine) query, then
   * counted by checking the query list's length.
   */
  var MdLine = /** @class */ (function () {
      function MdLine() {
      }
      MdLine.decorators = [
          { type: core.Directive, args: [{
                      selector: '[md-line], [mat-line], [mdLine], [matLine]',
                      host: { 'class': 'mat-line' }
                  },] }
      ];
      return MdLine;
  }());
  /**
   * Helper that takes a query list of lines and sets the correct class on the host.
   * \@docs-private
   */
  var /**
   * Helper that takes a query list of lines and sets the correct class on the host.
   * \@docs-private
   */ MdLineSetter = /** @class */ (function () {
      function MdLineSetter(_lines, _renderer, _element) {
          var _this = this;
          this._lines = _lines;
          this._renderer = _renderer;
          this._element = _element;
          this._setLineClass(this._lines.length);
          this._lines.changes.subscribe(function () {
              _this._setLineClass(_this._lines.length);
          });
      }
      /**
       * @param {?} count
       * @return {?}
       */
      MdLineSetter.prototype._setLineClass = /**
       * @param {?} count
       * @return {?}
       */
          function (count) {
              this._resetClasses();
              if (count === 2 || count === 3) {
                  this._setClass("mat-" + count + "-line", true);
              }
              else if (count > 3) {
                  this._setClass("mat-multi-line", true);
              }
          };
      /**
       * @return {?}
       */
      MdLineSetter.prototype._resetClasses = /**
       * @return {?}
       */
          function () {
              this._setClass('mat-2-line', false);
              this._setClass('mat-3-line', false);
              this._setClass('mat-multi-line', false);
          };
      /**
       * @param {?} className
       * @param {?} isAdd
       * @return {?}
       */
      MdLineSetter.prototype._setClass = /**
       * @param {?} className
       * @param {?} isAdd
       * @return {?}
       */
          function (className, isAdd) {
              if (isAdd) {
                  this._renderer.addClass(this._element.nativeElement, className);
              }
              else {
                  this._renderer.removeClass(this._element.nativeElement, className);
              }
          };
      return MdLineSetter;
  }());
  var MdLineModule = /** @class */ (function () {
      function MdLineModule() {
      }
      MdLineModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MdCommonModule],
                      exports: [MdLine, MdCommonModule],
                      declarations: [MdLine],
                  },] }
      ];
      return MdLineModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Directive to listen for changes of direction of part of the DOM.
   *
   * Applications should use this directive instead of the native attribute so that Material
   * components can listen on changes of direction.
   */
  var Dir = /** @class */ (function () {
      function Dir() {
          /**
           * Layout direction of the element.
           */
          this._dir = 'ltr';
          /**
           * Event emitted when the direction changes.
           */
          this.dirChange = new core.EventEmitter();
      }
      Object.defineProperty(Dir.prototype, "dir", {
          /** @docs-private */
          get: /**
           * \@docs-private
           * @return {?}
           */ function () {
              return this._dir;
          },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              /** @type {?} */
              var old = this._dir;
              this._dir = v;
              if (old != this._dir) {
                  this.dirChange.emit();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Dir.prototype, "value", {
          /** Current layout direction of the element. */
          get: /**
           * Current layout direction of the element.
           * @return {?}
           */ function () { return this.dir; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) { this.dir = v; },
          enumerable: true,
          configurable: true
      });
      Dir.decorators = [
          { type: core.Directive, args: [{
                      selector: '[dir]',
                      // TODO(hansl): maybe `$implicit` isn't the best option here, but for now that's the best we got.
                      exportAs: '$implicit'
                  },] }
      ];
      Dir.propDecorators = {
          _dir: [{ type: core.Input, args: ['dir',] }],
          dirChange: [{ type: core.Output }],
          dir: [{ type: core.HostBinding, args: ['attr.dir',] }]
      };
      return Dir;
  }());
  var RtlModule = /** @class */ (function () {
      function RtlModule() {
      }
      RtlModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [Dir],
                      declarations: [Dir]
                  },] }
      ];
      return RtlModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.
   * \@docs-private
   */
  var MdMutationObserverFactory = /** @class */ (function () {
      function MdMutationObserverFactory() {
      }
      /**
       * @param {?} callback
       * @return {?}
       */
      MdMutationObserverFactory.prototype.create = /**
       * @param {?} callback
       * @return {?}
       */
          function (callback) {
              return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);
          };
      MdMutationObserverFactory.decorators = [
          { type: core.Injectable }
      ];
      return MdMutationObserverFactory;
  }());
  /**
   * Directive that triggers a callback whenever the content of
   * its associated element has changed.
   */
  var ObserveContent = /** @class */ (function () {
      function ObserveContent(_mutationObserverFactory, _elementRef) {
          this._mutationObserverFactory = _mutationObserverFactory;
          this._elementRef = _elementRef;
          /**
           * Event emitted for each change in the element's content.
           */
          this.event = new core.EventEmitter();
          /**
           * Used for debouncing the emitted values to the observeContent event.
           */
          this._debouncer = new rxjs.Subject();
      }
      /**
       * @return {?}
       */
      ObserveContent.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.debounce > 0) {
                  this._debouncer
                      .pipe(operators.debounceTime(this.debounce))
                      .subscribe(function (mutations) { return _this.event.emit(mutations); });
              }
              else {
                  this._debouncer.subscribe(function (mutations) { return _this.event.emit(mutations); });
              }
              this._observer = this._mutationObserverFactory.create(function (mutations) {
                  _this._debouncer.next(mutations);
              });
              if (this._observer) {
                  this._observer.observe(this._elementRef.nativeElement, {
                      characterData: true,
                      childList: true,
                      subtree: true
                  });
              }
          };
      /**
       * @return {?}
       */
      ObserveContent.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._observer) {
                  this._observer.disconnect();
                  this._debouncer.complete();
                  this._debouncer = this._observer = null;
              }
          };
      ObserveContent.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkObserveContent]'
                  },] }
      ];
      /** @nocollapse */
      ObserveContent.ctorParameters = function () {
          return [
              { type: MdMutationObserverFactory },
              { type: core.ElementRef }
          ];
      };
      ObserveContent.propDecorators = {
          event: [{ type: core.Output, args: ['cdkObserveContent',] }],
          debounce: [{ type: core.Input }]
      };
      return ObserveContent;
  }());
  var ObserveContentModule = /** @class */ (function () {
      function ObserveContentModule() {
      }
      ObserveContentModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [ObserveContent],
                      declarations: [ObserveContent],
                      providers: [MdMutationObserverFactory]
                  },] }
      ];
      return ObserveContentModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @enum {number} */
  var RippleState = {
      FADING_IN: 0, VISIBLE: 1, FADING_OUT: 2, HIDDEN: 3,
  };
  RippleState[RippleState.FADING_IN] = 'FADING_IN';
  RippleState[RippleState.VISIBLE] = 'VISIBLE';
  RippleState[RippleState.FADING_OUT] = 'FADING_OUT';
  RippleState[RippleState.HIDDEN] = 'HIDDEN';
  /**
   * Reference to a previously launched ripple element.
   */
  var /**
   * Reference to a previously launched ripple element.
   */ RippleRef = /** @class */ (function () {
      function RippleRef(_renderer, element, config) {
          this._renderer = _renderer;
          this.element = element;
          this.config = config;
          /**
           * Current state of the ripple reference.
           */
          this.state = RippleState.HIDDEN;
      }
      /** Fades out the ripple element. */
      /**
       * Fades out the ripple element.
       * @return {?}
       */
      RippleRef.prototype.fadeOut = /**
       * Fades out the ripple element.
       * @return {?}
       */
          function () {
              this._renderer.fadeOutRipple(this);
          };
      return RippleRef;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Fade-in duration for the ripples. Can be modified with the speedFactor option.
    @type {?} */
  var RIPPLE_FADE_IN_DURATION = 450;
  /** *
   * Fade-out duration for the ripples in milliseconds. This can't be modified by the speedFactor.
    @type {?} */
  var RIPPLE_FADE_OUT_DURATION = 400;
  /**
   * Helper service that performs DOM manipulations. Not intended to be used outside this module.
   * The constructor takes a reference to the ripple directive's host element and a map of DOM
   * event handlers to be installed on the element that triggers ripple animations.
   * This will eventually become a custom renderer once Angular support exists.
   * \@docs-private
   */
  var /**
   * Helper service that performs DOM manipulations. Not intended to be used outside this module.
   * The constructor takes a reference to the ripple directive's host element and a map of DOM
   * event handlers to be installed on the element that triggers ripple animations.
   * This will eventually become a custom renderer once Angular support exists.
   * \@docs-private
   */ RippleRenderer = /** @class */ (function () {
      function RippleRenderer(elementRef, _ngZone, _ruler, platform) {
          this._ngZone = _ngZone;
          this._ruler = _ruler;
          /**
           * Whether the mouse is currently down or not.
           */
          this._isMousedown = false;
          /**
           * Events to be registered on the trigger element.
           */
          this._triggerEvents = new Map();
          /**
           * Set of currently active ripple references.
           */
          this._activeRipples = new Set();
          /**
           * Ripple config for all ripples created by events.
           */
          this.rippleConfig = {};
          /**
           * Whether mouse ripples should be created or not.
           */
          this.rippleDisabled = false;
          // Only do anything if we're on the browser.
          if (platform.isBrowser) {
              this._containerElement = elementRef.nativeElement;
              // Specify events which need to be registered on the trigger.
              this._triggerEvents.set('mousedown', this.onMousedown.bind(this));
              this._triggerEvents.set('mouseup', this.onMouseup.bind(this));
              this._triggerEvents.set('mouseleave', this.onMouseLeave.bind(this));
              // By default use the host element as trigger element.
              this.setTriggerElement(this._containerElement);
          }
      }
      /** Fades in a ripple at the given coordinates. */
      /**
       * Fades in a ripple at the given coordinates.
       * @param {?} pageX
       * @param {?} pageY
       * @param {?=} config
       * @return {?}
       */
      RippleRenderer.prototype.fadeInRipple = /**
       * Fades in a ripple at the given coordinates.
       * @param {?} pageX
       * @param {?} pageY
       * @param {?=} config
       * @return {?}
       */
          function (pageX, pageY, config) {
              var _this = this;
              if (config === void 0) {
                  config = {};
              }
              /** @type {?} */
              var containerRect = this._containerElement.getBoundingClientRect();
              if (config.centered) {
                  pageX = containerRect.left + containerRect.width / 2;
                  pageY = containerRect.top + containerRect.height / 2;
              }
              else {
                  /** @type {?} */
                  var scrollPosition = this._ruler.getViewportScrollPosition();
                  pageX -= scrollPosition.left;
                  pageY -= scrollPosition.top;
              }
              /** @type {?} */
              var radius = config.radius || distanceToFurthestCorner(pageX, pageY, containerRect);
              /** @type {?} */
              var duration = RIPPLE_FADE_IN_DURATION * (1 / (config.speedFactor || 1));
              /** @type {?} */
              var offsetX = pageX - containerRect.left;
              /** @type {?} */
              var offsetY = pageY - containerRect.top;
              /** @type {?} */
              var ripple = document.createElement('div');
              ripple.classList.add('mat-ripple-element');
              ripple.style.left = offsetX - radius + "px";
              ripple.style.top = offsetY - radius + "px";
              ripple.style.height = radius * 2 + "px";
              ripple.style.width = radius * 2 + "px";
              // If the color is not set, the default CSS color will be used.
              ripple.style.backgroundColor = config.color;
              ripple.style.transitionDuration = duration + "ms";
              this._containerElement.appendChild(ripple);
              // By default the browser does not recalculate the styles of dynamically created
              // ripple elements. This is critical because then the `scale` would not animate properly.
              enforceStyleRecalculation(ripple);
              ripple.style.transform = 'scale(1)';
              /** @type {?} */
              var rippleRef = new RippleRef(this, ripple, config);
              rippleRef.state = RippleState.FADING_IN;
              // Add the ripple reference to the list of all active ripples.
              this._activeRipples.add(rippleRef);
              // Wait for the ripple element to be completely faded in.
              // Once it's faded in, the ripple can be hidden immediately if the mouse is released.
              this.runTimeoutOutsideZone(function () {
                  rippleRef.state = RippleState.VISIBLE;
                  if (!config.persistent && !_this._isMousedown) {
                      rippleRef.fadeOut();
                  }
              }, duration);
              return rippleRef;
          };
      /** Fades out a ripple reference. */
      /**
       * Fades out a ripple reference.
       * @param {?} rippleRef
       * @return {?}
       */
      RippleRenderer.prototype.fadeOutRipple = /**
       * Fades out a ripple reference.
       * @param {?} rippleRef
       * @return {?}
       */
          function (rippleRef) {
              // For ripples that are not active anymore, don't re-un the fade-out animation.
              if (!this._activeRipples.delete(rippleRef)) {
                  return;
              }
              /** @type {?} */
              var rippleEl = rippleRef.element;
              rippleEl.style.transitionDuration = RIPPLE_FADE_OUT_DURATION + "ms";
              rippleEl.style.opacity = '0';
              rippleRef.state = RippleState.FADING_OUT;
              // Once the ripple faded out, the ripple can be safely removed from the DOM.
              this.runTimeoutOutsideZone(function () {
                  rippleRef.state = RippleState.HIDDEN;
                  rippleEl.parentNode.removeChild(rippleEl);
              }, RIPPLE_FADE_OUT_DURATION);
          };
      /** Fades out all currently active ripples. */
      /**
       * Fades out all currently active ripples.
       * @return {?}
       */
      RippleRenderer.prototype.fadeOutAll = /**
       * Fades out all currently active ripples.
       * @return {?}
       */
          function () {
              this._activeRipples.forEach(function (ripple) { return ripple.fadeOut(); });
          };
      /** Sets the trigger element and registers the mouse events. */
      /**
       * Sets the trigger element and registers the mouse events.
       * @param {?} element
       * @return {?}
       */
      RippleRenderer.prototype.setTriggerElement = /**
       * Sets the trigger element and registers the mouse events.
       * @param {?} element
       * @return {?}
       */
          function (element) {
              var _this = this;
              // Remove all previously register event listeners from the trigger element.
              if (this._triggerElement) {
                  this._triggerEvents.forEach(function (fn, type) { return _this._triggerElement.removeEventListener(type, fn); });
              }
              if (element) {
                  // If the element is not null, register all event listeners on the trigger element.
                  this._ngZone.runOutsideAngular(function () {
                      _this._triggerEvents.forEach(function (fn, type) { return element.addEventListener(type, fn); });
                  });
              }
              this._triggerElement = element;
          };
      /**
       * Listener being called on mousedown event.
       * @param {?} event
       * @return {?}
       */
      RippleRenderer.prototype.onMousedown = /**
       * Listener being called on mousedown event.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!this.rippleDisabled) {
                  this._isMousedown = true;
                  this.fadeInRipple(event.pageX, event.pageY, this.rippleConfig);
              }
          };
      /**
       * Listener being called on mouseup event.
       * @return {?}
       */
      RippleRenderer.prototype.onMouseup = /**
       * Listener being called on mouseup event.
       * @return {?}
       */
          function () {
              this._isMousedown = false;
              // Fade-out all ripples that are completely visible and not persistent.
              this._activeRipples.forEach(function (ripple) {
                  if (!ripple.config.persistent && ripple.state === RippleState.VISIBLE) {
                      ripple.fadeOut();
                  }
              });
          };
      /**
       * Listener being called on mouseleave event.
       * @return {?}
       */
      RippleRenderer.prototype.onMouseLeave = /**
       * Listener being called on mouseleave event.
       * @return {?}
       */
          function () {
              if (this._isMousedown) {
                  this.onMouseup();
              }
          };
      /**
       * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
       * @param {?} fn
       * @param {?=} delay
       * @return {?}
       */
      RippleRenderer.prototype.runTimeoutOutsideZone = /**
       * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
       * @param {?} fn
       * @param {?=} delay
       * @return {?}
       */
          function (fn, delay) {
              if (delay === void 0) {
                  delay = 0;
              }
              this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
          };
      return RippleRenderer;
  }());
  /**
   * Enforces a style recalculation of a DOM element by computing its styles.
   * @param {?} element
   * @return {?}
   */
  function enforceStyleRecalculation(element) {
      // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.
      // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.
      // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
      window.getComputedStyle(element).getPropertyValue('opacity');
  }
  /**
   * Returns the distance from the point (x, y) to the furthest corner of a rectangle.
   * @param {?} x
   * @param {?} y
   * @param {?} rect
   * @return {?}
   */
  function distanceToFurthestCorner(x, y, rect) {
      /** @type {?} */
      var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
      /** @type {?} */
      var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
      return Math.sqrt(distX * distX + distY * distY);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var hasV8BreakIterator = (typeof (Intl) !== 'undefined' && ( /** @type {?} */(Intl)).v8BreakIterator);
  /**
   * Service to detect the current platform by comparing the userAgent strings and
   * checking browser-specific global properties.
   * \@docs-private
   */
  var Platform = /** @class */ (function () {
      function Platform() {
          this.isBrowser = typeof document === 'object' && !!document;
          /**
           * Layout Engines
           */
          this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
          this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
          // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
          this.BLINK = this.isBrowser &&
              (!!(( /** @type {?} */(window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);
          // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
          // ensure that Webkit runs standalone and is not used as another engine's base.
          this.WEBKIT = this.isBrowser &&
              /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
          /**
           * Browsers and Platform Types
           */
          this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !( /** @type {?} */(window)).MSStream;
          // It's difficult to detect the plain Gecko engine, because most of the browsers identify
          // them self as Gecko-like browsers and modify the userAgent's according to that.
          // Since we only cover one explicit Firefox case, we can simply check for Firefox
          // instead of having an unstable check for Gecko.
          this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
          // Trident on mobile adds the android platform to the userAgent to trick detections.
          this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
          // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
          // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
          // Safari browser should also use Webkit as its layout engine.
          this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      }
      Platform.decorators = [
          { type: core.Injectable }
      ];
      return Platform;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Cached result Set of input types support by the current browser.
    @type {?} */
  var supportedInputTypes;
  /** *
   * Types of <input> that *might* be supported.
    @type {?} */
  var candidateInputTypes = [
      'color',
      'button',
      'checkbox',
      'date',
      'datetime-local',
      'email',
      'file',
      'hidden',
      'image',
      'month',
      'number',
      'password',
      'radio',
      'range',
      'reset',
      'search',
      'submit',
      'tel',
      'text',
      'time',
      'url',
      'week',
  ];
  /**
   * @return {?} The input types supported by this browser.
   */
  function getSupportedInputTypes() {
      // Result is cached.
      if (supportedInputTypes) {
          return supportedInputTypes;
      }
      // We can't check if an input type is not supported until we're on the browser, so say that
      // everything is supported when not on the browser. We don't use `Platform` here since it's
      // just a helper function and can't inject it.
      if (typeof document !== 'object' || !document) {
          supportedInputTypes = new Set(candidateInputTypes);
          return supportedInputTypes;
      }
      /** @type {?} */
      var featureTestInput = document.createElement('input');
      supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {
          featureTestInput.setAttribute('type', value);
          return featureTestInput.type === value;
      }));
      return supportedInputTypes;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var PlatformModule = /** @class */ (function () {
      function PlatformModule() {
      }
      PlatformModule.decorators = [
          { type: core.NgModule, args: [{
                      providers: [Platform]
                  },] }
      ];
      return PlatformModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Time in ms to throttle the scrolling events by default.
    @type {?} */
  var DEFAULT_SCROLL_TIME = 20;
  /**
   * Service contained all registered Scrollable references and emits an event when any one of the
   * Scrollable references emit a scrolled event.
   */
  var ScrollDispatcher = /** @class */ (function () {
      function ScrollDispatcher(_ngZone, _platform) {
          this._ngZone = _ngZone;
          this._platform = _platform;
          /**
           * Subject for notifying that a registered scrollable reference element has been scrolled.
           */
          this._scrolled = new rxjs.Subject();
          /**
           * Keeps track of the global `scroll` and `resize` subscriptions.
           */
          this._globalSubscription = null;
          /**
           * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.
           */
          this._scrolledCount = 0;
          /**
           * Map of all the scrollable references that are registered with the service and their
           * scroll event subscriptions.
           */
          this.scrollableReferences = new Map();
      }
      /**
       * Registers a Scrollable with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event in its scrolled observable.
       * @param scrollable Scrollable instance to be registered.
       */
      /**
       * Registers a Scrollable with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event in its scrolled observable.
       * @param {?} scrollable Scrollable instance to be registered.
       * @return {?}
       */
      ScrollDispatcher.prototype.register = /**
       * Registers a Scrollable with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event in its scrolled observable.
       * @param {?} scrollable Scrollable instance to be registered.
       * @return {?}
       */
          function (scrollable) {
              var _this = this;
              /** @type {?} */
              var scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });
              this.scrollableReferences.set(scrollable, scrollSubscription);
          };
      /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param scrollable Scrollable instance to be deregistered.
       */
      /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param {?} scrollable Scrollable instance to be deregistered.
       * @return {?}
       */
      ScrollDispatcher.prototype.deregister = /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param {?} scrollable Scrollable instance to be deregistered.
       * @return {?}
       */
          function (scrollable) {
              if (this.scrollableReferences.has(scrollable)) {
                  this.scrollableReferences.get(scrollable).unsubscribe();
                  this.scrollableReferences.delete(scrollable);
              }
          };
      /**
       * Subscribes to an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       */
      /**
       * Subscribes to an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       * @param {?=} auditTimeInMs
       * @param {?=} callback
       * @return {?}
       */
      ScrollDispatcher.prototype.scrolled = /**
       * Subscribes to an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       * @param {?=} auditTimeInMs
       * @param {?=} callback
       * @return {?}
       */
          function (auditTimeInMs, callback) {
              var _this = this;
              if (auditTimeInMs === void 0) {
                  auditTimeInMs = DEFAULT_SCROLL_TIME;
              }
              // Scroll events can only happen on the browser, so do nothing if we're not on the browser.
              if (!this._platform.isBrowser) {
                  return rxjs.Subscription.EMPTY;
              }
              /** @type {?} */
              var observable = auditTimeInMs > 0 ?
                  this._scrolled.asObservable().pipe(operators.auditTime(auditTimeInMs)) :
                  this._scrolled.asObservable();
              this._scrolledCount++;
              if (!this._globalSubscription) {
                  this._globalSubscription = this._ngZone.runOutsideAngular(function () {
                      return rxjs.merge(rxjs.fromEvent(window.document, 'scroll'), rxjs.fromEvent(window, 'resize')).subscribe(function () { return _this._notify(); });
                  });
              }
              /** @type {?} */
              var subscription = observable.subscribe(callback);
              subscription.add(function () {
                  _this._scrolledCount--;
                  if (_this._globalSubscription && !_this.scrollableReferences.size && !_this._scrolledCount) {
                      _this._globalSubscription.unsubscribe();
                      _this._globalSubscription = null;
                  }
              });
              return subscription;
          };
      /** Returns all registered Scrollables that contain the provided element. */
      /**
       * Returns all registered Scrollables that contain the provided element.
       * @param {?} elementRef
       * @return {?}
       */
      ScrollDispatcher.prototype.getScrollContainers = /**
       * Returns all registered Scrollables that contain the provided element.
       * @param {?} elementRef
       * @return {?}
       */
          function (elementRef) {
              var _this = this;
              /** @type {?} */
              var scrollingContainers = [];
              this.scrollableReferences.forEach(function (_subscription, scrollable) {
                  if (_this.scrollableContainsElement(scrollable, elementRef)) {
                      scrollingContainers.push(scrollable);
                  }
              });
              return scrollingContainers;
          };
      /** Returns true if the element is contained within the provided Scrollable. */
      /**
       * Returns true if the element is contained within the provided Scrollable.
       * @param {?} scrollable
       * @param {?} elementRef
       * @return {?}
       */
      ScrollDispatcher.prototype.scrollableContainsElement = /**
       * Returns true if the element is contained within the provided Scrollable.
       * @param {?} scrollable
       * @param {?} elementRef
       * @return {?}
       */
          function (scrollable, elementRef) {
              /** @type {?} */
              var element = elementRef.nativeElement;
              /** @type {?} */
              var scrollableElement = scrollable.getElementRef().nativeElement;
              // Traverse through the element parents until we reach null, checking if any of the elements
              // are the scrollable's element.
              do {
                  if (element == scrollableElement) {
                      return true;
                  }
              } while (element = element.parentElement);
          };
      /** Sends a notification that a scroll event has been fired. */
      /**
       * Sends a notification that a scroll event has been fired.
       * @return {?}
       */
      ScrollDispatcher.prototype._notify = /**
       * Sends a notification that a scroll event has been fired.
       * @return {?}
       */
          function () {
              this._scrolled.next();
          };
      ScrollDispatcher.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      ScrollDispatcher.ctorParameters = function () {
          return [
              { type: core.NgZone },
              { type: Platform }
          ];
      };
      return ScrollDispatcher;
  }());
  /**
   * @param {?} parentDispatcher
   * @param {?} ngZone
   * @param {?} platform
   * @return {?}
   */
  function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
      return parentDispatcher || new ScrollDispatcher(ngZone, platform);
  }
  /** @type {?} */
  var SCROLL_DISPATCHER_PROVIDER = {
      // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
      provide: ScrollDispatcher,
      deps: [[new core.Optional(), new core.SkipSelf(), ScrollDispatcher], core.NgZone, Platform],
      useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Simple utility for getting the bounds of the browser viewport.
   * \@docs-private
   */
  var ViewportRuler = /** @class */ (function () {
      function ViewportRuler(scrollDispatcher) {
          var _this = this;
          // Subscribe to scroll and resize events and update the document rectangle on changes.
          scrollDispatcher.scrolled(null, function () { return _this._cacheViewportGeometry(); });
      }
      /** Gets a ClientRect for the viewport's bounds. */
      /**
       * Gets a ClientRect for the viewport's bounds.
       * @param {?=} documentRect
       * @return {?}
       */
      ViewportRuler.prototype.getViewportRect = /**
       * Gets a ClientRect for the viewport's bounds.
       * @param {?=} documentRect
       * @return {?}
       */
          function (documentRect) {
              if (documentRect === void 0) {
                  documentRect = this._documentRect;
              }
              // Cache the document bounding rect so that we don't recompute it for multiple calls.
              if (!documentRect) {
                  this._cacheViewportGeometry();
                  documentRect = this._documentRect;
              }
              /** @type {?} */
              var scrollPosition = this.getViewportScrollPosition(documentRect);
              /** @type {?} */
              var height = window.innerHeight;
              /** @type {?} */
              var width = window.innerWidth;
              return {
                  top: scrollPosition.top,
                  left: scrollPosition.left,
                  bottom: scrollPosition.top + height,
                  right: scrollPosition.left + width,
                  height: height,
                  width: width,
              };
          };
      /**
       * Gets the (top, left) scroll position of the viewport.
       * @param documentRect
       */
      /**
       * Gets the (top, left) scroll position of the viewport.
       * @param {?=} documentRect
       * @return {?}
       */
      ViewportRuler.prototype.getViewportScrollPosition = /**
       * Gets the (top, left) scroll position of the viewport.
       * @param {?=} documentRect
       * @return {?}
       */
          function (documentRect) {
              if (documentRect === void 0) {
                  documentRect = this._documentRect;
              }
              // Cache the document bounding rect so that we don't recompute it for multiple calls.
              if (!documentRect) {
                  this._cacheViewportGeometry();
                  documentRect = this._documentRect;
              }
              /** @type {?} */
              var top = -documentRect.top || document.body.scrollTop || window.scrollY ||
                  document.documentElement.scrollTop || 0;
              /** @type {?} */
              var left = -documentRect.left || document.body.scrollLeft || window.scrollX ||
                  document.documentElement.scrollLeft || 0;
              return { top: top, left: left };
          };
      /** Caches the latest client rectangle of the document element. */
      /**
       * Caches the latest client rectangle of the document element.
       * @return {?}
       */
      ViewportRuler.prototype._cacheViewportGeometry = /**
       * Caches the latest client rectangle of the document element.
       * @return {?}
       */
          function () {
              this._documentRect = document.documentElement.getBoundingClientRect();
          };
      ViewportRuler.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      ViewportRuler.ctorParameters = function () {
          return [
              { type: ScrollDispatcher }
          ];
      };
      return ViewportRuler;
  }());
  /**
   * @param {?} parentRuler
   * @param {?} scrollDispatcher
   * @return {?}
   */
  function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, scrollDispatcher) {
      return parentRuler || new ViewportRuler(scrollDispatcher);
  }
  /** @type {?} */
  var VIEWPORT_RULER_PROVIDER = {
      // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
      provide: ViewportRuler,
      deps: [[new core.Optional(), new core.SkipSelf(), ViewportRuler], ScrollDispatcher],
      useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Injection token that can be used to specify the global ripple options.
    @type {?} */
  var MD_RIPPLE_GLOBAL_OPTIONS = new core.InjectionToken('md-ripple-global-options');
  var MdRipple = /** @class */ (function () {
      function MdRipple(elementRef, ngZone, ruler, platform, globalOptions) {
          /**
           * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
           * will be the distance from the center of the ripple to the furthest corner of the host element's
           * bounding rectangle.
           */
          this.radius = 0;
          /**
           * If set, the normal duration of ripple animations is divided by this value. For example,
           * setting it to 0.5 will cause the animations to take twice as long.
           * A changed speedFactor will not modify the fade-out duration of the ripples.
           */
          this.speedFactor = 1;
          this._rippleRenderer = new RippleRenderer(elementRef, ngZone, ruler, platform);
          this._globalOptions = globalOptions ? globalOptions : {};
          this._updateRippleRenderer();
      }
      /**
       * @param {?} changes
       * @return {?}
       */
      MdRipple.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (changes['trigger'] && this.trigger) {
                  this._rippleRenderer.setTriggerElement(this.trigger);
              }
              this._updateRippleRenderer();
          };
      /**
       * @return {?}
       */
      MdRipple.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              // Set the trigger element to null to cleanup all listeners.
              this._rippleRenderer.setTriggerElement(null);
          };
      /** Launches a manual ripple at the specified position. */
      /**
       * Launches a manual ripple at the specified position.
       * @param {?} pageX
       * @param {?} pageY
       * @param {?=} config
       * @return {?}
       */
      MdRipple.prototype.launch = /**
       * Launches a manual ripple at the specified position.
       * @param {?} pageX
       * @param {?} pageY
       * @param {?=} config
       * @return {?}
       */
          function (pageX, pageY, config) {
              if (config === void 0) {
                  config = this.rippleConfig;
              }
              return this._rippleRenderer.fadeInRipple(pageX, pageY, config);
          };
      /** Fades out all currently showing ripple elements. */
      /**
       * Fades out all currently showing ripple elements.
       * @return {?}
       */
      MdRipple.prototype.fadeOutAll = /**
       * Fades out all currently showing ripple elements.
       * @return {?}
       */
          function () {
              this._rippleRenderer.fadeOutAll();
          };
      Object.defineProperty(MdRipple.prototype, "rippleConfig", {
          /** Ripple configuration from the directive's input values. */
          get: /**
           * Ripple configuration from the directive's input values.
           * @return {?}
           */ function () {
              return {
                  centered: this.centered,
                  speedFactor: this.speedFactor * (this._globalOptions.baseSpeedFactor || 1),
                  radius: this.radius,
                  color: this.color
              };
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Updates the ripple renderer with the latest ripple configuration.
       * @return {?}
       */
      MdRipple.prototype._updateRippleRenderer = /**
       * Updates the ripple renderer with the latest ripple configuration.
       * @return {?}
       */
          function () {
              this._rippleRenderer.rippleDisabled = this._globalOptions.disabled || this.disabled;
              this._rippleRenderer.rippleConfig = this.rippleConfig;
          };
      MdRipple.decorators = [
          { type: core.Directive, args: [{
                      selector: '[md-ripple], [mat-ripple], [mdRipple], [matRipple]',
                      exportAs: 'mdRipple',
                      host: {
                          'class': 'mat-ripple',
                          '[class.mat-ripple-unbounded]': 'unbounded'
                      }
                  },] }
      ];
      /** @nocollapse */
      MdRipple.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: ViewportRuler },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MD_RIPPLE_GLOBAL_OPTIONS,] }] }
          ];
      };
      MdRipple.propDecorators = {
          trigger: [{ type: core.Input, args: ['mdRippleTrigger',] }],
          centered: [{ type: core.Input, args: ['mdRippleCentered',] }],
          disabled: [{ type: core.Input, args: ['mdRippleDisabled',] }],
          radius: [{ type: core.Input, args: ['mdRippleRadius',] }],
          speedFactor: [{ type: core.Input, args: ['mdRippleSpeedFactor',] }],
          color: [{ type: core.Input, args: ['mdRippleColor',] }],
          unbounded: [{ type: core.Input, args: ['mdRippleUnbounded',] }]
      };
      return MdRipple;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Sends an event when the directive's element is scrolled. Registers itself with the
   * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
   * can be listened to through the service.
   */
  var Scrollable = /** @class */ (function () {
      function Scrollable(_elementRef, _scroll, _ngZone, _renderer) {
          this._elementRef = _elementRef;
          this._scroll = _scroll;
          this._ngZone = _ngZone;
          this._renderer = _renderer;
          this._elementScrolled = new rxjs.Subject();
      }
      /**
       * @return {?}
       */
      Scrollable.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._scrollListener = this._ngZone.runOutsideAngular(function () {
                  return _this._renderer.listen(_this.getElementRef().nativeElement, 'scroll', function (event) {
                      _this._elementScrolled.next(event);
                  });
              });
              this._scroll.register(this);
          };
      /**
       * @return {?}
       */
      Scrollable.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._scroll.deregister(this);
              if (this._scrollListener) {
                  this._scrollListener();
                  this._scrollListener = null;
              }
          };
      /**
       * Returns observable that emits when a scroll event is fired on the host element.
       */
      /**
       * Returns observable that emits when a scroll event is fired on the host element.
       * @return {?}
       */
      Scrollable.prototype.elementScrolled = /**
       * Returns observable that emits when a scroll event is fired on the host element.
       * @return {?}
       */
          function () {
              return this._elementScrolled.asObservable();
          };
      /**
       * @return {?}
       */
      Scrollable.prototype.getElementRef = /**
       * @return {?}
       */
          function () {
              return this._elementRef;
          };
      Scrollable.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-scrollable], [cdkScrollable]'
                  },] }
      ];
      /** @nocollapse */
      Scrollable.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.NgZone },
              { type: core.Renderer2 }
          ];
      };
      return Scrollable;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
   * @return {?}
   */
  function getMdScrollStrategyAlreadyAttachedError() {
      return Error("Scroll strategy has already been attached.");
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Strategy that will close the overlay as soon as the user starts scrolling.
   */
  var /**
   * Strategy that will close the overlay as soon as the user starts scrolling.
   */ CloseScrollStrategy = /** @class */ (function () {
      function CloseScrollStrategy(_scrollDispatcher) {
          this._scrollDispatcher = _scrollDispatcher;
          this._scrollSubscription = null;
      }
      /**
       * @param {?} overlayRef
       * @return {?}
       */
      CloseScrollStrategy.prototype.attach = /**
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              if (this._overlayRef) {
                  throw getMdScrollStrategyAlreadyAttachedError();
              }
              this._overlayRef = overlayRef;
          };
      /**
       * @return {?}
       */
      CloseScrollStrategy.prototype.enable = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._scrollSubscription) {
                  this._scrollSubscription = this._scrollDispatcher.scrolled(null, function () {
                      if (_this._overlayRef.hasAttached()) {
                          _this._overlayRef.detach();
                      }
                      _this.disable();
                  });
              }
          };
      /**
       * @return {?}
       */
      CloseScrollStrategy.prototype.disable = /**
       * @return {?}
       */
          function () {
              if (this._scrollSubscription) {
                  this._scrollSubscription.unsubscribe();
                  this._scrollSubscription = null;
              }
          };
      return CloseScrollStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Scroll strategy that doesn't do anything.
   */
  var /**
   * Scroll strategy that doesn't do anything.
   */ NoopScrollStrategy = /** @class */ (function () {
      function NoopScrollStrategy() {
      }
      /**
       * @return {?}
       */
      NoopScrollStrategy.prototype.enable = /**
       * @return {?}
       */
          function () { };
      /**
       * @return {?}
       */
      NoopScrollStrategy.prototype.disable = /**
       * @return {?}
       */
          function () { };
      /**
       * @return {?}
       */
      NoopScrollStrategy.prototype.attach = /**
       * @return {?}
       */
          function () { };
      return NoopScrollStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Strategy that will prevent the user from scrolling while the overlay is visible.
   */
  var /**
   * Strategy that will prevent the user from scrolling while the overlay is visible.
   */ BlockScrollStrategy = /** @class */ (function () {
      function BlockScrollStrategy(_viewportRuler) {
          this._viewportRuler = _viewportRuler;
          this._previousHTMLStyles = { top: '', left: '' };
          this._isEnabled = false;
      }
      /**
       * @return {?}
       */
      BlockScrollStrategy.prototype.attach = /**
       * @return {?}
       */
          function () { };
      /**
       * @return {?}
       */
      BlockScrollStrategy.prototype.enable = /**
       * @return {?}
       */
          function () {
              if (this._canBeEnabled()) {
                  /** @type {?} */
                  var root = document.documentElement;
                  this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
                  // Cache the previous inline styles in case the user had set them.
                  this._previousHTMLStyles.left = root.style.left;
                  this._previousHTMLStyles.top = root.style.top;
                  // Note: we're using the `html` node, instead of the `body`, because the `body` may
                  // have the user agent margin, whereas the `html` is guaranteed not to have one.
                  root.style.left = -this._previousScrollPosition.left + "px";
                  root.style.top = -this._previousScrollPosition.top + "px";
                  root.classList.add('cdk-global-scrollblock');
                  this._isEnabled = true;
              }
          };
      /**
       * @return {?}
       */
      BlockScrollStrategy.prototype.disable = /**
       * @return {?}
       */
          function () {
              if (this._isEnabled) {
                  this._isEnabled = false;
                  document.documentElement.style.left = this._previousHTMLStyles.left;
                  document.documentElement.style.top = this._previousHTMLStyles.top;
                  document.documentElement.classList.remove('cdk-global-scrollblock');
                  window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
              }
          };
      /**
       * @return {?}
       */
      BlockScrollStrategy.prototype._canBeEnabled = /**
       * @return {?}
       */
          function () {
              // Since the scroll strategies can't be singletons, we have to use a global CSS class
              // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
              // scrolling multiple times.
              if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
                  return false;
              }
              /** @type {?} */
              var body = document.body;
              /** @type {?} */
              var viewport = this._viewportRuler.getViewportRect();
              return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
          };
      return BlockScrollStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Strategy that will update the element position as the user is scrolling.
   */
  var /**
   * Strategy that will update the element position as the user is scrolling.
   */ RepositionScrollStrategy = /** @class */ (function () {
      function RepositionScrollStrategy(_scrollDispatcher, _config) {
          this._scrollDispatcher = _scrollDispatcher;
          this._config = _config;
          this._scrollSubscription = null;
      }
      /**
       * @param {?} overlayRef
       * @return {?}
       */
      RepositionScrollStrategy.prototype.attach = /**
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              if (this._overlayRef) {
                  throw getMdScrollStrategyAlreadyAttachedError();
              }
              this._overlayRef = overlayRef;
          };
      /**
       * @return {?}
       */
      RepositionScrollStrategy.prototype.enable = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._scrollSubscription) {
                  /** @type {?} */
                  var throttle = this._config ? this._config.scrollThrottle : 0;
                  this._scrollSubscription = this._scrollDispatcher.scrolled(throttle, function () {
                      _this._overlayRef.updatePosition();
                  });
              }
          };
      /**
       * @return {?}
       */
      RepositionScrollStrategy.prototype.disable = /**
       * @return {?}
       */
          function () {
              if (this._scrollSubscription) {
                  this._scrollSubscription.unsubscribe();
                  this._scrollSubscription = null;
              }
          };
      return RepositionScrollStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Options for how an overlay will handle scrolling.
   *
   * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
   * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
   */
  var ScrollStrategyOptions = /** @class */ (function () {
      function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler) {
          var _this = this;
          this._scrollDispatcher = _scrollDispatcher;
          this._viewportRuler = _viewportRuler;
          /**
           * Do nothing on scroll.
           */
          this.noop = function () { return new NoopScrollStrategy(); };
          /**
           * Close the overlay as soon as the user scrolls.
           */
          this.close = function () { return new CloseScrollStrategy(_this._scrollDispatcher); };
          /**
           * Block scrolling.
           */
          this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };
          /**
           * Update the overlay's position on scroll.
           * @param config Configuration to be used inside the scroll strategy.
           * Allows debouncing the reposition calls.
           */
          this.reposition = function (config) {
              return new RepositionScrollStrategy(_this._scrollDispatcher, config);
          };
      }
      ScrollStrategyOptions.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      ScrollStrategyOptions.ctorParameters = function () {
          return [
              { type: ScrollDispatcher },
              { type: ViewportRuler }
          ];
      };
      return ScrollStrategyOptions;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var ScrollDispatchModule = /** @class */ (function () {
      function ScrollDispatchModule() {
      }
      ScrollDispatchModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [PlatformModule],
                      exports: [Scrollable],
                      declarations: [Scrollable],
                      providers: [SCROLL_DISPATCHER_PROVIDER, ScrollStrategyOptions],
                  },] }
      ];
      return ScrollDispatchModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdRippleModule = /** @class */ (function () {
      function MdRippleModule() {
      }
      MdRippleModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MdCommonModule, PlatformModule, ScrollDispatchModule],
                      exports: [MdRipple, MdCommonModule],
                      declarations: [MdRipple],
                      providers: [VIEWPORT_RULER_PROVIDER],
                  },] }
      ];
      return MdRippleModule;
  }());

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */
  var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b)
              if (b.hasOwnProperty(p))
                  d[p] = b[p]; };
      return extendStatics(d, b);
  };
  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __values(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m)
          return m.call(o);
      return {
          next: function () {
              if (o && i >= o.length)
                  o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
  }
  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
          return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
      }
      catch (error) {
          e = { error: error };
      }
      finally {
          try {
              if (r && !r.done && (m = i["return"]))
                  m.call(i);
          }
          finally {
              if (e)
                  throw e.error;
          }
      }
      return ar;
  }
  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `color` property.
   * @template T
   * @param {?} base
   * @param {?=} defaultColor
   * @return {?}
   */
  function mixinColor(base, defaultColor) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, __spread(args)) || this;
              _this._color = null;
              // Set the default color that can be specified from the mixin.
              // Set the default color that can be specified from the mixin.
              _this.color = defaultColor;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "color", {
              get: /**
               * @return {?}
               */ function () { return this._color; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) {
                  /** @type {?} */
                  var colorPalette = value || defaultColor;
                  if (colorPalette !== this._color) {
                      if (this._color) {
                          this._renderer.removeClass(this._elementRef.nativeElement, "mat-" + this._color);
                      }
                      if (colorPalette) {
                          this._renderer.addClass(this._elementRef.nativeElement, "mat-" + colorPalette);
                      }
                      this._color = colorPalette;
                  }
              },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdPseudoCheckboxBase = /** @class */ (function () {
      function MdPseudoCheckboxBase(_renderer, _elementRef) {
          this._renderer = _renderer;
          this._elementRef = _elementRef;
      }
      return MdPseudoCheckboxBase;
  }());
  /** @type {?} */
  var _MdPseudoCheckboxBase = mixinColor(MdPseudoCheckboxBase, 'accent');
  /**
   * Component that shows a simplified checkbox without including any kind of "real" checkbox.
   * Meant to be used when the checkbox is purely decorative and a large number of them will be
   * included, such as for the options in a multi-select. Uses no SVGs or complex animations.
   *
   * Note that this component will be completely invisible to screen-reader users. This is *not*
   * interchangeable with <md-checkbox> and should *not* be used if the user would directly interact
   * with the checkbox. The pseudo-checkbox should only be used as an implementation detail of
   * more complex components that appropriately handle selected / checked state.
   * \@docs-private
   */
  var MdPseudoCheckbox = /** @class */ (function (_super) {
      __extends(MdPseudoCheckbox, _super);
      function MdPseudoCheckbox(elementRef, renderer) {
          var _this = _super.call(this, renderer, elementRef) || this;
          /**
           * Display state of the checkbox.
           */
          _this.state = 'unchecked';
          /**
           * Whether the checkbox is disabled.
           */
          _this.disabled = false;
          return _this;
      }
      MdPseudoCheckbox.decorators = [
          { type: core.Component, args: [{
                      encapsulation: core.ViewEncapsulation.None,
                      selector: 'md-pseudo-checkbox, mat-pseudo-checkbox',
                      inputs: ['color'],
                      template: '',
                      host: {
                          'class': 'mat-pseudo-checkbox',
                          '[class.mat-pseudo-checkbox-indeterminate]': 'state === "indeterminate"',
                          '[class.mat-pseudo-checkbox-checked]': 'state === "checked"',
                          '[class.mat-pseudo-checkbox-disabled]': 'disabled',
                      },
                      styles: [".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:'';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:9px;left:2px;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:5px;left:3px;width:12px;height:5px;border-left:2px solid currentColor;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);opacity:1}"]
                  }] }
      ];
      /** @nocollapse */
      MdPseudoCheckbox.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.Renderer2 }
          ];
      };
      MdPseudoCheckbox.propDecorators = {
          state: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return MdPseudoCheckbox;
  }(_MdPseudoCheckboxBase));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdSelectionModule = /** @class */ (function () {
      function MdSelectionModule() {
      }
      MdSelectionModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [MdPseudoCheckbox],
                      declarations: [MdPseudoCheckbox]
                  },] }
      ];
      return MdSelectionModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  // Due to a bug in the ChromeDriver, Angular keyboard events are not triggered by `sendKeys`
  // during E2E tests when using dot notation such as `(keydown.rightArrow)`. To get around this,
  // we are temporarily using a single (keydown) handler.
  // See: https://github.com/angular/angular/issues/9419
  /** @type {?} */
  var UP_ARROW = 38;
  /** @type {?} */
  var DOWN_ARROW = 40;
  /** @type {?} */
  var RIGHT_ARROW = 39;
  /** @type {?} */
  var LEFT_ARROW = 37;
  /** @type {?} */
  var PAGE_UP = 33;
  /** @type {?} */
  var PAGE_DOWN = 34;
  /** @type {?} */
  var HOME = 36;
  /** @type {?} */
  var END = 35;
  /** @type {?} */
  var ENTER = 13;
  /** @type {?} */
  var SPACE = 32;
  /** @type {?} */
  var TAB = 9;
  /** @type {?} */
  var ESCAPE = 27;
  /** @type {?} */
  var BACKSPACE = 8;
  /** @type {?} */
  var DELETE = 46;
  /** @type {?} */
  var COMMA = 188;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Coerces a data-bound value (typically a string) to a boolean.
   * @param {?} value
   * @return {?}
   */
  function coerceBooleanProperty(value) {
      return value != null && "" + value !== 'false';
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `disabled` property.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinDisabled(base) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, __spread(args)) || this;
              _this._disabled = false;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "disabled", {
              get: /**
               * @return {?}
               */ function () { return this._disabled; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) { this._disabled = coerceBooleanProperty(value); },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdOptgroupBase = /** @class */ (function () {
      function MdOptgroupBase() {
      }
      return MdOptgroupBase;
  }());
  /** @type {?} */
  var _MdOptgroupMixinBase = mixinDisabled(MdOptgroupBase);
  /** @type {?} */
  var _uniqueOptgroupIdCounter = 0;
  /**
   * Component that is used to group instances of `md-option`.
   */
  var MdOptgroup = /** @class */ (function (_super) {
      __extends(MdOptgroup, _super);
      function MdOptgroup() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Unique id for the underlying label.
           */
          _this._labelId = "mat-optgroup-label-" + _uniqueOptgroupIdCounter++;
          return _this;
      }
      MdOptgroup.decorators = [
          { type: core.Component, args: [{
                      selector: 'md-optgroup, mat-optgroup',
                      template: "<label class=\"mat-optgroup-label\" [id]=\"_labelId\">{{ label }}</label>\n<ng-content select=\"md-option, mat-option\"></ng-content>\n",
                      encapsulation: core.ViewEncapsulation.None,
                      inputs: ['disabled'],
                      host: {
                          'class': 'mat-optgroup',
                          'role': 'group',
                          '[class.mat-optgroup-disabled]': 'disabled',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-labelledby]': '_labelId',
                      }
                  }] }
      ];
      MdOptgroup.propDecorators = {
          label: [{ type: core.Input }]
      };
      return MdOptgroup;
  }(_MdOptgroupMixinBase));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Option IDs need to be unique across components, so this counter exists outside of
   * the component definition.
    @type {?} */
  var _uniqueIdCounter = 0;
  /**
   * Event object emitted by MdOption when selected or deselected.
   */
  var /**
   * Event object emitted by MdOption when selected or deselected.
   */ MdOptionSelectionChange = /** @class */ (function () {
      function MdOptionSelectionChange(source, isUserInput) {
          if (isUserInput === void 0) {
              isUserInput = false;
          }
          this.source = source;
          this.isUserInput = isUserInput;
      }
      return MdOptionSelectionChange;
  }());
  /**
   * Single option inside of a `<md-select>` element.
   */
  var MdOption = /** @class */ (function () {
      function MdOption(_element, group, _isCompatibilityMode) {
          this._element = _element;
          this.group = group;
          this._isCompatibilityMode = _isCompatibilityMode;
          this._selected = false;
          this._active = false;
          /**
           * Whether the option is disabled.
           */
          this._disabled = false;
          this._id = "md-option-" + _uniqueIdCounter++;
          /**
           * Whether the wrapping component is in multiple selection mode.
           */
          this.multiple = false;
          /**
           * Event emitted when the option is selected or deselected.
           */
          this.onSelectionChange = new core.EventEmitter();
      }
      Object.defineProperty(MdOption.prototype, "id", {
          /** The unique ID of the option. */
          get: /**
           * The unique ID of the option.
           * @return {?}
           */ function () { return this._id; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdOption.prototype, "selected", {
          /** Whether or not the option is currently selected. */
          get: /**
           * Whether or not the option is currently selected.
           * @return {?}
           */ function () { return this._selected; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdOption.prototype, "disabled", {
          /** Whether the option is disabled. */
          get: /**
           * Whether the option is disabled.
           * @return {?}
           */ function () { return (this.group && this.group.disabled) || this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdOption.prototype, "active", {
          /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           */
          get: /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           * @return {?}
           */ function () {
              return this._active;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdOption.prototype, "viewValue", {
          /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           */
          get: /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           * @return {?}
           */ function () {
              // TODO(kara): Add input property alternative for node envs.
              return this._getHostElement().textContent.trim();
          },
          enumerable: true,
          configurable: true
      });
      /** Selects the option. */
      /**
       * Selects the option.
       * @return {?}
       */
      MdOption.prototype.select = /**
       * Selects the option.
       * @return {?}
       */
          function () {
              this._selected = true;
              this._emitSelectionChangeEvent();
          };
      /** Deselects the option. */
      /**
       * Deselects the option.
       * @return {?}
       */
      MdOption.prototype.deselect = /**
       * Deselects the option.
       * @return {?}
       */
          function () {
              this._selected = false;
              this._emitSelectionChangeEvent();
          };
      /** Sets focus onto this option. */
      /**
       * Sets focus onto this option.
       * @return {?}
       */
      MdOption.prototype.focus = /**
       * Sets focus onto this option.
       * @return {?}
       */
          function () {
              this._getHostElement().focus();
          };
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      MdOption.prototype.setActiveStyles = /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              this._active = true;
          };
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      MdOption.prototype.setInactiveStyles = /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              this._active = false;
          };
      /** Ensures the option is selected when activated from the keyboard. */
      /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
      MdOption.prototype._handleKeydown = /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.keyCode === ENTER || event.keyCode === SPACE) {
                  this._selectViaInteraction();
              }
          };
      /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       */
      /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       * @return {?}
       */
      MdOption.prototype._selectViaInteraction = /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this._selected = this.multiple ? !this._selected : true;
                  this._emitSelectionChangeEvent(true);
              }
          };
      /** Returns the correct tabindex for the option depending on disabled state. */
      /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
      MdOption.prototype._getTabIndex = /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
          function () {
              return this.disabled ? '-1' : '0';
          };
      /** Fetches the host DOM element. */
      /**
       * Fetches the host DOM element.
       * @return {?}
       */
      MdOption.prototype._getHostElement = /**
       * Fetches the host DOM element.
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      /**
       * Emits the selection change event.
       * @param {?=} isUserInput
       * @return {?}
       */
      MdOption.prototype._emitSelectionChangeEvent = /**
       * Emits the selection change event.
       * @param {?=} isUserInput
       * @return {?}
       */
          function (isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              this.onSelectionChange.emit(new MdOptionSelectionChange(this, isUserInput));
          };
      MdOption.decorators = [
          { type: core.Component, args: [{
                      selector: 'md-option, mat-option',
                      host: {
                          'role': 'option',
                          '[attr.tabindex]': '_getTabIndex()',
                          '[class.mat-selected]': 'selected',
                          '[class.mat-option-multiple]': 'multiple',
                          '[class.mat-active]': 'active',
                          '[id]': 'id',
                          '[attr.aria-selected]': 'selected.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[class.mat-option-disabled]': 'disabled',
                          '(click)': '_selectViaInteraction()',
                          '(keydown)': '_handleKeydown($event)',
                          '[class.mat-option]': 'true',
                      },
                      template: "<span [ngSwitch]=\"_isCompatibilityMode\" *ngIf=\"multiple\">\n  <mat-pseudo-checkbox class=\"mat-option-pseudo-checkbox\" *ngSwitchCase=\"true\"\n      [state]=\"selected ? 'checked' : ''\" color=\"primary\"></mat-pseudo-checkbox>\n  <md-pseudo-checkbox class=\"mat-option-pseudo-checkbox\" *ngSwitchDefault\n      [state]=\"selected ? 'checked' : ''\" color=\"primary\"></md-pseudo-checkbox>\n</span>\n\n<ng-content></ng-content>\n<div class=\"mat-option-ripple\" *ngIf=\"!disabled\" md-ripple [mdRippleTrigger]=\"_getHostElement()\">\n</div>\n",
                      encapsulation: core.ViewEncapsulation.None
                  }] }
      ];
      /** @nocollapse */
      MdOption.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: MdOptgroup, decorators: [{ type: core.Optional }] },
              { type: Boolean, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_COMPATIBILITY_MODE,] }] }
          ];
      };
      MdOption.propDecorators = {
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          onSelectionChange: [{ type: core.Output }]
      };
      return MdOption;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdOptionModule = /** @class */ (function () {
      function MdOptionModule() {
      }
      MdOptionModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MdRippleModule, common.CommonModule, MdSelectionModule],
                      exports: [MdOption, MdOptgroup],
                      declarations: [MdOption, MdOptgroup]
                  },] }
      ];
      return MdOptionModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Throws an exception when attempting to attach a null portal to a host.
   * \@docs-private
   * @return {?}
   */
  function throwNullPortalError() {
      throw Error('Must provide a portal to attach');
  }
  /**
   * Throws an exception when attempting to attach a portal to a host that is already attached.
   * \@docs-private
   * @return {?}
   */
  function throwPortalAlreadyAttachedError() {
      throw Error('Host already has a portal attached');
  }
  /**
   * Throws an exception when attempting to attach a portal to an already-disposed host.
   * \@docs-private
   * @return {?}
   */
  function throwPortalHostAlreadyDisposedError() {
      throw Error('This PortalHost has already been disposed');
  }
  /**
   * Throws an exception when attempting to attach an unknown portal type.
   * \@docs-private
   * @return {?}
   */
  function throwUnknownPortalTypeError() {
      throw Error('Attempting to attach an unknown Portal type. BasePortalHost accepts either' +
          'a ComponentPortal or a TemplatePortal.');
  }
  /**
   * Throws an exception when attempting to attach a portal to a null host.
   * \@docs-private
   * @return {?}
   */
  function throwNullPortalHostError() {
      throw Error('Attempting to attach a portal to a null PortalHost');
  }
  /**
   * Throws an exception when attempting to detach a portal that is not attached.
   * \@docs-privatew
   * @return {?}
   */
  function throwNoPortalAttachedError() {
      throw Error('Attempting to detach a portal that is not attached to a host');
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * A `Portal` is something that you want to render somewhere else.
   * It can be attach to / detached from a `PortalHost`.
   * @abstract
   * @template T
   */
  var /**
   * A `Portal` is something that you want to render somewhere else.
   * It can be attach to / detached from a `PortalHost`.
   * @abstract
   * @template T
   */ Portal = /** @class */ (function () {
      function Portal() {
      }
      /** Attach this portal to a host. */
      /**
       * Attach this portal to a host.
       * @param {?} host
       * @return {?}
       */
      Portal.prototype.attach = /**
       * Attach this portal to a host.
       * @param {?} host
       * @return {?}
       */
          function (host) {
              if (host == null) {
                  throwNullPortalHostError();
              }
              if (host.hasAttached()) {
                  throwPortalAlreadyAttachedError();
              }
              this._attachedHost = host;
              return /** @type {?} */ (host.attach(this));
          };
      /** Detach this portal from its host */
      /**
       * Detach this portal from its host
       * @return {?}
       */
      Portal.prototype.detach = /**
       * Detach this portal from its host
       * @return {?}
       */
          function () {
              /** @type {?} */
              var host = this._attachedHost;
              if (host == null) {
                  throwNoPortalAttachedError();
              }
              this._attachedHost = null;
              return host.detach();
          };
      Object.defineProperty(Portal.prototype, "isAttached", {
          /** Whether this portal is attached to a host. */
          get: /**
           * Whether this portal is attached to a host.
           * @return {?}
           */ function () {
              return this._attachedHost != null;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Sets the PortalHost reference without performing `attach()`. This is used directly by
       * the PortalHost when it is performing an `attach()` or `detach()`.
       */
      /**
       * Sets the PortalHost reference without performing `attach()`. This is used directly by
       * the PortalHost when it is performing an `attach()` or `detach()`.
       * @param {?} host
       * @return {?}
       */
      Portal.prototype.setAttachedHost = /**
       * Sets the PortalHost reference without performing `attach()`. This is used directly by
       * the PortalHost when it is performing an `attach()` or `detach()`.
       * @param {?} host
       * @return {?}
       */
          function (host) {
              this._attachedHost = host;
          };
      return Portal;
  }());
  /**
   * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
   * @template T
   */
  var /**
   * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
   * @template T
   */ ComponentPortal = /** @class */ (function (_super) {
      __extends(ComponentPortal, _super);
      function ComponentPortal(component, viewContainerRef, injector) {
          if (viewContainerRef === void 0) {
              viewContainerRef = null;
          }
          if (injector === void 0) {
              injector = null;
          }
          var _this = _super.call(this) || this;
          _this.component = component;
          _this.viewContainerRef = viewContainerRef;
          _this.injector = injector;
          return _this;
      }
      return ComponentPortal;
  }(Portal));
  /**
   * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
   */
  var /**
   * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
   */ TemplatePortal = /** @class */ (function (_super) {
      __extends(TemplatePortal, _super);
      function TemplatePortal(template, viewContainerRef) {
          var _this = _super.call(this) || this;
          /**
           * Additional locals for the instantiated embedded view.
           * These locals can be seen as "exports" for the template, such as how ngFor has
           * index / event / odd.
           * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html
           */
          _this.locals = new Map();
          _this.templateRef = template;
          _this.viewContainerRef = viewContainerRef;
          return _this;
      }
      Object.defineProperty(TemplatePortal.prototype, "origin", {
          get: /**
           * @return {?}
           */ function () {
              return this.templateRef.elementRef;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} host
       * @param {?=} locals
       * @return {?}
       */
      TemplatePortal.prototype.attach = /**
       * @param {?} host
       * @param {?=} locals
       * @return {?}
       */
          function (host, locals) {
              this.locals = locals == null ? new Map() : locals;
              return _super.prototype.attach.call(this, host);
          };
      /**
       * @return {?}
       */
      TemplatePortal.prototype.detach = /**
       * @return {?}
       */
          function () {
              this.locals = new Map();
              return _super.prototype.detach.call(this);
          };
      return TemplatePortal;
  }(Portal));
  /**
   * Partial implementation of PortalHost that only deals with attaching either a
   * ComponentPortal or a TemplatePortal.
   * @abstract
   */
  var /**
   * Partial implementation of PortalHost that only deals with attaching either a
   * ComponentPortal or a TemplatePortal.
   * @abstract
   */ BasePortalHost = /** @class */ (function () {
      function BasePortalHost() {
          /**
           * Whether this host has already been permanently disposed.
           */
          this._isDisposed = false;
      }
      /** Whether this host has an attached portal. */
      /**
       * Whether this host has an attached portal.
       * @return {?}
       */
      BasePortalHost.prototype.hasAttached = /**
       * Whether this host has an attached portal.
       * @return {?}
       */
          function () {
              return !!this._attachedPortal;
          };
      /**
       * @param {?} portal
       * @return {?}
       */
      BasePortalHost.prototype.attach = /**
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              if (!portal) {
                  throwNullPortalError();
              }
              if (this.hasAttached()) {
                  throwPortalAlreadyAttachedError();
              }
              if (this._isDisposed) {
                  throwPortalHostAlreadyDisposedError();
              }
              if (portal instanceof ComponentPortal) {
                  this._attachedPortal = portal;
                  return this.attachComponentPortal(portal);
              }
              else if (portal instanceof TemplatePortal) {
                  this._attachedPortal = portal;
                  return this.attachTemplatePortal(portal);
              }
              throwUnknownPortalTypeError();
          };
      /**
       * @return {?}
       */
      BasePortalHost.prototype.detach = /**
       * @return {?}
       */
          function () {
              if (this._attachedPortal) {
                  this._attachedPortal.setAttachedHost(null);
                  this._attachedPortal = null;
              }
              this._invokeDisposeFn();
          };
      /**
       * @return {?}
       */
      BasePortalHost.prototype.dispose = /**
       * @return {?}
       */
          function () {
              if (this.hasAttached()) {
                  this.detach();
              }
              this._invokeDisposeFn();
              this._isDisposed = true;
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      BasePortalHost.prototype.setDisposeFn = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._disposeFn = fn;
          };
      /**
       * @return {?}
       */
      BasePortalHost.prototype._invokeDisposeFn = /**
       * @return {?}
       */
          function () {
              if (this._disposeFn) {
                  this._disposeFn();
                  this._disposeFn = null;
              }
          };
      return BasePortalHost;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
   * the directive instance itself can be attached to a host, enabling declarative use of portals.
   *
   * Usage:
   * <ng-template portal #greeting>
   *   <p> Hello {{name}} </p>
   * </ng-template>
   */
  var TemplatePortalDirective = /** @class */ (function (_super) {
      __extends(TemplatePortalDirective, _super);
      function TemplatePortalDirective(templateRef, viewContainerRef) {
          return _super.call(this, templateRef, viewContainerRef) || this;
      }
      TemplatePortalDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-portal], [cdkPortal], [portal]',
                      exportAs: 'cdkPortal',
                  },] }
      ];
      /** @nocollapse */
      TemplatePortalDirective.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.ViewContainerRef }
          ];
      };
      return TemplatePortalDirective;
  }(TemplatePortal));
  /**
   * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be
   * directly attached to it, enabling declarative use.
   *
   * Usage:
   * <ng-template [cdkPortalHost]="greeting"></ng-template>
   */
  var PortalHostDirective = /** @class */ (function (_super) {
      __extends(PortalHostDirective, _super);
      function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {
          var _this = _super.call(this) || this;
          _this._componentFactoryResolver = _componentFactoryResolver;
          _this._viewContainerRef = _viewContainerRef;
          return _this;
      }
      Object.defineProperty(PortalHostDirective.prototype, "_deprecatedPortal", {
          /** @deprecated */
          get: /**
           * @deprecated
           * @return {?}
           */ function () { return this.portal; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) { this.portal = v; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PortalHostDirective.prototype, "portal", {
          /** Portal associated with the Portal host. */
          get: /**
           * Portal associated with the Portal host.
           * @return {?}
           */ function () {
              return this._portal;
          },
          set: /**
           * @param {?} portal
           * @return {?}
           */ function (portal) {
              if (this.hasAttached()) {
                  _super.prototype.detach.call(this);
              }
              if (portal) {
                  _super.prototype.attach.call(this, portal);
              }
              this._portal = portal;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      PortalHostDirective.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              _super.prototype.dispose.call(this);
              this._portal = null;
          };
      /**
       * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.
       *
       * @param portal Portal to be attached to the portal host.
       */
      /**
       * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.
       *
       * @template T
       * @param {?} portal Portal to be attached to the portal host.
       * @return {?}
       */
      PortalHostDirective.prototype.attachComponentPortal = /**
       * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.
       *
       * @template T
       * @param {?} portal Portal to be attached to the portal host.
       * @return {?}
       */
          function (portal) {
              portal.setAttachedHost(this);
              /** @type {?} */
              var viewContainerRef = portal.viewContainerRef != null ?
                  portal.viewContainerRef :
                  this._viewContainerRef;
              /** @type {?} */
              var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
              /** @type {?} */
              var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);
              _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });
              this._portal = portal;
              return ref;
          };
      /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @param portal Portal to be attached.
       */
      /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @param {?} portal Portal to be attached.
       * @return {?}
       */
      PortalHostDirective.prototype.attachTemplatePortal = /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @param {?} portal Portal to be attached.
       * @return {?}
       */
          function (portal) {
              var _this = this;
              portal.setAttachedHost(this);
              this._viewContainerRef.createEmbeddedView(portal.templateRef);
              _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });
              this._portal = portal;
              // TODO(jelbourn): return locals from view
              return new Map();
          };
      PortalHostDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkPortalHost], [portalHost]',
                      inputs: ['portal: cdkPortalHost']
                  },] }
      ];
      /** @nocollapse */
      PortalHostDirective.ctorParameters = function () {
          return [
              { type: core.ComponentFactoryResolver },
              { type: core.ViewContainerRef }
          ];
      };
      PortalHostDirective.propDecorators = {
          _deprecatedPortal: [{ type: core.Input, args: ['portalHost',] }]
      };
      return PortalHostDirective;
  }(BasePortalHost));
  var PortalModule = /** @class */ (function () {
      function PortalModule() {
      }
      PortalModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [TemplatePortalDirective, PortalHostDirective],
                      declarations: [TemplatePortalDirective, PortalHostDirective],
                  },] }
      ];
      return PortalModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * OverlayState is a bag of values for either the initial configuration or current state of an
   * overlay.
   */
  var /**
   * OverlayState is a bag of values for either the initial configuration or current state of an
   * overlay.
   */ OverlayState = /** @class */ (function () {
      function OverlayState() {
          /**
           * Custom class to add to the overlay pane.
           */
          this.panelClass = '';
          /**
           * Whether the overlay has a backdrop.
           */
          this.hasBackdrop = false;
          /**
           * Custom class to add to the backdrop
           */
          this.backdropClass = 'cdk-overlay-dark-backdrop';
          /**
           * The direction of the text in the overlay panel.
           */
          this.direction = 'ltr';
      }
      return OverlayState;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular
   * application context.
   *
   * This is the only part of the portal core that directly touches the DOM.
   */
  var /**
   * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular
   * application context.
   *
   * This is the only part of the portal core that directly touches the DOM.
   */ DomPortalHost = /** @class */ (function (_super) {
      __extends(DomPortalHost, _super);
      function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {
          var _this = _super.call(this) || this;
          _this._hostDomElement = _hostDomElement;
          _this._componentFactoryResolver = _componentFactoryResolver;
          _this._appRef = _appRef;
          _this._defaultInjector = _defaultInjector;
          return _this;
      }
      /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @param portal Portal to be attached
       */
      /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @template T
       * @param {?} portal Portal to be attached
       * @return {?}
       */
      DomPortalHost.prototype.attachComponentPortal = /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @template T
       * @param {?} portal Portal to be attached
       * @return {?}
       */
          function (portal) {
              var _this = this;
              /** @type {?} */
              var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
              /** @type {?} */
              var componentRef;
              // If the portal specifies a ViewContainerRef, we will use that as the attachment point
              // for the component (in terms of Angular's component tree, not rendering).
              // When the ViewContainerRef is missing, we use the factory to create the component directly
              // and then manually attach the view to the application.
              if (portal.viewContainerRef) {
                  componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);
                  this.setDisposeFn(function () { return componentRef.destroy(); });
              }
              else {
                  componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                  this._appRef.attachView(componentRef.hostView);
                  this.setDisposeFn(function () {
                      _this._appRef.detachView(componentRef.hostView);
                      componentRef.destroy();
                  });
              }
              // At this point the component has been instantiated, so we move it to the location in the DOM
              // where we want it to be rendered.
              this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));
              return componentRef;
          };
      /**
       * Attaches a template portal to the DOM as an embedded view.
       * @param portal Portal to be attached.
       */
      /**
       * Attaches a template portal to the DOM as an embedded view.
       * @param {?} portal Portal to be attached.
       * @return {?}
       */
      DomPortalHost.prototype.attachTemplatePortal = /**
       * Attaches a template portal to the DOM as an embedded view.
       * @param {?} portal Portal to be attached.
       * @return {?}
       */
          function (portal) {
              var _this = this;
              /** @type {?} */
              var viewContainer = portal.viewContainerRef;
              /** @type {?} */
              var viewRef = viewContainer.createEmbeddedView(portal.templateRef);
              viewRef.detectChanges();
              // The method `createEmbeddedView` will add the view as a child of the viewContainer.
              // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)
              // To move the view to the specified host element. We just re-append the existing root nodes.
              viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });
              this.setDisposeFn((function () {
                  /** @type {?} */
                  var index = viewContainer.indexOf(viewRef);
                  if (index !== -1) {
                      viewContainer.remove(index);
                  }
              }));
              // TODO(jelbourn): Return locals from view.
              return new Map();
          };
      /**
       * Clears out a portal from the DOM.
       */
      /**
       * Clears out a portal from the DOM.
       * @return {?}
       */
      DomPortalHost.prototype.dispose = /**
       * Clears out a portal from the DOM.
       * @return {?}
       */
          function () {
              _super.prototype.dispose.call(this);
              if (this._hostDomElement.parentNode != null) {
                  this._hostDomElement.parentNode.removeChild(this._hostDomElement);
              }
          };
      /**
       * Gets the root HTMLElement for an instantiated component.
       * @param {?} componentRef
       * @return {?}
       */
      DomPortalHost.prototype._getComponentRootNode = /**
       * Gets the root HTMLElement for an instantiated component.
       * @param {?} componentRef
       * @return {?}
       */
          function (componentRef) {
              return /** @type {?} */ (( /** @type {?} */(componentRef.hostView)).rootNodes[0]);
          };
      return DomPortalHost;
  }(BasePortalHost));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Reference to an overlay that has been created with the Overlay service.
   * Used to manipulate or dispose of said overlay.
   */
  var /**
   * Reference to an overlay that has been created with the Overlay service.
   * Used to manipulate or dispose of said overlay.
   */ OverlayRef = /** @class */ (function () {
      function OverlayRef(_portalHost, _pane, _state, _scrollStrategy, _ngZone) {
          this._portalHost = _portalHost;
          this._pane = _pane;
          this._state = _state;
          this._scrollStrategy = _scrollStrategy;
          this._ngZone = _ngZone;
          this._backdropElement = null;
          this._backdropClick = new rxjs.Subject();
          this._attachments = new rxjs.Subject();
          this._detachments = new rxjs.Subject();
          _scrollStrategy.attach(this);
      }
      Object.defineProperty(OverlayRef.prototype, "overlayElement", {
          /** The overlay's HTML element */
          get: /**
           * The overlay's HTML element
           * @return {?}
           */ function () {
              return this._pane;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Attaches the overlay to a portal instance and adds the backdrop.
       * @param portal Portal instance to which to attach the overlay.
       * @returns The portal attachment result.
       */
      /**
       * Attaches the overlay to a portal instance and adds the backdrop.
       * @param {?} portal Portal instance to which to attach the overlay.
       * @return {?} The portal attachment result.
       */
      OverlayRef.prototype.attach = /**
       * Attaches the overlay to a portal instance and adds the backdrop.
       * @param {?} portal Portal instance to which to attach the overlay.
       * @return {?} The portal attachment result.
       */
          function (portal) {
              /** @type {?} */
              var attachResult = this._portalHost.attach(portal);
              // Update the pane element with the given state configuration.
              this._updateStackingOrder();
              this.updateSize();
              this.updateDirection();
              this.updatePosition();
              this._scrollStrategy.enable();
              // Enable pointer events for the overlay pane element.
              this._togglePointerEvents(true);
              if (this._state.hasBackdrop) {
                  this._attachBackdrop();
              }
              if (this._state.panelClass) {
                  this._pane.classList.add(this._state.panelClass);
              }
              // Only emit the `attachments` event once all other setup is done.
              this._attachments.next();
              return attachResult;
          };
      /**
       * Detaches an overlay from a portal.
       * @returns Resolves when the overlay has been detached.
       */
      /**
       * Detaches an overlay from a portal.
       * @return {?} Resolves when the overlay has been detached.
       */
      OverlayRef.prototype.detach = /**
       * Detaches an overlay from a portal.
       * @return {?} Resolves when the overlay has been detached.
       */
          function () {
              this.detachBackdrop();
              // When the overlay is detached, the pane element should disable pointer events.
              // This is necessary because otherwise the pane element will cover the page and disable
              // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
              this._togglePointerEvents(false);
              this._scrollStrategy.disable();
              /** @type {?} */
              var detachmentResult = this._portalHost.detach();
              // Only emit after everything is detached.
              this._detachments.next();
              return detachmentResult;
          };
      /**
       * Cleans up the overlay from the DOM.
       */
      /**
       * Cleans up the overlay from the DOM.
       * @return {?}
       */
      OverlayRef.prototype.dispose = /**
       * Cleans up the overlay from the DOM.
       * @return {?}
       */
          function () {
              if (this._state.positionStrategy) {
                  this._state.positionStrategy.dispose();
              }
              if (this._scrollStrategy) {
                  this._scrollStrategy.disable();
                  this._scrollStrategy = null;
              }
              this.detachBackdrop();
              this._portalHost.dispose();
              this._attachments.complete();
              this._backdropClick.complete();
              this._detachments.next();
              this._detachments.complete();
          };
      /**
       * Checks whether the overlay has been attached.
       */
      /**
       * Checks whether the overlay has been attached.
       * @return {?}
       */
      OverlayRef.prototype.hasAttached = /**
       * Checks whether the overlay has been attached.
       * @return {?}
       */
          function () {
              return this._portalHost.hasAttached();
          };
      /**
       * Returns an observable that emits when the backdrop has been clicked.
       */
      /**
       * Returns an observable that emits when the backdrop has been clicked.
       * @return {?}
       */
      OverlayRef.prototype.backdropClick = /**
       * Returns an observable that emits when the backdrop has been clicked.
       * @return {?}
       */
          function () {
              return this._backdropClick.asObservable();
          };
      /** Returns an observable that emits when the overlay has been attached. */
      /**
       * Returns an observable that emits when the overlay has been attached.
       * @return {?}
       */
      OverlayRef.prototype.attachments = /**
       * Returns an observable that emits when the overlay has been attached.
       * @return {?}
       */
          function () {
              return this._attachments.asObservable();
          };
      /** Returns an observable that emits when the overlay has been detached. */
      /**
       * Returns an observable that emits when the overlay has been detached.
       * @return {?}
       */
      OverlayRef.prototype.detachments = /**
       * Returns an observable that emits when the overlay has been detached.
       * @return {?}
       */
          function () {
              return this._detachments.asObservable();
          };
      /**
       * Gets the current state config of the overlay.
       */
      /**
       * Gets the current state config of the overlay.
       * @return {?}
       */
      OverlayRef.prototype.getState = /**
       * Gets the current state config of the overlay.
       * @return {?}
       */
          function () {
              return this._state;
          };
      /** Updates the position of the overlay based on the position strategy. */
      /**
       * Updates the position of the overlay based on the position strategy.
       * @return {?}
       */
      OverlayRef.prototype.updatePosition = /**
       * Updates the position of the overlay based on the position strategy.
       * @return {?}
       */
          function () {
              if (this._state.positionStrategy) {
                  this._state.positionStrategy.apply(this._pane);
              }
          };
      /**
       * Updates the text direction of the overlay panel.
       * @return {?}
       */
      OverlayRef.prototype.updateDirection = /**
       * Updates the text direction of the overlay panel.
       * @return {?}
       */
          function () {
              this._pane.setAttribute('dir', this._state.direction);
          };
      /** Updates the size of the overlay based on the overlay config. */
      /**
       * Updates the size of the overlay based on the overlay config.
       * @return {?}
       */
      OverlayRef.prototype.updateSize = /**
       * Updates the size of the overlay based on the overlay config.
       * @return {?}
       */
          function () {
              if (this._state.width || this._state.width === 0) {
                  this._pane.style.width = formatCssUnit(this._state.width);
              }
              if (this._state.height || this._state.height === 0) {
                  this._pane.style.height = formatCssUnit(this._state.height);
              }
              if (this._state.minWidth || this._state.minWidth === 0) {
                  this._pane.style.minWidth = formatCssUnit(this._state.minWidth);
              }
              if (this._state.minHeight || this._state.minHeight === 0) {
                  this._pane.style.minHeight = formatCssUnit(this._state.minHeight);
              }
          };
      /**
       * Toggles the pointer events for the overlay pane element.
       * @param {?} enablePointer
       * @return {?}
       */
      OverlayRef.prototype._togglePointerEvents = /**
       * Toggles the pointer events for the overlay pane element.
       * @param {?} enablePointer
       * @return {?}
       */
          function (enablePointer) {
              this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
          };
      /**
       * Attaches a backdrop for this overlay.
       * @return {?}
       */
      OverlayRef.prototype._attachBackdrop = /**
       * Attaches a backdrop for this overlay.
       * @return {?}
       */
          function () {
              var _this = this;
              this._backdropElement = document.createElement('div');
              this._backdropElement.classList.add('cdk-overlay-backdrop');
              this._backdropElement.classList.add(this._state.backdropClass);
              // Insert the backdrop before the pane in the DOM order,
              // in order to handle stacked overlays properly.
              this._pane.parentElement.insertBefore(this._backdropElement, this._pane);
              // Forward backdrop clicks such that the consumer of the overlay can perform whatever
              // action desired when such a click occurs (usually closing the overlay).
              this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });
              // Add class to fade-in the backdrop after one frame.
              requestAnimationFrame(function () {
                  if (_this._backdropElement) {
                      _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');
                  }
              });
          };
      /**
       * Updates the stacking order of the element, moving it to the top if necessary.
       * This is required in cases where one overlay was detached, while another one,
       * that should be behind it, was destroyed. The next time both of them are opened,
       * the stacking will be wrong, because the detached element's pane will still be
       * in its original DOM position.
       * @return {?}
       */
      OverlayRef.prototype._updateStackingOrder = /**
       * Updates the stacking order of the element, moving it to the top if necessary.
       * This is required in cases where one overlay was detached, while another one,
       * that should be behind it, was destroyed. The next time both of them are opened,
       * the stacking will be wrong, because the detached element's pane will still be
       * in its original DOM position.
       * @return {?}
       */
          function () {
              if (this._pane.nextSibling) {
                  this._pane.parentNode.appendChild(this._pane);
              }
          };
      /** Detaches the backdrop (if any) associated with the overlay. */
      /**
       * Detaches the backdrop (if any) associated with the overlay.
       * @return {?}
       */
      OverlayRef.prototype.detachBackdrop = /**
       * Detaches the backdrop (if any) associated with the overlay.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var backdropToDetach = this._backdropElement;
              if (backdropToDetach) {
                  /** @type {?} */
                  var finishDetach_1 = function () {
                      // It may not be attached to anything in certain cases (e.g. unit tests).
                      if (backdropToDetach && backdropToDetach.parentNode) {
                          backdropToDetach.parentNode.removeChild(backdropToDetach);
                      }
                      // It is possible that a new portal has been attached to this overlay since we started
                      // removing the backdrop. If that is the case, only clear the backdrop reference if it
                      // is still the same instance that we started to remove.
                      if (_this._backdropElement == backdropToDetach) {
                          _this._backdropElement = null;
                      }
                  };
                  backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
                  backdropToDetach.classList.remove(this._state.backdropClass);
                  backdropToDetach.addEventListener('transitionend', finishDetach_1);
                  // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
                  // In this case we make it unclickable and we try to remove it after a delay.
                  backdropToDetach.style.pointerEvents = 'none';
                  // Run this outside the Angular zone because there's nothing that Angular cares about.
                  // If it were to run inside the Angular zone, every test that used Overlay would have to be
                  // either async or fakeAsync.
                  this._ngZone.runOutsideAngular(function () {
                      setTimeout(finishDetach_1, 500);
                  });
              }
          };
      return OverlayRef;
  }());
  /**
   * @param {?} value
   * @return {?}
   */
  function formatCssUnit(value) {
      return typeof value === 'string' ? /** @type {?} */ (value) : value + "px";
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * The points of the origin element and the overlay element to connect.
   */
  var /**
   * The points of the origin element and the overlay element to connect.
   */ ConnectionPositionPair = /** @class */ (function () {
      function ConnectionPositionPair(origin, overlay) {
          this.originX = origin.originX;
          this.originY = origin.originY;
          this.overlayX = overlay.overlayX;
          this.overlayY = overlay.overlayY;
      }
      return ConnectionPositionPair;
  }());
  /**
   * Set of properties regarding the position of the origin and overlay relative to the viewport
   * with respect to the containing Scrollable elements.
   *
   * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
   * bounds of any one of the strategy's Scrollable's bounding client rectangle.
   *
   * The overlay and origin are outside view if there is no overlap between their bounding client
   * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
   *
   *       -----------                    -----------
   *       | outside |                    | clipped |
   *       |  view   |              --------------------------
   *       |         |              |     |         |        |
   *       ----------               |     -----------        |
   *  --------------------------    |                        |
   *  |                        |    |      Scrollable        |
   *  |                        |    |                        |
   *  |                        |     --------------------------
   *  |      Scrollable        |
   *  |                        |
   *  --------------------------
   */
  var /**
   * Set of properties regarding the position of the origin and overlay relative to the viewport
   * with respect to the containing Scrollable elements.
   *
   * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
   * bounds of any one of the strategy's Scrollable's bounding client rectangle.
   *
   * The overlay and origin are outside view if there is no overlap between their bounding client
   * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
   *
   *       -----------                    -----------
   *       | outside |                    | clipped |
   *       |  view   |              --------------------------
   *       |         |              |     |         |        |
   *       ----------               |     -----------        |
   *  --------------------------    |                        |
   *  |                        |    |      Scrollable        |
   *  |                        |    |                        |
   *  |                        |     --------------------------
   *  |      Scrollable        |
   *  |                        |
   *  --------------------------
   */ ScrollableViewProperties = /** @class */ (function () {
      function ScrollableViewProperties() {
      }
      return ScrollableViewProperties;
  }());
  /**
   * The change event emitted by the strategy when a fallback position is used.
   */
  var ConnectedOverlayPositionChange = /** @class */ (function () {
      function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
          this.connectionPair = connectionPair;
          this.scrollableViewProperties = scrollableViewProperties;
      }
      /** @nocollapse */
      ConnectedOverlayPositionChange.ctorParameters = function () {
          return [
              { type: ConnectionPositionPair },
              { type: ScrollableViewProperties, decorators: [{ type: core.Optional }] }
          ];
      };
      return ConnectedOverlayPositionChange;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   */
  var /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   */ ConnectedPositionStrategy = /** @class */ (function () {
      function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {
          this._connectedTo = _connectedTo;
          this._originPos = _originPos;
          this._overlayPos = _overlayPos;
          this._viewportRuler = _viewportRuler;
          this._dir = 'ltr';
          /**
           * The offset in pixels for the overlay connection point on the x-axis
           */
          this._offsetX = 0;
          /**
           * The offset in pixels for the overlay connection point on the y-axis
           */
          this._offsetY = 0;
          /**
           * The Scrollable containers used to check scrollable view properties on position change.
           */
          this.scrollables = [];
          /**
           * Ordered list of preferred positions, from most to least desirable.
           */
          this._preferredPositions = [];
          this._onPositionChange = new rxjs.Subject();
          this._origin = this._connectedTo.nativeElement;
          this.withFallbackPosition(_originPos, _overlayPos);
      }
      Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
          /** Whether the we're dealing with an RTL context */
          get: /**
           * Whether the we're dealing with an RTL context
           * @return {?}
           */ function () {
              return this._dir === 'rtl';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
          /** Emits an event when the connection point changes. */
          get: /**
           * Emits an event when the connection point changes.
           * @return {?}
           */ function () {
              return this._onPositionChange.asObservable();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
          /** Ordered list of preferred positions, from most to least desirable. */
          get: /**
           * Ordered list of preferred positions, from most to least desirable.
           * @return {?}
           */ function () {
              return this._preferredPositions;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * To be used to for any cleanup after the element gets destroyed.
       */
      /**
       * To be used to for any cleanup after the element gets destroyed.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.dispose = /**
       * To be used to for any cleanup after the element gets destroyed.
       * @return {?}
       */
          function () { };
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * @docs-private
       *
       * @param element Element to which to apply the CSS styles.
       * @returns Resolves when the styles have been applied.
       */
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * \@docs-private
       *
       * @param {?} element Element to which to apply the CSS styles.
       * @return {?} Resolves when the styles have been applied.
       */
      ConnectedPositionStrategy.prototype.apply = /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * \@docs-private
       *
       * @param {?} element Element to which to apply the CSS styles.
       * @return {?} Resolves when the styles have been applied.
       */
          function (element) {
              var e_1, _a;
              // Cache the overlay pane element in case re-calculating position is necessary
              this._pane = element;
              /** @type {?} */
              var originRect = this._origin.getBoundingClientRect();
              /** @type {?} */
              var overlayRect = element.getBoundingClientRect();
              /** @type {?} */
              var viewportRect = this._viewportRuler.getViewportRect();
              /** @type {?} */
              var fallbackPoint = null;
              /** @type {?} */
              var fallbackPosition = null;
              try {
                  // We want to place the overlay in the first of the preferred positions such that the
                  // overlay fits on-screen.
                  for (var _b = __values(this._preferredPositions), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var pos = _c.value;
                      /** @type {?} */
                      var originPoint = this._getOriginConnectionPoint(originRect, pos);
                      /** @type {?} */
                      var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);
                      // If the overlay in the calculated position fits on-screen, put it there and we're done.
                      if (overlayPoint.fitsInViewport) {
                          this._setElementPosition(element, overlayRect, overlayPoint, pos);
                          // Save the last connected position in case the position needs to be re-calculated.
                          this._lastConnectedPosition = pos;
                          /** @type {?} */
                          var scrollableViewProperties = this.getScrollableViewProperties(element);
                          /** @type {?} */
                          var positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);
                          this._onPositionChange.next(positionChange);
                          return Promise.resolve(null);
                      }
                      else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {
                          fallbackPoint = overlayPoint;
                          fallbackPosition = pos;
                      }
                  }
              }
              catch (e_1_1) {
                  e_1 = { error: e_1_1 };
              }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return))
                          _a.call(_b);
                  }
                  finally {
                      if (e_1)
                          throw e_1.error;
                  }
              }
              // If none of the preferred positions were in the viewport, take the one
              // with the largest visible area.
              this._setElementPosition(element, overlayRect, fallbackPoint, fallbackPosition);
              return Promise.resolve(null);
          };
      /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       */
      /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.recalculateLastPosition = /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var originRect = this._origin.getBoundingClientRect();
              /** @type {?} */
              var overlayRect = this._pane.getBoundingClientRect();
              /** @type {?} */
              var viewportRect = this._viewportRuler.getViewportRect();
              /** @type {?} */
              var lastPosition = this._lastConnectedPosition || this._preferredPositions[0];
              /** @type {?} */
              var originPoint = this._getOriginConnectionPoint(originRect, lastPosition);
              /** @type {?} */
              var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);
              this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);
          };
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       */
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withScrollableContainers = /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
          function (scrollables) {
              this.scrollables = scrollables;
          };
      /**
       * Adds a new preferred fallback position.
       * @param originPos
       * @param overlayPos
       */
      /**
       * Adds a new preferred fallback position.
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withFallbackPosition = /**
       * Adds a new preferred fallback position.
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
          function (originPos, overlayPos) {
              this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));
              return this;
          };
      /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @param dir New layout direction.
       */
      /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @param {?} dir New layout direction.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withDirection = /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @param {?} dir New layout direction.
       * @return {?}
       */
          function (dir) {
              this._dir = dir;
              return this;
          };
      /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @param offset New offset in the X axis.
       */
      /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @param {?} offset New offset in the X axis.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withOffsetX = /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @param {?} offset New offset in the X axis.
       * @return {?}
       */
          function (offset) {
              this._offsetX = offset;
              return this;
          };
      /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @param  offset New offset in the Y axis.
       */
      /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @param {?} offset New offset in the Y axis.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withOffsetY = /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @param {?} offset New offset in the Y axis.
       * @return {?}
       */
          function (offset) {
              this._offsetY = offset;
              return this;
          };
      /**
       * Gets the horizontal (x) "start" dimension based on whether the overlay is in an RTL context.
       * @param {?} rect
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._getStartX = /**
       * Gets the horizontal (x) "start" dimension based on whether the overlay is in an RTL context.
       * @param {?} rect
       * @return {?}
       */
          function (rect) {
              return this._isRtl ? rect.right : rect.left;
          };
      /**
       * Gets the horizontal (x) "end" dimension based on whether the overlay is in an RTL context.
       * @param {?} rect
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._getEndX = /**
       * Gets the horizontal (x) "end" dimension based on whether the overlay is in an RTL context.
       * @param {?} rect
       * @return {?}
       */
          function (rect) {
              return this._isRtl ? rect.left : rect.right;
          };
      /**
       * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
       * @param {?} originRect
       * @param {?} pos
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**
       * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
       * @param {?} originRect
       * @param {?} pos
       * @return {?}
       */
          function (originRect, pos) {
              /** @type {?} */
              var originStartX = this._getStartX(originRect);
              /** @type {?} */
              var originEndX = this._getEndX(originRect);
              /** @type {?} */
              var x;
              if (pos.originX == 'center') {
                  x = originStartX + (originRect.width / 2);
              }
              else {
                  x = pos.originX == 'start' ? originStartX : originEndX;
              }
              /** @type {?} */
              var y;
              if (pos.originY == 'center') {
                  y = originRect.top + (originRect.height / 2);
              }
              else {
                  y = pos.originY == 'top' ? originRect.top : originRect.bottom;
              }
              return { x: x, y: y };
          };
      /**
       * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
       * origin point to which the overlay should be connected, as well as how much of the element
       * would be inside the viewport at that position.
       * @param {?} originPoint
       * @param {?} overlayRect
       * @param {?} viewportRect
       * @param {?} pos
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._getOverlayPoint = /**
       * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
       * origin point to which the overlay should be connected, as well as how much of the element
       * would be inside the viewport at that position.
       * @param {?} originPoint
       * @param {?} overlayRect
       * @param {?} viewportRect
       * @param {?} pos
       * @return {?}
       */
          function (originPoint, overlayRect, viewportRect, pos) {
              /** @type {?} */
              var overlayStartX;
              if (pos.overlayX == 'center') {
                  overlayStartX = -overlayRect.width / 2;
              }
              else if (pos.overlayX === 'start') {
                  overlayStartX = this._isRtl ? -overlayRect.width : 0;
              }
              else {
                  overlayStartX = this._isRtl ? 0 : -overlayRect.width;
              }
              /** @type {?} */
              var overlayStartY;
              if (pos.overlayY == 'center') {
                  overlayStartY = -overlayRect.height / 2;
              }
              else {
                  overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
              }
              /** @type {?} */
              var x = originPoint.x + overlayStartX + this._offsetX;
              /** @type {?} */
              var y = originPoint.y + overlayStartY + this._offsetY;
              /** @type {?} */
              var leftOverflow = 0 - x;
              /** @type {?} */
              var rightOverflow = (x + overlayRect.width) - viewportRect.width;
              /** @type {?} */
              var topOverflow = 0 - y;
              /** @type {?} */
              var bottomOverflow = (y + overlayRect.height) - viewportRect.height;
              /** @type {?} */
              var visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);
              /** @type {?} */
              var visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);
              /** @type {?} */
              var visibleArea = visibleWidth * visibleHeight;
              /** @type {?} */
              var fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;
              return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };
          };
      /**
       * Gets the view properties of the trigger and overlay, including whether they are clipped
       * or completely outside the view of any of the strategy's scrollables.
       * @param {?} overlay
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.getScrollableViewProperties = /**
       * Gets the view properties of the trigger and overlay, including whether they are clipped
       * or completely outside the view of any of the strategy's scrollables.
       * @param {?} overlay
       * @return {?}
       */
          function (overlay) {
              var _this = this;
              /** @type {?} */
              var originBounds = this._getElementBounds(this._origin);
              /** @type {?} */
              var overlayBounds = this._getElementBounds(overlay);
              /** @type {?} */
              var scrollContainerBounds = this.scrollables.map(function (scrollable) {
                  return _this._getElementBounds(scrollable.getElementRef().nativeElement);
              });
              return {
                  isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),
                  isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),
                  isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),
                  isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),
              };
          };
      /**
       * Whether the element is completely out of the view of any of the containers.
       * @param {?} elementBounds
       * @param {?} containersBounds
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.isElementOutsideView = /**
       * Whether the element is completely out of the view of any of the containers.
       * @param {?} elementBounds
       * @param {?} containersBounds
       * @return {?}
       */
          function (elementBounds, containersBounds) {
              return containersBounds.some(function (containerBounds) {
                  /** @type {?} */
                  var outsideAbove = elementBounds.bottom < containerBounds.top;
                  /** @type {?} */
                  var outsideBelow = elementBounds.top > containerBounds.bottom;
                  /** @type {?} */
                  var outsideLeft = elementBounds.right < containerBounds.left;
                  /** @type {?} */
                  var outsideRight = elementBounds.left > containerBounds.right;
                  return outsideAbove || outsideBelow || outsideLeft || outsideRight;
              });
          };
      /**
       * Whether the element is clipped by any of the containers.
       * @param {?} elementBounds
       * @param {?} containersBounds
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.isElementClipped = /**
       * Whether the element is clipped by any of the containers.
       * @param {?} elementBounds
       * @param {?} containersBounds
       * @return {?}
       */
          function (elementBounds, containersBounds) {
              return containersBounds.some(function (containerBounds) {
                  /** @type {?} */
                  var clippedAbove = elementBounds.top < containerBounds.top;
                  /** @type {?} */
                  var clippedBelow = elementBounds.bottom > containerBounds.bottom;
                  /** @type {?} */
                  var clippedLeft = elementBounds.left < containerBounds.left;
                  /** @type {?} */
                  var clippedRight = elementBounds.right > containerBounds.right;
                  return clippedAbove || clippedBelow || clippedLeft || clippedRight;
              });
          };
      /**
       * Physically positions the overlay element to the given coordinate.
       * @param {?} element
       * @param {?} overlayRect
       * @param {?} overlayPoint
       * @param {?} pos
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._setElementPosition = /**
       * Physically positions the overlay element to the given coordinate.
       * @param {?} element
       * @param {?} overlayRect
       * @param {?} overlayPoint
       * @param {?} pos
       * @return {?}
       */
          function (element, overlayRect, overlayPoint, pos) {
              /** @type {?} */
              var verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';
              /** @type {?} */
              var y = verticalStyleProperty === 'top' ?
                  overlayPoint.y :
                  document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);
              /** @type {?} */
              var horizontalStyleProperty;
              if (this._dir === 'rtl') {
                  horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';
              }
              else {
                  horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';
              }
              /** @type {?} */
              var x = horizontalStyleProperty === 'left' ?
                  overlayPoint.x :
                  document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);
              // Reset any existing styles. This is necessary in case the preferred position has
              // changed since the last `apply`.
              ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });
              element.style[verticalStyleProperty] = y + "px";
              element.style[horizontalStyleProperty] = x + "px";
          };
      /**
       * Returns the bounding positions of the provided element with respect to the viewport.
       * @param {?} element
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._getElementBounds = /**
       * Returns the bounding positions of the provided element with respect to the viewport.
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var boundingClientRect = element.getBoundingClientRect();
              return {
                  top: boundingClientRect.top,
                  right: boundingClientRect.left + boundingClientRect.width,
                  bottom: boundingClientRect.top + boundingClientRect.height,
                  left: boundingClientRect.left
              };
          };
      /**
       * Subtracts the amount that an element is overflowing on an axis from it's length.
       * @param {?} length
       * @param {...?} overflows
       * @return {?}
       */
      ConnectedPositionStrategy.prototype._subtractOverflows = /**
       * Subtracts the amount that an element is overflowing on an axis from it's length.
       * @param {?} length
       * @param {...?} overflows
       * @return {?}
       */
          function (length) {
              var overflows = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  overflows[_i - 1] = arguments[_i];
              }
              return overflows.reduce(function (currentValue, currentOverflow) {
                  return currentValue - Math.max(currentOverflow, 0);
              }, length);
          };
      return ConnectedPositionStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * explicit position relative to the browser's viewport. We use flexbox, instead of
   * transforms, in order to avoid issues with subpixel rendering which can cause the
   * element to become blurry.
   */
  var /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * explicit position relative to the browser's viewport. We use flexbox, instead of
   * transforms, in order to avoid issues with subpixel rendering which can cause the
   * element to become blurry.
   */ GlobalPositionStrategy = /** @class */ (function () {
      function GlobalPositionStrategy() {
          this._cssPosition = 'static';
          this._topOffset = '';
          this._bottomOffset = '';
          this._leftOffset = '';
          this._rightOffset = '';
          this._alignItems = '';
          this._justifyContent = '';
          this._width = '';
          this._height = '';
      }
      /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @param value New top offset.
       */
      /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @param {?} value New top offset.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.top = /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @param {?} value New top offset.
       * @return {?}
       */
          function (value) {
              this._bottomOffset = '';
              this._topOffset = value;
              this._alignItems = 'flex-start';
              return this;
          };
      /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @param value New left offset.
       */
      /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @param {?} value New left offset.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.left = /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @param {?} value New left offset.
       * @return {?}
       */
          function (value) {
              this._rightOffset = '';
              this._leftOffset = value;
              this._justifyContent = 'flex-start';
              return this;
          };
      /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @param value New bottom offset.
       */
      /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @param {?} value New bottom offset.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.bottom = /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @param {?} value New bottom offset.
       * @return {?}
       */
          function (value) {
              this._topOffset = '';
              this._bottomOffset = value;
              this._alignItems = 'flex-end';
              return this;
          };
      /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @param value New right offset.
       */
      /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @param {?} value New right offset.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.right = /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @param {?} value New right offset.
       * @return {?}
       */
          function (value) {
              this._leftOffset = '';
              this._rightOffset = value;
              this._justifyContent = 'flex-end';
              return this;
          };
      /**
       * Sets the overlay width and clears any previously set width.
       * @param value New width for the overlay
       */
      /**
       * Sets the overlay width and clears any previously set width.
       * @param {?} value New width for the overlay
       * @return {?}
       */
      GlobalPositionStrategy.prototype.width = /**
       * Sets the overlay width and clears any previously set width.
       * @param {?} value New width for the overlay
       * @return {?}
       */
          function (value) {
              this._width = value;
              // When the width is 100%, we should reset the `left` and the offset,
              // in order to ensure that the element is flush against the viewport edge.
              if (value === '100%') {
                  this.left('0px');
              }
              return this;
          };
      /**
       * Sets the overlay height and clears any previously set height.
       * @param value New height for the overlay
       */
      /**
       * Sets the overlay height and clears any previously set height.
       * @param {?} value New height for the overlay
       * @return {?}
       */
      GlobalPositionStrategy.prototype.height = /**
       * Sets the overlay height and clears any previously set height.
       * @param {?} value New height for the overlay
       * @return {?}
       */
          function (value) {
              this._height = value;
              // When the height is 100%, we should reset the `top` and the offset,
              // in order to ensure that the element is flush against the viewport edge.
              if (value === '100%') {
                  this.top('0px');
              }
              return this;
          };
      /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @param offset Overlay offset from the horizontal center.
       */
      /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @param {?=} offset Overlay offset from the horizontal center.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.centerHorizontally = /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @param {?=} offset Overlay offset from the horizontal center.
       * @return {?}
       */
          function (offset) {
              if (offset === void 0) {
                  offset = '';
              }
              this.left(offset);
              this._justifyContent = 'center';
              return this;
          };
      /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @param offset Overlay offset from the vertical center.
       */
      /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @param {?=} offset Overlay offset from the vertical center.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.centerVertically = /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @param {?=} offset Overlay offset from the vertical center.
       * @return {?}
       */
          function (offset) {
              if (offset === void 0) {
                  offset = '';
              }
              this.top(offset);
              this._alignItems = 'center';
              return this;
          };
      /**
       * Apply the position to the element.
       * @docs-private
       *
       * @param element Element to which to apply the CSS.
       * @returns Resolved when the styles have been applied.
       */
      /**
       * Apply the position to the element.
       * \@docs-private
       *
       * @param {?} element Element to which to apply the CSS.
       * @return {?} Resolved when the styles have been applied.
       */
      GlobalPositionStrategy.prototype.apply = /**
       * Apply the position to the element.
       * \@docs-private
       *
       * @param {?} element Element to which to apply the CSS.
       * @return {?} Resolved when the styles have been applied.
       */
          function (element) {
              if (!this._wrapper) {
                  this._wrapper = document.createElement('div');
                  this._wrapper.classList.add('cdk-global-overlay-wrapper');
                  element.parentNode.insertBefore(this._wrapper, element);
                  this._wrapper.appendChild(element);
              }
              /** @type {?} */
              var styles = element.style;
              /** @type {?} */
              var parentStyles = ( /** @type {?} */(element.parentNode)).style;
              styles.position = this._cssPosition;
              styles.marginTop = this._topOffset;
              styles.marginLeft = this._leftOffset;
              styles.marginBottom = this._bottomOffset;
              styles.marginRight = this._rightOffset;
              styles.width = this._width;
              styles.height = this._height;
              parentStyles.justifyContent = this._justifyContent;
              parentStyles.alignItems = this._alignItems;
              return Promise.resolve(null);
          };
      /**
       * Removes the wrapper element from the DOM.
       */
      /**
       * Removes the wrapper element from the DOM.
       * @return {?}
       */
      GlobalPositionStrategy.prototype.dispose = /**
       * Removes the wrapper element from the DOM.
       * @return {?}
       */
          function () {
              if (this._wrapper && this._wrapper.parentNode) {
                  this._wrapper.parentNode.removeChild(this._wrapper);
                  this._wrapper = null;
              }
          };
      return GlobalPositionStrategy;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Builder for overlay position strategy.
   */
  var OverlayPositionBuilder = /** @class */ (function () {
      function OverlayPositionBuilder(_viewportRuler) {
          this._viewportRuler = _viewportRuler;
      }
      /**
       * Creates a global position strategy.
       */
      /**
       * Creates a global position strategy.
       * @return {?}
       */
      OverlayPositionBuilder.prototype.global = /**
       * Creates a global position strategy.
       * @return {?}
       */
          function () {
              return new GlobalPositionStrategy();
          };
      /**
       * Creates a relative position strategy.
       * @param elementRef
       * @param originPos
       * @param overlayPos
       */
      /**
       * Creates a relative position strategy.
       * @param {?} elementRef
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
      OverlayPositionBuilder.prototype.connectedTo = /**
       * Creates a relative position strategy.
       * @param {?} elementRef
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
          function (elementRef, originPos, overlayPos) {
              return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);
          };
      OverlayPositionBuilder.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      OverlayPositionBuilder.ctorParameters = function () {
          return [
              { type: ViewportRuler }
          ];
      };
      return OverlayPositionBuilder;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * The OverlayContainer is the container in which all overlays will load.
   * It should be provided in the root component to ensure it is properly shared.
   */
  var OverlayContainer = /** @class */ (function () {
      function OverlayContainer() {
      }
      Object.defineProperty(OverlayContainer.prototype, "themeClass", {
          /**
           * Base theme to be applied to all overlay-based components.
           */
          get: /**
           * Base theme to be applied to all overlay-based components.
           * @return {?}
           */ function () { return this._themeClass; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._containerElement) {
                  this._containerElement.classList.remove(this._themeClass);
                  if (value) {
                      this._containerElement.classList.add(value);
                  }
              }
              this._themeClass = value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * This method returns the overlay container element.  It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @returns the container element
       */
      /**
       * This method returns the overlay container element.  It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @return {?} the container element
       */
      OverlayContainer.prototype.getContainerElement = /**
       * This method returns the overlay container element.  It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @return {?} the container element
       */
          function () {
              if (!this._containerElement) {
                  this._createContainer();
              }
              return this._containerElement;
          };
      /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       */
      /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       * @return {?}
       */
      OverlayContainer.prototype._createContainer = /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var container = document.createElement('div');
              container.classList.add('cdk-overlay-container');
              if (this._themeClass) {
                  container.classList.add(this._themeClass);
              }
              document.body.appendChild(container);
              this._containerElement = container;
          };
      OverlayContainer.decorators = [
          { type: core.Injectable }
      ];
      return OverlayContainer;
  }());
  /**
   * @param {?} parentContainer
   * @return {?}
   */
  function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {
      return parentContainer || new OverlayContainer();
  }
  /** @type {?} */
  var OVERLAY_CONTAINER_PROVIDER = {
      // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
      provide: OverlayContainer,
      deps: [[new core.Optional(), new core.SkipSelf(), OverlayContainer]],
      useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Next overlay unique ID.
    @type {?} */
  var nextUniqueId = 0;
  /** *
   * The default state for newly created overlays.
    @type {?} */
  var defaultState = new OverlayState();
  /**
   * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
   * used as a low-level building building block for other components. Dialogs, tooltips, menus,
   * selects, etc. can all be built using overlays. The service should primarily be used by authors
   * of re-usable components rather than developers building end-user applications.
   *
   * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.
   */
  var Overlay = /** @class */ (function () {
      function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {
          this.scrollStrategies = scrollStrategies;
          this._overlayContainer = _overlayContainer;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._positionBuilder = _positionBuilder;
          this._appRef = _appRef;
          this._injector = _injector;
          this._ngZone = _ngZone;
      }
      /**
       * Creates an overlay.
       * @param state State to apply to the overlay.
       * @returns Reference to the created overlay.
       */
      /**
       * Creates an overlay.
       * @param {?=} state State to apply to the overlay.
       * @return {?} Reference to the created overlay.
       */
      Overlay.prototype.create = /**
       * Creates an overlay.
       * @param {?=} state State to apply to the overlay.
       * @return {?} Reference to the created overlay.
       */
          function (state) {
              if (state === void 0) {
                  state = defaultState;
              }
              return this._createOverlayRef(this._createPaneElement(), state);
          };
      /**
       * Returns a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       */
      /**
       * Returns a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       * @return {?}
       */
      Overlay.prototype.position = /**
       * Returns a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       * @return {?}
       */
          function () {
              return this._positionBuilder;
          };
      /**
       * Creates the DOM element for an overlay and appends it to the overlay container.
       * @return {?} Newly-created pane element
       */
      Overlay.prototype._createPaneElement = /**
       * Creates the DOM element for an overlay and appends it to the overlay container.
       * @return {?} Newly-created pane element
       */
          function () {
              /** @type {?} */
              var pane = document.createElement('div');
              pane.id = "cdk-overlay-" + nextUniqueId++;
              pane.classList.add('cdk-overlay-pane');
              this._overlayContainer.getContainerElement().appendChild(pane);
              return pane;
          };
      /**
       * Create a DomPortalHost into which the overlay content can be loaded.
       * @param {?} pane The DOM element to turn into a portal host.
       * @return {?} A portal host for the given DOM element.
       */
      Overlay.prototype._createPortalHost = /**
       * Create a DomPortalHost into which the overlay content can be loaded.
       * @param {?} pane The DOM element to turn into a portal host.
       * @return {?} A portal host for the given DOM element.
       */
          function (pane) {
              return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);
          };
      /**
       * Creates an OverlayRef for an overlay in the given DOM element.
       * @param {?} pane DOM element for the overlay
       * @param {?} state
       * @return {?}
       */
      Overlay.prototype._createOverlayRef = /**
       * Creates an OverlayRef for an overlay in the given DOM element.
       * @param {?} pane DOM element for the overlay
       * @param {?} state
       * @return {?}
       */
          function (pane, state) {
              /** @type {?} */
              var scrollStrategy = state.scrollStrategy || this.scrollStrategies.noop();
              /** @type {?} */
              var portalHost = this._createPortalHost(pane);
              return new OverlayRef(portalHost, pane, state, scrollStrategy, this._ngZone);
          };
      Overlay.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      Overlay.ctorParameters = function () {
          return [
              { type: ScrollStrategyOptions },
              { type: OverlayContainer },
              { type: core.ComponentFactoryResolver },
              { type: OverlayPositionBuilder },
              { type: core.ApplicationRef },
              { type: core.Injector },
              { type: core.NgZone }
          ];
      };
      return Overlay;
  }());
  /** *
   * Providers for Overlay and its related injectables.
    @type {?} */
  var OVERLAY_PROVIDERS = [
      Overlay,
      OverlayPositionBuilder,
      VIEWPORT_RULER_PROVIDER,
      OVERLAY_CONTAINER_PROVIDER,
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Default set of positions for the overlay. Follows the behavior of a dropdown.
    @type {?} */
  var defaultPositionList = [
      new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
      new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
  ];
  /**
   * Directive applied to an element to make it usable as an origin for an Overlay using a
   * ConnectedPositionStrategy.
   */
  var OverlayOrigin = /** @class */ (function () {
      function OverlayOrigin(elementRef) {
          this.elementRef = elementRef;
      }
      OverlayOrigin.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
                      exportAs: 'cdkOverlayOrigin',
                  },] }
      ];
      /** @nocollapse */
      OverlayOrigin.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      return OverlayOrigin;
  }());
  /**
   * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.
   */
  var ConnectedOverlayDirective = /** @class */ (function () {
      // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
      function ConnectedOverlayDirective(_overlay, _renderer, templateRef, viewContainerRef, _dir) {
          this._overlay = _overlay;
          this._renderer = _renderer;
          this._dir = _dir;
          this._hasBackdrop = false;
          this._offsetX = 0;
          this._offsetY = 0;
          /**
           * Strategy to be used when handling scroll events while the overlay is open.
           */
          this.scrollStrategy = this._overlay.scrollStrategies.reposition();
          /**
           * Whether the overlay is open.
           */
          this.open = false;
          /**
           * Event emitted when the backdrop is clicked.
           */
          this.backdropClick = new core.EventEmitter();
          /**
           * Event emitted when the position has changed.
           */
          this.positionChange = new core.EventEmitter();
          /**
           * Event emitted when the overlay has been attached.
           */
          this.attach = new core.EventEmitter();
          /**
           * Event emitted when the overlay has been detached.
           */
          this.detach = new core.EventEmitter();
          this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
      }
      Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetX", {
          /** The offset in pixels for the overlay connection point on the x-axis */
          get: /**
           * The offset in pixels for the overlay connection point on the x-axis
           * @return {?}
           */ function () {
              return this._offsetX;
          },
          set: /**
           * @param {?} offsetX
           * @return {?}
           */ function (offsetX) {
              this._offsetX = offsetX;
              if (this._position) {
                  this._position.withOffsetX(offsetX);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetY", {
          /** The offset in pixels for the overlay connection point on the y-axis */
          get: /**
           * The offset in pixels for the overlay connection point on the y-axis
           * @return {?}
           */ function () {
              return this._offsetY;
          },
          set: /**
           * @param {?} offsetY
           * @return {?}
           */ function (offsetY) {
              this._offsetY = offsetY;
              if (this._position) {
                  this._position.withOffsetY(offsetY);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedOverlayDirective.prototype, "hasBackdrop", {
          /** Whether or not the overlay should attach a backdrop. */
          get: /**
           * Whether or not the overlay should attach a backdrop.
           * @return {?}
           */ function () {
              return this._hasBackdrop;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hasBackdrop = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedOverlayDirective.prototype, "overlayRef", {
          /** The associated overlay reference. */
          get: /**
           * The associated overlay reference.
           * @return {?}
           */ function () {
              return this._overlayRef;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedOverlayDirective.prototype, "dir", {
          /** The element's layout direction. */
          get: /**
           * The element's layout direction.
           * @return {?}
           */ function () {
              return this._dir ? this._dir.value : 'ltr';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      ConnectedOverlayDirective.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyOverlay();
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      ConnectedOverlayDirective.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (changes['open']) {
                  this.open ? this._attachOverlay() : this._detachOverlay();
              }
          };
      /**
       * Creates an overlay
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._createOverlay = /**
       * Creates an overlay
       * @return {?}
       */
          function () {
              if (!this.positions || !this.positions.length) {
                  this.positions = defaultPositionList;
              }
              this._overlayRef = this._overlay.create(this._buildConfig());
          };
      /**
       * Builds the overlay config based on the directive's inputs
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._buildConfig = /**
       * Builds the overlay config based on the directive's inputs
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayConfig = new OverlayState();
              if (this.width || this.width === 0) {
                  overlayConfig.width = this.width;
              }
              if (this.height || this.height === 0) {
                  overlayConfig.height = this.height;
              }
              if (this.minWidth || this.minWidth === 0) {
                  overlayConfig.minWidth = this.minWidth;
              }
              if (this.minHeight || this.minHeight === 0) {
                  overlayConfig.minHeight = this.minHeight;
              }
              overlayConfig.hasBackdrop = this.hasBackdrop;
              if (this.backdropClass) {
                  overlayConfig.backdropClass = this.backdropClass;
              }
              this._position = /** @type {?} */ (this._createPositionStrategy());
              overlayConfig.positionStrategy = this._position;
              overlayConfig.scrollStrategy = this.scrollStrategy;
              return overlayConfig;
          };
      /**
       * Returns the position strategy of the overlay to be set on the overlay config
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._createPositionStrategy = /**
       * Returns the position strategy of the overlay to be set on the overlay config
       * @return {?}
       */
          function () {
              /** @type {?} */
              var pos = this.positions[0];
              /** @type {?} */
              var originPoint = { originX: pos.originX, originY: pos.originY };
              /** @type {?} */
              var overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };
              /** @type {?} */
              var strategy = this._overlay.position()
                  .connectedTo(this.origin.elementRef, originPoint, overlayPoint)
                  .withOffsetX(this.offsetX)
                  .withOffsetY(this.offsetY);
              this._handlePositionChanges(strategy);
              return strategy;
          };
      /**
       * @param {?} strategy
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._handlePositionChanges = /**
       * @param {?} strategy
       * @return {?}
       */
          function (strategy) {
              var _this = this;
              for (var i = 1; i < this.positions.length; i++) {
                  strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });
              }
              this._positionSubscription =
                  strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });
          };
      /**
       * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._attachOverlay = /**
       * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._overlayRef) {
                  this._createOverlay();
              }
              this._position.withDirection(this.dir);
              this._overlayRef.getState().direction = this.dir;
              this._initEscapeListener();
              if (!this._overlayRef.hasAttached()) {
                  this._overlayRef.attach(this._templatePortal);
                  this.attach.emit();
              }
              if (this.hasBackdrop) {
                  this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                      _this.backdropClick.emit();
                  });
              }
          };
      /**
       * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._detachOverlay = /**
       * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.detach();
                  this.detach.emit();
              }
              if (this._backdropSubscription) {
                  this._backdropSubscription.unsubscribe();
                  this._backdropSubscription = null;
              }
              if (this._escapeListener) {
                  this._escapeListener();
              }
          };
      /**
       * Destroys the overlay created by this directive.
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._destroyOverlay = /**
       * Destroys the overlay created by this directive.
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.dispose();
              }
              if (this._backdropSubscription) {
                  this._backdropSubscription.unsubscribe();
              }
              if (this._positionSubscription) {
                  this._positionSubscription.unsubscribe();
              }
              if (this._escapeListener) {
                  this._escapeListener();
              }
          };
      /**
       * Sets the event listener that closes the overlay when pressing Escape.
       * @return {?}
       */
      ConnectedOverlayDirective.prototype._initEscapeListener = /**
       * Sets the event listener that closes the overlay when pressing Escape.
       * @return {?}
       */
          function () {
              var _this = this;
              this._escapeListener = this._renderer.listen('document', 'keydown', function (event) {
                  if (event.keyCode === ESCAPE) {
                      _this._detachOverlay();
                  }
              });
          };
      ConnectedOverlayDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
                      exportAs: 'cdkConnectedOverlay'
                  },] }
      ];
      /** @nocollapse */
      ConnectedOverlayDirective.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.Renderer2 },
              { type: core.TemplateRef },
              { type: core.ViewContainerRef },
              { type: Dir, decorators: [{ type: core.Optional }] }
          ];
      };
      ConnectedOverlayDirective.propDecorators = {
          origin: [{ type: core.Input }],
          positions: [{ type: core.Input }],
          offsetX: [{ type: core.Input }],
          offsetY: [{ type: core.Input }],
          width: [{ type: core.Input }],
          height: [{ type: core.Input }],
          minWidth: [{ type: core.Input }],
          minHeight: [{ type: core.Input }],
          backdropClass: [{ type: core.Input }],
          scrollStrategy: [{ type: core.Input }],
          open: [{ type: core.Input }],
          hasBackdrop: [{ type: core.Input }],
          backdropClick: [{ type: core.Output }],
          positionChange: [{ type: core.Output }],
          attach: [{ type: core.Output }],
          detach: [{ type: core.Output }]
      };
      return ConnectedOverlayDirective;
  }());
  var OverlayModule = /** @class */ (function () {
      function OverlayModule() {
      }
      OverlayModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [PortalModule, ScrollDispatchModule],
                      exports: [ConnectedOverlayDirective, OverlayOrigin, ScrollDispatchModule],
                      declarations: [ConnectedOverlayDirective, OverlayOrigin],
                      providers: [OVERLAY_PROVIDERS],
                  },] }
      ];
      return OverlayModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Utility for checking the interactivity of an element, such as whether is is focusable or
   * tabbable.
   */
  var InteractivityChecker = /** @class */ (function () {
      function InteractivityChecker(_platform) {
          this._platform = _platform;
      }
      /**
       * Gets whether an element is disabled.
       *
       * @param element Element to be checked.
       * @returns Whether the element is disabled.
       */
      /**
       * Gets whether an element is disabled.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is disabled.
       */
      InteractivityChecker.prototype.isDisabled = /**
       * Gets whether an element is disabled.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is disabled.
       */
          function (element) {
              // This does not capture some cases, such as a non-form control with a disabled attribute or
              // a form control inside of a disabled form, but should capture the most common cases.
              return element.hasAttribute('disabled');
          };
      /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @returns Whether the element is visible.
       */
      /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @param {?} element
       * @return {?} Whether the element is visible.
       */
      InteractivityChecker.prototype.isVisible = /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @param {?} element
       * @return {?} Whether the element is visible.
       */
          function (element) {
              return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';
          };
      /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param element Element to be checked.
       * @returns Whether the element is tabbable.
       */
      /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is tabbable.
       */
      InteractivityChecker.prototype.isTabbable = /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is tabbable.
       */
          function (element) {
              // Nothing is tabbable on the the server 😎
              if (!this._platform.isBrowser) {
                  return false;
              }
              /** @type {?} */
              var frameElement = /** @type {?} */ (getWindow(element).frameElement);
              if (frameElement) {
                  /** @type {?} */
                  var frameType = frameElement && frameElement.nodeName.toLowerCase();
                  // Frame elements inherit their tabindex onto all child elements.
                  if (getTabIndexValue(frameElement) === -1) {
                      return false;
                  }
                  // Webkit and Blink consider anything inside of an <object> element as non-tabbable.
                  if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {
                      return false;
                  }
                  // Webkit and Blink disable tabbing to an element inside of an invisible frame.
                  if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {
                      return false;
                  }
              }
              /** @type {?} */
              var nodeName = element.nodeName.toLowerCase();
              /** @type {?} */
              var tabIndexValue = getTabIndexValue(element);
              if (element.hasAttribute('contenteditable')) {
                  return tabIndexValue !== -1;
              }
              if (nodeName === 'iframe') {
                  // The frames may be tabbable depending on content, but it's not possibly to reliably
                  // investigate the content of the frames.
                  return false;
              }
              if (nodeName === 'audio') {
                  if (!element.hasAttribute('controls')) {
                      // By default an <audio> element without the controls enabled is not tabbable.
                      return false;
                  }
                  else if (this._platform.BLINK) {
                      // In Blink <audio controls> elements are always tabbable.
                      return true;
                  }
              }
              if (nodeName === 'video') {
                  if (!element.hasAttribute('controls') && this._platform.TRIDENT) {
                      // In Trident a <video> element without the controls enabled is not tabbable.
                      return false;
                  }
                  else if (this._platform.BLINK || this._platform.FIREFOX) {
                      // In Chrome and Firefox <video controls> elements are always tabbable.
                      return true;
                  }
              }
              if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {
                  // In all Blink and WebKit based browsers <object> elements are never tabbable.
                  return false;
              }
              // In iOS the browser only considers some specific elements as tabbable.
              if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
                  return false;
              }
              return element.tabIndex >= 0;
          };
      /**
       * Gets whether an element can be focused by the user.
       *
       * @param element Element to be checked.
       * @returns Whether the element is focusable.
       */
      /**
       * Gets whether an element can be focused by the user.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is focusable.
       */
      InteractivityChecker.prototype.isFocusable = /**
       * Gets whether an element can be focused by the user.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is focusable.
       */
          function (element) {
              // Perform checks in order of left to most expensive.
              // Again, naive approach that does not capture many edge cases and browser quirks.
              return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);
          };
      InteractivityChecker.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      InteractivityChecker.ctorParameters = function () {
          return [
              { type: Platform }
          ];
      };
      return InteractivityChecker;
  }());
  /**
   * Checks whether the specified element has any geometry / rectangles.
   * @param {?} element
   * @return {?}
   */
  function hasGeometry(element) {
      // Use logic from jQuery to check for an invisible element.
      // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12
      return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
  }
  /**
   * Gets whether an element's
   * @param {?} element
   * @return {?}
   */
  function isNativeFormElement(element) {
      /** @type {?} */
      var nodeName = element.nodeName.toLowerCase();
      return nodeName === 'input' ||
          nodeName === 'select' ||
          nodeName === 'button' ||
          nodeName === 'textarea';
  }
  /**
   * Gets whether an element is an <input type="hidden">.
   * @param {?} element
   * @return {?}
   */
  function isHiddenInput(element) {
      return isInputElement(element) && element.type == 'hidden';
  }
  /**
   * Gets whether an element is an anchor that has an href attribute.
   * @param {?} element
   * @return {?}
   */
  function isAnchorWithHref(element) {
      return isAnchorElement(element) && element.hasAttribute('href');
  }
  /**
   * Gets whether an element is an input element.
   * @param {?} element
   * @return {?}
   */
  function isInputElement(element) {
      return element.nodeName.toLowerCase() == 'input';
  }
  /**
   * Gets whether an element is an anchor element.
   * @param {?} element
   * @return {?}
   */
  function isAnchorElement(element) {
      return element.nodeName.toLowerCase() == 'a';
  }
  /**
   * Gets whether an element has a valid tabindex.
   * @param {?} element
   * @return {?}
   */
  function hasValidTabIndex(element) {
      if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {
          return false;
      }
      /** @type {?} */
      var tabIndex = element.getAttribute('tabindex');
      // IE11 parses tabindex="" as the value "-32768"
      if (tabIndex == '-32768') {
          return false;
      }
      return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
  }
  /**
   * Returns the parsed tabindex from the element attributes instead of returning the
   * evaluated tabindex from the browsers defaults.
   * @param {?} element
   * @return {?}
   */
  function getTabIndexValue(element) {
      if (!hasValidTabIndex(element)) {
          return null;
      }
      /** @type {?} */
      var tabIndex = parseInt(element.getAttribute('tabindex'), 10);
      return isNaN(tabIndex) ? -1 : tabIndex;
  }
  /**
   * Checks whether the specified element is potentially tabbable on iOS
   * @param {?} element
   * @return {?}
   */
  function isPotentiallyTabbableIOS(element) {
      /** @type {?} */
      var nodeName = element.nodeName.toLowerCase();
      /** @type {?} */
      var inputType = nodeName === 'input' && ( /** @type {?} */(element)).type;
      return inputType === 'text'
          || inputType === 'password'
          || nodeName === 'select'
          || nodeName === 'textarea';
  }
  /**
   * Gets whether an element is potentially focusable without taking current visible/disabled state
   * into account.
   * @param {?} element
   * @return {?}
   */
  function isPotentiallyFocusable(element) {
      // Inputs are potentially focusable *unless* they're type="hidden".
      if (isHiddenInput(element)) {
          return false;
      }
      return isNativeFormElement(element) ||
          isAnchorWithHref(element) ||
          element.hasAttribute('contenteditable') ||
          hasValidTabIndex(element);
  }
  /**
   * Gets the parent window of a DOM node with regards of being inside of an iframe.
   * @param {?} node
   * @return {?}
   */
  function getWindow(node) {
      return node.ownerDocument.defaultView || window;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Class that allows for trapping focus within a DOM element.
   *
   * NOTE: This class currently uses a very simple (naive) approach to focus trapping.
   * It assumes that the tab order is the same as DOM order, which is not necessarily true.
   * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.
   * This will be replaced with a more intelligent solution before the library is considered stable.
   */
  var /**
   * Class that allows for trapping focus within a DOM element.
   *
   * NOTE: This class currently uses a very simple (naive) approach to focus trapping.
   * It assumes that the tab order is the same as DOM order, which is not necessarily true.
   * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.
   * This will be replaced with a more intelligent solution before the library is considered stable.
   */ FocusTrap = /** @class */ (function () {
      function FocusTrap(_element, _platform, _checker, _ngZone, deferAnchors) {
          if (deferAnchors === void 0) {
              deferAnchors = false;
          }
          this._element = _element;
          this._platform = _platform;
          this._checker = _checker;
          this._ngZone = _ngZone;
          this._enabled = true;
          if (!deferAnchors) {
              this.attachAnchors();
          }
      }
      Object.defineProperty(FocusTrap.prototype, "enabled", {
          /** Whether the focus trap is active. */
          get: /**
           * Whether the focus trap is active.
           * @return {?}
           */ function () { return this._enabled; },
          set: /**
           * @param {?} val
           * @return {?}
           */ function (val) {
              this._enabled = val;
              if (this._startAnchor && this._endAnchor) {
                  this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;
              }
          },
          enumerable: true,
          configurable: true
      });
      /** Destroys the focus trap by cleaning up the anchors. */
      /**
       * Destroys the focus trap by cleaning up the anchors.
       * @return {?}
       */
      FocusTrap.prototype.destroy = /**
       * Destroys the focus trap by cleaning up the anchors.
       * @return {?}
       */
          function () {
              if (this._startAnchor && this._startAnchor.parentNode) {
                  this._startAnchor.parentNode.removeChild(this._startAnchor);
              }
              if (this._endAnchor && this._endAnchor.parentNode) {
                  this._endAnchor.parentNode.removeChild(this._endAnchor);
              }
              this._startAnchor = this._endAnchor = null;
          };
      /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       */
      /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @return {?}
       */
      FocusTrap.prototype.attachAnchors = /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @return {?}
       */
          function () {
              var _this = this;
              // If we're not on the browser, there can be no focus to trap.
              if (!this._platform.isBrowser) {
                  return;
              }
              if (!this._startAnchor) {
                  this._startAnchor = this._createAnchor();
              }
              if (!this._endAnchor) {
                  this._endAnchor = this._createAnchor();
              }
              this._ngZone.runOutsideAngular(function () {
                  _this._startAnchor.addEventListener('focus', function () { return _this.focusLastTabbableElement(); });
                  _this._endAnchor.addEventListener('focus', function () { return _this.focusFirstTabbableElement(); });
                  _this._element.parentNode.insertBefore(_this._startAnchor, _this._element);
                  _this._element.parentNode.insertBefore(_this._endAnchor, _this._element.nextSibling);
              });
          };
      /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element..
       */
      /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element..
       * @return {?}
       */
      FocusTrap.prototype.focusInitialElementWhenReady = /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element..
       * @return {?}
       */
          function () {
              var _this = this;
              this._executeOnStable(function () { return _this.focusInitialElement(); });
          };
      /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       */
      /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @return {?}
       */
      FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @return {?}
       */
          function () {
              var _this = this;
              this._executeOnStable(function () { return _this.focusFirstTabbableElement(); });
          };
      /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       */
      /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @return {?}
       */
      FocusTrap.prototype.focusLastTabbableElementWhenReady = /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @return {?}
       */
          function () {
              var _this = this;
              this._executeOnStable(function () { return _this.focusLastTabbableElement(); });
          };
      /**
       * Get the specified boundary element of the trapped region.
       * @param {?} bound The boundary to get (start or end of trapped region).
       * @return {?} The boundary element.
       */
      FocusTrap.prototype._getRegionBoundary = /**
       * Get the specified boundary element of the trapped region.
       * @param {?} bound The boundary to get (start or end of trapped region).
       * @return {?} The boundary element.
       */
          function (bound) {
              /** @type {?} */
              var markers = /** @type {?} */ (this._element.querySelectorAll("[cdk-focus-region-" + bound + "], " +
                  ("[cdk-focus-" + bound + "]")));
              for (var i = 0; i < markers.length; i++) {
                  if (markers[i].hasAttribute("cdk-focus-" + bound)) {
                      console.warn("Found use of deprecated attribute 'cdk-focus-" + bound + "'," +
                          (" use 'cdk-focus-region-" + bound + "' instead."), markers[i]);
                  }
              }
              if (bound == 'start') {
                  return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
              }
              return markers.length ?
                  markers[markers.length - 1] : this._getLastTabbableElement(this._element);
          };
      /** Focuses the element that should be focused when the focus trap is initialized. */
      /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @return {?}
       */
      FocusTrap.prototype.focusInitialElement = /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var redirectToElement = /** @type {?} */ (this._element.querySelector('[cdk-focus-initial]'));
              if (redirectToElement) {
                  redirectToElement.focus();
              }
              else {
                  this.focusFirstTabbableElement();
              }
          };
      /** Focuses the first tabbable element within the focus trap region. */
      /**
       * Focuses the first tabbable element within the focus trap region.
       * @return {?}
       */
      FocusTrap.prototype.focusFirstTabbableElement = /**
       * Focuses the first tabbable element within the focus trap region.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var redirectToElement = this._getRegionBoundary('start');
              if (redirectToElement) {
                  redirectToElement.focus();
              }
          };
      /** Focuses the last tabbable element within the focus trap region. */
      /**
       * Focuses the last tabbable element within the focus trap region.
       * @return {?}
       */
      FocusTrap.prototype.focusLastTabbableElement = /**
       * Focuses the last tabbable element within the focus trap region.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var redirectToElement = this._getRegionBoundary('end');
              if (redirectToElement) {
                  redirectToElement.focus();
              }
          };
      /**
       * Get the first tabbable element from a DOM subtree (inclusive).
       * @param {?} root
       * @return {?}
       */
      FocusTrap.prototype._getFirstTabbableElement = /**
       * Get the first tabbable element from a DOM subtree (inclusive).
       * @param {?} root
       * @return {?}
       */
          function (root) {
              if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
                  return root;
              }
              /** @type {?} */
              var children = root.children || root.childNodes;
              for (var i = 0; i < children.length; i++) {
                  /** @type {?} */
                  var tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?
                      this._getFirstTabbableElement(/** @type {?} */ (children[i])) :
                      null;
                  if (tabbableChild) {
                      return tabbableChild;
                  }
              }
              return null;
          };
      /**
       * Get the last tabbable element from a DOM subtree (inclusive).
       * @param {?} root
       * @return {?}
       */
      FocusTrap.prototype._getLastTabbableElement = /**
       * Get the last tabbable element from a DOM subtree (inclusive).
       * @param {?} root
       * @return {?}
       */
          function (root) {
              if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
                  return root;
              }
              /** @type {?} */
              var children = root.children || root.childNodes;
              for (var i = children.length - 1; i >= 0; i--) {
                  /** @type {?} */
                  var tabbableChild = children[i].nodeType === Node.ELEMENT_NODE ?
                      this._getLastTabbableElement(/** @type {?} */ (children[i])) :
                      null;
                  if (tabbableChild) {
                      return tabbableChild;
                  }
              }
              return null;
          };
      /**
       * Creates an anchor element.
       * @return {?}
       */
      FocusTrap.prototype._createAnchor = /**
       * Creates an anchor element.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var anchor = document.createElement('div');
              anchor.tabIndex = this._enabled ? 0 : -1;
              anchor.classList.add('cdk-visually-hidden');
              anchor.classList.add('cdk-focus-trap-anchor');
              return anchor;
          };
      /**
       * Executes a function when the zone is stable.
       * @param {?} fn
       * @return {?}
       */
      FocusTrap.prototype._executeOnStable = /**
       * Executes a function when the zone is stable.
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              if (this._ngZone.isStable) {
                  fn();
              }
              else {
                  this._ngZone.onStable.pipe(operators.first()).subscribe(fn);
              }
          };
      return FocusTrap;
  }());
  /**
   * Factory that allows easy instantiation of focus traps.
   */
  var FocusTrapFactory = /** @class */ (function () {
      function FocusTrapFactory(_checker, _platform, _ngZone) {
          this._checker = _checker;
          this._platform = _platform;
          this._ngZone = _ngZone;
      }
      /**
       * @param {?} element
       * @param {?=} deferAnchors
       * @return {?}
       */
      FocusTrapFactory.prototype.create = /**
       * @param {?} element
       * @param {?=} deferAnchors
       * @return {?}
       */
          function (element, deferAnchors) {
              if (deferAnchors === void 0) {
                  deferAnchors = false;
              }
              return new FocusTrap(element, this._platform, this._checker, this._ngZone, deferAnchors);
          };
      FocusTrapFactory.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      FocusTrapFactory.ctorParameters = function () {
          return [
              { type: InteractivityChecker },
              { type: Platform },
              { type: core.NgZone }
          ];
      };
      return FocusTrapFactory;
  }());
  /**
   * Directive for trapping focus within a region.
   * @deprecated
   */
  var FocusTrapDeprecatedDirective = /** @class */ (function () {
      function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {
          this._elementRef = _elementRef;
          this._focusTrapFactory = _focusTrapFactory;
          this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
      }
      Object.defineProperty(FocusTrapDeprecatedDirective.prototype, "disabled", {
          /** Whether the focus trap is active. */
          get: /**
           * Whether the focus trap is active.
           * @return {?}
           */ function () { return !this.focusTrap.enabled; },
          set: /**
           * @param {?} val
           * @return {?}
           */ function (val) {
              this.focusTrap.enabled = !coerceBooleanProperty(val);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.focusTrap.destroy();
          };
      /**
       * @return {?}
       */
      FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this.focusTrap.attachAnchors();
          };
      FocusTrapDeprecatedDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-focus-trap',
                  },] }
      ];
      /** @nocollapse */
      FocusTrapDeprecatedDirective.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusTrapFactory }
          ];
      };
      FocusTrapDeprecatedDirective.propDecorators = {
          disabled: [{ type: core.Input }]
      };
      return FocusTrapDeprecatedDirective;
  }());
  /**
   * Directive for trapping focus within a region.
   */
  var FocusTrapDirective = /** @class */ (function () {
      function FocusTrapDirective(_elementRef, _focusTrapFactory) {
          this._elementRef = _elementRef;
          this._focusTrapFactory = _focusTrapFactory;
          this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
      }
      Object.defineProperty(FocusTrapDirective.prototype, "enabled", {
          /** Whether the focus trap is active. */
          get: /**
           * Whether the focus trap is active.
           * @return {?}
           */ function () { return this.focusTrap.enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      FocusTrapDirective.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.focusTrap.destroy();
          };
      /**
       * @return {?}
       */
      FocusTrapDirective.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this.focusTrap.attachAnchors();
          };
      FocusTrapDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTrapFocus]',
                      exportAs: 'cdkTrapFocus',
                  },] }
      ];
      /** @nocollapse */
      FocusTrapDirective.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusTrapFactory }
          ];
      };
      FocusTrapDirective.propDecorators = {
          enabled: [{ type: core.Input, args: ['cdkTrapFocus',] }]
      };
      return FocusTrapDirective;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var LIVE_ANNOUNCER_ELEMENT_TOKEN = new core.InjectionToken('liveAnnouncerElement');
  var LiveAnnouncer = /** @class */ (function () {
      function LiveAnnouncer(elementToken, platform) {
          // Only do anything if we're on the browser platform.
          if (platform.isBrowser) {
              // We inject the live element as `any` because the constructor signature cannot reference
              // browser globals (HTMLElement) on non-browser environments, since having a class decorator
              // causes TypeScript to preserve the constructor signature types.
              this._liveElement = elementToken || this._createLiveElement();
          }
      }
      /**
       * Announces a message to screenreaders.
       * @param message Message to be announced to the screenreader
       * @param politeness The politeness of the announcer element
       */
      /**
       * Announces a message to screenreaders.
       * @param {?} message Message to be announced to the screenreader
       * @param {?=} politeness The politeness of the announcer element
       * @return {?}
       */
      LiveAnnouncer.prototype.announce = /**
       * Announces a message to screenreaders.
       * @param {?} message Message to be announced to the screenreader
       * @param {?=} politeness The politeness of the announcer element
       * @return {?}
       */
          function (message, politeness) {
              var _this = this;
              if (politeness === void 0) {
                  politeness = 'polite';
              }
              this._liveElement.textContent = '';
              // TODO: ensure changing the politeness works on all environments we support.
              this._liveElement.setAttribute('aria-live', politeness);
              // This 100ms timeout is necessary for some browser + screen-reader combinations:
              // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
              // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
              //   second time without clearing and then using a non-zero delay.
              // (using JAWS 17 at time of this writing).
              setTimeout(function () { return _this._liveElement.textContent = message; }, 100);
          };
      /** Removes the aria-live element from the DOM. */
      /**
       * Removes the aria-live element from the DOM.
       * @return {?}
       */
      LiveAnnouncer.prototype._removeLiveElement = /**
       * Removes the aria-live element from the DOM.
       * @return {?}
       */
          function () {
              if (this._liveElement && this._liveElement.parentNode) {
                  this._liveElement.parentNode.removeChild(this._liveElement);
              }
          };
      /**
       * @return {?}
       */
      LiveAnnouncer.prototype._createLiveElement = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var liveEl = document.createElement('div');
              liveEl.classList.add('cdk-visually-hidden');
              liveEl.setAttribute('aria-atomic', 'true');
              liveEl.setAttribute('aria-live', 'polite');
              document.body.appendChild(liveEl);
              return liveEl;
          };
      LiveAnnouncer.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      LiveAnnouncer.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },
              { type: Platform }
          ];
      };
      return LiveAnnouncer;
  }());
  /**
   * @param {?} parentDispatcher
   * @param {?} liveElement
   * @param {?} platform
   * @return {?}
   */
  function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, platform) {
      return parentDispatcher || new LiveAnnouncer(liveElement, platform);
  }
  /** @type {?} */
  var LIVE_ANNOUNCER_PROVIDER = {
      // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.
      provide: LiveAnnouncer,
      deps: [
          [new core.Optional(), new core.SkipSelf(), LiveAnnouncer],
          [new core.Optional(), new core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],
          Platform,
      ],
      useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var A11yModule = /** @class */ (function () {
      function A11yModule() {
      }
      A11yModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, PlatformModule],
                      declarations: [FocusTrapDirective, FocusTrapDeprecatedDirective],
                      exports: [FocusTrapDirective, FocusTrapDeprecatedDirective],
                      providers: [InteractivityChecker, FocusTrapFactory, LIVE_ANNOUNCER_PROVIDER]
                  },] }
      ];
      return A11yModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * The FullscreenOverlayContainer is the alternative to OverlayContainer
   * that supports correct displaying of overlay elements in Fullscreen mode
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
   * It should be provided in the root component that way:
   * providers: [
   *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}
   * ],
   */
  var FullscreenOverlayContainer = /** @class */ (function (_super) {
      __extends(FullscreenOverlayContainer, _super);
      function FullscreenOverlayContainer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._createContainer = /**
       * @return {?}
       */
          function () {
              var _this = this;
              _super.prototype._createContainer.call(this);
              this._adjustParentForFullscreenChange();
              this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });
          };
      /**
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**
       * @return {?}
       */
          function () {
              if (!this._containerElement) {
                  return;
              }
              /** @type {?} */
              var fullscreenElement = this.getFullscreenElement();
              /** @type {?} */
              var parent = fullscreenElement || document.body;
              parent.appendChild(this._containerElement);
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              if (document.fullscreenEnabled) {
                  document.addEventListener('fullscreenchange', fn);
              }
              else if (document.webkitFullscreenEnabled) {
                  document.addEventListener('webkitfullscreenchange', fn);
              }
              else if (( /** @type {?} */(document)).mozFullScreenEnabled) {
                  document.addEventListener('mozfullscreenchange', fn);
              }
              else if (( /** @type {?} */(document)).msFullscreenEnabled) {
                  document.addEventListener('MSFullscreenChange', fn);
              }
          };
      /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
      */
      /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
       * @return {?}
       */
      FullscreenOverlayContainer.prototype.getFullscreenElement = /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
       * @return {?}
       */
          function () {
              return document.fullscreenElement ||
                  document.webkitFullscreenElement ||
                  ( /** @type {?} */(document)).mozFullScreenElement ||
                  ( /** @type {?} */(document)).msFullscreenElement ||
                  null;
          };
      FullscreenOverlayContainer.decorators = [
          { type: core.Injectable }
      ];
      return FullscreenOverlayContainer;
  }(OverlayContainer));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var GestureConfig = /** @class */ (function (_super) {
      __extends(GestureConfig, _super);
      function GestureConfig() {
          var _this = _super.call(this) || this;
          _this._hammer = typeof window !== 'undefined' ? ( /** @type {?} */(window)).Hammer : null;
          /* List of new event names to add to the gesture support list */
          _this.events = _this._hammer ? [
              'longpress',
              'slide',
              'slidestart',
              'slideend',
              'slideright',
              'slideleft'
          ] : [];
          if (!_this._hammer && core.isDevMode()) {
              console.warn('Could not find HammerJS. Certain Angular Material ' +
                  'components may not work correctly.');
          }
          return _this;
      }
      /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param element Element to which to assign the new HammerJS gestures.
       * @returns Newly-created HammerJS instance.
       */
      /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param {?} element Element to which to assign the new HammerJS gestures.
       * @return {?} Newly-created HammerJS instance.
       */
      GestureConfig.prototype.buildHammer = /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param {?} element Element to which to assign the new HammerJS gestures.
       * @return {?} Newly-created HammerJS instance.
       */
          function (element) {
              /** @type {?} */
              var mc = new this._hammer(element);
              /** @type {?} */
              var pan = new this._hammer.Pan();
              /** @type {?} */
              var swipe = new this._hammer.Swipe();
              /** @type {?} */
              var press = new this._hammer.Press();
              /** @type {?} */
              var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
              /** @type {?} */
              var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
              // Overwrite the default `pan` event to use the swipe event.
              pan.recognizeWith(swipe);
              // Add customized gestures to Hammer manager
              mc.add([swipe, press, pan, slide, longpress]);
              return /** @type {?} */ (mc);
          };
      /**
       * Creates a new recognizer, without affecting the default recognizers of HammerJS
       * @param {?} base
       * @param {?} options
       * @param {...?} inheritances
       * @return {?}
       */
      GestureConfig.prototype._createRecognizer = /**
       * Creates a new recognizer, without affecting the default recognizers of HammerJS
       * @param {?} base
       * @param {?} options
       * @param {...?} inheritances
       * @return {?}
       */
          function (base, options) {
              var inheritances = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                  inheritances[_i - 2] = arguments[_i];
              }
              /** @type {?} */
              var recognizer = new ( /** @type {?} */(base.constructor))(options);
              inheritances.push(base);
              inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
              return recognizer;
          };
      GestureConfig.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      GestureConfig.ctorParameters = function () { return []; };
      return GestureConfig;
  }(platformBrowser.HammerGestureConfig));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Class to be used to power selecting one or more options from a list.
   * \@docs-private
   * @template T
   */
  var /**
   * Class to be used to power selecting one or more options from a list.
   * \@docs-private
   * @template T
   */ SelectionModel = /** @class */ (function () {
      function SelectionModel(_isMulti, initiallySelectedValues, _emitChanges) {
          if (_isMulti === void 0) {
              _isMulti = false;
          }
          if (_emitChanges === void 0) {
              _emitChanges = true;
          }
          var _this = this;
          this._isMulti = _isMulti;
          this._emitChanges = _emitChanges;
          /**
           * Currently-selected values.
           */
          this._selection = new Set();
          /**
           * Keeps track of the deselected options that haven't been emitted by the change event.
           */
          this._deselectedToEmit = [];
          /**
           * Keeps track of the selected option that haven't been emitted by the change event.
           */
          this._selectedToEmit = [];
          /**
           * Event emitted when the value has changed.
           */
          this.onChange = this._emitChanges ? new rxjs.Subject() : null;
          if (initiallySelectedValues) {
              if (_isMulti) {
                  initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });
              }
              else {
                  this._markSelected(initiallySelectedValues[0]);
              }
              // Clear the array in order to avoid firing the change event for preselected values.
              this._selectedToEmit.length = 0;
          }
      }
      Object.defineProperty(SelectionModel.prototype, "selected", {
          /** Selected value(s). */
          get: /**
           * Selected value(s).
           * @return {?}
           */ function () {
              if (!this._selected) {
                  this._selected = Array.from(this._selection.values());
              }
              return this._selected;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Selects a value or an array of values.
       */
      /**
       * Selects a value or an array of values.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.select = /**
       * Selects a value or an array of values.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this._markSelected(value);
              this._emitChangeEvent();
          };
      /**
       * Deselects a value or an array of values.
       */
      /**
       * Deselects a value or an array of values.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.deselect = /**
       * Deselects a value or an array of values.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this._unmarkSelected(value);
              this._emitChangeEvent();
          };
      /**
       * Toggles a value between selected and deselected.
       */
      /**
       * Toggles a value between selected and deselected.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.toggle = /**
       * Toggles a value between selected and deselected.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.isSelected(value) ? this.deselect(value) : this.select(value);
          };
      /**
       * Clears all of the selected values.
       */
      /**
       * Clears all of the selected values.
       * @return {?}
       */
      SelectionModel.prototype.clear = /**
       * Clears all of the selected values.
       * @return {?}
       */
          function () {
              this._unmarkAll();
              this._emitChangeEvent();
          };
      /**
       * Determines whether a value is selected.
       */
      /**
       * Determines whether a value is selected.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.isSelected = /**
       * Determines whether a value is selected.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              return this._selection.has(value);
          };
      /**
       * Determines whether the model does not have a value.
       */
      /**
       * Determines whether the model does not have a value.
       * @return {?}
       */
      SelectionModel.prototype.isEmpty = /**
       * Determines whether the model does not have a value.
       * @return {?}
       */
          function () {
              return this._selection.size === 0;
          };
      /**
       * Determines whether the model has a value.
       */
      /**
       * Determines whether the model has a value.
       * @return {?}
       */
      SelectionModel.prototype.hasValue = /**
       * Determines whether the model has a value.
       * @return {?}
       */
          function () {
              return !this.isEmpty();
          };
      /**
       * Sorts the selected values based on a predicate function.
       */
      /**
       * Sorts the selected values based on a predicate function.
       * @param {?=} predicate
       * @return {?}
       */
      SelectionModel.prototype.sort = /**
       * Sorts the selected values based on a predicate function.
       * @param {?=} predicate
       * @return {?}
       */
          function (predicate) {
              if (this._isMulti && this.selected) {
                  this._selected.sort(predicate);
              }
          };
      /**
       * Emits a change event and clears the records of selected and deselected values.
       * @return {?}
       */
      SelectionModel.prototype._emitChangeEvent = /**
       * Emits a change event and clears the records of selected and deselected values.
       * @return {?}
       */
          function () {
              if (this._selectedToEmit.length || this._deselectedToEmit.length) {
                  /** @type {?} */
                  var eventData = new SelectionChange(this._selectedToEmit, this._deselectedToEmit);
                  this.onChange.next(eventData);
                  this._deselectedToEmit = [];
                  this._selectedToEmit = [];
              }
              this._selected = null;
          };
      /**
       * Selects a value.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype._markSelected = /**
       * Selects a value.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (!this.isSelected(value)) {
                  if (!this._isMulti) {
                      this._unmarkAll();
                  }
                  this._selection.add(value);
                  if (this._emitChanges) {
                      this._selectedToEmit.push(value);
                  }
              }
          };
      /**
       * Deselects a value.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype._unmarkSelected = /**
       * Deselects a value.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (this.isSelected(value)) {
                  this._selection.delete(value);
                  if (this._emitChanges) {
                      this._deselectedToEmit.push(value);
                  }
              }
          };
      /**
       * Clears out the selected values.
       * @return {?}
       */
      SelectionModel.prototype._unmarkAll = /**
       * Clears out the selected values.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.isEmpty()) {
                  this._selection.forEach(function (value) { return _this._unmarkSelected(value); });
              }
          };
      return SelectionModel;
  }());
  /**
   * Describes an event emitted when the value of a MdSelectionModel has changed.
   * \@docs-private
   * @template T
   */
  var /**
   * Describes an event emitted when the value of a MdSelectionModel has changed.
   * \@docs-private
   * @template T
   */ SelectionChange = /** @class */ (function () {
      function SelectionChange(added, removed) {
          this.added = added;
          this.removed = removed;
      }
      return SelectionChange;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Screenreaders will often fire fake mousedown events when a focusable element
   * is activated using the keyboard. We can typically distinguish between these faked
   * mousedown events and real mousedown events using the "buttons" property. While
   * real mousedowns will indicate the mouse button that was pressed (e.g. "1" for
   * the left mouse button), faked mousedowns will usually set the property value to 0.
   * @param {?} event
   * @return {?}
   */
  function isFakeMousedownFromScreenReader(event) {
      return event.buttons === 0;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Class to coordinate unique selection based on name.
   * Intended to be consumed as an Angular service.
   * This service is needed because native radio change events are only fired on the item currently
   * being selected, and we still need to uncheck the previous selection.
   *
   * This service does not *store* any IDs and names because they may change at any time, so it is
   * less error-prone if they are simply passed through when the events occur.
   */
  var UniqueSelectionDispatcher = /** @class */ (function () {
      function UniqueSelectionDispatcher() {
          this._listeners = [];
      }
      /**
       * Notify other items that selection for the given name has been set.
       * @param id ID of the item.
       * @param name Name of the item.
       */
      /**
       * Notify other items that selection for the given name has been set.
       * @param {?} id ID of the item.
       * @param {?} name Name of the item.
       * @return {?}
       */
      UniqueSelectionDispatcher.prototype.notify = /**
       * Notify other items that selection for the given name has been set.
       * @param {?} id ID of the item.
       * @param {?} name Name of the item.
       * @return {?}
       */
          function (id, name) {
              var e_1, _a;
              try {
                  for (var _b = __values(this._listeners), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var listener = _c.value;
                      listener(id, name);
                  }
              }
              catch (e_1_1) {
                  e_1 = { error: e_1_1 };
              }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return))
                          _a.call(_b);
                  }
                  finally {
                      if (e_1)
                          throw e_1.error;
                  }
              }
          };
      /** Listen for future changes to item selection. */
      /**
       * Listen for future changes to item selection.
       * @param {?} listener
       * @return {?}
       */
      UniqueSelectionDispatcher.prototype.listen = /**
       * Listen for future changes to item selection.
       * @param {?} listener
       * @return {?}
       */
          function (listener) {
              this._listeners.push(listener);
          };
      UniqueSelectionDispatcher.decorators = [
          { type: core.Injectable }
      ];
      return UniqueSelectionDispatcher;
  }());
  /**
   * @param {?} parentDispatcher
   * @return {?}
   */
  function UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {
      return parentDispatcher || new UniqueSelectionDispatcher();
  }
  /** @type {?} */
  var UNIQUE_SELECTION_DISPATCHER_PROVIDER = {
      // If there is already a dispatcher available, use that. Otherwise, provide a new one.
      provide: UniqueSelectionDispatcher,
      deps: [[new core.Optional(), new core.SkipSelf(), UniqueSelectionDispatcher]],
      useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var TOUCH_BUFFER_MS = 650;
  /**
   * Monitors mouse and keyboard events to determine the cause of focus events.
   */
  var FocusOriginMonitor = /** @class */ (function () {
      function FocusOriginMonitor(_ngZone, _platform) {
          var _this = this;
          this._ngZone = _ngZone;
          this._platform = _platform;
          /**
           * The focus origin that the next focus event is a result of.
           */
          this._origin = null;
          /**
           * Whether the window has just been focused.
           */
          this._windowFocused = false;
          /**
           * Weak map of elements being monitored to their info.
           */
          this._elementInfo = new WeakMap();
          this._ngZone.runOutsideAngular(function () { return _this._registerDocumentEvents(); });
      }
      /**
       * Monitors focus on an element and applies appropriate CSS classes.
       * @param element The element to monitor
       * @param renderer The renderer to use to apply CSS classes to the element.
       * @param checkChildren Whether to count the element as focused when its children are focused.
       * @returns An observable that emits when the focus state of the element changes.
       *     When the element is blurred, null will be emitted.
       */
      /**
       * Monitors focus on an element and applies appropriate CSS classes.
       * @param {?} element The element to monitor
       * @param {?} renderer The renderer to use to apply CSS classes to the element.
       * @param {?} checkChildren Whether to count the element as focused when its children are focused.
       * @return {?} An observable that emits when the focus state of the element changes.
       *     When the element is blurred, null will be emitted.
       */
      FocusOriginMonitor.prototype.monitor = /**
       * Monitors focus on an element and applies appropriate CSS classes.
       * @param {?} element The element to monitor
       * @param {?} renderer The renderer to use to apply CSS classes to the element.
       * @param {?} checkChildren Whether to count the element as focused when its children are focused.
       * @return {?} An observable that emits when the focus state of the element changes.
       *     When the element is blurred, null will be emitted.
       */
          function (element, renderer, checkChildren) {
              var _this = this;
              // Do nothing if we're not on the browser platform.
              if (!this._platform.isBrowser) {
                  return rxjs.of();
              }
              // Check if we're already monitoring this element.
              if (this._elementInfo.has(element)) {
                  /** @type {?} */
                  var info_1 = this._elementInfo.get(element);
                  info_1.checkChildren = checkChildren;
                  return info_1.subject.asObservable();
              }
              /** @type {?} */
              var info = {
                  unlisten: null,
                  checkChildren: checkChildren,
                  renderer: renderer,
                  subject: new rxjs.Subject()
              };
              this._elementInfo.set(element, info);
              /** @type {?} */
              var focusListener = function (event) { return _this._onFocus(event, element); };
              /** @type {?} */
              var blurListener = function (event) { return _this._onBlur(event, element); };
              this._ngZone.runOutsideAngular(function () {
                  element.addEventListener('focus', focusListener, true);
                  element.addEventListener('blur', blurListener, true);
              });
              // Create an unlisten function for later.
              info.unlisten = function () {
                  element.removeEventListener('focus', focusListener, true);
                  element.removeEventListener('blur', blurListener, true);
              };
              return info.subject.asObservable();
          };
      /**
       * Stops monitoring an element and removes all focus classes.
       * @param element The element to stop monitoring.
       */
      /**
       * Stops monitoring an element and removes all focus classes.
       * @param {?} element The element to stop monitoring.
       * @return {?}
       */
      FocusOriginMonitor.prototype.stopMonitoring = /**
       * Stops monitoring an element and removes all focus classes.
       * @param {?} element The element to stop monitoring.
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var elementInfo = this._elementInfo.get(element);
              if (elementInfo) {
                  elementInfo.unlisten();
                  elementInfo.subject.complete();
                  this._setClasses(element, null);
                  this._elementInfo.delete(element);
              }
          };
      /**
       * Focuses the element via the specified focus origin.
       * @param element The element to focus.
       * @param origin The focus origin.
       */
      /**
       * Focuses the element via the specified focus origin.
       * @param {?} element The element to focus.
       * @param {?} origin The focus origin.
       * @return {?}
       */
      FocusOriginMonitor.prototype.focusVia = /**
       * Focuses the element via the specified focus origin.
       * @param {?} element The element to focus.
       * @param {?} origin The focus origin.
       * @return {?}
       */
          function (element, origin) {
              this._setOriginForCurrentEventQueue(origin);
              element.focus();
          };
      /**
       * Register necessary event listeners on the document and window.
       * @return {?}
       */
      FocusOriginMonitor.prototype._registerDocumentEvents = /**
       * Register necessary event listeners on the document and window.
       * @return {?}
       */
          function () {
              var _this = this;
              // Do nothing if we're not on the browser platform.
              if (!this._platform.isBrowser) {
                  return;
              }
              // Note: we listen to events in the capture phase so we can detect them even if the user stops
              // propagation.
              // On keydown record the origin and clear any touch event that may be in progress.
              document.addEventListener('keydown', function () {
                  _this._lastTouchTarget = null;
                  _this._setOriginForCurrentEventQueue('keyboard');
              }, true);
              // On mousedown record the origin only if there is not touch target, since a mousedown can
              // happen as a result of a touch event.
              document.addEventListener('mousedown', function () {
                  if (!_this._lastTouchTarget) {
                      _this._setOriginForCurrentEventQueue('mouse');
                  }
              }, true);
              // When the touchstart event fires the focus event is not yet in the event queue. This means
              // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to
              // see if a focus happens.
              document.addEventListener('touchstart', function (event) {
                  if (_this._touchTimeout != null) {
                      clearTimeout(_this._touchTimeout);
                  }
                  _this._lastTouchTarget = event.target;
                  _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);
              }, true);
              // Make a note of when the window regains focus, so we can restore the origin info for the
              // focused element.
              window.addEventListener('focus', function () {
                  _this._windowFocused = true;
                  setTimeout(function () { return _this._windowFocused = false; }, 0);
              });
          };
      /**
       * Sets the focus classes on the element based on the given focus origin.
       * @param {?} element The element to update the classes on.
       * @param {?} origin The focus origin.
       * @return {?}
       */
      FocusOriginMonitor.prototype._setClasses = /**
       * Sets the focus classes on the element based on the given focus origin.
       * @param {?} element The element to update the classes on.
       * @param {?} origin The focus origin.
       * @return {?}
       */
          function (element, origin) {
              /** @type {?} */
              var renderer = this._elementInfo.get(element).renderer;
              /** @type {?} */
              var toggleClass = function (className, shouldSet) {
                  shouldSet ? renderer.addClass(element, className) : renderer.removeClass(element, className);
              };
              toggleClass('cdk-focused', !!origin);
              toggleClass('cdk-touch-focused', origin === 'touch');
              toggleClass('cdk-keyboard-focused', origin === 'keyboard');
              toggleClass('cdk-mouse-focused', origin === 'mouse');
              toggleClass('cdk-program-focused', origin === 'program');
          };
      /**
       * Sets the origin and schedules an async function to clear it at the end of the event queue.
       * @param {?} origin The origin to set.
       * @return {?}
       */
      FocusOriginMonitor.prototype._setOriginForCurrentEventQueue = /**
       * Sets the origin and schedules an async function to clear it at the end of the event queue.
       * @param {?} origin The origin to set.
       * @return {?}
       */
          function (origin) {
              var _this = this;
              this._origin = origin;
              setTimeout(function () { return _this._origin = null; }, 0);
          };
      /**
       * Checks whether the given focus event was caused by a touchstart event.
       * @param {?} event The focus event to check.
       * @return {?} Whether the event was caused by a touch.
       */
      FocusOriginMonitor.prototype._wasCausedByTouch = /**
       * Checks whether the given focus event was caused by a touchstart event.
       * @param {?} event The focus event to check.
       * @return {?} Whether the event was caused by a touch.
       */
          function (event) {
              /** @type {?} */
              var focusTarget = event.target;
              return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&
                  (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
          };
      /**
       * Handles focus events on a registered element.
       * @param {?} event The focus event.
       * @param {?} element The monitored element.
       * @return {?}
       */
      FocusOriginMonitor.prototype._onFocus = /**
       * Handles focus events on a registered element.
       * @param {?} event The focus event.
       * @param {?} element The monitored element.
       * @return {?}
       */
          function (event, element) {
              // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent
              // focus event affecting the monitored element. If we want to use the origin of the first event
              // instead we should check for the cdk-focused class here and return if the element already has
              // it. (This only matters for elements that have includesChildren = true).
              // If we are not counting child-element-focus as focused, make sure that the event target is the
              // monitored element itself.
              if (!this._elementInfo.get(element).checkChildren && element !== event.target) {
                  return;
              }
              // If we couldn't detect a cause for the focus event, it's due to one of three reasons:
              // 1) The window has just regained focus, in which case we want to restore the focused state of
              //    the element from before the window blurred.
              // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.
              // 3) The element was programmatically focused, in which case we should mark the origin as
              //    'program'.
              if (!this._origin) {
                  if (this._windowFocused && this._lastFocusOrigin) {
                      this._origin = this._lastFocusOrigin;
                  }
                  else if (this._wasCausedByTouch(event)) {
                      this._origin = 'touch';
                  }
                  else {
                      this._origin = 'program';
                  }
              }
              this._setClasses(element, this._origin);
              this._elementInfo.get(element).subject.next(this._origin);
              this._lastFocusOrigin = this._origin;
              this._origin = null;
          };
      /**
       * Handles blur events on a registered element.
       * @param {?} event The blur event.
       * @param {?} element The monitored element.
       * @return {?}
       */
      FocusOriginMonitor.prototype._onBlur = /**
       * Handles blur events on a registered element.
       * @param {?} event The blur event.
       * @param {?} element The monitored element.
       * @return {?}
       */
          function (event, element) {
              // If we are counting child-element-focus as focused, make sure that we aren't just blurring in
              // order to focus another child of the monitored element.
              if (this._elementInfo.get(element).checkChildren && event.relatedTarget instanceof Node &&
                  element.contains(event.relatedTarget)) {
                  return;
              }
              this._setClasses(element, null);
              this._elementInfo.get(element).subject.next(null);
          };
      FocusOriginMonitor.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      FocusOriginMonitor.ctorParameters = function () {
          return [
              { type: core.NgZone },
              { type: Platform }
          ];
      };
      return FocusOriginMonitor;
  }());
  /**
   * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or
   * programmatically) and adds corresponding classes to the element.
   *
   * There are two variants of this directive:
   * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is
   *    focused.
   * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.
   */
  var CdkMonitorFocus = /** @class */ (function () {
      function CdkMonitorFocus(_elementRef, _focusOriginMonitor, renderer) {
          var _this = this;
          this._elementRef = _elementRef;
          this._focusOriginMonitor = _focusOriginMonitor;
          this.cdkFocusChange = new core.EventEmitter();
          this._focusOriginMonitor.monitor(this._elementRef.nativeElement, renderer, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))
              .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });
      }
      /**
       * @return {?}
       */
      CdkMonitorFocus.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusOriginMonitor.stopMonitoring(this._elementRef.nativeElement);
          };
      CdkMonitorFocus.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',
                  },] }
      ];
      /** @nocollapse */
      CdkMonitorFocus.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusOriginMonitor },
              { type: core.Renderer2 }
          ];
      };
      CdkMonitorFocus.propDecorators = {
          cdkFocusChange: [{ type: core.Output }]
      };
      return CdkMonitorFocus;
  }());
  /**
   * @param {?} parentDispatcher
   * @param {?} ngZone
   * @param {?} platform
   * @return {?}
   */
  function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
      return parentDispatcher || new FocusOriginMonitor(ngZone, platform);
  }
  /** @type {?} */
  var FOCUS_ORIGIN_MONITOR_PROVIDER = {
      // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.
      provide: FocusOriginMonitor,
      deps: [[new core.Optional(), new core.SkipSelf(), FocusOriginMonitor], core.NgZone, Platform],
      useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Applies a CSS transform to an element, including browser-prefixed properties.
   * @param {?} element
   * @param {?} transformValue
   * @return {?}
   */
  function applyCssTransform(element, transformValue) {
      /** @type {?} */
      var value = transformValue.trim();
      element.style.transform = value;
      element.style.webkitTransform = value;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var StyleModule = /** @class */ (function () {
      function StyleModule() {
      }
      StyleModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [PlatformModule],
                      declarations: [CdkMonitorFocus],
                      exports: [CdkMonitorFocus],
                      providers: [FOCUS_ORIGIN_MONITOR_PROVIDER],
                  },] }
      ];
      return StyleModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   */
  var AnimationCurves = /** @class */ (function () {
      function AnimationCurves() {
      }
      AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';
      AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';
      AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';
      AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';
      return AnimationCurves;
  }());
  /**
   * \@docs-private
   */
  var AnimationDurations = /** @class */ (function () {
      function AnimationDurations() {
      }
      AnimationDurations.COMPLEX = '375ms';
      AnimationDurations.ENTERING = '225ms';
      AnimationDurations.EXITING = '195ms';
      return AnimationDurations;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Coerces a data-bound value (typically a string) to a number.
   * @param {?} value
   * @param {?=} fallbackValue
   * @return {?}
   */
  function coerceNumberProperty(value, fallbackValue) {
      if (fallbackValue === void 0) {
          fallbackValue = 0;
      }
      // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
      // and other non-number values as NaN, where Number just uses 0) but it considers the string
      // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
      return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */
  var /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */ DateAdapter = /** @class */ (function () {
      function DateAdapter() {
      }
      /**
       * Sets the locale used for all dates.
       * @param locale The new locale.
       */
      /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
      DateAdapter.prototype.setLocale = /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
          function (locale) {
              this.locale = locale;
          };
      /**
       * Compares two dates.
       * @param first The first date to compare.
       * @param second The second date to compare.
       * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      DateAdapter.prototype.compareDate = /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
          function (first, second) {
              return this.getYear(first) - this.getYear(second) ||
                  this.getMonth(first) - this.getMonth(second) ||
                  this.getDate(first) - this.getDate(second);
          };
      /**
       * Checks if two dates are equal.
       * @param first The first date to check.
       * @param second The second date to check.
       * @returns Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      DateAdapter.prototype.sameDate = /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
          function (first, second) {
              return first && second ? !this.compareDate(first, second) : first == second;
          };
      /**
       * Clamp the given date between min and max dates.
       * @param date The date to clamp.
       * @param min The minimum value to allow. If null or omitted no min is enforced.
       * @param max The maximum value to allow. If null or omitted no max is enforced.
       * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      DateAdapter.prototype.clampDate = /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
          function (date, min, max) {
              if (min && this.compareDate(date, min) < 0) {
                  return min;
              }
              if (max && this.compareDate(date, max) > 0) {
                  return max;
              }
              return date;
          };
      return DateAdapter;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Whether the browser supports the Intl API.
    @type {?} */
  var SUPPORTS_INTL_API = typeof Intl != 'undefined';
  /** *
   * The default month names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_MONTH_NAMES = {
      'long': [
          'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
          'October', 'November', 'December'
      ],
      'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
  };
  var ɵ0 = function (i) { return String(i + 1); };
  /** *
   * The default date names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DATE_NAMES = range(31, ɵ0);
  /** *
   * The default day of the week names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DAY_OF_WEEK_NAMES = {
      'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  };
  /**
   * Creates an array and fills it with values.
   * @template T
   * @param {?} length
   * @param {?} valueFunction
   * @return {?}
   */
  function range(length, valueFunction) {
      /** @type {?} */
      var valuesArray = Array(length);
      for (var i = 0; i < length; i++) {
          valuesArray[i] = valueFunction(i);
      }
      return valuesArray;
  }
  /**
   * Adapts the native JS Date for use with cdk-based components that work with dates.
   */
  var /**
   * Adapts the native JS Date for use with cdk-based components that work with dates.
   */ NativeDateAdapter = /** @class */ (function (_super) {
      __extends(NativeDateAdapter, _super);
      function NativeDateAdapter() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYear = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getFullYear();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getMonth();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDate = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDate();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeek = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDay();
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonthNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style });
                  return range(12, function (i) { return _this._stripDirectionalityCharacters(dtf_1.format(new Date(2017, i, 1))); });
              }
              return DEFAULT_MONTH_NAMES[style];
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getDateNames = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_2 = new Intl.DateTimeFormat(this.locale, { day: 'numeric' });
                  return range(31, function (i) { return _this._stripDirectionalityCharacters(dtf_2.format(new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DATE_NAMES;
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeekNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style });
                  return range(7, function (i) { return _this._stripDirectionalityCharacters(dtf_3.format(new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DAY_OF_WEEK_NAMES[style];
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYearName = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric' });
                  return this._stripDirectionalityCharacters(dtf.format(date));
              }
              return String(this.getYear(date));
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getFirstDayOfWeek = /**
       * @return {?}
       */
          function () {
              // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
              return 0;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getNumDaysInMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.clone = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date));
          };
      /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.createDate = /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              // Check for invalid month and date (except upper bound on date which we have to check after
              // creating the Date).
              if (month < 0 || month > 11 || date < 1) {
                  return null;
              }
              /** @type {?} */
              var result = this._createDateWithOverflow(year, month, date);
              // Check that the date wasn't above the upper bound for the month, causing the month to
              // overflow.
              if (result.getMonth() != month) {
                  return null;
              }
              return result;
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.today = /**
       * @return {?}
       */
          function () {
              return new Date();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      NativeDateAdapter.prototype.parse = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var timestamp = typeof value == 'number' ? value : Date.parse(value);
              return isNaN(timestamp) ? null : new Date(timestamp);
          };
      /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
      NativeDateAdapter.prototype.format = /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
          function (date, displayFormat) {
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
                  return this._stripDirectionalityCharacters(dtf.format(date));
              }
              return this._stripDirectionalityCharacters(date.toDateString());
          };
      /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarYears = /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
          function (date, years) {
              return this.addCalendarMonths(date, years * 12);
          };
      /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarMonths = /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
          function (date, months) {
              /** @type {?} */
              var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
              // It's possible to wind up in the wrong month if the original month has more days than the new
              // month. In this case we want to go to the last day of the desired month.
              // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
              // guarantee this.
              if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
                  newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
              }
              return newDate;
          };
      /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarDays = /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
          function (date, days) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getISODateString = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return [
                  date.getUTCFullYear(),
                  this._2digit(date.getUTCMonth() + 1),
                  this._2digit(date.getUTCDate())
              ].join('-');
          };
      /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype._createDateWithOverflow = /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              /** @type {?} */
              var result = new Date(year, month, date);
              // We need to correct for the fact that JS native Date treats years in range [0, 99] as
              // abbreviations for 19xx.
              if (year >= 0 && year < 100) {
                  result.setFullYear(this.getYear(result) - 1900);
              }
              return result;
          };
      /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
      NativeDateAdapter.prototype._2digit = /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
          function (n) {
              return ('00' + n).slice(-2);
          };
      /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} s The string to strip direction characters from.
       * @return {?} The stripped string.
       */
      NativeDateAdapter.prototype._stripDirectionalityCharacters = /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} s The string to strip direction characters from.
       * @return {?} The stripped string.
       */
          function (s) {
              return s.replace(/[\u200e\u200f]/g, '');
          };
      return NativeDateAdapter;
  }(DateAdapter));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MD_DATE_FORMATS = new core.InjectionToken('md-date-formats');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MD_NATIVE_DATE_FORMATS = {
      parse: {
          dateInput: null,
      },
      display: {
          dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },
          monthYearLabel: { year: 'numeric', month: 'short' },
          dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
          monthYearA11yLabel: { year: 'numeric', month: 'long' },
      }
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var NativeDateModule = /** @class */ (function () {
      function NativeDateModule() {
      }
      NativeDateModule.decorators = [
          { type: core.NgModule, args: [{
                      providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],
                  },] }
      ];
      return NativeDateModule;
  }());
  var ɵ0$1 = MD_NATIVE_DATE_FORMATS;
  var MdNativeDateModule = /** @class */ (function () {
      function MdNativeDateModule() {
      }
      MdNativeDateModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [NativeDateModule],
                      providers: [{ provide: MD_DATE_FORMATS, useValue: ɵ0$1 }],
                  },] }
      ];
      return MdNativeDateModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * InjectionToken that can be used to specify the global placeholder options.
    @type {?} */
  var MD_PLACEHOLDER_GLOBAL_OPTIONS = new core.InjectionToken('md-placeholder-global-options');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var MdCoreModule = /** @class */ (function () {
      function MdCoreModule() {
      }
      MdCoreModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          MdLineModule,
                          RtlModule,
                          MdRippleModule,
                          ObserveContentModule,
                          PortalModule,
                          OverlayModule,
                          A11yModule,
                          MdOptionModule,
                          MdSelectionModule,
                      ],
                      exports: [
                          MdLineModule,
                          RtlModule,
                          MdRippleModule,
                          ObserveContentModule,
                          PortalModule,
                          OverlayModule,
                          A11yModule,
                          MdOptionModule,
                          MdSelectionModule,
                      ],
                  },] }
      ];
      return MdCoreModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2Accordion = /** @class */ (function () {
      function Md2Accordion() {
          this.close = new core.EventEmitter();
          this.open = new core.EventEmitter();
          this.tabs = [];
      }
      Object.defineProperty(Md2Accordion.prototype, "multiple", {
          get: /**
           * @return {?}
           */ function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._multiple = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * Add or append tab in accordion
       * @param tab object of Md2AccordionTab
       */
      /**
       * Add or append tab in accordion
       * @param {?} tab object of Md2AccordionTab
       * @return {?}
       */
      Md2Accordion.prototype.addTab = /**
       * Add or append tab in accordion
       * @param {?} tab object of Md2AccordionTab
       * @return {?}
       */
          function (tab) {
              this.tabs.push(tab);
          };
      Md2Accordion.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-accordion',
                      template: "<ng-content></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'md2Accordion',
                      styles: ["md2-accordion{display:block}md2-accordion-tab{position:relative;display:block;outline:0;box-sizing:border-box}md2-accordion-tab[hidden]{display:none}.md2-accordion-header{position:relative;display:block;padding-right:30px;font-weight:500;line-height:40px;text-align:left;color:rgba(0,0,0,.87);cursor:pointer;white-space:nowrap;border-bottom:1px solid rgba(0,0,0,.12);border-radius:0;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}md2-accordion-tab.md2-accordion-tab-active>.md2-accordion-header{border-color:#106cc8;box-shadow:0 1px 0 #106cc8}md2-accordion-tab.md2-accordion-tab-disabled>.md2-accordion-header{pointer-events:none;color:rgba(0,0,0,.26);background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-position:0 bottom;border-color:transparent;box-shadow:none;cursor:default}.md2-accordion-header-icon{position:absolute;top:12px;right:8px;width:8px;height:8px;overflow:hidden;display:inline-block;border-width:0 2px 2px 0;border-style:solid;border-color:currentColor;opacity:.64;-webkit-transform:rotate(45deg);transform:rotate(45deg);transition:.3s ease-in-out}md2-accordion-tab.md2-accordion-tab-active>.md2-accordion-header>.md2-accordion-header-icon{-webkit-transform:rotate(225deg);transform:rotate(225deg);top:16px}.md2-accordion-tab-body{position:relative;overflow:hidden}md2-accordion-tab.md2-accordion-tab-active .md2-accordion-tab-body{overflow:visible}.md2-accordion-tab-content{position:relative;padding:20px 0;border-bottom:1px solid rgba(0,0,0,.12)}"]
                  }] }
      ];
      Md2Accordion.propDecorators = {
          multiple: [{ type: core.Input }],
          close: [{ type: core.Output }],
          open: [{ type: core.Output }]
      };
      return Md2Accordion;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2AccordionHeader = /** @class */ (function () {
      function Md2AccordionHeader() {
      }
      Md2AccordionHeader.decorators = [
          { type: core.Directive, args: [{ selector: 'md2-accordion-header' },] }
      ];
      return Md2AccordionHeader;
  }());
  var Md2AccordionTab = /** @class */ (function () {
      function Md2AccordionTab(_accordion) {
          this._accordion = _accordion;
          this._disabled = false;
          this._active = false;
          this._accordion.addTab(this);
      }
      Object.defineProperty(Md2AccordionTab.prototype, "active", {
          get: /**
           * @return {?}
           */ function () { return this._active; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._active = coerceBooleanProperty(value);
              if (this._active && !this._accordion.multiple) {
                  for (var i = 0; i < this._accordion.tabs.length; i++) {
                      if (this._accordion.tabs[i] !== this) {
                          this._accordion.tabs[i].active = false;
                      }
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2AccordionTab.prototype, "slide", {
          get: /**
           * @return {?}
           */ function () {
              return this.active ? 'down' : 'up';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2AccordionTab.prototype, "disabled", {
          get: /**
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * Toggle the accordion
       * @param event
       * @return if it is disabled
       */
      /**
       * Toggle the accordion
       * @param {?} event
       * @return {?} if it is disabled
       */
      Md2AccordionTab.prototype._handleClick = /**
       * Toggle the accordion
       * @param {?} event
       * @return {?} if it is disabled
       */
          function (event) {
              if (this.disabled) {
                  return;
              }
              /** @type {?} */
              var index = this.findTabIndex();
              if (this.active) {
                  this.active = !this.active;
                  this._accordion.close.emit({ originalEvent: event, index: index });
              }
              else if (!this._accordion.multiple) {
                  for (var i = 0; i < this._accordion.tabs.length; i++) {
                      this._accordion.tabs[i].active = false;
                  }
                  this._active = true;
                  this._accordion.open.emit({ originalEvent: event, index: index });
              }
              else {
                  this._active = true;
                  this._accordion.open.emit({ originalEvent: event, index: index });
              }
              event.preventDefault();
          };
      /**
       * Find index of specific tab of accordion
       * @return index number of this tab
       */
      /**
       * Find index of specific tab of accordion
       * @return {?} index number of this tab
       */
      Md2AccordionTab.prototype.findTabIndex = /**
       * Find index of specific tab of accordion
       * @return {?} index number of this tab
       */
          function () {
              /** @type {?} */
              var index = -1;
              for (var i = 0; i < this._accordion.tabs.length; i++) {
                  if (this._accordion.tabs[i] === this) {
                      index = i;
                      break;
                  }
              }
              return index;
          };
      Md2AccordionTab.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-accordion-tab',
                      template: "\n    <div class=\"md2-accordion-header\" (click)=\"_handleClick($event)\">\n      <span>{{header}}</span>\n      <ng-content select=\"md2-accordion-header\"></ng-content>\n      <span class=\"md2-accordion-header-icon\"></span>\n    </div>\n    <div class=\"md2-accordion-tab-body\" [@slide]=\"slide\">\n      <div class=\"md2-accordion-tab-content\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  ",
                      animations: [
                          animations.trigger('slide', [
                              animations.state('up', animations.style({ height: 0 })),
                              animations.state('down', animations.style({ height: '*' })),
                              animations.transition('down => up', [
                                  animations.style({ height: '*' }),
                                  animations.animate(300, animations.style({ height: 0 }))
                              ]),
                              animations.transition('up => down', [
                                  animations.style({ height: 0 }),
                                  animations.animate(300, animations.style({
                                      height: '*'
                                  }))
                              ])
                          ])
                      ],
                      host: {
                          'role': 'accordion-tab',
                          '[class.md2-accordion-tab-active]': 'active',
                          '[class.md2-accordion-tab-disabled]': 'disabled'
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'md2AccordionTab',
                      styles: ["md2-accordion{display:block}md2-accordion-tab{position:relative;display:block;outline:0;box-sizing:border-box}md2-accordion-tab[hidden]{display:none}.md2-accordion-header{position:relative;display:block;padding-right:30px;font-weight:500;line-height:40px;text-align:left;color:rgba(0,0,0,.87);cursor:pointer;white-space:nowrap;border-bottom:1px solid rgba(0,0,0,.12);border-radius:0;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}md2-accordion-tab.md2-accordion-tab-active>.md2-accordion-header{border-color:#106cc8;box-shadow:0 1px 0 #106cc8}md2-accordion-tab.md2-accordion-tab-disabled>.md2-accordion-header{pointer-events:none;color:rgba(0,0,0,.26);background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-position:0 bottom;border-color:transparent;box-shadow:none;cursor:default}.md2-accordion-header-icon{position:absolute;top:12px;right:8px;width:8px;height:8px;overflow:hidden;display:inline-block;border-width:0 2px 2px 0;border-style:solid;border-color:currentColor;opacity:.64;-webkit-transform:rotate(45deg);transform:rotate(45deg);transition:.3s ease-in-out}md2-accordion-tab.md2-accordion-tab-active>.md2-accordion-header>.md2-accordion-header-icon{-webkit-transform:rotate(225deg);transform:rotate(225deg);top:16px}.md2-accordion-tab-body{position:relative;overflow:hidden}md2-accordion-tab.md2-accordion-tab-active .md2-accordion-tab-body{overflow:visible}.md2-accordion-tab-content{position:relative;padding:20px 0;border-bottom:1px solid rgba(0,0,0,.12)}"]
                  }] }
      ];
      /** @nocollapse */
      Md2AccordionTab.ctorParameters = function () {
          return [
              { type: Md2Accordion }
          ];
      };
      Md2AccordionTab.propDecorators = {
          header: [{ type: core.Input }],
          active: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return Md2AccordionTab;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2AccordionModule = /** @class */ (function () {
      function Md2AccordionModule() {
      }
      Md2AccordionModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule],
                      exports: [Md2Accordion, Md2AccordionTab, Md2AccordionHeader],
                      declarations: [Md2Accordion, Md2AccordionTab, Md2AccordionHeader],
                  },] }
      ];
      return Md2AccordionModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var HighlightPipe = /** @class */ (function () {
      function HighlightPipe() {
      }
      /**
       * Transform function
       * @param value string
       * @param query string filter value
       * @return filtered string with markup
       */
      /**
       * Transform function
       * @param {?} value string
       * @param {?} query string filter value
       * @return {?} filtered string with markup
       */
      HighlightPipe.prototype.transform = /**
       * Transform function
       * @param {?} value string
       * @param {?} query string filter value
       * @return {?} filtered string with markup
       */
          function (value, query) {
              if (query.length < 1) {
                  return value;
              }
              return query ? value.replace(new RegExp(this._escapeRegexp(query), 'gi'), '<span class="highlight">$&</span>') : value;
          };
      /**
       * filter pipe
       * @param {?} queryToEscape
       * @return {?} queryToEscape with replace string
       */
      HighlightPipe.prototype._escapeRegexp = /**
       * filter pipe
       * @param {?} queryToEscape
       * @return {?} queryToEscape with replace string
       */
          function (queryToEscape) {
              return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
          };
      HighlightPipe.decorators = [
          { type: core.Pipe, args: [{ name: 'highlight' },] }
      ];
      return HighlightPipe;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Item = /** @class */ (function () {
      function Item(source, textKey, valueKey) {
          if (typeof source === 'string') {
              this.text = this.value = source;
          }
          if (typeof source === 'object') {
              this.text = source[textKey];
              this.value = valueKey ? source[valueKey] : source;
          }
      }
      return Item;
  }());
  /** @type {?} */
  var nextId = 0;
  /** @type {?} */
  var MD2_AUTOCOMPLETE_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return Md2Autocomplete; }),
      multi: true
  };
  /**
   * Change event object emitted by Md2Autocomplete.
   */
  var /**
   * Change event object emitted by Md2Autocomplete.
   */ Md2AutocompleteChange = /** @class */ (function () {
      function Md2AutocompleteChange() {
      }
      return Md2AutocompleteChange;
  }());
  var Md2Autocomplete = /** @class */ (function () {
      function Md2Autocomplete(_element) {
          this._element = _element;
          this.change = new core.EventEmitter();
          this.textChange = new core.EventEmitter();
          this._value = '';
          this._readonly = false;
          this._required = false;
          this._disabled = false;
          this._isInitialized = false;
          this._onChange = function () { };
          this._onTouched = function () { };
          this._items = [];
          this._list = [];
          this.selectedItem = null;
          this.noBlur = false;
          this._focusedOption = 0;
          this._inputValue = '';
          this._inputFocused = false;
          this.id = 'md2-autocomplete-' + (++nextId);
          this.tabindex = 0;
          this.placeholder = '';
          this.textKey = 'text';
          this.valueKey = null;
          this.minLength = 1;
      }
      /**
       * @return {?}
       */
      Md2Autocomplete.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () { this._isInitialized = true; };
      Object.defineProperty(Md2Autocomplete.prototype, "readonly", {
          get: /**
           * @return {?}
           */ function () { return this._readonly; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._readonly = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Autocomplete.prototype, "required", {
          get: /**
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Autocomplete.prototype, "disabled", {
          get: /**
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Autocomplete.prototype, "items", {
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._items = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Autocomplete.prototype, "value", {
          get: /**
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              if (value !== this._value) {
                  this._value = value;
                  this._inputValue = '';
                  if (value) {
                      /** @type {?} */
                      var selItm = this._items.find(function (i) {
                          return _this.equals(_this.valueKey ?
                              i[_this.valueKey] : i, value);
                      });
                      this.selectedItem = new Item(selItm, this.textKey, this.valueKey);
                      if (this.selectedItem) {
                          this._inputValue = this.selectedItem.text;
                      }
                  }
                  if (!this._inputValue) {
                      this._inputValue = '';
                  }
                  if (this._isInitialized) {
                      this._emitChangeEvent();
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
      Md2Autocomplete.prototype.equals = /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
          function (o1, o2) {
              if (o1 === o2) {
                  return true;
              }
              if (o1 === null || o2 === null) {
                  return false;
              }
              if (o1 !== o1 && o2 !== o2) {
                  return true;
              }
              /** @type {?} */
              var t1 = typeof o1;
              /** @type {?} */
              var t2 = typeof o2;
              /** @type {?} */
              var key;
              /** @type {?} */
              var keySet;
              if (t1 === t2 && t1 === 'object') {
                  keySet = Object.create(null);
                  for (key in o1) {
                      if (!this.equals(o1[key], o2[key])) {
                          return false;
                      }
                      keySet[key] = true;
                  }
                  for (key in o2) {
                      if (!(key in keySet) && key.charAt(0) !== '$' && o2[key]) {
                          return false;
                      }
                  }
                  return true;
              }
              return false;
          };
      Object.defineProperty(Md2Autocomplete.prototype, "isMenuVisible", {
          get: /**
           * @return {?}
           */ function () {
              return ((this._inputFocused || this.noBlur) && this._list && this._list.length &&
                  !this.selectedItem) && !this.readonly ? true : false;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * update scroll of suggestion menu
       * @return {?}
       */
      Md2Autocomplete.prototype.updateScroll = /**
       * update scroll of suggestion menu
       * @return {?}
       */
          function () {
              if (this._focusedOption < 0) {
                  return;
              }
              /** @type {?} */
              var menuContainer = this._element.nativeElement.querySelector('.md2-autocomplete-menu');
              if (!menuContainer) {
                  return;
              }
              /** @type {?} */
              var choices = menuContainer.querySelectorAll('.md2-option');
              if (choices.length < 1) {
                  return;
              }
              /** @type {?} */
              var highlighted = choices[this._focusedOption];
              if (!highlighted) {
                  return;
              }
              /** @type {?} */
              var top = highlighted.offsetTop + highlighted.clientHeight - menuContainer.scrollTop;
              /** @type {?} */
              var height = menuContainer.offsetHeight;
              if (top > height) {
                  menuContainer.scrollTop += top - height;
              }
              else if (top < highlighted.clientHeight) {
                  menuContainer.scrollTop -= highlighted.clientHeight - top;
              }
          };
      /**
       * input event listner
       * @param event
       */
      /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
      Md2Autocomplete.prototype._handleKeyup = /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this.textChange.emit(this._inputValue);
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Autocomplete.prototype._handleKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var _this = this;
              if (this.disabled) {
                  return;
              }
              switch (event.keyCode) {
                  case TAB:
                      this._handleMouseLeave();
                      break;
                  case ESCAPE:
                      event.stopPropagation();
                      event.preventDefault();
                      if (this._inputValue) {
                          this._onClear();
                      }
                      break;
                  case ENTER:
                      event.preventDefault();
                      event.stopPropagation();
                      if (this.isMenuVisible) {
                          this._selectOption(event, this._focusedOption);
                      }
                      break;
                  case DOWN_ARROW:
                      event.preventDefault();
                      event.stopPropagation();
                      if (this.isMenuVisible) {
                          this._focusedOption = (this._focusedOption === this._list.length - 1) ? 0 :
                              Math.min(this._focusedOption + 1, this._list.length - 1);
                          this.updateScroll();
                      }
                      break;
                  case UP_ARROW:
                      event.preventDefault();
                      event.stopPropagation();
                      if (this.isMenuVisible) {
                          this._focusedOption = (this._focusedOption === 0) ? this._list.length - 1 :
                              Math.max(0, this._focusedOption - 1);
                          this.updateScroll();
                      }
                      break;
                  default:
                      setTimeout(function () {
                          _this.updateItems();
                      }, 10);
              }
          };
      /**
       * select option
       * @param event
       * @param index of selected item
       */
      /**
       * select option
       * @param {?} event
       * @param {?} index of selected item
       * @return {?}
       */
      Md2Autocomplete.prototype._selectOption = /**
       * select option
       * @param {?} event
       * @param {?} index of selected item
       * @return {?}
       */
          function (event, index) {
              event.preventDefault();
              event.stopPropagation();
              this.selectedItem = this._list[index];
              this._inputValue = this._list[index].text;
              this.updateValue();
              this._handleMouseLeave();
          };
      /**
       * clear selected suggestion
       */
      /**
       * clear selected suggestion
       * @return {?}
       */
      Md2Autocomplete.prototype._onClear = /**
       * clear selected suggestion
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              this._inputValue = '';
              this.selectedItem = null;
              this.updateItems();
              this._value = this.selectedItem ? this.selectedItem.value : this.selectedItem;
              this.updateValue();
          };
      /**
       * update value
       * @return {?}
       */
      Md2Autocomplete.prototype.updateValue = /**
       * update value
       * @return {?}
       */
          function () {
              this._value = this.selectedItem ? this.selectedItem.value : this.selectedItem;
              this._emitChangeEvent();
              this.onFocus();
          };
      /**
       * component focus listener
       * @return {?}
       */
      Md2Autocomplete.prototype.onFocus = /**
       * component focus listener
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              this._element.nativeElement.querySelector('input').focus();
          };
      /**
       * input focus listener
       */
      /**
       * input focus listener
       * @return {?}
       */
      Md2Autocomplete.prototype._handleFocus = /**
       * input focus listener
       * @return {?}
       */
          function () {
              this._inputFocused = true;
              this.updateItems();
              this._focusedOption = 0;
          };
      /**
       * input blur listener
       */
      /**
       * input blur listener
       * @return {?}
       */
      Md2Autocomplete.prototype._handleBlur = /**
       * input blur listener
       * @return {?}
       */
          function () {
              this._inputFocused = false;
              this._onTouched();
          };
      /**
       * suggestion menu mouse enter listener
       */
      /**
       * suggestion menu mouse enter listener
       * @return {?}
       */
      Md2Autocomplete.prototype._handleMouseEnter = /**
       * suggestion menu mouse enter listener
       * @return {?}
       */
          function () { this.noBlur = true; };
      /**
       * suggestion menu mouse leave listener
       */
      /**
       * suggestion menu mouse leave listener
       * @return {?}
       */
      Md2Autocomplete.prototype._handleMouseLeave = /**
       * suggestion menu mouse leave listener
       * @return {?}
       */
          function () { this.noBlur = false; };
      /**
       * Update suggestion to filter the query
       * @return {?}
       */
      Md2Autocomplete.prototype.updateItems = /**
       * Update suggestion to filter the query
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._inputValue.length < this.minLength) {
                  this._list = [];
              }
              else {
                  this._list = this._items.map(function (i) { return new Item(i, _this.textKey, _this.valueKey); }).filter(function (i) { return new RegExp(_this._inputValue.trim(), 'ig').test(i.text); });
                  if (this._list.length && this._list[0].text !== this._inputValue) {
                      this.selectedItem = null;
                  }
              }
          };
      /**
       * @return {?}
       */
      Md2Autocomplete.prototype._emitChangeEvent = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var event = new Md2AutocompleteChange();
              event.source = this;
              event.value = this._value;
              this._onChange(event.value);
              this.change.emit(event);
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Autocomplete.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              if (value !== this._value) {
                  this._value = value;
                  this._inputValue = '';
                  if (value) {
                      /** @type {?} */
                      var selItm = this._items.find(function (i) {
                          return _this.equals(_this.valueKey ?
                              i[_this.valueKey] : i, value);
                      });
                      this.selectedItem = new Item(selItm, this.textKey, this.valueKey);
                      if (this.selectedItem) {
                          this._inputValue = this.selectedItem.text;
                      }
                  }
                  if (!this._inputValue) {
                      this._inputValue = '';
                  }
              }
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Autocomplete.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onChange = fn; };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Autocomplete.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onTouched = fn; };
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      Md2Autocomplete.prototype.setDisabledState = /**
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      Md2Autocomplete.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-autocomplete',
                      template: "<div class=\"md2-autocomplete-trigger\" [class.is-focused]=\"_inputFocused || isMenuVisible\">\n  <input [(ngModel)]=\"_inputValue\" type=\"text\" autocomplete=\"off\" [readonly]=\"readonly\" [tabindex]=\"disabled ? -1 : tabindex\" [disabled]=\"disabled\" class=\"md2-autocomplete-input\" (focus)=\"_handleFocus()\" (blur)=\"_handleBlur()\" (keydown)=\"_handleKeydown($event)\" (keyup)=\"_handleKeyup($event)\" (change)=\"$event.stopPropagation()\" />\n  <span class=\"md2-autocomplete-placeholder\" [class.has-value]=\"_inputValue\"> {{ placeholder }} </span>\n  <svg *ngIf=\"_inputValue && !required && !disabled\" (click)=\"_onClear()\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n  </svg>\n</div>\n<ul *ngIf=\"isMenuVisible\" class=\"md2-autocomplete-menu\" (mouseenter)=\"_handleMouseEnter()\" (mouseleave)=\"_handleMouseLeave()\">\n  <li class=\"md2-option\" *ngFor=\"let l of _list; let i = index;\" [class.focus]=\"_focusedOption === i\" (click)=\"_selectOption($event, i)\">\n    <div class=\"md2-text\" [innerHtml]=\"l.text | highlight:_inputValue\"></div>\n  </li>\n</ul>\n",
                      providers: [MD2_AUTOCOMPLETE_CONTROL_VALUE_ACCESSOR],
                      host: {
                          'role': 'autocomplete',
                          '[id]': 'id',
                          '[attr.aria-label]': 'placeholder',
                          '[attr.aria-required]': 'required.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[class.md2-autocomplete-disabled]': 'disabled',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'md2Autocomplete',
                      styles: ["md2-autocomplete{position:relative;display:block;margin:18px 0;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-backface-visibility:hidden;backface-visibility:hidden}md2-autocomplete.md2-autocomplete-disabled{pointer-events:none;cursor:default}.md2-autocomplete-trigger{position:relative;display:block;width:100%;padding:2px 2px 1px;border-bottom:1px solid rgba(0,0,0,.12);box-sizing:border-box;min-width:64px;min-height:26px;cursor:pointer}.md2-autocomplete-trigger.is-focused{padding-bottom:0;border-bottom:2px solid #106cc8}md2-autocomplete.ng-invalid.ng-touched:not(.md2-autocomplete-disabled) .md2-autocomplete-trigger{color:#f44336;border-bottom-color:#f44336}md2-autocomplete.md2-autocomplete-disabled .md2-autocomplete-trigger{color:rgba(0,0,0,.38);border-color:transparent;background-image:linear-gradient(to right,rgba(0,0,0,.38) 0,rgba(0,0,0,.38) 33%,transparent 0);background-position:bottom -1px left 0;background-size:4px 1px;background-repeat:repeat-x;cursor:default}md2-autocomplete.md2-autocomplete-disabled .md2-autocomplete-trigger.is-focused{padding-bottom:1px;border-bottom:1px solid transparent}.md2-autocomplete-input{width:100%;height:26px;font-size:15px;outline:0;background:0 0;border:0;box-sizing:border-box}md2-autocomplete.md2-autocomplete-disabled .md2-autocomplete-input{color:rgba(0,0,0,.38)}.md2-autocomplete-placeholder{position:absolute;right:26px;bottom:100%;left:0;max-width:100%;padding-left:3px;padding-right:0;line-height:1.4;color:rgba(0,0,0,.38);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;pointer-events:none;z-index:1;-webkit-transform:translate3d(0,26px,0) scale(1);transform:translate3d(0,26px,0) scale(1);transition:transform .4s cubic-bezier(.25,.8,.25,1);transition:transform .4s cubic-bezier(.25,.8,.25,1),-webkit-transform .4s cubic-bezier(.25,.8,.25,1);-webkit-transform-origin:left top;transform-origin:left top}[aria-required=true] .md2-autocomplete-placeholder::after{content:'*'}.md2-autocomplete-trigger.is-focused .md2-autocomplete-placeholder{color:#106cc8}.md2-autocomplete-trigger.is-focused .md2-autocomplete-placeholder,md2-autocomplete .md2-autocomplete-placeholder.has-value{-webkit-transform:translate3d(0,6px,0) scale(.75);transform:translate3d(0,6px,0) scale(.75)}.md2-autocomplete-trigger svg{position:absolute;right:0;top:0;display:block;height:100%;background:#fff;fill:currentColor;color:rgba(0,0,0,.54)}.md2-autocomplete-menu{position:absolute;left:0;top:100%;display:block;z-index:10;width:100%;margin:0;padding:8px 0;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);max-height:256px;min-height:48px;overflow-y:auto;background:#fff}.md2-autocomplete-menu .md2-option{position:relative;display:block;color:#212121;cursor:pointer;width:auto;padding:0 16px;height:48px;line-height:48px;transition:background 150ms linear}.md2-autocomplete-menu .md2-option.focus,.md2-autocomplete-menu .md2-option:hover{background:#ededed}.md2-autocomplete-menu .md2-option .md2-text{width:auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:16px}.md2-autocomplete-menu .highlight{color:#737373}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Autocomplete.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      Md2Autocomplete.propDecorators = {
          change: [{ type: core.Output }],
          textChange: [{ type: core.Output }],
          id: [{ type: core.Input }],
          tabindex: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          textKey: [{ type: core.Input, args: ['item-text',] }],
          valueKey: [{ type: core.Input, args: ['item-value',] }],
          minLength: [{ type: core.Input, args: ['min-length',] }],
          readonly: [{ type: core.Input }],
          required: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          items: [{ type: core.Input }],
          value: [{ type: core.Input }]
      };
      return Md2Autocomplete;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2AutocompleteModule = /** @class */ (function () {
      function Md2AutocompleteModule() {
      }
      Md2AutocompleteModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, forms.FormsModule],
                      exports: [Md2Autocomplete, HighlightPipe],
                      declarations: [Md2Autocomplete, HighlightPipe],
                  },] }
      ];
      return Md2AutocompleteModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Chip = /** @class */ (function () {
      function Chip(source, textKey, valueKey) {
          if (typeof source === 'string') {
              this.text = this.value = source;
          }
          if (typeof source === 'object') {
              this.text = source[textKey];
              this.value = valueKey ? source[valueKey] : source;
          }
      }
      return Chip;
  }());
  /** @type {?} */
  var nextId$1 = 0;
  /** @type {?} */
  var MD2_CHIPS_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return Md2Chips; }),
      multi: true
  };
  /**
   * Change event object emitted by Md2Chips.
   */
  var /**
   * Change event object emitted by Md2Chips.
   */ Md2ChipsChange = /** @class */ (function () {
      function Md2ChipsChange() {
      }
      return Md2ChipsChange;
  }());
  var Md2Chips = /** @class */ (function () {
      function Md2Chips(elementRef) {
          this.elementRef = elementRef;
          this.tabindex = 0;
          this.addOnComma = true;
          this.addOnEnter = true;
          this.addOnPaste = true;
          this.addOnSpace = false;
          this.allowedPattern = /.+/;
          this.pasteSplitPattern = ',';
          this.placeholder = '';
          this.isAutoComplete = false;
          this.isRemovable = true;
          this.disabled = false;
          this.minChips = 0;
          this.maxChips = 10000;
          this.type = 'text';
          this.id = 'md2-chips-' + (++nextId$1);
          this.autocompleteItemText = 'text';
          this.autocompleteItemValue = 'value';
          this.textKey = 'text';
          this.valueKey = null;
          this.change = new core.EventEmitter();
          this._onChange = function () { };
          this._onTouched = function () { };
          this.chipItemList = [];
          this.inputValue = '';
          this.selectedChip = -1;
          this.inputFocused = false;
          this.autoCompleteFocued = false;
          this._value = '';
          this.isEmptyAutoComplete = true;
      }
      Object.defineProperty(Md2Chips.prototype, "element", {
          get: /**
           * @return {?}
           */ function () {
              /** @type {?} */
              var elements = { root: this.elementRef.nativeElement, mainDiv: null, template: null };
              elements.mainDiv = elements.root.querySelector('.md2-chips-container');
              elements.template = elements.mainDiv.querySelector('.md2-template');
              return elements;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Chips.prototype, "value", {
          get: /**
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.setValue(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Chips.prototype, "setValue", {
          /**
           * set value
           * @param value
           */
          set: /**
           * set value
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this._value) {
                  this._value = value;
                  this.chipItemList = [];
                  if (value) {
                      if (value && value.length && Array.isArray(value)) {
                          for (var i = 0; i < value.length; i++) {
                              this.chipItemList.push(new Chip(value[i], this.textKey, this.valueKey));
                          }
                      }
                  }
              }
              this._emitChangeEvent();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Chips.prototype.getFocusAutocomplete = /**
       * @return {?}
       */
          function () {
              this._onTouched();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Chips.prototype.changeAutocomplete = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (value) {
                  this.addNewChip(value.value);
                  this.item = null;
              }
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elements = this.element;
              this.splitRegExp = new RegExp(this.pasteSplitPattern);
              if (elements.template) {
                  this.templateHtmlString = elements.template.innerHTML;
              }
          };
      // check autocomplete input is empty or not
      /**
       * @param {?} evt
       * @return {?}
       */
      Md2Chips.prototype.valueupdate = /**
       * @param {?} evt
       * @return {?}
       */
          function (evt) {
              this.isEmptyAutoComplete = evt ? false : true;
          };
      /**
       * input key listener
       * @param event
       */
      /**
       * input key listener
       * @param {?} event
       * @return {?}
       */
      Md2Chips.prototype.inputChanged = /**
       * input key listener
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var key = event.keyCode;
              switch (key) {
                  // back space
                  case BACKSPACE:
                      this.backspaceEvent();
                      break;
                  // delete
                  case DELETE:
                      this.backspaceEvent();
                      break;
                  // left arrow
                  case LEFT_ARROW:
                      if (this.isAutoComplete && this.isEmptyAutoComplete) {
                          this.leftArrowKeyEvents();
                      }
                      else if (!this.isAutoComplete && !this.inputValue) {
                          this.leftArrowKeyEvents();
                      }
                      break;
                  // right arrow
                  case RIGHT_ARROW:
                      if (this.isAutoComplete && this.isEmptyAutoComplete) {
                          this.rightArrowKeyEvents();
                      }
                      else if (!this.isAutoComplete && !this.inputValue) {
                          this.rightArrowKeyEvents();
                      }
                      break;
                  // enter
                  case ENTER:
                      if (this.addOnEnter) {
                          this.addNewChip(this.inputValue);
                          event.preventDefault();
                      }
                      break;
                  // comma
                  case COMMA:
                      if (this.addOnComma) {
                          this.addNewChip(this.inputValue);
                          event.preventDefault();
                      }
                      break;
                  // space
                  case SPACE:
                      if (this.addOnSpace) {
                          this.addNewChip(this.inputValue);
                          event.preventDefault();
                      }
                      break;
                  default:
                      break;
              }
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype._handleFocus = /**
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              if (!this.isAutoComplete) {
                  this.elementRef.nativeElement.querySelector('input.chip-input').focus();
              }
              else {
                  this.autoCompleteFocued = true;
                  this._onTouched();
              }
              this._resetSelected();
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.inputBlurred = /**
       * @return {?}
       */
          function () {
              this.inputFocused = false;
              if (this.inputValue) {
                  this.addNewChip(this.inputValue);
              }
              this._onTouched();
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.inputFocus = /**
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              this.inputFocused = true;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Chips.prototype.inputPaste = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var _this = this;
              /** @type {?} */
              var clipboardData = event.clipboardData ||
                  (event.originalEvent && event.originalEvent.clipboardData);
              /** @type {?} */
              var pastedString = clipboardData.getData('text/plain').trim();
              this.addNewChip(pastedString);
              setTimeout(function () { return _this._resetInput(); });
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.leftArrowKeyEvents = /**
       * @return {?}
       */
          function () {
              event.preventDefault();
              if (this.selectedChip) {
                  if (this.selectedChip < 0) {
                      this.selectedChip = this.chipItemList.length - 1;
                  }
                  else {
                      this.selectedChip = this.selectedChip - 1;
                  }
              }
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.rightArrowKeyEvents = /**
       * @return {?}
       */
          function () {
              event.preventDefault();
              if (this.selectedChip != -1) {
                  if (this.selectedChip >= this.chipItemList.length) {
                      this.selectedChip = 0;
                  }
                  else {
                      this.selectedChip = this.selectedChip + 1;
                  }
              }
          };
      /**
       * @param {?} chipString
       * @return {?}
       */
      Md2Chips.prototype._isValid = /**
       * @param {?} chipString
       * @return {?}
       */
          function (chipString) {
              /** @type {?} */
              var typeString = typeof chipString;
              /** @type {?} */
              var isExist;
              if (typeString === 'string') {
                  chipString = chipString.trim();
                  isExist = this.chipItemList.filter(function (chip) { return chip.text === chipString; });
              }
              else {
                  isExist = this.chipItemList.filter(function (chip) { return chip.text === chipString.text; });
              }
              if (this.chipItemList.indexOf(chipString) === -1 && (isExist.length ? false : true)) {
                  return this.allowedPattern.test(chipString);
              }
          };
      /**
       * add new chip
       * @param {?} chips
       * @return {?}
       */
      Md2Chips.prototype.addNewChip = /**
       * add new chip
       * @param {?} chips
       * @return {?}
       */
          function (chips) {
              /** @type {?} */
              var validInput = this._isValid(chips);
              if (validInput) {
                  if (this.maxChips && this.maxChips < this.chipItemList.length - 1) {
                      return;
                  }
                  else {
                      this.chipItemList.push(new Chip(chips, this.autocompleteItemText, this.autocompleteItemValue));
                      this.item = null;
                  }
              }
              this._resetSelected();
              this._resetInput();
              this.updateValue();
          };
      /**
     * remove selected chip
     * @param chipIndexToRemove index of selected chip
     */
      /**
       * remove selected chip
       * @param {?} chipIndexToRemove index of selected chip
       * @return {?}
       */
      Md2Chips.prototype.removeSelectedChip = /**
       * remove selected chip
       * @param {?} chipIndexToRemove index of selected chip
       * @return {?}
       */
          function (chipIndexToRemove) {
              this.chipItemList.splice(chipIndexToRemove, 1);
              this._resetSelected();
              this.updateValue();
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype.backspaceEvent = /**
       * @return {?}
       */
          function () {
              if (!this.inputValue.length && this.chipItemList.length &&
                  this.isRemovable && this.isEmptyAutoComplete) {
                  if (this.selectedChip != -1) {
                      this.removeSelectedChip(this.selectedChip);
                      this.selectedChip = this.chipItemList.length - 1;
                  }
                  else {
                      this.selectedChip = this.chipItemList.length - 1;
                  }
              }
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype._resetSelected = /**
       * @return {?}
       */
          function () {
              this.selectedChip = -1;
          };
      /**
       * @return {?}
       */
      Md2Chips.prototype._resetInput = /**
       * @return {?}
       */
          function () {
              if (this.isAutoComplete) {
                  this.chipInputForm.controls['autocomplete'].setValue('');
              }
              else {
                  this.chipInputForm.controls['chipInput'].setValue('');
              }
          };
      /**
       * update value
       * @return {?}
       */
      Md2Chips.prototype.updateValue = /**
       * update value
       * @return {?}
       */
          function () {
              var _this = this;
              this._value = new Array();
              this._value = this.chipItemList.map(function (chip) {
                  if (_this.valueKey) {
                      /** @type {?} */
                      var c = {};
                      c[_this.textKey] = chip.text;
                      c[_this.valueKey] = chip.value;
                      return c;
                  }
                  else {
                      return chip.value;
                  }
              });
              this._emitChangeEvent();
          };
      /** Emits an event when the user selects a color. */
      /**
       * Emits an event when the user selects a color.
       * @return {?}
       */
      Md2Chips.prototype._emitChangeEvent = /**
       * Emits an event when the user selects a color.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var event = new Md2ChipsChange();
              event.source = this;
              event.value = this._value;
              this._onChange(event.value);
              this.change.emit(event);
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Chips.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (value !== this._value) {
                  this._value = value;
                  this.chipItemList = [];
                  if (value) {
                      if (value && value.length && Array.isArray(value)) {
                          for (var i = 0; i < value.length; i++) {
                              this.chipItemList.push(new Chip(value[i], this.textKey, this.valueKey));
                          }
                      }
                  }
              }
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Chips.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onChange = fn; };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Chips.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onTouched = fn; };
      Md2Chips.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-chips',
                      template: "<div class=\"md2-chips-container\" [class.md2-chip-disabled]=\"disabled\" [class.md2-chip-remove]=\"!isRemovable\">\n  <span *ngFor=\"let chip of chipItemList; let i = index\" class=\"md2-chip\" [class.active]=\"selectedChip === i\">\n    <span>{{chip.text}}</span>\n    <span [innerHTML]=\"templateHtmlString\"></span>\n    <svg (click)=\"removeSelectedChip(i)\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" *ngIf=\"isRemovable\">\n      <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n    </svg>\n  </span>\n  <ng-content select=\".md2-template\"></ng-content>\n  <form #chipInputForm=\"ngForm\" class=\"chip-input-form\">\n    <input *ngIf=\"!isAutoComplete\" class=\"chip-input\" [disabled]=\"disabled\" [type]=\"type\" [(ngModel)]=\"inputValue\" name=\"chipInput\" [placeholder]=\"placeholder\" (paste)=\"inputPaste($event)\" (keydown)=\"inputChanged($event)\" (blur)=\"inputBlurred()\" (focus)=\"inputFocus()\" />\n    <div *ngIf=\"isAutoComplete\">\n      <md2-autocomplete name=\"autocomplete\"\n                        [placeholder]=\"placeholder\"\n                        [disabled]=\"disabled\"\n                        [(ngModel)]=\"item\"\n                        [items]=\"autocompleteDataList\"\n                        [item-text]=\"autocompleteItemText\"\n                        (textChange)=\"valueupdate($event)\"\n                        (change)=\"changeAutocomplete($event)\"\n                        (keydown)=\"inputChanged($event)\"\n                        (click)=\"getFocusAutocomplete()\">\n      </md2-autocomplete>\n    </div>\n  </form>\n</div>\n<div class=\"chip-error\" *ngIf=\"this.chipItemList.length<this.minChips\">Minimum {{minChips}} chip required.</div>\n<div class=\"chip-error\" *ngIf=\"this.chipItemList.length>=this.maxChips\">You are able to add Maximum {{maxChips}} chip.</div>\n",
                      providers: [MD2_CHIPS_CONTROL_VALUE_ACCESSOR],
                      host: {
                          'role': 'chips',
                          '[id]': 'id',
                          '[tabindex]': 'disabled ? -1 : tabindex',
                          '[class.chip-input-focus]': 'inputFocused || selectedChip >= 0',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: [".template-content{display:inline}md2-chips{outline:0}md2-chips .md2-chips-container{display:block;box-shadow:0 1px #ccc;padding:5px 0;margin-bottom:10px;min-height:50px;box-sizing:border-box;clear:both}md2-chips .md2-chips-container::after{clear:both;content:'';display:table}md2-chips.chip-input-focus .md2-chips-container{box-shadow:0 2px #0d8bff}md2-chips .md2-chip-disabled{cursor:default}md2-chips md2-autocomplete{margin:0}md2-chips .md2-autocomplete-wrap{border-bottom:0!important}.md2-chip-remove .md2-chip{padding:0 12px}.md2-chip{font-size:14px;position:relative;cursor:default;border-radius:16px;display:block;height:32px;line-height:32px;margin:8px 8px 0 0;padding:0 28px 0 12px;float:left;box-sizing:border-box;max-width:100%;background:#e0e0e0;color:#424242;white-space:nowrap;overflow:hidden;-ms-text-overflow:ellipsis;text-overflow:ellipsis}.md2-chip.active{color:#fff;background:#0d8bff}.md2-chip.active svg{color:rgba(255,255,255,.87)}.md2-chip svg{position:absolute;top:4px;right:4px;cursor:pointer;display:inline-block;overflow:hidden;fill:currentColor;color:rgba(0,0,0,.54)}.md2-template{display:none}.chip-input-disabled{pointer-events:none;cursor:default}.chip-input-form{display:inline-block;height:32px;margin:8px 8px 0 0}.chip-remove{cursor:pointer;display:inline-block;padding:0 3px;color:#616161;font-size:30px;vertical-align:top;line-height:21px;font-family:serif}.chip-input{display:inline-block;width:auto;border:0;outline:0;height:32px;line-height:32px;font-size:16px;background:0 0}.chip-error{font-size:13px;color:#fd0f0f}.md2-chips-container .chip-input-form .md2-autocomplete-wrap{border-bottom:0}.md2-chips-container .md2-autocomplete-wrap .md2-autocomplete-placeholder.has-value,.md2-chips-container .md2-autocomplete-wrap svg,.md2-chips-container .md2-autocomplete-wrap.is-focused .md2-autocomplete-placeholder{display:none}.md2-chips-container .md2-autocomplete-wrap .md2-autocomplete-input{height:32px;font-size:16px}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Chips.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      Md2Chips.propDecorators = {
          tabindex: [{ type: core.Input }],
          addOnComma: [{ type: core.Input }],
          addOnEnter: [{ type: core.Input }],
          addOnPaste: [{ type: core.Input }],
          addOnSpace: [{ type: core.Input }],
          allowedPattern: [{ type: core.Input }],
          ngModel: [{ type: core.Input }],
          pasteSplitPattern: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          autocompleteDataList: [{ type: core.Input }],
          isAutoComplete: [{ type: core.Input }],
          isRemovable: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          minChips: [{ type: core.Input }],
          maxChips: [{ type: core.Input }],
          type: [{ type: core.Input }],
          id: [{ type: core.Input }],
          autocompleteItemText: [{ type: core.Input, args: ['autocomplete-item-text',] }],
          autocompleteItemValue: [{ type: core.Input, args: ['autocomplete-item-value',] }],
          textKey: [{ type: core.Input, args: ['item-text',] }],
          valueKey: [{ type: core.Input, args: ['item-value',] }],
          change: [{ type: core.Output }],
          chipInputForm: [{ type: core.ViewChild, args: ['chipInputForm',] }],
          value: [{ type: core.Input }],
          _handleFocus: [{ type: core.HostListener, args: ['focus',] }]
      };
      return Md2Chips;
  }());
  /** @type {?} */
  var MD2_CHIPS_DIRECTIVES = [Md2Chips];
  var Md2ChipsModule = /** @class */ (function () {
      function Md2ChipsModule() {
      }
      Md2ChipsModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, forms.FormsModule, Md2AutocompleteModule],
                      declarations: MD2_CHIPS_DIRECTIVES,
                      exports: MD2_CHIPS_DIRECTIVES
                  },] }
      ];
      return Md2ChipsModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2Collapse = /** @class */ (function () {
      function Md2Collapse() {
          this._collapse = true;
          this._collapsing = false;
          this.collapsed = new core.EventEmitter();
          this.expanded = new core.EventEmitter();
      }
      Object.defineProperty(Md2Collapse.prototype, "collapse", {
          get: /**
           * @return {?}
           */ function () { return this._collapse; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._collapse = value;
              this.toggle();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * toggle collapse
       */
      /**
       * toggle collapse
       * @return {?}
       */
      Md2Collapse.prototype.toggle = /**
       * toggle collapse
       * @return {?}
       */
          function () {
              if (this._collapse) {
                  this.hide();
              }
              else {
                  this.show();
              }
          };
      /**
      * show collapse
      */
      /**
       * show collapse
       * @return {?}
       */
      Md2Collapse.prototype.show = /**
       * show collapse
       * @return {?}
       */
          function () {
              var _this = this;
              this._collapsing = true;
              this._collapse = true;
              setTimeout(function () {
                  _this._collapsing = false;
              }, 4);
              this.expanded.emit();
          };
      /**
       * hide collapse
       */
      /**
       * hide collapse
       * @return {?}
       */
      Md2Collapse.prototype.hide = /**
       * hide collapse
       * @return {?}
       */
          function () {
              var _this = this;
              this._collapsing = true;
              this._collapse = false;
              setTimeout(function () {
                  _this._collapsing = false;
              }, 4);
              this.collapsed.emit();
          };
      Md2Collapse.decorators = [
          { type: core.Directive, args: [{
                      selector: '[collapse]',
                      host: {
                          'role': 'collapse',
                          '[class.in]': '_collapse',
                          '[class.collapse]': 'true',
                          '[class.collapsing]': '_collapsing',
                          '[attr.aria-expanded]': '_collapse',
                          '[attr.aria-hidden]': '!_collapse'
                      },
                      exportAs: 'md2Collapse'
                  },] }
      ];
      Md2Collapse.propDecorators = {
          collapsed: [{ type: core.Output }],
          expanded: [{ type: core.Output }],
          collapse: [{ type: core.Input }]
      };
      return Md2Collapse;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2CollapseModule = /** @class */ (function () {
      function Md2CollapseModule() {
      }
      Md2CollapseModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule],
                      exports: [Md2Collapse],
                      declarations: [Md2Collapse],
                  },] }
      ];
      return Md2CollapseModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var COLOR_RGB = /(rgb)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*%?,\s*(\d{1,3})\s*%?(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/;
  /** @type {?} */
  var COLOR_HSL = /(hsl)a?\(\s*(\d{1,3})\s*,\s*(\d{1,3})%\s*,\s*(\d{1,3})%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/;
  var Hsva = /** @class */ (function () {
      function Hsva(h, s, v, a) {
          this.h = h;
          this.s = s;
          this.v = v;
          this.a = a;
      }
      return Hsva;
  }());
  var Hsla = /** @class */ (function () {
      function Hsla(h, s, l, a) {
          this.h = h;
          this.s = s;
          this.l = l;
          this.a = a;
      }
      return Hsla;
  }());
  var Rgba = /** @class */ (function () {
      function Rgba(r, g, b, a) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
      }
      return Rgba;
  }());
  var ColorUtil = /** @class */ (function () {
      function ColorUtil() {
      }
      /**
    * hsla to hsva
    * @param hsla
    */
      /**
       * hsla to hsva
       * @param {?} hsla
       * @return {?}
       */
      ColorUtil.prototype.hsla2hsva = /**
       * hsla to hsva
       * @param {?} hsla
       * @return {?}
       */
          function (hsla) {
              /** @type {?} */
              var h = Math.min(hsla.h, 1);
              /** @type {?} */
              var s = Math.min(hsla.s, 1);
              /** @type {?} */
              var l = Math.min(hsla.l, 1);
              /** @type {?} */
              var a = Math.min(hsla.a, 1);
              if (l === 0) {
                  return { h: h, s: 0, v: 0, a: a };
              }
              else {
                  /** @type {?} */
                  var v = l + s * (1 - Math.abs(2 * l - 1)) / 2;
                  return { h: h, s: 2 * (v - l) / v, v: v, a: a };
              }
          };
      /**
      * hsva to hsla
      * @param hsva
      */
      /**
       * hsva to hsla
       * @param {?} hsva
       * @return {?}
       */
      ColorUtil.prototype.hsva2hsla = /**
       * hsva to hsla
       * @param {?} hsva
       * @return {?}
       */
          function (hsva) {
              /** @type {?} */
              var h = hsva.h;
              /** @type {?} */
              var s = hsva.s;
              /** @type {?} */
              var v = hsva.v;
              /** @type {?} */
              var a = hsva.a;
              if (v === 0) {
                  return new Hsla(h, 0, 0, a);
              }
              else if (s === 0 && v === 1) {
                  return new Hsla(h, 1, 1, a);
              }
              else {
                  /** @type {?} */
                  var l = v * (2 - s) / 2;
                  return new Hsla(h, v * s / (1 - Math.abs(2 * l - 1)), l, a);
              }
          };
      /**
       * rgba to hsva
       * @param rgba
       */
      /**
       * rgba to hsva
       * @param {?} rgba
       * @return {?}
       */
      ColorUtil.prototype.rgbaToHsva = /**
       * rgba to hsva
       * @param {?} rgba
       * @return {?}
       */
          function (rgba) {
              /** @type {?} */
              var r = Math.min(rgba.r, 1);
              /** @type {?} */
              var g = Math.min(rgba.g, 1);
              /** @type {?} */
              var b = Math.min(rgba.b, 1);
              /** @type {?} */
              var a = Math.min(rgba.a, 1);
              /** @type {?} */
              var max = Math.max(r, g, b);
              /** @type {?} */
              var min = Math.min(r, g, b);
              /** @type {?} */
              var h;
              /** @type {?} */
              var s;
              /** @type {?} */
              var v = max;
              /** @type {?} */
              var d = max - min;
              s = max === 0 ? 0 : d / max;
              if (max === min) {
                  h = 0;
              }
              else {
                  switch (max) {
                      case r:
                          h = (g - b) / d + (g < b ? 6 : 0);
                          break;
                      case g:
                          h = (b - r) / d + 2;
                          break;
                      case b:
                          h = (r - g) / d + 4;
                          break;
                  }
                  h /= 6;
              }
              return new Hsva(h, s, v, a);
          };
      /**
       * hsva to rgba
       * @param hsva
       */
      /**
       * hsva to rgba
       * @param {?} hsva
       * @return {?}
       */
      ColorUtil.prototype.hsvaToRgba = /**
       * hsva to rgba
       * @param {?} hsva
       * @return {?}
       */
          function (hsva) {
              /** @type {?} */
              var h = hsva.h;
              /** @type {?} */
              var s = hsva.s;
              /** @type {?} */
              var v = hsva.v;
              /** @type {?} */
              var a = hsva.a;
              /** @type {?} */
              var r;
              /** @type {?} */
              var g;
              /** @type {?} */
              var b;
              /** @type {?} */
              var i = Math.floor(h * 6);
              /** @type {?} */
              var f = h * 6 - i;
              /** @type {?} */
              var p = v * (1 - s);
              /** @type {?} */
              var q = v * (1 - f * s);
              /** @type {?} */
              var t = v * (1 - (1 - f) * s);
              switch (i % 6) {
                  case 0:
                      r = v;
                      g = t;
                      b = p;
                      break;
                  case 1:
                      r = q;
                      g = v;
                      b = p;
                      break;
                  case 2:
                      r = p;
                      g = v;
                      b = t;
                      break;
                  case 3:
                      r = p;
                      g = q;
                      b = v;
                      break;
                  case 4:
                      r = t;
                      g = p;
                      b = v;
                      break;
                  case 5:
                      r = v;
                      g = p;
                      b = q;
                      break;
              }
              return new Rgba(r, g, b, a);
          };
      /**
       * string to hsva
       * @param colorString
       */
      /**
       * string to hsva
       * @param {?} colorString
       * @return {?}
       */
      ColorUtil.prototype.stringToHsva = /**
       * string to hsva
       * @param {?} colorString
       * @return {?}
       */
          function (colorString) {
              /** @type {?} */
              var stringParsers = [
                  {
                      re: COLOR_RGB,
                      parse: function (execResult) {
                          return new Rgba(parseInt(execResult[2]) / 255, parseInt(execResult[3]) / 255, parseInt(execResult[4]) / 255, isNaN(parseFloat(execResult[5])) ? 1 : parseFloat(execResult[5]));
                      }
                  },
                  {
                      re: COLOR_HSL,
                      parse: function (execResult) {
                          return new Hsla(parseInt(execResult[2]) / 360, parseInt(execResult[3]) / 100, parseInt(execResult[4]) / 100, isNaN(parseFloat(execResult[5])) ? 1 : parseFloat(execResult[5]));
                      }
                  },
                  {
                      re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/,
                      parse: function (execResult) {
                          return new Rgba(parseInt(execResult[1], 16) / 255, parseInt(execResult[2], 16) / 255, parseInt(execResult[3], 16) / 255, 1);
                      }
                  },
                  {
                      re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])$/,
                      parse: function (execResult) {
                          return new Rgba(parseInt(execResult[1] + execResult[1], 16) / 255, parseInt(execResult[2] + execResult[2], 16) / 255, parseInt(execResult[3] + execResult[3], 16) / 255, 1);
                      }
                  }
              ];
              colorString = colorString.toLowerCase();
              /** @type {?} */
              var hsva = null;
              for (var key in stringParsers) {
                  if (stringParsers.hasOwnProperty(key)) {
                      /** @type {?} */
                      var parser = stringParsers[key];
                      /** @type {?} */
                      var match = parser.re.exec(colorString);
                      /** @type {?} */
                      var color = match && parser.parse(match);
                      if (color) {
                          if (color instanceof Rgba) {
                              hsva = this.rgbaToHsva(color);
                          }
                          else if (color instanceof Hsla) {
                              hsva = this.hsla2hsva(color);
                          }
                          return hsva;
                      }
                  }
              }
              return hsva;
          };
      /**
       * output formate of color
       * @param hsva
       * @param outputFormat
       */
      /**
       * output formate of color
       * @param {?} hsva
       * @param {?} outputFormat
       * @return {?}
       */
      ColorUtil.prototype.outputFormat = /**
       * output formate of color
       * @param {?} hsva
       * @param {?} outputFormat
       * @return {?}
       */
          function (hsva, outputFormat) {
              if (hsva.a < 1) {
                  switch (outputFormat) {
                      case 'hsl':
                          /** @type {?} */
                          var hsla = this.hsva2hsla(hsva);
                          /** @type {?} */
                          var hslaText = new Hsla(Math.round((hsla.h) * 360), Math.round(hsla.s * 100), Math.round(hsla.l * 100), Math.round(hsla.a * 100) / 100);
                          return 'hsla(' + hslaText.h + ',' + hslaText.s + '%,' +
                              hslaText.l + '%,' + hslaText.a + ')';
                      default:
                          /** @type {?} */
                          var rgba = this.denormalizeRGBA(this.hsvaToRgba(hsva));
                          return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b +
                              ',' + Math.round(rgba.a * 100) / 100 + ')';
                  }
              }
              else {
                  switch (outputFormat) {
                      case 'hsl':
                          /** @type {?} */
                          var hsla = this.hsva2hsla(hsva);
                          /** @type {?} */
                          var hslaText = new Hsla(Math.round((hsla.h) * 360), Math.round(hsla.s * 100), Math.round(hsla.l * 100), Math.round(hsla.a * 100) / 100);
                          return 'hsl(' + hslaText.h + ',' + hslaText.s + '%,' + hslaText.l + '%)';
                      case 'rgb':
                          /** @type {?} */
                          var rgba = this.denormalizeRGBA(this.hsvaToRgba(hsva));
                          return 'rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')';
                      default:
                          return this.hexText(this.denormalizeRGBA(this.hsvaToRgba(hsva)));
                  }
              }
          };
      /**
       * @param {?} rgba
       * @return {?}
       */
      ColorUtil.prototype.hexText = /**
       * @param {?} rgba
       * @return {?}
       */
          function (rgba) {
              /** @type {?} */
              var mainText = ((1 << 24) | (rgba.r << 16) | (rgba.g << 8) | rgba.b).toString(16);
              /** @type {?} */
              var hexText = '#' + mainText.substr(1);
              return hexText.toLowerCase();
          };
      /**
       * @param {?} rgba
       * @return {?}
       */
      ColorUtil.prototype.denormalizeRGBA = /**
       * @param {?} rgba
       * @return {?}
       */
          function (rgba) {
              return new Rgba(Math.round(rgba.r * 255), Math.round(rgba.g * 255), Math.round(rgba.b * 255), rgba.a);
          };
      ColorUtil.decorators = [
          { type: core.Injectable }
      ];
      return ColorUtil;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var SliderPosition = /** @class */ (function () {
      function SliderPosition(h, s, v, a) {
          this.h = h;
          this.s = s;
          this.v = v;
          this.a = a;
      }
      return SliderPosition;
  }());
  var SliderDimension = /** @class */ (function () {
      function SliderDimension(h, s, v, a) {
          this.h = h;
          this.s = s;
          this.v = v;
          this.a = a;
      }
      return SliderDimension;
  }());
  /** @type {?} */
  var nextId$2 = 0;
  var TextDirective = /** @class */ (function () {
      function TextDirective() {
          this.newValue = new core.EventEmitter();
      }
      /**
       * @param {?} event
       * @return {?}
       */
      TextDirective.prototype.changeInput = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              event.stopPropagation();
              event.preventDefault();
              /** @type {?} */
              var value = event.target.value;
              if (this.rg === undefined) {
                  this.newValue.emit(value);
              }
              else {
                  /** @type {?} */
                  var numeric = parseFloat(value);
                  if (!isNaN(numeric) && numeric >= 0 && numeric <= this.rg) {
                      this.newValue.emit({ v: numeric, rg: this.rg });
                  }
              }
          };
      TextDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[text]',
                      host: {
                          '(input)': 'changeInput($event)'
                      }
                  },] }
      ];
      TextDirective.propDecorators = {
          newValue: [{ type: core.Output, args: ['newValue',] }],
          text: [{ type: core.Input, args: ['text',] }],
          rg: [{ type: core.Input, args: ['rg',] }]
      };
      return TextDirective;
  }());
  var ColorpickerSliderDirective = /** @class */ (function () {
      function ColorpickerSliderDirective(_element) {
          var _this = this;
          this._element = _element;
          this.change = new core.EventEmitter();
          this.listenerMove = function (event) { _this.move(event); };
          this.listenerStop = function () { _this.stop(); };
      }
      /**
       * set cursor position
       * @param event
       */
      /**
       * set cursor position
       * @param {?} event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.setCursor = /**
       * set cursor position
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var height = this._getNativeElement().offsetHeight;
              /** @type {?} */
              var width = this._getNativeElement().offsetWidth;
              /** @type {?} */
              var x = Math.max(0, Math.min(this.getX(event), width));
              /** @type {?} */
              var y = Math.max(0, Math.min(this.getY(event), height));
              if (this.pointX !== undefined && this.pointY !== undefined) {
                  this.change.emit({
                      s: x / width, v: (1 - y / height),
                      pointX: this.pointX, pointY: this.pointY
                  });
              }
              else if (this.pointX === undefined && this.pointY !== undefined) {
                  this.change.emit({ v: y / height, rg: this.pointY });
              }
              else {
                  this.change.emit({ v: x / width, rg: this.pointX });
              }
          };
      /**
       * input event listner
       * @param event
       */
      /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.move = /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
          function (event) {
              event.preventDefault();
              this.setCursor(event);
          };
      /**
       * input event listner
       * @param event
       */
      /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.start = /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this.setCursor(event);
              document.addEventListener('mousemove', this.listenerMove);
              document.addEventListener('touchmove', this.listenerMove);
              document.addEventListener('mouseup', this.listenerStop);
              document.addEventListener('touchend', this.listenerStop);
          };
      /**
       * stop mouse event
       */
      /**
       * stop mouse event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.stop = /**
       * stop mouse event
       * @return {?}
       */
          function () {
              document.removeEventListener('mousemove', this.listenerMove);
              document.removeEventListener('touchmove', this.listenerMove);
              document.removeEventListener('mouseup', this.listenerStop);
              document.removeEventListener('touchend', this.listenerStop);
          };
      /**
       * get x
       * @param event
       */
      /**
       * get x
       * @param {?} event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.getX = /**
       * get x
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var boundingClientRect = this._getNativeElement().getBoundingClientRect();
              return (event.pageX !== undefined ? event.pageX : event.touches[0].pageX) -
                  boundingClientRect.left - window.pageXOffset;
          };
      /**
       * get y
       * @param event
       */
      /**
       * get y
       * @param {?} event
       * @return {?}
       */
      ColorpickerSliderDirective.prototype.getY = /**
       * get y
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var boundingClientRect = this._getNativeElement().getBoundingClientRect();
              return (event.pageY !== undefined ? event.pageY : event.touches[0].pageY) -
                  boundingClientRect.top - window.pageYOffset;
          };
      /**
       * @return {?}
       */
      ColorpickerSliderDirective.prototype._getNativeElement = /**
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      ColorpickerSliderDirective.decorators = [
          { type: core.Directive, args: [{
                      selector: '[colorpicker-slider]',
                      host: {
                          '(mousedown)': 'start($event)',
                          '(touchstart)': 'start($event)'
                      }
                  },] }
      ];
      /** @nocollapse */
      ColorpickerSliderDirective.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      ColorpickerSliderDirective.propDecorators = {
          slider: [{ type: core.Input, args: ['colorpicker-slider',] }],
          pointX: [{ type: core.Input, args: ['point-x',] }],
          pointY: [{ type: core.Input, args: ['point-y',] }],
          change: [{ type: core.Output, args: ['change',] }]
      };
      return ColorpickerSliderDirective;
  }());
  /**
   * Change event object emitted by Md2Colorpicker.
   */
  var /**
   * Change event object emitted by Md2Colorpicker.
   */ Md2ColorChange = /** @class */ (function () {
      function Md2ColorChange(source, color) {
          this.source = source;
          this.color = color;
      }
      return Md2ColorChange;
  }());
  var Md2Colorpicker = /** @class */ (function () {
      function Md2Colorpicker(_element, _overlay, _viewContainerRef, _renderer, _util, _control) {
          this._element = _element;
          this._overlay = _overlay;
          this._viewContainerRef = _viewContainerRef;
          this._renderer = _renderer;
          this._util = _util;
          this._control = _control;
          this._innerValue = '';
          this.backColor = true;
          this._defalutColor = '#000000';
          /**
           * Whether or not the overlay panel is open.
           */
          this._panelOpen = false;
          this._color = null;
          /**
           * Whether filling out the select is required in the form.
           */
          this._required = false;
          /**
           * Whether the select is disabled.
           */
          this._disabled = false;
          this.isInputFocus = false;
          this._container = 'inline';
          this.isInputValidColor = false;
          this._onChange = function () { };
          this._onTouched = function () { };
          this.cFormat = 'hex';
          this.colorpickerChange = new core.EventEmitter();
          /**
           * Event emitted when the selected date has been changed by the user.
           */
          this.change = new core.EventEmitter();
          this.tabindex = 0;
          this.id = 'md2-colorpicker-' + (++nextId$2);
          /**
           * Event emitted when the select has been opened.
           */
          this.onOpen = new core.EventEmitter();
          /**
           * Event emitted when the select has been closed.
           */
          this.onClose = new core.EventEmitter();
          this._created = false;
          if (this._control) {
              this._control.valueAccessor = this;
          }
      }
      Object.defineProperty(Md2Colorpicker.prototype, "color", {
          get: /**
           * @return {?}
           */ function () { return this._color; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._color = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "placeholder", {
          /** Placeholder to be shown if no value has been selected. */
          get: /**
           * Placeholder to be shown if no value has been selected.
           * @return {?}
           */ function () { return this._placeholder; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._placeholder = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "required", {
          get: /**
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "disabled", {
          /** Whether the component is disabled. */
          get: /**
           * Whether the component is disabled.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "value", {
          get: /**
           * @return {?}
           */ function () {
              return this._innerValue;
          },
          /**
          * set accessor including call the onchange callback
          */
          set: /**
           * set accessor including call the onchange callback
           * @param {?} v
           * @return {?}
           */ function (v) {
              if (v !== this._innerValue) {
                  if (v) {
                      this.hsva = this._util.stringToHsva(v);
                  }
                  this._innerValue = v;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "container", {
          get: /**
           * @return {?}
           */ function () { return this._container; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._container !== value) {
                  this._container = value || 'inline';
                  this.destroyPanel();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Colorpicker.prototype, "setGradient", {
          get: /**
           * @return {?}
           */ function () {
              return {
                  'background-image': 'linear-gradient(to right, transparent, transparent),' +
                      'linear-gradient(to left, ' + this.hexText + ', rgba(255, 255, 255, 0))'
              };
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () { this.destroyPanel(); };
      Object.defineProperty(Md2Colorpicker.prototype, "panelOpen", {
          /** Whether or not the overlay panel is open. */
          get: /**
           * Whether or not the overlay panel is open.
           * @return {?}
           */ function () {
              return this._panelOpen;
          },
          enumerable: true,
          configurable: true
      });
      /** Toggles the overlay panel open or closed. */
      /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
      Md2Colorpicker.prototype.toggle = /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
          function () {
              this.panelOpen ? this.close() : this.open();
          };
      /** Opens the overlay panel. */
      /**
       * Opens the overlay panel.
       * @return {?}
       */
      Md2Colorpicker.prototype.open = /**
       * Opens the overlay panel.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var hsva = this._util.stringToHsva(this.color + '');
              this.isInputFocus = true;
              if (hsva) {
                  this.hsva = hsva;
              }
              else {
                  this.hsva = this._util.stringToHsva(this._defalutColor);
              }
              this.sliderDim = new SliderDimension(245, 250, 130, 245);
              this.slider = new SliderPosition(0, 0, 0, 0);
              if (this.cFormat === 'rgb') {
                  this.format = 1;
              }
              else if (this.cFormat === 'hsl') {
                  this.format = 2;
              }
              else {
                  this.format = 0;
              }
              this.update();
              if (this.disabled) {
                  return;
              }
              if (!this._isColorpickerVisible) {
                  this._initialColor = this.color;
                  this.update();
                  this._isColorpickerVisible = true;
              }
              else {
                  this._isColorpickerVisible = false;
              }
              this._createOverlay();
              if (!this._portal) {
                  this._portal = new TemplatePortal(this._templatePortal, this._viewContainerRef);
              }
              this._overlayRef.attach(this._portal);
              this._subscribeToBackdrop();
              this._panelOpen = true;
              this.onOpen.emit();
          };
      /** Closes the overlay panel and focuses the host element. */
      /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
      Md2Colorpicker.prototype.close = /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
          function () {
              this._panelOpen = false;
              this.isInputFocus = false;
              if (this._overlayRef) {
                  this._overlayRef.detach();
                  this._backdropSubscription.unsubscribe();
              }
              this._isColorpickerVisible = false;
              if (this._innerValue) {
                  this.setColorFromString(this._innerValue);
              }
          };
      /** Removes the panel from the DOM. */
      /**
       * Removes the panel from the DOM.
       * @return {?}
       */
      Md2Colorpicker.prototype.destroyPanel = /**
       * Removes the panel from the DOM.
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.dispose();
                  this._overlayRef = null;
                  this._cleanUpSubscriptions();
              }
          };
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype._onBlur = /**
       * @return {?}
       */
          function () {
              if (!this.panelOpen) {
                  this._onTouched();
              }
          };
      /**
        * input event listner
        * @param event
        */
      /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
      Md2Colorpicker.prototype.changeInput = /**
       * input event listner
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var value = event.target.value;
              this.colorpickerChange.emit(value);
          };
      /**
      * set saturation,lightness,hue,alpha,RGB value
      * @param val
      * @param rg
      */
      /**
       * set saturation,lightness,hue,alpha,RGB value
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setSaturation = /**
       * set saturation,lightness,hue,alpha,RGB value
       * @param {?} val
       * @return {?}
       */
          function (val) {
              /** @type {?} */
              var hsla = this._util.hsva2hsla(this.hsva);
              hsla.s = val.v / val.rg;
              this.hsva = this._util.hsla2hsva(hsla);
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setLightness = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              /** @type {?} */
              var hsla = this._util.hsva2hsla(this.hsva);
              hsla.l = val.v / val.rg;
              this.hsva = this._util.hsla2hsva(hsla);
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setHue = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              this.hsva.h = val.v / val.rg;
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setAlpha = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              this.hsva.a = val.v / val.rg;
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setR = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              /** @type {?} */
              var rgba = this._util.hsvaToRgba(this.hsva);
              rgba.r = val.v / val.rg;
              this.hsva = this._util.rgbaToHsva(rgba);
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setG = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              /** @type {?} */
              var rgba = this._util.hsvaToRgba(this.hsva);
              rgba.g = val.v / val.rg;
              this.hsva = this._util.rgbaToHsva(rgba);
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setB = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              /** @type {?} */
              var rgba = this._util.hsvaToRgba(this.hsva);
              rgba.b = val.v / val.rg;
              this.hsva = this._util.rgbaToHsva(rgba);
              this.update();
          };
      /**
       * @param {?} val
       * @return {?}
       */
      Md2Colorpicker.prototype.setSaturationAndBrightness = /**
       * @param {?} val
       * @return {?}
       */
          function (val) {
              this.hsva.s = val.s / val.pointX;
              this.hsva.v = val.v / val.pointY;
              this.update();
          };
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype.clickOk = /**
       * @return {?}
       */
          function () {
              this._isColorpickerVisible = false;
              this.isInputValidColor = false;
              this.color = this._innerValue;
              if (this._innerValue != this._initialColor) {
                  this._emitChangeEvent();
              }
              this.close();
          };
      /**
      * deselect recent color and close popup
      */
      /**
       * deselect recent color and close popup
       * @return {?}
       */
      Md2Colorpicker.prototype.cancelColor = /**
       * deselect recent color and close popup
       * @return {?}
       */
          function () {
              this._innerValue = this._initialColor;
              this.close();
          };
      /**
       * @param {?} str
       * @return {?}
       */
      Md2Colorpicker.prototype.isValidColor = /**
       * @param {?} str
       * @return {?}
       */
          function (str) {
              return str.match(/^#[a-f0-9]{6}$/i) !== null;
          };
      /**
         * set color
         * @param value
         */
      /**
       * set color
       * @param {?} value
       * @return {?}
       */
      Md2Colorpicker.prototype.setColorFromString = /**
       * set color
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (!this.isValidColor(value)) {
                  value = '#000000';
                  this.backColor = false;
              }
              /** @type {?} */
              var hsva = this._util.stringToHsva(value);
              if (hsva !== null) {
                  this.hsva = hsva;
              }
              this.update();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Colorpicker.prototype.formatPolicy = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.format = value;
              if (this.format === 0 && this.hsva.a < 1) {
                  this.format++;
              }
              return this.format;
          };
      /**
       * update color
       */
      /**
       * update color
       * @return {?}
       */
      Md2Colorpicker.prototype.update = /**
       * update color
       * @return {?}
       */
          function () {
              /** @type {?} */
              var hsla = this._util.hsva2hsla(this.hsva);
              /** @type {?} */
              var rgba = this._util.denormalizeRGBA(this._util.hsvaToRgba(this.hsva));
              /** @type {?} */
              var hueRgba = this._util.denormalizeRGBA(this._util.hsvaToRgba(new Hsva(this.hsva.h, 1, 1, 1)));
              this.alphaColor = 'rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')';
              this._hueSliderColor = 'rgb(' + hueRgba.r + ',' + hueRgba.g + ',' + hueRgba.b + ')';
              this.hslaText = new Hsla(Math.round((hsla.h) * 360), Math.round(hsla.s * 100), Math.round(hsla.l * 100), Math.round(hsla.a * 100) / 100);
              this.rgbaText = new Rgba(rgba.r, rgba.g, rgba.b, Math.round(rgba.a * 100) / 100);
              if (this.backColor) {
                  this.hexText = this._util.hexText(rgba);
              }
              this.backColor = true;
              /** @type {?} */
              var colorCode = Math.round((this.rgbaText.r * 299 + this.rgbaText.g * 587 +
                  this.rgbaText.b * 114) / 1000);
              if (colorCode >= 128 || this.hsva.a < 0.35) {
                  this.fontColor = 'black';
                  this._isDark = true;
              }
              else {
                  this.fontColor = 'white';
                  this._isDark = false;
              }
              if (this.format === 0 && this.hsva.a < 1) {
                  this.format++;
              }
              this.outputColor = this._util.outputFormat(this.hsva, this.cFormat);
              this.slider = new SliderPosition((this.hsva.h) * this.sliderDim.h, this.hsva.s * this.sliderDim.s - 7, (1 - this.hsva.v) * this.sliderDim.v - 7, this.hsva.a * this.sliderDim.a);
              this._innerValue = this.outputColor;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Colorpicker.prototype.clearColor = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              event.stopPropagation();
              this.color = '';
              this._emitChangeEvent();
          };
      /**
       * @param {?} parent
       * @param {?} child
       * @return {?}
       */
      Md2Colorpicker.prototype.isDescendant = /**
       * @param {?} parent
       * @param {?} child
       * @return {?}
       */
          function (parent, child) {
              /** @type {?} */
              var node = child.parentNode;
              while (node !== null) {
                  if (node === parent) {
                      return true;
                  }
                  node = node.parentNode;
              }
              return false;
          };
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype.checkInputVal = /**
       * @return {?}
       */
          function () {
              this.hsva = this._util.stringToHsva(this.color + '');
              this.isInputFocus = false;
              if (this.hsva) {
                  if (this._innerValue !== this.color) {
                      this._emitChangeEvent();
                  }
                  this.isInputValidColor = false;
              }
              else {
                  this.isInputValidColor = true;
              }
              this._onTouched();
          };
      /** Emits an event when the user selects a color. */
      /**
       * Emits an event when the user selects a color.
       * @return {?}
       */
      Md2Colorpicker.prototype._emitChangeEvent = /**
       * Emits an event when the user selects a color.
       * @return {?}
       */
          function () {
              this._onChange(this.color);
              this.change.emit(new Md2ColorChange(this, this.color));
              this._innerValue = this.color;
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Colorpicker.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this._innerValue = value;
              this.color = value;
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Colorpicker.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onChange = fn; };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Colorpicker.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onTouched = fn; };
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      Md2Colorpicker.prototype.setDisabledState = /**
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype._subscribeToBackdrop = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                  _this._innerValue = _this._initialColor;
                  _this.close();
              });
          };
      /**
       *  This method creates the overlay from the provided panel's template and saves its
       *  OverlayRef so that it can be attached to the DOM when open is called.
       * @return {?}
       */
      Md2Colorpicker.prototype._createOverlay = /**
       *  This method creates the overlay from the provided panel's template and saves its
       *  OverlayRef so that it can be attached to the DOM when open is called.
       * @return {?}
       */
          function () {
              if (!this._overlayRef) {
                  /** @type {?} */
                  var config = new OverlayState();
                  if (this.container === 'inline') {
                      config.positionStrategy = this._createPickerPositionStrategy();
                      config.hasBackdrop = true;
                      config.backdropClass = 'cdk-overlay-transparent-backdrop';
                      config.scrollStrategy = this._overlay.scrollStrategies.reposition();
                  }
                  else {
                      config.positionStrategy = this._overlay.position()
                          .global()
                          .centerHorizontally()
                          .centerVertically();
                      config.hasBackdrop = true;
                  }
                  this._overlayRef = this._overlay.create(config);
              }
          };
      /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
      Md2Colorpicker.prototype._createPickerPositionStrategy = /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
          function () {
              return this._overlay.position()
                  .connectedTo(this._element, { originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
                  .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
          };
      /**
       * @return {?}
       */
      Md2Colorpicker.prototype._cleanUpSubscriptions = /**
       * @return {?}
       */
          function () {
              if (this._backdropSubscription) {
                  this._backdropSubscription.unsubscribe();
              }
              if (this._positionSubscription) {
                  this._positionSubscription.unsubscribe();
              }
          };
      Md2Colorpicker.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-colorpicker',
                      template: "\n<div class=\"md2-colorpicker-trigger\">\n  <div class=\"color-picker-selector\" [class.color-error]=\"isInputValidColor && required\">\n    <div class=\"md2-colorpicker-preview\" (click)=\"toggle()\">\n      <div class=\"color-fill\" [style.background-color]=\"color\"> </div>\n    </div>\n    <div class=\"md2-colorpicker-input\" [class.input-focused]=\"isInputFocus\">\n      <span class=\"md2-colorpicker-placeholder\" [class.has-value]=\"color\">{{ placeholder }}</span>\n      <input class=\"md2-colorpicker-value\" autocomplete=\"off\" value=\"color\" [tabindex]=\"tabindex\" [disabled]=\"disabled\" [(ngModel)]=\"color\" (focus)=\"isInputFocus=true\" (blur)=\"checkInputVal()\" />\n      <span *ngIf=\"color && !required && !disabled\" class=\"color-clear\" (click)=\"clearColor($event)\">\n        <svg viewBox=\"0 0 24 24\" width=\"20\" height=\"20\">\n          <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n        </svg>\n      </span>\n    </div>\n  </div>\n</div>\n<ng-template #portal>\n  <div class=\"md2-colorpicker-panel\" tabindex=\"0\" [attr.container]=\"container\">\n    <div class=\"md2-colorpicker-content\">\n      <div class=\"md2-colorpicker-wrapper\">\n        <div class=\"md2-color-picker\">\n          <div class=\"selected-color\">\n            <div class=\"selected-color-bg\" [style.background]=\"outputColor\">\n              <div class=\"color-input\">\n                <div [hidden]=\"format!=2\" class=\"hsla-text\">\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"360\" [rg]=\"360\" (newValue)=\"setHue($event)\" [value]=\"hslaText.h\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"100\" [rg]=\"100\" (newValue)=\"setSaturation($event)\" [value]=\"hslaText.s\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"100\" [rg]=\"100\" (newValue)=\"setLightness($event)\" [value]=\"hslaText.l\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]+([\\.,][0-9]{1,2})?\" min=\"0\" max=\"1\" step=\"0.1\" [rg]=\"1\" (newValue)=\"setAlpha($event)\" [value]=\"hslaText.a\" />\n                </div>\n                <div [hidden]=\"format!=1\" class=\"rgba-text\">\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"255\" [rg]=\"255\" (newValue)=\"setR($event)\" [value]=\"rgbaText.r\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"255\" [rg]=\"255\" (newValue)=\"setG($event)\" [value]=\"rgbaText.g\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]*\" min=\"0\" max=\"255\" [rg]=\"255\" (newValue)=\"setB($event)\" [value]=\"rgbaText.b\" />\n                  <input [text] type=\"number\" [style.color]=\"fontColor\" pattern=\"[0-9]+([\\.,][0-9]{1,2})?\" min=\"0\" max=\"1\" step=\"0.1\" [rg]=\"1\" (newValue)=\"setAlpha($event)\" [value]=\"rgbaText.a\" />\n                </div>\n                <div [hidden]=\"format!=0\" class=\"hex-text\">\n                  <input [text] (newValue)=\"setColorFromString($event)\" [style.color]=\"fontColor\" [value]=\"hexText\" />\n                </div>\n              </div>\n              <div class=\"color-bar\" [class.dark]=\"_isDark\">\n                <div [style.color]=\"fontColor\" class=\"clearfix\">\n                  <div class=\"type-policy\" [class.active]=\"format==0\" (click)=\"formatPolicy(0)\">HEX</div>\n                  <div class=\"type-policy\" [class.active]=\"format==1\" (click)=\"formatPolicy(1)\">RGBA</div>\n                  <div class=\"type-policy\" [class.active]=\"format==2\" (click)=\"formatPolicy(2)\">HSLA</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div class=\"input-color-content\">\n            <div [colorpicker-slider] [style.background-color]=\"_hueSliderColor\" [point-x]=\"1\" [point-y]=\"1\" (change)=\"setSaturationAndBrightness($event)\" class=\"saturation-lightness\">\n              <div [style.left.px]=\"slider.s\" [style.top.px]=\"slider.v\" class=\"cursor\"></div>\n            </div>\n            <div [colorpicker-slider] [point-x]=\"1\" (change)=\"setHue($event)\" class=\"hue\">\n              <div [style.left.px]=\"slider.h\" class=\"color-picker-marker\"></div>\n            </div>\n            <div [colorpicker-slider] [point-x]=\"1\" (change)=\"setAlpha($event)\" class=\"alpha\">\n              <div class=\"alpha-main\" [ngStyle]=\"setGradient\">\n                <div [style.left.px]=\"slider.a\" class=\"color-picker-marker\"></div>\n              </div>\n\n            </div>\n          </div>\n          <div class=\"md2-color-picker-actions\">\n            <div class=\"md2-button\" (click)=\"cancelColor()\">Cancel</div>\n            <div class=\"md2-button\" (click)=\"clickOk()\">Ok</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-template>\n",
                      host: {
                          'role': 'colorpicker',
                          '[id]': 'id',
                          '[class.md2-colorpicker-disabled]': 'disabled',
                          '[attr.aria-label]': 'placeholder',
                          '[attr.aria-required]': 'required.toString()',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: [".md2-colorpicker-wrapper{border-radius:3px;background-color:#fff;z-index:10;box-shadow:0 2px 6px rgba(0,0,0,.4);overflow:hidden}.md2-colorpicker-panel{outline:0;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.md2-colorpicker-panel[container=dialog]{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.md2-colorpicker-disabled{pointer-events:none;cursor:default}.md2-colorpicker-disabled .color-picker-selector .md2-colorpicker-value{color:rgba(0,0,0,.38);border-color:transparent;background-image:linear-gradient(to right,rgba(0,0,0,.38) 0,rgba(0,0,0,.38) 33%,transparent 0);background-position:bottom -1px left 0;background-size:4px 1px;background-repeat:repeat-x}.md2-colorpicker-input{color:rgba(0,0,0,.38);border-bottom:1px solid rgba(0,0,0,.12);display:flex;justify-content:space-between;align-items:center;height:30px;min-width:180px;line-height:22px;position:relative;box-sizing:border-box}[aria-disabled=true] .md2-colorpicker-input{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;border-color:transparent;background-position:0 bottom;cursor:default}md2-colorpicker:focus:not(.md2-colorpicker-disabled) .md2-colorpicker-input{color:#106cc8;border-color:#106cc8}md2-colorpicker.ng-invalid.ng-touched:not(.md2-colorpicker-disabled) .md2-colorpicker-input{color:#f44336;border-color:#f44336}.input-focused{color:#106cc8;border-color:#106cc8}.inline-control{width:150px;margin-right:16px;padding:16px 0}.md2-colorpicker-placeholder{position:absolute;right:18px;bottom:100%;left:0;padding:0 2px;-webkit-transform:translate3d(0,26px,0) scale(1);transform:translate3d(0,26px,0) scale(1);-webkit-transform-origin:left top;transform-origin:left top;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;transition:150ms cubic-bezier(.25,.8,.25,1)}[aria-required=true] .md2-colorpicker-placeholder::after{content:'*'}.md2-colorpicker-input.input-focused .md2-colorpicker-placeholder{color:#106cc8}.md2-colorpicker-input.input-focused .md2-colorpicker-placeholder,md2-colorpicker .md2-colorpicker-placeholder.has-value{-webkit-transform:translate3d(0,6px,0) scale(.75);transform:translate3d(0,6px,0) scale(.75)}.color-error .md2-colorpicker-input,.color-error .md2-colorpicker-placeholder{color:#f44336!important;border-color:#f44336}.color-error .color-fill{background-color:transparent!important}.color-picker-selector{display:block;padding:18px 0 4px 46px;white-space:nowrap}.color-picker-selector .md2-colorpicker-preview{position:absolute;top:19px;left:6px;content:'';width:24px;height:24px;overflow:hidden;background-color:#fff;background:linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd),linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd);background-size:8px 8px;background-position:0 0,4px 4px;border:2px solid #fafafa;display:block;fill:#5a5a5a;cursor:pointer;border-radius:50%;vertical-align:middle;box-shadow:0 1px 1px 0 rgba(0,0,0,.2),0 1px 1px 1px rgba(0,0,0,.14),0 1px 1px 1px rgba(0,0,0,.12)}.color-picker-selector .md2-colorpicker-preview .color-fill{width:100%;height:100%}.color-picker-selector .md2-colorpicker-value{font-size:15px;background:0 0;border:0;outline:0;position:relative;display:block;min-width:160px;height:30px;padding:2px 2px 1px;margin:0;line-height:26px;color:rgba(0,0,0,.87);vertical-align:middle;box-sizing:border-box}md2-colorpicker{position:relative;display:block;outline:0}.md2-color-picker{position:relative;display:block;width:266px;outline:0}.md2-color-picker *{box-sizing:border-box}.md2-color-picker .input-color-content{position:relative;padding:8px}.md2-color-picker i{cursor:default;position:relative}.md2-color-picker input{font-size:16px;height:50px;outline:0}.md2-color-picker div.cursor-sv{cursor:default;position:relative;border-radius:50%;width:15px;height:15px;border:1px solid #ddd}.md2-color-picker div.cursor{cursor:crosshair;position:relative;border-radius:50%;width:13px;height:13px;box-shadow:0 0 2px 0 rgba(0,0,0,.5),inset 0 0 2px 0 rgba(0,0,0,.5);border:2px solid #fff}.md2-color-picker div.color-picker-marker{cursor:crosshair;position:relative;border:2px solid #fff;box-shadow:0 0 2px 0 rgba(0,0,0,.5);height:100%;width:5px;border-bottom:0;border-top:0}.md2-color-picker .saturation-lightness{width:100%;height:130px;border-radius:2px;overflow:hidden;background-image:linear-gradient(to top,#000,rgba(0,0,0,0)),linear-gradient(to right,#fff,rgba(255,255,255,0))}.md2-color-picker .saturation-lightness:hover{cursor:crosshair}.md2-color-picker .hue{position:relative;width:100%;height:30px;margin:8px 0;border-radius:2px;background:linear-gradient(to right,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}.md2-color-picker .alpha{position:relative;width:100%;height:30px;border-radius:2px;background:linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd),linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd);background-size:8px 8px;background-position:0 0,4px 4px}.md2-color-picker .alpha .alpha-main{position:absolute;height:100%;opacity:1;background-image:linear-gradient(to left,transparent,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));width:100%}.md2-color-picker .selected-color{position:relative;width:100%;height:75px;background-color:#fff;background:linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd),linear-gradient(45deg,#ddd 25%,transparent 0,transparent 75%,#ddd 0,#ddd);background-size:8px 8px;background-position:0 0,4px 4px}.md2-color-picker .selected-color .selected-color-bg{position:absolute;height:100%;opacity:1;width:100%}.md2-color-picker .selected-color .color-bar{position:absolute;width:100%;bottom:0}.md2-color-picker .selected-color .color-input{position:relative}.color-clear{color:rgba(0,0,0,.4);cursor:pointer}.color-clear svg{vertical-align:bottom;fill:#686868}.clearfix::after,.clearfix::before{content:' ';display:table}.clearfix::after{clear:both}.hex-text{width:100%}.hex-text input{width:100%;border:0;padding:4px;text-align:center;background:0 0}.hex-text div{text-align:center;float:left;clear:left;width:160px;margin-top:4px}.hsla-text,.rgba-text{text-align:center}.hsla-text input,.rgba-text input{width:50px;border:0;padding:4px 0;background:0 0;text-align:center}.hsla-text div,.rgba-text div{text-align:center;display:block}.hsla-text label,.rgba-text label{text-align:center;display:inline-block;font-size:15px}.md2-color-picker-actions{text-align:right}.md2-color-picker-actions .md2-button{display:inline-block;min-width:64px;margin:4px 8px 8px 0;padding:0 12px;font-size:14px;color:#106cc8;line-height:36px;text-align:center;text-transform:uppercase;border-radius:2px;cursor:pointer;box-sizing:border-box;transition:450ms cubic-bezier(.23,1,.32,1)}.md2-color-picker-actions .md2-button:hover{background:#ebebeb}.hsla-text div:nth-child(5),.rgba-text div:nth-child(5){clear:left}.type-policy{width:33.333333%;text-align:center;font-size:14px;display:inline-block;float:left;padding:4px 8px 3px;border-bottom:2px solid transparent;cursor:pointer;background:rgba(255,255,255,.25)}.dark .type-policy{background:rgba(0,0,0,.25)}.type-policy.active{border-color:rgba(255,255,255,.5);background:0 0}.dark .type-policy.active{border-color:rgba(0,0,0,.5)}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.6)}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Colorpicker.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Overlay },
              { type: core.ViewContainerRef },
              { type: core.Renderer },
              { type: ColorUtil },
              { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] }
          ];
      };
      Md2Colorpicker.propDecorators = {
          color: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          required: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          cFormat: [{ type: core.Input, args: ['format',] }],
          colorpickerChange: [{ type: core.Output, args: ['colorpickerChange',] }],
          change: [{ type: core.Output }],
          tabindex: [{ type: core.Input }],
          id: [{ type: core.Input }],
          container: [{ type: core.Input }],
          onOpen: [{ type: core.Output }],
          onClose: [{ type: core.Output }],
          _templatePortal: [{ type: core.ViewChild, args: ['portal',] }]
      };
      return Md2Colorpicker;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2ColorpickerModule = /** @class */ (function () {
      function Md2ColorpickerModule() {
      }
      Md2ColorpickerModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          forms.FormsModule,
                          OverlayModule,
                          PortalModule,
                          StyleModule,
                          A11yModule,
                      ],
                      exports: [
                          Md2Colorpicker,
                          ColorpickerSliderDirective,
                          TextDirective
                      ],
                      declarations: [
                          Md2Colorpicker,
                          ColorpickerSliderDirective,
                          TextDirective
                      ],
                      providers: [ColorUtil]
                  },] }
      ];
      return Md2ColorpickerModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2OptgroupBase = /** @class */ (function () {
      function Md2OptgroupBase() {
      }
      return Md2OptgroupBase;
  }());
  /** @type {?} */
  var _Md2OptgroupMixinBase = mixinDisabled(Md2OptgroupBase);
  /** @type {?} */
  var nextId$3 = 0;
  /**
   * Component that is used to group instances of `md2-option`.
   */
  var Md2Optgroup = /** @class */ (function (_super) {
      __extends(Md2Optgroup, _super);
      function Md2Optgroup() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Unique id for the underlying label.
           */
          _this._labelId = "md2-optgroup-label-" + nextId$3++;
          return _this;
      }
      Md2Optgroup.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-optgroup',
                      template: "<label class=\"md2-optgroup-label\" [id]=\"_labelId\">{{ label }}</label>\n<ng-content select=\"md2-option\"></ng-content>\n",
                      encapsulation: core.ViewEncapsulation.None,
                      inputs: ['disabled'],
                      host: {
                          'class': 'md2-optgroup',
                          'role': 'group',
                          '[class.md2-optgroup-disabled]': 'disabled',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-labelledby]': '_labelId',
                      },
                      styles: [".md2-optgroup-label{color:rgba(0,0,0,.54);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default;font-weight:700;font-size:14px}.md2-optgroup-disabled .md2-optgroup-label{color:rgba(0,0,0,.38)}"]
                  }] }
      ];
      Md2Optgroup.propDecorators = {
          label: [{ type: core.Input }]
      };
      return Md2Optgroup;
  }(_Md2OptgroupMixinBase));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Option IDs need to be unique across components, so this counter exists outside of
   * the component definition.
    @type {?} */
  var _uniqueIdCounter$1 = 0;
  /**
   * Event object emitted by MdOption when selected or deselected.
   */
  var /**
   * Event object emitted by MdOption when selected or deselected.
   */ Md2OptionSelectionChange = /** @class */ (function () {
      function Md2OptionSelectionChange(source, isUserInput) {
          if (isUserInput === void 0) {
              isUserInput = false;
          }
          this.source = source;
          this.isUserInput = isUserInput;
      }
      return Md2OptionSelectionChange;
  }());
  /**
   * Single option inside of a `<md2-select>` element.
   */
  var Md2Option = /** @class */ (function () {
      function Md2Option(group, _element) {
          this.group = group;
          this._element = _element;
          this._selected = false;
          this._active = false;
          /**
           * Whether the option is disabled.
           */
          this._disabled = false;
          this._id = "md2-option-" + _uniqueIdCounter$1++;
          /**
           * Whether the wrapping component is in multiple selection mode.
           */
          this.multiple = false;
          /**
           * Event emitted when the option is selected or deselected.
           */
          this.onSelectionChange = new core.EventEmitter();
      }
      Object.defineProperty(Md2Option.prototype, "id", {
          /** The unique ID of the option. */
          get: /**
           * The unique ID of the option.
           * @return {?}
           */ function () { return this._id; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Option.prototype, "selected", {
          /** Whether or not the option is currently selected. */
          get: /**
           * Whether or not the option is currently selected.
           * @return {?}
           */ function () { return this._selected; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Option.prototype, "disabled", {
          /** Whether the option is disabled. */
          get: /**
           * Whether the option is disabled.
           * @return {?}
           */ function () { return (this.group && this.group.disabled) || this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Option.prototype, "active", {
          /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           */
          get: /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           * @return {?}
           */ function () {
              return this._active;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Option.prototype, "viewValue", {
          /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           */
          get: /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           * @return {?}
           */ function () {
              return this._getHostElement().textContent.trim();
          },
          enumerable: true,
          configurable: true
      });
      /** Selects the option. */
      /**
       * Selects the option.
       * @return {?}
       */
      Md2Option.prototype.select = /**
       * Selects the option.
       * @return {?}
       */
          function () {
              this._selected = true;
              this._emitSelectionChangeEvent();
          };
      /** Deselects the option. */
      /**
       * Deselects the option.
       * @return {?}
       */
      Md2Option.prototype.deselect = /**
       * Deselects the option.
       * @return {?}
       */
          function () {
              this._selected = false;
              this._emitSelectionChangeEvent();
          };
      /** Sets focus onto this option. */
      /**
       * Sets focus onto this option.
       * @return {?}
       */
      Md2Option.prototype.focus = /**
       * Sets focus onto this option.
       * @return {?}
       */
          function () {
              this._getHostElement().focus();
          };
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      Md2Option.prototype.setActiveStyles = /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              this._active = true;
          };
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      Md2Option.prototype.setInactiveStyles = /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              this._active = false;
          };
      /** Ensures the option is selected when activated from the keyboard. */
      /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
      Md2Option.prototype._handleKeydown = /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.keyCode === ENTER || event.keyCode === SPACE) {
                  this._selectViaInteraction();
              }
          };
      /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       */
      /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       * @return {?}
       */
      Md2Option.prototype._selectViaInteraction = /**
       * Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this._selected = this.multiple ? !this._selected : true;
                  this._emitSelectionChangeEvent(true);
              }
          };
      /** Returns the correct tabindex for the option depending on disabled state. */
      /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
      Md2Option.prototype._getTabIndex = /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
          function () {
              return this.disabled ? '-1' : '0';
          };
      /** Fetches the host DOM element. */
      /**
       * Fetches the host DOM element.
       * @return {?}
       */
      Md2Option.prototype._getHostElement = /**
       * Fetches the host DOM element.
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      /**
       * Emits the selection change event.
       * @param {?=} isUserInput
       * @return {?}
       */
      Md2Option.prototype._emitSelectionChangeEvent = /**
       * Emits the selection change event.
       * @param {?=} isUserInput
       * @return {?}
       */
          function (isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              this.onSelectionChange.emit(new Md2OptionSelectionChange(this, isUserInput));
          };
      Md2Option.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-option',
                      host: {
                          'role': 'option',
                          '[attr.tabindex]': '_getTabIndex()',
                          '[class.md2-selected]': 'selected',
                          '[class.md2-option-multiple]': 'multiple',
                          '[class.md2-active]': 'active',
                          '[id]': 'id',
                          '[attr.aria-selected]': 'selected.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[class.md2-option-disabled]': 'disabled',
                          '(click)': '_selectViaInteraction()',
                          '(keydown)': '_handleKeydown($event)',
                          '[class.md2-option]': 'true',
                      },
                      template: '<ng-content></ng-content>',
                      encapsulation: core.ViewEncapsulation.None,
                      styles: [".md2-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;position:relative;font-family:inherit;cursor:pointer;outline:0}.md2-option[disabled]{cursor:default}[dir=rtl] .md2-option{text-align:right}.md2-option .mat-icon{margin-right:16px}[dir=rtl] .md2-option .mat-icon{margin-left:16px;margin-right:0}.md2-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.md2-option:focus:not(.md2-option-disabled),.md2-option:hover:not(.md2-option-disabled){background:rgba(0,0,0,.04)}.md2-option.md2-selected{color:#106cc8}.md2-option.md2-selected:not(.md2-option-multiple){background:rgba(0,0,0,.04)}.md2-option.md2-active{background:rgba(0,0,0,.04);color:#106cc8}.md2-option.md2-option-disabled{color:rgba(0,0,0,.38)}.md2-option.md2-option-multiple{padding-left:40px}.md2-option.md2-option-multiple::after{content:'';position:absolute;top:50%;left:12px;display:block;width:16px;height:16px;margin-top:-8px;border:2px solid;border-radius:2px;box-sizing:border-box;transition:240ms}.md2-option.md2-option-multiple.md2-selected::after{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);height:8px;border-width:0 0 2px 2px}.md2-optgroup .md2-option:not(.md2-option-multiple){padding-left:32px}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Option.ctorParameters = function () {
          return [
              { type: Md2Optgroup, decorators: [{ type: core.Optional }] },
              { type: core.ElementRef }
          ];
      };
      Md2Option.propDecorators = {
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          onSelectionChange: [{ type: core.Output }]
      };
      return Md2Option;
  }());
  var Md2OptionModule = /** @class */ (function () {
      function Md2OptionModule() {
      }
      Md2OptionModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, MdSelectionModule],
                      exports: [Md2Option, Md2Optgroup],
                      declarations: [Md2Option, Md2Optgroup]
                  },] }
      ];
      return Md2OptionModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  // unsupported: template constraints.
  /**
   * This class manages keyboard events for selectable lists. If you pass it a query list
   * of items, it will set the active item correctly when arrow events occur.
   * @template T
   */
  var 
  // unsupported: template constraints.
  /**
   * This class manages keyboard events for selectable lists. If you pass it a query list
   * of items, it will set the active item correctly when arrow events occur.
   * @template T
   */
  ListKeyManager = /** @class */ (function () {
      function ListKeyManager(_items) {
          this._items = _items;
          this._activeItemIndex = null;
          this._tabOut = new rxjs.Subject();
          this._wrap = false;
      }
      /**
       * Turns on wrapping mode, which ensures that the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       *
       * @returns The ListKeyManager that the method was called on.
       */
      /**
       * Turns on wrapping mode, which ensures that the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       *
       * @return {?} The ListKeyManager that the method was called on.
       */
      ListKeyManager.prototype.withWrap = /**
       * Turns on wrapping mode, which ensures that the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       *
       * @return {?} The ListKeyManager that the method was called on.
       */
          function () {
              this._wrap = true;
              return this;
          };
      /**
       * Sets the active item to the item at the index specified.
       *
       * @param index The index of the item to be set as active.
       */
      /**
       * Sets the active item to the item at the index specified.
       *
       * @param {?} index The index of the item to be set as active.
       * @return {?}
       */
      ListKeyManager.prototype.setActiveItem = /**
       * Sets the active item to the item at the index specified.
       *
       * @param {?} index The index of the item to be set as active.
       * @return {?}
       */
          function (index) {
              this._activeItemIndex = index;
              this._activeItem = this._items.toArray()[index];
          };
      /**
       * Sets the active item depending on the key event passed in.
       * @param event Keyboard event to be used for determining which element should be active.
       */
      /**
       * Sets the active item depending on the key event passed in.
       * @param {?} event Keyboard event to be used for determining which element should be active.
       * @return {?}
       */
      ListKeyManager.prototype.onKeydown = /**
       * Sets the active item depending on the key event passed in.
       * @param {?} event Keyboard event to be used for determining which element should be active.
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  case DOWN_ARROW:
                      this.setNextItemActive();
                      break;
                  case UP_ARROW:
                      this.setPreviousItemActive();
                      break;
                  case TAB:
                      // Note that we shouldn't prevent the default action on tab.
                      this._tabOut.next(null);
                      return;
                  default:
                      return;
              }
              event.preventDefault();
          };
      Object.defineProperty(ListKeyManager.prototype, "activeItemIndex", {
          /** Returns the index of the currently active item. */
          get: /**
           * Returns the index of the currently active item.
           * @return {?}
           */ function () {
              return this._activeItemIndex;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ListKeyManager.prototype, "activeItem", {
          /** Returns the currently active item. */
          get: /**
           * Returns the currently active item.
           * @return {?}
           */ function () {
              return this._activeItem;
          },
          enumerable: true,
          configurable: true
      });
      /** Sets the active item to the first enabled item in the list. */
      /**
       * Sets the active item to the first enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setFirstItemActive = /**
       * Sets the active item to the first enabled item in the list.
       * @return {?}
       */
          function () {
              this._setActiveItemByIndex(0, 1);
          };
      /** Sets the active item to the last enabled item in the list. */
      /**
       * Sets the active item to the last enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setLastItemActive = /**
       * Sets the active item to the last enabled item in the list.
       * @return {?}
       */
          function () {
              this._setActiveItemByIndex(this._items.length - 1, -1);
          };
      /** Sets the active item to the next enabled item in the list. */
      /**
       * Sets the active item to the next enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setNextItemActive = /**
       * Sets the active item to the next enabled item in the list.
       * @return {?}
       */
          function () {
              this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
          };
      /** Sets the active item to a previous enabled item in the list. */
      /**
       * Sets the active item to a previous enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setPreviousItemActive = /**
       * Sets the active item to a previous enabled item in the list.
       * @return {?}
       */
          function () {
              this._activeItemIndex === null && this._wrap ? this.setLastItemActive()
                  : this._setActiveItemByDelta(-1);
          };
      /**
       * Allows setting of the activeItemIndex without any other effects.
       * @param index The new activeItemIndex.
       */
      /**
       * Allows setting of the activeItemIndex without any other effects.
       * @param {?} index The new activeItemIndex.
       * @return {?}
       */
      ListKeyManager.prototype.updateActiveItemIndex = /**
       * Allows setting of the activeItemIndex without any other effects.
       * @param {?} index The new activeItemIndex.
       * @return {?}
       */
          function (index) {
              this._activeItemIndex = index;
          };
      Object.defineProperty(ListKeyManager.prototype, "tabOut", {
          /**
           * Observable that emits any time the TAB key is pressed, so components can react
           * when focus is shifted off of the list.
           */
          get: /**
           * Observable that emits any time the TAB key is pressed, so components can react
           * when focus is shifted off of the list.
           * @return {?}
           */ function () {
              return this._tabOut.asObservable();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * This method sets the active item, given a list of items and the delta between the
       * currently active item and the new active item. It will calculate differently
       * depending on whether wrap mode is turned on.
       * @param {?} delta
       * @param {?=} items
       * @return {?}
       */
      ListKeyManager.prototype._setActiveItemByDelta = /**
       * This method sets the active item, given a list of items and the delta between the
       * currently active item and the new active item. It will calculate differently
       * depending on whether wrap mode is turned on.
       * @param {?} delta
       * @param {?=} items
       * @return {?}
       */
          function (delta, items) {
              if (items === void 0) {
                  items = this._items.toArray();
              }
              this._wrap ? this._setActiveInWrapMode(delta, items)
                  : this._setActiveInDefaultMode(delta, items);
          };
      /**
       * Sets the active item properly given "wrap" mode. In other words, it will continue to move
       * down the list until it finds an item that is not disabled, and it will wrap if it
       * encounters either end of the list.
       * @param {?} delta
       * @param {?} items
       * @return {?}
       */
      ListKeyManager.prototype._setActiveInWrapMode = /**
       * Sets the active item properly given "wrap" mode. In other words, it will continue to move
       * down the list until it finds an item that is not disabled, and it will wrap if it
       * encounters either end of the list.
       * @param {?} delta
       * @param {?} items
       * @return {?}
       */
          function (delta, items) {
              // when active item would leave menu, wrap to beginning or end
              this._activeItemIndex =
                  (this._activeItemIndex + delta + items.length) % items.length;
              // skip all disabled menu items recursively until an enabled one is reached
              if (items[this._activeItemIndex].disabled) {
                  this._setActiveInWrapMode(delta, items);
              }
              else {
                  this.setActiveItem(this._activeItemIndex);
              }
          };
      /**
       * Sets the active item properly given the default mode. In other words, it will
       * continue to move down the list until it finds an item that is not disabled. If
       * it encounters either end of the list, it will stop and not wrap.
       * @param {?} delta
       * @param {?} items
       * @return {?}
       */
      ListKeyManager.prototype._setActiveInDefaultMode = /**
       * Sets the active item properly given the default mode. In other words, it will
       * continue to move down the list until it finds an item that is not disabled. If
       * it encounters either end of the list, it will stop and not wrap.
       * @param {?} delta
       * @param {?} items
       * @return {?}
       */
          function (delta, items) {
              this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);
          };
      /**
       * Sets the active item to the first enabled item starting at the index specified. If the
       * item is disabled, it will move in the fallbackDelta direction until it either
       * finds an enabled item or encounters the end of the list.
       * @param {?} index
       * @param {?} fallbackDelta
       * @param {?=} items
       * @return {?}
       */
      ListKeyManager.prototype._setActiveItemByIndex = /**
       * Sets the active item to the first enabled item starting at the index specified. If the
       * item is disabled, it will move in the fallbackDelta direction until it either
       * finds an enabled item or encounters the end of the list.
       * @param {?} index
       * @param {?} fallbackDelta
       * @param {?=} items
       * @return {?}
       */
          function (index, fallbackDelta, items) {
              if (items === void 0) {
                  items = this._items.toArray();
              }
              if (!items[index]) {
                  return;
              }
              while (items[index].disabled) {
                  index += fallbackDelta;
                  if (!items[index]) {
                      return;
                  }
              }
              this.setActiveItem(index);
          };
      return ListKeyManager;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var FocusKeyManager = /** @class */ (function (_super) {
      __extends(FocusKeyManager, _super);
      function FocusKeyManager(items) {
          return _super.call(this, items) || this;
      }
      /**
       * This method sets the active item to the item at the specified index.
       * It also adds focuses the newly active item.
       */
      /**
       * This method sets the active item to the item at the specified index.
       * It also adds focuses the newly active item.
       * @param {?} index
       * @return {?}
       */
      FocusKeyManager.prototype.setActiveItem = /**
       * This method sets the active item to the item at the specified index.
       * It also adds focuses the newly active item.
       * @param {?} index
       * @return {?}
       */
          function (index) {
              _super.prototype.setActiveItem.call(this, index);
              if (this.activeItem) {
                  this.activeItem.focus();
              }
          };
      return FocusKeyManager;
  }(ListKeyManager));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * This animation shrinks the placeholder text to 75% of its normal size and translates
   * it to either the top left corner (ltr) or top right corner (rtl) of the trigger,
   * depending on the text direction of the application.
    @type {?} */
  var transformPlaceholder = animations.trigger('transformPlaceholder', [
      animations.state('floating-ltr', animations.style({
          top: '-22px',
          left: '-2px',
          transform: "scale(0.75)"
      })),
      animations.state('floating-rtl', animations.style({
          top: '-22px',
          left: '2px',
          transform: "scale(0.75)"
      })),
      animations.transition('* => *', animations.animate("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))
  ]);
  /** *
   * This animation transforms the select's overlay panel on and off the page.
   *
   * When the panel is attached to the DOM, it expands its width 32px, scales it up to
   * 100% on the Y axis, fades in its border, and translates slightly up and to the
   * side to ensure the option text correctly overlaps the trigger text.
   *
   * When the panel is removed from the DOM, it simply fades out linearly.
    @type {?} */
  var transformPanel = animations.trigger('transformPanel', [
      animations.state('showing', animations.style({
          opacity: 1,
          minWidth: 'calc(100% + 32px)',
          transform: "scaleY(1)"
      })),
      animations.transition('void => *', [
          animations.style({
              opacity: 0,
              minWidth: '100%',
              transform: "scaleY(0)"
          }),
          animations.animate("150ms cubic-bezier(0.25, 0.8, 0.25, 1)")
      ]),
      animations.transition('* => void', [
          animations.animate('250ms 100ms linear', animations.style({ opacity: 0 }))
      ])
  ]);
  /** *
   * This animation fades in the background color and text content of the
   * select's options. It is time delayed to occur 100ms after the overlay
   * panel has transformed in.
    @type {?} */
  var fadeInContent = animations.trigger('fadeInContent', [
      animations.state('showing', animations.style({ opacity: 1 })),
      animations.transition('void => showing', [
          animations.style({ opacity: 0 }),
          animations.animate("150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
      ])
  ]);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Returns an exception to be thrown when attempting to change a s
   * elect's `multiple` option after initialization.
   * \@docs-private
   * @return {?}
   */
  function getMdSelectDynamicMultipleError() {
      return new Error('Cannot change `multiple` mode of select after initialization.');
  }
  /**
   * Returns an exception to be thrown when attempting to assign a non-array value to a select
   * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for
   * resetting the value.
   * \@docs-private
   * @return {?}
   */
  function getMdSelectNonArrayValueError() {
      return new Error('Cannot assign truthy non-array value to select in `multiple` mode.');
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * The fixed height of every option element (option, group header etc.).
    @type {?} */
  var SELECT_ITEM_HEIGHT = 48;
  /** *
   * The max height of the select's overlay panel
    @type {?} */
  var SELECT_PANEL_MAX_HEIGHT = 256;
  /** *
   * The max number of options visible at once in the select panel.
    @type {?} */
  var SELECT_MAX_OPTIONS_DISPLAYED = Math.floor(SELECT_PANEL_MAX_HEIGHT / SELECT_ITEM_HEIGHT);
  /** *
   * The fixed height of the select's trigger element.
    @type {?} */
  var SELECT_TRIGGER_HEIGHT = 30;
  /** *
   * Must adjust for the difference in height between the option and the trigger,
   * so the text will align on the y axis.
    @type {?} */
  var SELECT_ITEM_HEIGHT_ADJUSTMENT = (SELECT_ITEM_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2;
  /** *
   * The panel's padding on the x-axis
    @type {?} */
  var SELECT_PANEL_PADDING_X = 16;
  /** *
   * The panel's x axis padding if it is indented (e.g. there is an option group).
    @type {?} */
  var SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;
  /** *
   * Distance between the panel edge and the option text in
   * multi-selection mode.
   *
   * (SELECT_PADDING * 1.75) + 20 = 48
   * The padding is multiplied by 1.75 because the checkbox's margin is half the padding, and
   * the browser adds ~4px, because we're using inline elements.
   * The checkbox width is 20px.
    @type {?} */
  var SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.25 + 20;
  /** *
   * The panel's padding on the y-axis. This padding indicates there are more
   * options available if you scroll.
    @type {?} */
  var SELECT_PANEL_PADDING_Y = 16;
  /** *
   * The select panel will only "fit" inside the viewport if it is positioned at
   * this value or more away from the viewport boundary.
    @type {?} */
  var SELECT_PANEL_VIEWPORT_PADDING = 8;
  /**
   * Change event object that is emitted when the select value has changed.
   */
  var /**
   * Change event object that is emitted when the select value has changed.
   */ Md2SelectChange = /** @class */ (function () {
      function Md2SelectChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return Md2SelectChange;
  }());
  var Md2Select = /** @class */ (function () {
      function Md2Select(_element, _renderer, _viewportRuler, _changeDetectorRef, _dir, _control, tabIndex) {
          this._element = _element;
          this._renderer = _renderer;
          this._viewportRuler = _viewportRuler;
          this._changeDetectorRef = _changeDetectorRef;
          this._dir = _dir;
          this._control = _control;
          /**
           * Whether or not the overlay panel is open.
           */
          this._panelOpen = false;
          /**
           * Whether filling out the select is required in the form.
           */
          this._required = false;
          /**
           * Whether the select is disabled.
           */
          this._disabled = false;
          /**
           * The scroll position of the overlay panel, calculated to center the selected option.
           */
          this._scrollTop = 0;
          /**
           * Whether the component is in multiple selection mode.
           */
          this._multiple = false;
          /**
           * The animation state of the placeholder.
           */
          this._placeholderState = '';
          /**
           * View -> model callback called when value changes
           */
          this._onChange = function () { };
          /**
           * View -> model callback called when select has been touched
           */
          this._onTouched = function () { };
          /**
           * The IDs of child options to be passed to the aria-owns attribute.
           */
          this._optionIds = '';
          /**
           * The value of the select panel's transform-origin property.
           */
          this._transformOrigin = 'top';
          /**
           * Whether the panel's animation is done.
           */
          this._panelDoneAnimating = false;
          /**
           * The y-offset of the overlay panel in relation to the trigger's top start corner.
           * This must be adjusted to align the selected option text over the trigger text.
           * when the panel opens. Will change based on the y-position of the selected option.
           */
          this._offsetY = 0;
          /**
           * This position config ensures that the top "start" corner of the overlay
           * is aligned with with the top "start" of the origin by default (overlapping
           * the trigger completely). If the panel cannot fit below the trigger, it
           * will fall back to a position above the trigger.
           */
          this._positions = [
              {
                  originX: 'start',
                  originY: 'top',
                  overlayX: 'start',
                  overlayY: 'top',
              },
              {
                  originX: 'start',
                  originY: 'bottom',
                  overlayX: 'start',
                  overlayY: 'bottom',
              },
          ];
          this._floatPlaceholder = 'auto';
          /**
           * Aria label of the select. If not specified, the placeholder will be used as label.
           */
          this.ariaLabel = '';
          /**
           * Input that can be used to specify the `aria-labelledby` attribute.
           */
          this.ariaLabelledby = '';
          /**
           * Event emitted when the select has been opened.
           */
          this.onOpen = new core.EventEmitter();
          /**
           * Event emitted when the select has been closed.
           */
          this.onClose = new core.EventEmitter();
          /**
           * Event emitted when the selected value has been changed by the user.
           */
          this.change = new core.EventEmitter();
          if (this._control) {
              this._control.valueAccessor = this;
          }
          this._tabIndex = parseInt(tabIndex) || 0;
      }
      Object.defineProperty(Md2Select.prototype, "placeholder", {
          /** Placeholder to be shown if no value has been selected. */
          get: /**
           * Placeholder to be shown if no value has been selected.
           * @return {?}
           */ function () { return this._placeholder; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              this._placeholder = value;
              // Must wait to record the trigger width to ensure placeholder width is included.
              Promise.resolve(null).then(function () { return _this._setTriggerWidth(); });
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "disabled", {
          /** Whether the component is disabled. */
          get: /**
           * Whether the component is disabled.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "required", {
          /** Whether the component is required. */
          get: /**
           * Whether the component is required.
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "multiple", {
          /** Whether the user should be allowed to select multiple options. */
          get: /**
           * Whether the user should be allowed to select multiple options.
           * @return {?}
           */ function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._selectionModel) {
                  throw getMdSelectDynamicMultipleError();
              }
              this._multiple = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "floatPlaceholder", {
          /** Whether to float the placeholder text. */
          get: /**
           * Whether to float the placeholder text.
           * @return {?}
           */ function () { return this._floatPlaceholder; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._floatPlaceholder = value || 'auto';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "tabIndex", {
          /** Tab index for the select element. */
          get: /**
           * Tab index for the select element.
           * @return {?}
           */ function () { return this._disabled ? -1 : this._tabIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (typeof value !== 'undefined') {
                  this._tabIndex = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "optionSelectionChanges", {
          /** Combined stream of all of the child options' change events. */
          get: /**
           * Combined stream of all of the child options' change events.
           * @return {?}
           */ function () {
              return rxjs.merge.apply(void 0, __spread(this.options.map(function (option) { return option.onSelectionChange; })));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Select.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._selectionModel = new SelectionModel(this.multiple, null, false);
          };
      /**
       * @return {?}
       */
      Md2Select.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._initKeyManager();
              this._changeSubscription = this.options.changes.pipe(operators.startWith(null)).subscribe(function () {
                  _this._resetOptions();
                  if (_this._control) {
                      // Defer setting the value in order to avoid the "Expression
                      // has changed after it was checked" errors from Angular.
                      Promise.resolve(null).then(function () { return _this._setSelectionByValue(_this._control.value); });
                  }
              });
          };
      /**
       * @return {?}
       */
      Md2Select.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._dropSubscriptions();
              if (this._changeSubscription) {
                  this._changeSubscription.unsubscribe();
              }
              if (this._tabSubscription) {
                  this._tabSubscription.unsubscribe();
              }
          };
      /** Toggles the overlay panel open or closed. */
      /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
      Md2Select.prototype.toggle = /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
          function () {
              this.panelOpen ? this.close() : this.open();
          };
      /** Opens the overlay panel. */
      /**
       * Opens the overlay panel.
       * @return {?}
       */
      Md2Select.prototype.open = /**
       * Opens the overlay panel.
       * @return {?}
       */
          function () {
              if (this.disabled || !this.options.length) {
                  return;
              }
              if (!this._triggerWidth) {
                  this._setTriggerWidth();
              }
              this._calculateOverlayPosition();
              this._placeholderState = this._floatPlaceholderState();
              this._panelOpen = true;
          };
      /** Closes the overlay panel and focuses the host element. */
      /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
      Md2Select.prototype.close = /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
          function () {
              if (this._panelOpen) {
                  this._panelOpen = false;
                  if (this._selectionModel.isEmpty()) {
                      this._placeholderState = '';
                  }
                  this._focusHost();
              }
          };
      /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param value New value to be written to the model.
       */
      /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} value New value to be written to the model.
       * @return {?}
       */
      Md2Select.prototype.writeValue = /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} value New value to be written to the model.
       * @return {?}
       */
          function (value) {
              if (this.options) {
                  this._setSelectionByValue(value);
              }
          };
      /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param fn Callback to be triggered when the value changes.
       */
      /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the value changes.
       * @return {?}
       */
      Md2Select.prototype.registerOnChange = /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the value changes.
       * @return {?}
       */
          function (fn) {
              this._onChange = fn;
          };
      /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param fn Callback to be triggered when the component has been touched.
       */
      /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the component has been touched.
       * @return {?}
       */
      Md2Select.prototype.registerOnTouched = /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the component has been touched.
       * @return {?}
       */
          function (fn) {
              this._onTouched = fn;
          };
      /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param isDisabled Sets whether the component is disabled.
       */
      /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} isDisabled Sets whether the component is disabled.
       * @return {?}
       */
      Md2Select.prototype.setDisabledState = /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} isDisabled Sets whether the component is disabled.
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      Object.defineProperty(Md2Select.prototype, "panelOpen", {
          /** Whether or not the overlay panel is open. */
          get: /**
           * Whether or not the overlay panel is open.
           * @return {?}
           */ function () {
              return this._panelOpen;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "selected", {
          /** The currently selected option. */
          get: /**
           * The currently selected option.
           * @return {?}
           */ function () {
              return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Select.prototype, "triggerValue", {
          /** The value displayed in the trigger. */
          get: /**
           * The value displayed in the trigger.
           * @return {?}
           */ function () {
              if (this._multiple) {
                  /** @type {?} */
                  var selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });
                  if (this._isRtl()) {
                      selectedOptions.reverse();
                  }
                  // TODO(crisbeto): delimiter should be configurable for proper localization.
                  return selectedOptions.join(', ');
              }
              return this._selectionModel.selected[0].viewValue;
          },
          enumerable: true,
          configurable: true
      });
      /** Whether the element is in RTL mode. */
      /**
       * Whether the element is in RTL mode.
       * @return {?}
       */
      Md2Select.prototype._isRtl = /**
       * Whether the element is in RTL mode.
       * @return {?}
       */
          function () {
              return this._dir ? this._dir.value === 'rtl' : false;
          };
      /**
       * Sets the width of the trigger element. This is necessary to match
       * the overlay width to the trigger width.
       * @return {?}
       */
      Md2Select.prototype._setTriggerWidth = /**
       * Sets the width of the trigger element. This is necessary to match
       * the overlay width to the trigger width.
       * @return {?}
       */
          function () {
              this._triggerWidth = this._getTriggerRect().width;
          };
      /** Handles the keyboard interactions of a closed select. */
      /**
       * Handles the keyboard interactions of a closed select.
       * @param {?} event
       * @return {?}
       */
      Md2Select.prototype._handleClosedKeydown = /**
       * Handles the keyboard interactions of a closed select.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!this.disabled) {
                  if (event.keyCode === ENTER || event.keyCode === SPACE) {
                      event.preventDefault(); // prevents the page from scrolling down when pressing space
                      this.open();
                  }
                  else if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {
                      this._handleArrowKey(event);
                  }
              }
          };
      /** Handles keypresses inside the panel. */
      /**
       * Handles keypresses inside the panel.
       * @param {?} event
       * @return {?}
       */
      Md2Select.prototype._handlePanelKeydown = /**
       * Handles keypresses inside the panel.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.keyCode === HOME || event.keyCode === END) {
                  event.preventDefault();
                  event.keyCode === HOME ? this._keyManager.setFirstItemActive() :
                      this._keyManager.setLastItemActive();
              }
              else {
                  this._keyManager.onKeydown(event);
              }
          };
      /**
       * When the panel element is finished transforming in (though not fading in), it
       * emits an event and focuses an option if the panel is open.
       */
      /**
       * When the panel element is finished transforming in (though not fading in), it
       * emits an event and focuses an option if the panel is open.
       * @return {?}
       */
      Md2Select.prototype._onPanelDone = /**
       * When the panel element is finished transforming in (though not fading in), it
       * emits an event and focuses an option if the panel is open.
       * @return {?}
       */
          function () {
              if (this.panelOpen) {
                  this._focusCorrectOption();
                  this.onOpen.emit();
              }
              else {
                  this.onClose.emit();
                  this._panelDoneAnimating = false;
                  this.overlayDir.offsetX = 0;
              }
          };
      /**
       * When the panel content is done fading in, the _panelDoneAnimating property is
       * set so the proper class can be added to the panel.
       */
      /**
       * When the panel content is done fading in, the _panelDoneAnimating property is
       * set so the proper class can be added to the panel.
       * @return {?}
       */
      Md2Select.prototype._onFadeInDone = /**
       * When the panel content is done fading in, the _panelDoneAnimating property is
       * set so the proper class can be added to the panel.
       * @return {?}
       */
          function () {
              this._panelDoneAnimating = this.panelOpen;
          };
      /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       */
      /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       * @return {?}
       */
      Md2Select.prototype._onBlur = /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       * @return {?}
       */
          function () {
              if (!this.panelOpen) {
                  this._onTouched();
              }
          };
      /**
       * Callback that is invoked when the overlay panel has been attached.
       */
      /**
       * Callback that is invoked when the overlay panel has been attached.
       * @return {?}
       */
      Md2Select.prototype._onAttached = /**
       * Callback that is invoked when the overlay panel has been attached.
       * @return {?}
       */
          function () {
              this._calculateOverlayOffsetX();
              this._setScrollTop();
          };
      /**
       * Sets the scroll position of the scroll container. This must be called after
       * the overlay pane is attached or the scroll container element will not yet be
       * present in the DOM.
       * @return {?}
       */
      Md2Select.prototype._setScrollTop = /**
       * Sets the scroll position of the scroll container. This must be called after
       * the overlay pane is attached or the scroll container element will not yet be
       * present in the DOM.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var scrollContainer = this.overlayDir.overlayRef.overlayElement.querySelector('.md2-select-panel');
              scrollContainer.scrollTop = this._scrollTop;
          };
      /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @param {?} value
       * @return {?}
       */
      Md2Select.prototype._setSelectionByValue = /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              /** @type {?} */
              var isArray = Array.isArray(value);
              if (this.multiple && value && !isArray) {
                  throw getMdSelectNonArrayValueError();
              }
              this._clearSelection();
              if (isArray) {
                  value.forEach(function (currentValue) { return _this._selectValue(currentValue); });
                  this._sortValues();
              }
              else {
                  this._selectValue(value);
              }
              this._setValueWidth();
              if (this._selectionModel.isEmpty()) {
                  this._placeholderState = '';
              }
              this._changeDetectorRef.markForCheck();
          };
      /**
       * Finds and selects and option based on its value.
       * @param {?} value
       * @return {?} Option that has the corresponding value.
       */
      Md2Select.prototype._selectValue = /**
       * Finds and selects and option based on its value.
       * @param {?} value
       * @return {?} Option that has the corresponding value.
       */
          function (value) {
              var _this = this;
              /** @type {?} */
              var optionsArray = this.options.toArray();
              /** @type {?} */
              var correspondingOption = optionsArray.find(function (option) {
                  return option.value != null
                      && option.value != undefined && _this.equals(option.value, value);
              });
              if (correspondingOption) {
                  correspondingOption.select();
                  this._selectionModel.select(correspondingOption);
                  this._keyManager.setActiveItem(optionsArray.indexOf(correspondingOption));
              }
              return correspondingOption;
          };
      /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
      Md2Select.prototype.equals = /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
          function (o1, o2) {
              if (o1 === o2) {
                  return true;
              }
              if (o1 === null || o2 === null) {
                  return false;
              }
              if (o1 !== o1 && o2 !== o2) {
                  return true;
              }
              /** @type {?} */
              var t1 = typeof o1;
              /** @type {?} */
              var t2 = typeof o2;
              /** @type {?} */
              var key;
              /** @type {?} */
              var keySet;
              if (t1 === t2 && t1 === 'object') {
                  keySet = Object.create(null);
                  for (key in o1) {
                      if (!this.equals(o1[key], o2[key])) {
                          return false;
                      }
                      keySet[key] = true;
                  }
                  for (key in o2) {
                      if (!(key in keySet) && key.charAt(0) !== '$' && o2[key]) {
                          return false;
                      }
                  }
                  return true;
              }
              return false;
          };
      /**
       * Clears the select trigger and deselects every option in the list.
       * @param {?=} skip Option that should not be deselected.
       * @return {?}
       */
      Md2Select.prototype._clearSelection = /**
       * Clears the select trigger and deselects every option in the list.
       * @param {?=} skip Option that should not be deselected.
       * @return {?}
       */
          function (skip) {
              this._selectionModel.clear();
              this.options.forEach(function (option) {
                  if (option !== skip) {
                      option.deselect();
                  }
              });
          };
      /**
       * @return {?}
       */
      Md2Select.prototype._getTriggerRect = /**
       * @return {?}
       */
          function () {
              return this.trigger.nativeElement.getBoundingClientRect();
          };
      /**
       * Sets up a key manager to listen to keyboard events on the overlay panel.
       * @return {?}
       */
      Md2Select.prototype._initKeyManager = /**
       * Sets up a key manager to listen to keyboard events on the overlay panel.
       * @return {?}
       */
          function () {
              var _this = this;
              this._keyManager = new FocusKeyManager(this.options);
              this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.close(); });
          };
      /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @return {?}
       */
      Md2Select.prototype._resetOptions = /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @return {?}
       */
          function () {
              this._dropSubscriptions();
              this._listenToOptions();
              this._setOptionIds();
              this._setOptionMultiple();
          };
      /**
       * Listens to user-generated selection events on each option.
       * @return {?}
       */
      Md2Select.prototype._listenToOptions = /**
       * Listens to user-generated selection events on each option.
       * @return {?}
       */
          function () {
              var _this = this;
              this._optionSubscription = this.optionSelectionChanges
                  .pipe(operators.filter(function (event) { return event.isUserInput; }))
                  .subscribe(function (event) {
                  _this._onSelect(event.source);
                  _this._setValueWidth();
                  if (!_this.multiple) {
                      _this.close();
                  }
              });
          };
      /**
       * Invoked when an option is clicked.
       * @param {?} option
       * @return {?}
       */
      Md2Select.prototype._onSelect = /**
       * Invoked when an option is clicked.
       * @param {?} option
       * @return {?}
       */
          function (option) {
              /** @type {?} */
              var wasSelected = this._selectionModel.isSelected(option);
              if (this.multiple) {
                  this._selectionModel.toggle(option);
                  wasSelected ? option.deselect() : option.select();
                  this._sortValues();
              }
              else {
                  this._clearSelection(option.value == null ? null : option);
                  if (option.value == null) {
                      this._propagateChanges(option.value);
                  }
                  else {
                      this._selectionModel.select(option);
                  }
              }
              if (wasSelected !== this._selectionModel.isSelected(option)) {
                  this._propagateChanges();
              }
          };
      /**
       * Sorts the model values, ensuring that they keep the same
       * order that they have in the panel.
       * @return {?}
       */
      Md2Select.prototype._sortValues = /**
       * Sorts the model values, ensuring that they keep the same
       * order that they have in the panel.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._multiple) {
                  this._selectionModel.clear();
                  this.options.forEach(function (option) {
                      if (option.selected) {
                          _this._selectionModel.select(option);
                      }
                  });
              }
          };
      /**
       * Unsubscribes from all option subscriptions.
       * @return {?}
       */
      Md2Select.prototype._dropSubscriptions = /**
       * Unsubscribes from all option subscriptions.
       * @return {?}
       */
          function () {
              if (this._optionSubscription) {
                  this._optionSubscription.unsubscribe();
                  this._optionSubscription = null;
              }
          };
      /**
       * Emits change event to set the model value.
       * @param {?=} fallbackValue
       * @return {?}
       */
      Md2Select.prototype._propagateChanges = /**
       * Emits change event to set the model value.
       * @param {?=} fallbackValue
       * @return {?}
       */
          function (fallbackValue) {
              /** @type {?} */
              var valueToEmit = null;
              if (Array.isArray(this.selected)) {
                  valueToEmit = this.selected.map(function (option) { return option.value; });
              }
              else {
                  valueToEmit = this.selected ? this.selected.value : fallbackValue;
              }
              this._onChange(valueToEmit);
              this.change.emit(new Md2SelectChange(this, valueToEmit));
          };
      /**
       * Records option IDs to pass to the aria-owns property.
       * @return {?}
       */
      Md2Select.prototype._setOptionIds = /**
       * Records option IDs to pass to the aria-owns property.
       * @return {?}
       */
          function () {
              this._optionIds = this.options.map(function (option) { return option.id; }).join(' ');
          };
      /**
       * Sets the `multiple` property on each option. The promise is necessary
       * in order to avoid Angular errors when modifying the property after init.
       * @return {?}
       */
      Md2Select.prototype._setOptionMultiple = /**
       * Sets the `multiple` property on each option. The promise is necessary
       * in order to avoid Angular errors when modifying the property after init.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.multiple) {
                  Promise.resolve(null).then(function () {
                      _this.options.forEach(function (option) { return option.multiple = _this.multiple; });
                  });
              }
          };
      /**
       * Must set the width of the selected option's value programmatically
       * because it is absolutely positioned and otherwise will not clip
       * overflow. The selection arrow is 9px wide, add 4px of padding = 13
       * @return {?}
       */
      Md2Select.prototype._setValueWidth = /**
       * Must set the width of the selected option's value programmatically
       * because it is absolutely positioned and otherwise will not clip
       * overflow. The selection arrow is 9px wide, add 4px of padding = 13
       * @return {?}
       */
          function () {
              this._selectedValueWidth = this._triggerWidth - 13;
          };
      /**
       * Focuses the selected item. If no option is selected, it will focus
       * the first item instead.
       * @return {?}
       */
      Md2Select.prototype._focusCorrectOption = /**
       * Focuses the selected item. If no option is selected, it will focus
       * the first item instead.
       * @return {?}
       */
          function () {
              if (this._selectionModel.isEmpty()) {
                  this._keyManager.setFirstItemActive();
              }
              else {
                  this._keyManager.setActiveItem(this._getOptionIndex(this._selectionModel.selected[0]));
              }
          };
      /**
       * Focuses the host element when the panel closes.
       * @return {?}
       */
      Md2Select.prototype._focusHost = /**
       * Focuses the host element when the panel closes.
       * @return {?}
       */
          function () {
              this._element.nativeElement.focus();
          };
      /**
       * Gets the index of the provided option in the option list.
       * @param {?} option
       * @return {?}
       */
      Md2Select.prototype._getOptionIndex = /**
       * Gets the index of the provided option in the option list.
       * @param {?} option
       * @return {?}
       */
          function (option) {
              return this.options.reduce(function (result, current, index) {
                  return result === undefined ? (option === current ? index : undefined) : result;
              }, undefined);
          };
      /**
       * Calculates the scroll position and x- and y-offsets of the overlay panel.
       * @return {?}
       */
      Md2Select.prototype._calculateOverlayPosition = /**
       * Calculates the scroll position and x- and y-offsets of the overlay panel.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var items = this._getItemCount();
              /** @type {?} */
              var panelHeight = Math.min(items * SELECT_ITEM_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
              /** @type {?} */
              var scrollContainerHeight = items * SELECT_ITEM_HEIGHT;
              /** @type {?} */
              var maxScroll = scrollContainerHeight - panelHeight;
              if (this._selectionModel.hasValue()) {
                  /** @type {?} */
                  var selectedIndex = this._getOptionIndex(this._selectionModel.selected[0]);
                  selectedIndex += this._getLabelCountBeforeOption(selectedIndex);
                  /** @type {?} */
                  var scrollBuffer = panelHeight / 2;
                  this._scrollTop = this._calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll);
                  this._offsetY = this._calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll);
              }
              else {
                  // If no option is selected, the panel centers on the first option. In this case,
                  // we must only adjust for the height difference between the option element
                  // and the trigger element, then multiply it by -1 to ensure the panel moves
                  // in the correct direction up the page.
                  this._offsetY = (SELECT_ITEM_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2 * -1;
              }
              this._checkOverlayWithinViewport(maxScroll);
          };
      /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       */
      /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
      Md2Select.prototype._calculateOverlayScroll = /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
          function (selectedIndex, scrollBuffer, maxScroll) {
              /** @type {?} */
              var optionOffsetFromScrollTop = SELECT_ITEM_HEIGHT * selectedIndex;
              /** @type {?} */
              var halfOptionHeight = SELECT_ITEM_HEIGHT / 2;
              /** @type {?} */
              var optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
              return clampValue(0, optimalScrollPosition, maxScroll);
          };
      /**
       * Figures out the appropriate animation state for the placeholder.
       */
      /**
       * Figures out the appropriate animation state for the placeholder.
       * @return {?}
       */
      Md2Select.prototype._getPlaceholderAnimationState = /**
       * Figures out the appropriate animation state for the placeholder.
       * @return {?}
       */
          function () {
              if (this.floatPlaceholder === 'never') {
                  return '';
              }
              if (this.floatPlaceholder === 'always') {
                  return this._floatPlaceholderState();
              }
              return this._placeholderState;
          };
      /**
       * Determines the CSS `opacity` of the placeholder element.
       */
      /**
       * Determines the CSS `opacity` of the placeholder element.
       * @return {?}
       */
      Md2Select.prototype._getPlaceholderOpacity = /**
       * Determines the CSS `opacity` of the placeholder element.
       * @return {?}
       */
          function () {
              return (this.floatPlaceholder !== 'never' || this._selectionModel.isEmpty()) ?
                  '1' : '0';
          };
      Object.defineProperty(Md2Select.prototype, "_ariaLabel", {
          /** Returns the aria-label of the select component. */
          get: /**
           * Returns the aria-label of the select component.
           * @return {?}
           */ function () {
              // If an ariaLabelledby value has been set, the select should not overwrite the
              // `aria-labelledby` value by setting the ariaLabel to the placeholder.
              return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
       * This must be adjusted to align the selected option text over the trigger text when
       * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
       * can't be calculated until the panel has been attached, because we need to know the
       * content width in order to constrain the panel within the viewport.
       * @return {?}
       */
      Md2Select.prototype._calculateOverlayOffsetX = /**
       * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
       * This must be adjusted to align the selected option text over the trigger text when
       * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
       * can't be calculated until the panel has been attached, because we need to know the
       * content width in order to constrain the panel within the viewport.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();
              /** @type {?} */
              var viewportRect = this._viewportRuler.getViewportRect();
              /** @type {?} */
              var isRtl = this._isRtl();
              /** @type {?} */
              var offsetX;
              // Adjust the offset, depending on the option padding.
              if (this.multiple) {
                  offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;
              }
              else {
                  /** @type {?} */
                  var selected = this._selectionModel.selected[0];
                  offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;
              }
              // Invert the offset in LTR.
              if (!isRtl) {
                  offsetX *= -1;
              }
              /** @type {?} */
              var leftOverflow = 0 - (overlayRect.left + offsetX
                  - (isRtl ? SELECT_PANEL_PADDING_X * 2 : 0));
              /** @type {?} */
              var rightOverflow = overlayRect.right + offsetX - viewportRect.width
                  + (isRtl ? 0 : SELECT_PANEL_PADDING_X * 2);
              // If the element overflows on either side, reduce the offset to allow it to fit.
              if (leftOverflow > 0) {
                  offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;
              }
              else if (rightOverflow > 0) {
                  offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;
              }
              // Set the offset directly in order to avoid having to go through change detection and
              // potentially triggering "changed after it was checked" errors.
              this.overlayDir.offsetX = offsetX;
              this.overlayDir.overlayRef.updatePosition();
          };
      /**
       * Calculates the y-offset of the select's overlay panel in relation to the
       * top start corner of the trigger. It has to be adjusted in order for the
       * selected option to be aligned over the trigger when the panel opens.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
      Md2Select.prototype._calculateOverlayOffsetY = /**
       * Calculates the y-offset of the select's overlay panel in relation to the
       * top start corner of the trigger. It has to be adjusted in order for the
       * selected option to be aligned over the trigger when the panel opens.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
          function (selectedIndex, scrollBuffer, maxScroll) {
              /** @type {?} */
              var optionOffsetFromPanelTop;
              if (this._scrollTop === 0) {
                  optionOffsetFromPanelTop = selectedIndex * SELECT_ITEM_HEIGHT;
              }
              else if (this._scrollTop === maxScroll) {
                  /** @type {?} */
                  var firstDisplayedIndex = this._getItemCount() - SELECT_MAX_OPTIONS_DISPLAYED;
                  /** @type {?} */
                  var selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
                  // Because the panel height is longer than the height of the options alone,
                  // there is always extra padding at the top or bottom of the panel. When
                  // scrolled to the very bottom, this padding is at the top of the panel and
                  // must be added to the offset.
                  optionOffsetFromPanelTop =
                      selectedDisplayIndex * SELECT_ITEM_HEIGHT + SELECT_PANEL_PADDING_Y;
              }
              else {
                  // If the option was scrolled to the middle of the panel using a scroll buffer,
                  // its offset will be the scroll buffer minus the half height that was added to
                  // center it.
                  optionOffsetFromPanelTop = scrollBuffer - SELECT_ITEM_HEIGHT / 2;
              }
              // The final offset is the option's offset from the top, adjusted for the height
              // difference, multiplied by -1 to ensure that the overlay moves in the correct
              // direction up the page.
              return optionOffsetFromPanelTop * -1 - SELECT_ITEM_HEIGHT_ADJUSTMENT;
          };
      /**
       * Checks that the attempted overlay position will fit within the viewport.
       * If it will not fit, tries to adjust the scroll position and the associated
       * y-offset so the panel can open fully on-screen. If it still won't fit,
       * sets the offset back to 0 to allow the fallback position to take over.
       * @param {?} maxScroll
       * @return {?}
       */
      Md2Select.prototype._checkOverlayWithinViewport = /**
       * Checks that the attempted overlay position will fit within the viewport.
       * If it will not fit, tries to adjust the scroll position and the associated
       * y-offset so the panel can open fully on-screen. If it still won't fit,
       * sets the offset back to 0 to allow the fallback position to take over.
       * @param {?} maxScroll
       * @return {?}
       */
          function (maxScroll) {
              /** @type {?} */
              var viewportRect = this._viewportRuler.getViewportRect();
              /** @type {?} */
              var triggerRect = this._getTriggerRect();
              /** @type {?} */
              var topSpaceAvailable = triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
              /** @type {?} */
              var bottomSpaceAvailable = viewportRect.height - triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
              /** @type {?} */
              var panelHeightTop = Math.abs(this._offsetY);
              /** @type {?} */
              var totalPanelHeight = Math.min(this._getItemCount() * SELECT_ITEM_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
              /** @type {?} */
              var panelHeightBottom = totalPanelHeight - panelHeightTop - triggerRect.height;
              if (panelHeightBottom > bottomSpaceAvailable) {
                  this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
              }
              else if (panelHeightTop > topSpaceAvailable) {
                  this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
              }
              else {
                  this._transformOrigin = this._getOriginBasedOnOption();
              }
          };
      /**
       * Adjusts the overlay panel up to fit in the viewport.
       * @param {?} panelHeightBottom
       * @param {?} bottomSpaceAvailable
       * @return {?}
       */
      Md2Select.prototype._adjustPanelUp = /**
       * Adjusts the overlay panel up to fit in the viewport.
       * @param {?} panelHeightBottom
       * @param {?} bottomSpaceAvailable
       * @return {?}
       */
          function (panelHeightBottom, bottomSpaceAvailable) {
              /** @type {?} */
              var distanceBelowViewport = panelHeightBottom - bottomSpaceAvailable;
              // Scrolls the panel up by the distance it was extending past the boundary, then
              // adjusts the offset by that amount to move the panel up into the viewport.
              this._scrollTop -= distanceBelowViewport;
              this._offsetY -= distanceBelowViewport;
              this._transformOrigin = this._getOriginBasedOnOption();
              // If the panel is scrolled to the very top, it won't be able to fit the panel
              // by scrolling, so set the offset to 0 to allow the fallback position to take
              // effect.
              if (this._scrollTop <= 0) {
                  this._scrollTop = 0;
                  this._offsetY = 0;
                  this._transformOrigin = "50% bottom 0px";
              }
          };
      /**
       * Adjusts the overlay panel down to fit in the viewport.
       * @param {?} panelHeightTop
       * @param {?} topSpaceAvailable
       * @param {?} maxScroll
       * @return {?}
       */
      Md2Select.prototype._adjustPanelDown = /**
       * Adjusts the overlay panel down to fit in the viewport.
       * @param {?} panelHeightTop
       * @param {?} topSpaceAvailable
       * @param {?} maxScroll
       * @return {?}
       */
          function (panelHeightTop, topSpaceAvailable, maxScroll) {
              /** @type {?} */
              var distanceAboveViewport = panelHeightTop - topSpaceAvailable;
              // Scrolls the panel down by the distance it was extending past the boundary, then
              // adjusts the offset by that amount to move the panel down into the viewport.
              this._scrollTop += distanceAboveViewport;
              this._offsetY += distanceAboveViewport;
              this._transformOrigin = this._getOriginBasedOnOption();
              // If the panel is scrolled to the very bottom, it won't be able to fit the
              // panel by scrolling, so set the offset to 0 to allow the fallback position
              // to take effect.
              if (this._scrollTop >= maxScroll) {
                  this._scrollTop = maxScroll;
                  this._offsetY = 0;
                  this._transformOrigin = "50% top 0px";
                  return;
              }
          };
      /**
       * Sets the transform origin point based on the selected option.
       * @return {?}
       */
      Md2Select.prototype._getOriginBasedOnOption = /**
       * Sets the transform origin point based on the selected option.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var originY = Math.abs(this._offsetY) - SELECT_ITEM_HEIGHT_ADJUSTMENT + SELECT_ITEM_HEIGHT / 2;
              return "50% " + originY + "px 0px";
          };
      /**
       * Figures out the floating placeholder state value.
       * @return {?}
       */
      Md2Select.prototype._floatPlaceholderState = /**
       * Figures out the floating placeholder state value.
       * @return {?}
       */
          function () {
              return this._isRtl() ? 'floating-rtl' : 'floating-ltr';
          };
      /**
       * Handles the user pressing the arrow keys on a closed select.
       * @param {?} event
       * @return {?}
       */
      Md2Select.prototype._handleArrowKey = /**
       * Handles the user pressing the arrow keys on a closed select.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this._multiple) {
                  event.preventDefault();
                  this.open();
              }
              else {
                  /** @type {?} */
                  var prevActiveItem = this._keyManager.activeItem;
                  // Cycle though the select options even when the select is closed,
                  // matching the behavior of the native select element.
                  // TODO(crisbeto): native selects also cycle through the options with left/right arrows,
                  // however the key manager only supports up/down at the moment.
                  this._keyManager.onKeydown(event);
                  /** @type {?} */
                  var currentActiveItem = /** @type {?} */ (this._keyManager.activeItem);
                  if (currentActiveItem !== prevActiveItem) {
                      this._clearSelection();
                      this._setSelectionByValue(currentActiveItem.value);
                      this._propagateChanges();
                  }
              }
          };
      /**
       * Calculates the amount of items in the select. This includes options and group labels.
       * @return {?}
       */
      Md2Select.prototype._getItemCount = /**
       * Calculates the amount of items in the select. This includes options and group labels.
       * @return {?}
       */
          function () {
              return this.options.length + this.optionGroups.length;
          };
      /**
       * Calculates the amount of option group labels that precede the specified option.
       * Useful when positioning the panel, because the labels will offset the index of the
       * currently-selected option.
       * @param {?} optionIndex
       * @return {?}
       */
      Md2Select.prototype._getLabelCountBeforeOption = /**
       * Calculates the amount of option group labels that precede the specified option.
       * Useful when positioning the panel, because the labels will offset the index of the
       * currently-selected option.
       * @param {?} optionIndex
       * @return {?}
       */
          function (optionIndex) {
              if (this.optionGroups.length) {
                  /** @type {?} */
                  var options = this.options.toArray();
                  /** @type {?} */
                  var groups = this.optionGroups.toArray();
                  /** @type {?} */
                  var groupCounter = 0;
                  for (var i = 0; i < optionIndex + 1; i++) {
                      if (options[i].group && options[i].group === groups[groupCounter]) {
                          groupCounter++;
                      }
                  }
                  return groupCounter;
              }
              return 0;
          };
      Md2Select.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-select',
                      template: "<div class=\"md2-select-trigger\" cdk-overlay-origin (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger>\n  <span class=\"md2-select-placeholder\"\n        [class.md2-floating-placeholder]=\"_selectionModel.hasValue()\"\n        [@transformPlaceholder]=\"_getPlaceholderAnimationState()\"\n        [style.opacity]=\"_getPlaceholderOpacity()\"\n        [style.width.px]=\"_selectedValueWidth\">{{ placeholder }}</span>\n  <span class=\"md2-select-value\" *ngIf=\"_selectionModel.hasValue()\">\n    <span class=\"md2-select-value-text\">{{ triggerValue }}</span>\n  </span>\n  <span class=\"md2-select-arrow\"></span>\n  <span class=\"md2-select-underline\"></span>\n</div>\n<ng-template cdk-connected-overlay [origin]=\"origin\" [open]=\"panelOpen\" hasBackdrop (backdropClick)=\"close()\"\n             backdropClass=\"cdk-overlay-transparent-backdrop\" [positions]=\"_positions\" [minWidth]=\"_triggerWidth\"\n             [offsetY]=\"_offsetY\" (attach)=\"_onAttached()\" (detach)=\"close()\">\n  <div class=\"md2-select-panel\" [@transformPanel]=\"'showing'\" (@transformPanel.done)=\"_onPanelDone()\"\n       (keydown)=\"_keyManager.onKeydown($event)\" [style.transformOrigin]=\"_transformOrigin\"\n       [class.md2-select-panel-done-animating]=\"_panelDoneAnimating\">\n    <div class=\"md2-select-content\" [@fadeInContent]=\"'showing'\" (@fadeInContent.done)=\"_onFadeInDone()\">\n      <ng-content select=\"md2-select-header\"></ng-content>\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                      encapsulation: core.ViewEncapsulation.None,
                      host: {
                          'role': 'listbox',
                          '[attr.tabindex]': 'tabIndex',
                          '[attr.aria-label]': '_ariaLabel',
                          '[attr.aria-labelledby]': 'ariaLabelledby',
                          '[attr.aria-required]': 'required.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-invalid]': '_control?.invalid || "false"',
                          '[attr.aria-owns]': '_optionIds',
                          '[class.md2-select-disabled]': 'disabled',
                          '[class.md2-select]': 'true',
                          '(keydown)': '_handleClosedKeydown($event)',
                          '(blur)': '_onBlur()',
                      },
                      animations: [
                          transformPlaceholder,
                          transformPanel,
                          fadeInContent
                      ],
                      exportAs: 'md2Select',
                      styles: [".md2-select{display:inline-block;outline:0}.md2-select-trigger{color:rgba(0,0,0,.38);display:flex;align-items:center;height:30px;min-width:112px;cursor:pointer;position:relative;box-sizing:border-box;font-size:16px}[aria-disabled=true] .md2-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.md2-select:focus:not(.md2-select-disabled) .md2-select-trigger{color:#106cc8}.md2-select.ng-invalid.ng-touched:not(.md2-select-disabled) .md2-select-trigger{color:#f44336}.md2-select-underline{position:absolute;bottom:0;left:0;right:0;height:1px;background-color:rgba(0,0,0,.12)}[aria-disabled=true] .md2-select-underline{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-color:transparent;background-position:0 bottom}.md2-select:focus:not(.md2-select-disabled) .md2-select-underline{background-color:#106cc8}.md2-select.ng-invalid.ng-touched:not(.md2-select-disabled) .md2-select-underline{background-color:#f44336}.md2-select-placeholder{position:relative;padding:0 2px;-webkit-transform-origin:left top;transform-origin:left top;flex-grow:1}.md2-select-placeholder.md2-floating-placeholder{top:-22px;left:-2px;text-align:left;-webkit-transform:scale(.75);transform:scale(.75)}[dir=rtl] .md2-select-placeholder{-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .md2-select-placeholder.md2-floating-placeholder{left:2px;text-align:right}[aria-required=true] .md2-select-placeholder::after{content:'*'}.md2-select-value{position:absolute;max-width:calc(100% - 18px);flex-grow:1;top:0;left:0;bottom:0;display:flex;align-items:center;color:rgba(0,0,0,.87)}[dir=rtl] .md2-select-value{left:auto;right:0}.md2-select-disabled .md2-select-value{color:rgba(0,0,0,.38)}.md2-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;line-height:30px}.md2-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.md2-select-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%}@media screen and (-ms-high-contrast:active){.md2-select-panel{outline:solid 1px}}.md2-select-content,.md2-select-panel-done-animating{background:#fff}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-transparent-backdrop{background:0 0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Select.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.Renderer2 },
              { type: ViewportRuler },
              { type: core.ChangeDetectorRef },
              { type: Dir, decorators: [{ type: core.Optional }] },
              { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
          ];
      };
      Md2Select.propDecorators = {
          trigger: [{ type: core.ViewChild, args: ['trigger',] }],
          overlayDir: [{ type: core.ViewChild, args: [ConnectedOverlayDirective,] }],
          options: [{ type: core.ContentChildren, args: [Md2Option, { descendants: true },] }],
          optionGroups: [{ type: core.ContentChildren, args: [Md2Optgroup,] }],
          placeholder: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          required: [{ type: core.Input }],
          multiple: [{ type: core.Input }],
          floatPlaceholder: [{ type: core.Input }],
          tabIndex: [{ type: core.Input }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          onOpen: [{ type: core.Output }],
          onClose: [{ type: core.Output }],
          change: [{ type: core.Output }]
      };
      return Md2Select;
  }());
  /**
   * Clamps a value n between min and max values.
   * @param {?} min
   * @param {?} n
   * @param {?} max
   * @return {?}
   */
  function clampValue(min, n, max) {
      return Math.min(Math.max(min, n), max);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Fixed header that will be rendered above a select's options.
   */
  var Md2SelectHeader = /** @class */ (function () {
      function Md2SelectHeader() {
      }
      Md2SelectHeader.decorators = [
          { type: core.Directive, args: [{
                      selector: 'md2-select-header',
                      host: {
                          'class': 'md2-select-header',
                      }
                  },] }
      ];
      return Md2SelectHeader;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2SelectModule = /** @class */ (function () {
      function Md2SelectModule() {
      }
      Md2SelectModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          OverlayModule,
                          Md2OptionModule,
                          MdCommonModule,
                      ],
                      exports: [Md2Select, Md2SelectHeader, Md2OptionModule, MdCommonModule],
                      declarations: [Md2Select, Md2SelectHeader],
                  },] }
      ];
      return Md2SelectModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2PaginationChange = /** @class */ (function () {
      function Md2PaginationChange() {
      }
      return Md2PaginationChange;
  }());
  var Md2DataTable = /** @class */ (function () {
      function Md2DataTable(differs) {
          this.differs = differs;
          this.isDataChanged = false;
          this._data = [];
          this._activePage = 1;
          this._rowsPerPage = 1000;
          this._sortBy = '';
          this._sortOrder = 'asc';
          this.activePageChange = new core.EventEmitter();
          this.rowsPerPageChange = new core.EventEmitter();
          this.sortByChange = new core.EventEmitter();
          this.sortOrderChange = new core.EventEmitter();
          this.onSortChange = new core.EventEmitter();
          this.onPageChange = new core.EventEmitter();
          this.diff = differs.find([]).create(null);
      }
      Object.defineProperty(Md2DataTable.prototype, "md2Data", {
          get: /**
           * @return {?}
           */ function () { return this._data; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._data !== value) {
                  this._data = value || [];
                  this.recalculatePage();
                  this.isDataChanged = true;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2DataTable.prototype, "activePage", {
          get: /**
           * @return {?}
           */ function () { return this._activePage; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._activePage !== value) {
                  this._activePage = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2DataTable.prototype, "rowsPerPage", {
          get: /**
           * @return {?}
           */ function () { return this._rowsPerPage; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._rowsPerPage !== value) {
                  this._rowsPerPage = value;
                  this.setPage(this.activePage, value);
                  this.isDataChanged = true;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2DataTable.prototype, "sortBy", {
          get: /**
           * @return {?}
           */ function () { return this._sortBy; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._sortBy !== value) {
                  this._sortBy = value;
                  if (value) {
                      this.onSortChange.next({ sortBy: this.sortBy, sortOrder: this.sortOrder });
                  }
                  this.isDataChanged = true;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2DataTable.prototype, "sortOrder", {
          get: /**
           * @return {?}
           */ function () { return this._sortOrder; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (!(value === 'asc' || value === 'desc')) {
                  console.warn('sortOrder value must be one of ["asc", "desc"], but is:', value);
                  value = 'asc';
              }
              if (this._sortOrder !== value) {
                  this._sortOrder = value;
                  this.isDataChanged = true;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2DataTable.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var changes = this.diff.diff(this.md2Data);
              if (changes) {
                  this.recalculatePage();
                  this.isDataChanged = true;
              }
              if (this.isDataChanged) {
                  this.fillData();
                  this.diff.diff(this.md2Data);
                  this.isDataChanged = false;
              }
          };
      /**
       * @return {?}
       */
      Md2DataTable.prototype.getSort = /**
       * @return {?}
       */
          function () {
              return { sortBy: this.sortBy, sortOrder: this.sortOrder };
          };
      /**
       * @param {?} sortBy
       * @param {?} sortOrder
       * @return {?}
       */
      Md2DataTable.prototype.setSort = /**
       * @param {?} sortBy
       * @param {?} sortOrder
       * @return {?}
       */
          function (sortBy, sortOrder) {
              if (this.sortBy !== sortBy || this.sortOrder !== sortOrder) {
                  this.sortBy = sortBy;
                  this.sortOrder = sortOrder;
                  this.isDataChanged = true;
                  this.onSortChange.next({ sortBy: sortBy, sortOrder: sortOrder });
                  this.sortByChange.emit(this.sortBy);
                  this.sortOrderChange.emit(this.sortOrder);
              }
          };
      /**
       * @return {?}
       */
      Md2DataTable.prototype.getPage = /**
       * @return {?}
       */
          function () {
              return {
                  activePage: this.activePage,
                  rowsPerPage: this.rowsPerPage,
                  dataLength: this.md2Data.length
              };
          };
      /**
       * @param {?} activePage
       * @param {?} rowsPerPage
       * @return {?}
       */
      Md2DataTable.prototype.setPage = /**
       * @param {?} activePage
       * @param {?} rowsPerPage
       * @return {?}
       */
          function (activePage, rowsPerPage) {
              if (this.rowsPerPage !== rowsPerPage || this.activePage !== activePage) {
                  this.activePage = this.activePage !== activePage ?
                      activePage : this.calculateNewActivePage(this.rowsPerPage, rowsPerPage);
                  if (this.rowsPerPage !== rowsPerPage) {
                      this._rowsPerPage = rowsPerPage;
                      this.rowsPerPageChange.emit(this.rowsPerPage);
                  }
                  this.isDataChanged = true;
                  this.onPageChange.emit({
                      activePage: this.activePage,
                      rowsPerPage: this.rowsPerPage,
                      dataLength: this.md2Data ? this.md2Data.length : 0
                  });
                  this.activePageChange.emit(this.activePage);
              }
          };
      /**
       * @param {?} previousRowsPerPage
       * @param {?} currentRowsPerPage
       * @return {?}
       */
      Md2DataTable.prototype.calculateNewActivePage = /**
       * @param {?} previousRowsPerPage
       * @param {?} currentRowsPerPage
       * @return {?}
       */
          function (previousRowsPerPage, currentRowsPerPage) {
              /** @type {?} */
              var firstRowOnPage = (this.activePage - 1) * previousRowsPerPage + 1;
              /** @type {?} */
              var newActivePage = Math.ceil(firstRowOnPage / currentRowsPerPage);
              return newActivePage;
          };
      /**
       * @return {?}
       */
      Md2DataTable.prototype.recalculatePage = /**
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var lastPage = Math.ceil(this.md2Data.length / this.rowsPerPage);
              if (lastPage < this.activePage) {
                  this._activePage = lastPage || 1;
                  setTimeout(function () {
                      _this.activePageChange.emit(_this.activePage);
                  }, 10);
              }
              this.onPageChange.emit({
                  activePage: this.activePage,
                  rowsPerPage: this.rowsPerPage,
                  dataLength: this.md2Data.length
              });
          };
      /**
       * @return {?}
       */
      Md2DataTable.prototype.fillData = /**
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var offset = (this.activePage - 1) * this.rowsPerPage;
              /** @type {?} */
              var data = this.md2Data;
              /** @type {?} */
              var sortInt = this.sortOrder === 'desc' ? -1 : 1;
              if (this.sortBy) {
                  data = data.sort(function (a, b) {
                      /** @type {?} */
                      var x = _this.caseInsensitiveIteratee(a);
                      /** @type {?} */
                      var y = _this.caseInsensitiveIteratee(b);
                      return ((x > y) ? 1 : (y > x) ? -1 : 0) * sortInt;
                  });
              }
              this.data = data.slice(offset, offset + this.rowsPerPage);
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2DataTable.prototype.caseInsensitiveIteratee = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var e_1, _a;
              if (typeof this.sortBy === 'string' || this.sortBy instanceof String) {
                  try {
                      for (var _b = __values(this.sortBy.split('.')), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var sortByProperty = _c.value;
                          value = value[sortByProperty];
                      }
                  }
                  catch (e_1_1) {
                      e_1 = { error: e_1_1 };
                  }
                  finally {
                      try {
                          if (_c && !_c.done && (_a = _b.return))
                              _a.call(_b);
                      }
                      finally {
                          if (e_1)
                              throw e_1.error;
                      }
                  }
              }
              else {
                  value = value[this.sortBy + ''];
              }
              if (value && typeof value === 'string' || value instanceof String) {
                  return value.toLowerCase();
              }
              return value;
          };
      Md2DataTable.decorators = [
          { type: core.Directive, args: [{
                      selector: 'table[md2Data]',
                      exportAs: 'md2DataTable'
                  },] }
      ];
      /** @nocollapse */
      Md2DataTable.ctorParameters = function () {
          return [
              { type: core.IterableDiffers }
          ];
      };
      Md2DataTable.propDecorators = {
          md2Data: [{ type: core.Input }],
          activePage: [{ type: core.Input }],
          rowsPerPage: [{ type: core.Input }],
          sortBy: [{ type: core.Input }],
          sortOrder: [{ type: core.Input }],
          activePageChange: [{ type: core.Output }],
          rowsPerPageChange: [{ type: core.Output }],
          sortByChange: [{ type: core.Output }],
          sortOrderChange: [{ type: core.Output }]
      };
      return Md2DataTable;
  }());
  var Md2DataTableSortBy = /** @class */ (function () {
      function Md2DataTableSortBy(_md2Table) {
          this._md2Table = _md2Table;
          this._isAsc = false;
          this._isDesc = false;
      }
      /**
       * @return {?}
       */
      Md2DataTableSortBy.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._md2Table.onSortChange.subscribe(function (event) {
                  _this._isAsc = (event.sortBy === _this.md2SortBy && event.sortOrder === 'asc');
                  _this._isDesc = (event.sortBy === _this.md2SortBy && event.sortOrder === 'desc');
              });
          };
      /**
       * @return {?}
       */
      Md2DataTableSortBy.prototype._sort = /**
       * @return {?}
       */
          function () {
              if (this._isAsc) {
                  this._md2Table.setSort(this.md2SortBy, 'desc');
              }
              else {
                  this._md2Table.setSort(this.md2SortBy, 'asc');
              }
          };
      Md2DataTableSortBy.decorators = [
          { type: core.Component, args: [{
                      selector: '[md2SortBy]',
                      template: "<ng-content></ng-content>\n&nbsp;\n<svg *ngIf=\"!_isDesc\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n  <path d=\"M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z\" />\n</svg>\n<svg *ngIf=\"_isDesc\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n  <path d=\"M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z\" />\n</svg>\n",
                      host: {
                          '[class.md2-sort-active]': '_isAsc || _isDesc',
                          '(click)': '_sort()'
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["[md2SortBy]{line-height:24px;color:rgba(0,0,0,.54);white-space:nowrap;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[md2SortBy] svg{display:inline-block;vertical-align:middle;fill:currentColor;opacity:0}[md2SortBy]:hover:not(.md2-sort-active) svg{color:rgba(0,0,0,.26);opacity:1}[md2SortBy].md2-sort-active{color:rgba(0,0,0,.87)}[md2SortBy].md2-sort-active svg{opacity:1}md2-pagination{display:block;color:rgba(0,0,0,.54);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}md2-pagination::after,md2-pagination::before{display:table;content:''}md2-pagination::after{clear:both}md2-pagination .md2-pagination{display:inline-block;margin:8px 0;padding:0}md2-pagination .md2-pagination li{position:relative;display:inline-block;width:36px;vertical-align:top;text-align:center;line-height:36px;border-radius:100px;cursor:pointer;box-sizing:border-box}md2-pagination .md2-pagination li:hover:not(.disabled):not(.active){background:rgba(0,0,0,.12)}md2-pagination .md2-pagination li.disabled{pointer-events:none;background:0 0;cursor:default;opacity:.48}md2-pagination .md2-pagination li.active{background:#106cc8;color:#fff;cursor:default}md2-pagination .md2-pagination li svg{fill:currentColor;margin-bottom:-7px}md2-pagination .md2-rows-select{display:inline-block;margin:8px 0;padding:0;float:right;color:rgba(0,0,0,.54);line-height:36px}md2-pagination .md2-rows-select label{vertical-align:sub;margin-right:10px}md2-pagination .md2-rows-select md2-select{display:inline-block;border:0;outline:0}md2-pagination .md2-rows-select .md2-select-trigger{border-width:0;min-width:40px}"]
                  }] }
      ];
      /** @nocollapse */
      Md2DataTableSortBy.ctorParameters = function () {
          return [
              { type: Md2DataTable }
          ];
      };
      Md2DataTableSortBy.propDecorators = {
          md2SortBy: [{ type: core.Input }]
      };
      return Md2DataTableSortBy;
  }());
  var Md2Pagination = /** @class */ (function () {
      function Md2Pagination(_dataTable) {
          var _this = this;
          this._dataTable = _dataTable;
          this._activePage = 1;
          this.rowsPerPageSet = [];
          this.paginationLabel = 'Rows per page:';
          this._dataLength = 0;
          this.onPageChangeSubscriber = function (event) {
              _this._activePage = event.activePage;
              _this._rowsPerPage = event.rowsPerPage;
              _this._dataLength = event.dataLength;
              _this._lastPage = Math.ceil(_this._dataLength / _this._rowsPerPage);
          };
      }
      /**
       * @return {?}
       */
      Md2Pagination.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              this.md2Table = this.md2Table || this._dataTable;
              this.onPageChangeSubscriber(this.md2Table.getPage());
              this.md2Table.onPageChange.subscribe(this.onPageChangeSubscriber);
          };
      /**
       * @param {?} pageNumber
       * @return {?}
       */
      Md2Pagination.prototype._setPage = /**
       * @param {?} pageNumber
       * @return {?}
       */
          function (pageNumber) {
              this.md2Table.setPage(pageNumber, this._rowsPerPage);
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Pagination.prototype._setRows = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this.md2Table.setPage(this._activePage, parseInt(event.value));
          };
      Md2Pagination.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-pagination',
                      template: "<ul class=\"md2-pagination\" *ngIf=\"_dataLength > _rowsPerPage\">\n  <li [class.disabled]=\"_activePage <= 1\" (click)=\"_setPage(_activePage - 1)\">\n    <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\n    </svg>\n  </li>\n  <li *ngIf=\"_activePage > 4 && _activePage + 1 > _lastPage\" (click)=\"_setPage(_activePage - 4)\">\n    {{_activePage-4}}\n  </li>\n  <li *ngIf=\"_activePage > 3 && _activePage + 2 > _lastPage\" (click)=\"_setPage(_activePage - 3)\">\n    {{_activePage-3}}\n  </li>\n  <li *ngIf=\"_activePage > 2\" (click)=\"_setPage(_activePage - 2)\">\n    {{_activePage-2}}\n  </li>\n  <li *ngIf=\"_activePage > 1\" (click)=\"_setPage(_activePage - 1)\">\n    {{_activePage-1}}\n  </li>\n  <li class=\"active\">{{_activePage}}</li>\n  <li *ngIf=\"_activePage + 1 <= _lastPage\" (click)=\"_setPage(_activePage + 1)\">\n    {{_activePage+1}}\n  </li>\n  <li *ngIf=\"_activePage + 2 <= _lastPage\" (click)=\"_setPage(_activePage + 2)\">\n    {{_activePage+2}}\n  </li>\n  <li *ngIf=\"_activePage + 3 <= _lastPage && _activePage < 3\" (click)=\"_setPage(_activePage + 3)\">\n    {{_activePage+3}}\n  </li>\n  <li *ngIf=\"_activePage + 4 <= _lastPage && _activePage < 2\" (click)=\"_setPage(_activePage + 4)\">\n    {{_activePage+4}}\n  </li>\n  <li [class.disabled]=\"_activePage >= _lastPage\" (click)=\"_setPage(_activePage + 1)\">\n    <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\n    </svg>\n  </li>\n</ul>\n<div class=\"md2-rows-select\" *ngIf=\"rowsPerPageSet.length && _dataLength > 0\">\n  <label>{{paginationLabel}}</label>\n  <md2-select [(ngModel)]=\"_rowsPerPage\" (change)=\"_setRows($event)\">\n    <md2-option *ngFor=\"let row of rowsPerPageSet\" [value]=\"row\">{{row}}</md2-option>\n  </md2-select>\n</div>\n",
                      exportAs: 'md2Pagination',
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["[md2SortBy]{line-height:24px;color:rgba(0,0,0,.54);white-space:nowrap;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[md2SortBy] svg{display:inline-block;vertical-align:middle;fill:currentColor;opacity:0}[md2SortBy]:hover:not(.md2-sort-active) svg{color:rgba(0,0,0,.26);opacity:1}[md2SortBy].md2-sort-active{color:rgba(0,0,0,.87)}[md2SortBy].md2-sort-active svg{opacity:1}md2-pagination{display:block;color:rgba(0,0,0,.54);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}md2-pagination::after,md2-pagination::before{display:table;content:''}md2-pagination::after{clear:both}md2-pagination .md2-pagination{display:inline-block;margin:8px 0;padding:0}md2-pagination .md2-pagination li{position:relative;display:inline-block;width:36px;vertical-align:top;text-align:center;line-height:36px;border-radius:100px;cursor:pointer;box-sizing:border-box}md2-pagination .md2-pagination li:hover:not(.disabled):not(.active){background:rgba(0,0,0,.12)}md2-pagination .md2-pagination li.disabled{pointer-events:none;background:0 0;cursor:default;opacity:.48}md2-pagination .md2-pagination li.active{background:#106cc8;color:#fff;cursor:default}md2-pagination .md2-pagination li svg{fill:currentColor;margin-bottom:-7px}md2-pagination .md2-rows-select{display:inline-block;margin:8px 0;padding:0;float:right;color:rgba(0,0,0,.54);line-height:36px}md2-pagination .md2-rows-select label{vertical-align:sub;margin-right:10px}md2-pagination .md2-rows-select md2-select{display:inline-block;border:0;outline:0}md2-pagination .md2-rows-select .md2-select-trigger{border-width:0;min-width:40px}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Pagination.ctorParameters = function () {
          return [
              { type: Md2DataTable, decorators: [{ type: core.Optional }] }
          ];
      };
      Md2Pagination.propDecorators = {
          rowsPerPageSet: [{ type: core.Input }],
          md2Table: [{ type: core.Input }],
          paginationLabel: [{ type: core.Input }]
      };
      return Md2Pagination;
  }());
  /** @type {?} */
  var MD2_DATA_TABLE_DIRECTIVES = [
      Md2DataTable,
      Md2DataTableSortBy,
      Md2Pagination
  ];
  var Md2DataTableModule = /** @class */ (function () {
      function Md2DataTableModule() {
      }
      Md2DataTableModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, forms.FormsModule, Md2SelectModule],
                      exports: MD2_DATA_TABLE_DIRECTIVES,
                      declarations: MD2_DATA_TABLE_DIRECTIVES,
                  },] }
      ];
      return Md2DataTableModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * The default month names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_MONTH_NAMES$1 = {
      'long': [
          'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
          'October', 'November', 'December'
      ],
      'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
  };
  var ɵ0$2 = function (i) { return String(i + 1); };
  /** *
   * The default date names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DATE_NAMES$1 = range$1(31, ɵ0$2);
  var ɵ1 = function (i) { return String(i); };
  /** *
   * The default hour names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_HOUR_NAMES = range$1(24, ɵ1);
  var ɵ2 = function (i) { return String(i); };
  /** *
   * The default minute names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_MINUTE_NAMES = range$1(60, ɵ2);
  /** *
   * The default day of the week names to use if Intl API is not available.
    @type {?} */
  var DEFAULT_DAY_OF_WEEK_NAMES$1 = {
      'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  };
  /**
   * Creates an array and fills it with values.
   * @template T
   * @param {?} length
   * @param {?} valueFunction
   * @return {?}
   */
  function range$1(length, valueFunction) {
      /** @type {?} */
      var valuesArray = Array(length);
      for (var i = 0; i < length; i++) {
          valuesArray[i] = valueFunction(i);
      }
      return valuesArray;
  }
  var DateLocale = /** @class */ (function () {
      function DateLocale() {
          this.firstDayOfWeek = 0;
      }
      /**
       * @param {?} date
       * @return {?}
       */
      DateLocale.prototype.getDayOfWeek = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDay();
          };
      /**
       * @param {?} style
       * @return {?}
       */
      DateLocale.prototype.getMonthNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              if (this.months) {
                  return this.months[style];
              }
              return DEFAULT_MONTH_NAMES$1[style];
          };
      /**
       * @return {?}
       */
      DateLocale.prototype.getDateNames = /**
       * @return {?}
       */
          function () {
              if (this.dates) {
                  return this.dates;
              }
              return DEFAULT_DATE_NAMES$1;
          };
      /**
       * @return {?}
       */
      DateLocale.prototype.getHourNames = /**
       * @return {?}
       */
          function () {
              if (this.hours) {
                  return this.hours;
              }
              return DEFAULT_HOUR_NAMES;
          };
      /**
       * @return {?}
       */
      DateLocale.prototype.getMinuteNames = /**
       * @return {?}
       */
          function () {
              if (this.minutes) {
                  return this.minutes;
              }
              return DEFAULT_MINUTE_NAMES;
          };
      /**
       * @param {?} style
       * @return {?}
       */
      DateLocale.prototype.getDayOfWeekNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              if (this.daysOfWeek) {
                  return this.daysOfWeek[style];
              }
              return DEFAULT_DAY_OF_WEEK_NAMES$1[style];
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateLocale.prototype.getYearName = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return String(date.getFullYear());
          };
      /**
       * @return {?}
       */
      DateLocale.prototype.getFirstDayOfWeek = /**
       * @return {?}
       */
          function () {
              // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
              return this.firstDayOfWeek;
          };
      /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
      DateLocale.prototype.format = /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
          function (date, displayFormat) {
              return this._stripDirectionalityCharacters(date.toDateString());
          };
      /**
       * @param {?} d
       * @return {?}
       */
      DateLocale.prototype.getDateLabel = /**
       * @param {?} d
       * @return {?}
       */
          function (d) {
              /** @type {?} */
              var day = this.getDayOfWeekNames('short')[d.getDay()];
              /** @type {?} */
              var date = this.getDateNames()[d.getDate() - 1];
              /** @type {?} */
              var month = this.getMonthNames('short')[d.getMonth()];
              return day + ", " + month + " " + date;
          };
      /**
       * @param {?} d
       * @return {?}
       */
      DateLocale.prototype.getHoursLabel = /**
       * @param {?} d
       * @return {?}
       */
          function (d) { return "" + this.getHourNames()[d.getHours()]; };
      /**
       * @param {?} d
       * @return {?}
       */
      DateLocale.prototype.getMinutesLabel = /**
       * @param {?} d
       * @return {?}
       */
          function (d) { return "" + this.getMinuteNames()[d.getMinutes()]; };
      /**
       * @param {?} d
       * @return {?}
       */
      DateLocale.prototype.getMonthLabel = /**
       * @param {?} d
       * @return {?}
       */
          function (d) {
              return this.getMonthNames('long')[d.getMonth()] + " " + this.getYearName(d);
          };
      /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} s The string to strip direction characters from.
       * @return {?} The stripped string.
       */
      DateLocale.prototype._stripDirectionalityCharacters = /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param {?} s The string to strip direction characters from.
       * @return {?} The stripped string.
       */
          function (s) {
              return s.replace(/[\u200e\u200f]/g, '');
          };
      DateLocale.decorators = [
          { type: core.Injectable }
      ];
      return DateLocale;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var DateUtil = /** @class */ (function () {
      function DateUtil() {
          this._locale = new DateLocale();
          this.parseDateMap = {
              'y': 0,
              // placeholder -> ctorIndex
              'Y': [0, -2000],
              'M': [1, 1],
              // placeholder -> [ctorIndex, offset|value array]
              'n': [1, this._locale.getMonthNames('short')],
              'N': [1, this._locale.getMonthNames('long')],
              'd': 2,
              'm': 4,
              'H': 3,
              'h': 3,
              'K': [3, 1],
              'k': [3, 1],
              's': 5,
              'S': 6,
              'a': [3, ['am', 'pm']],
              'A': [3, ['AM', 'PM']]
          };
      }
      /**
       * @param {?} s
       * @param {?} regexp
       * @param {?=} sub
       * @return {?}
       */
      DateUtil.prototype.replace = /**
       * @param {?} s
       * @param {?} regexp
       * @param {?=} sub
       * @return {?}
       */
          function (s, regexp, sub) {
              return (s != null ? '' + s : '').replace(regexp, sub != null ? sub : '');
          };
      /**
       * @param {?} base
       * @param {?} start
       * @return {?}
       */
      DateUtil.prototype.startsWith = /**
       * @param {?} base
       * @param {?} start
       * @return {?}
       */
          function (base, start) {
              return start != null && base.substr(0, start.length) == start;
          };
      /**
       * @param {?} s
       * @param {?} o
       * @return {?}
       */
      DateUtil.prototype.isType = /**
       * @param {?} s
       * @param {?} o
       * @return {?}
       */
          function (s, o) {
              return typeof s == o;
          };
      /**
       * @param {?} f
       * @return {?}
       */
      DateUtil.prototype.isFunction = /**
       * @param {?} f
       * @return {?}
       */
          function (f) {
              return this.isType(f, 'function');
          };
      /**
       * @param {?} v
       * @return {?}
       */
      DateUtil.prototype.isList = /**
       * @param {?} v
       * @return {?}
       */
          function (v) {
              return !!v && v.length != null && !this.isString(v) && !this.isNode(v) && !this.isFunction(v);
          };
      /**
       * @param {?} s
       * @return {?}
       */
      DateUtil.prototype.isString = /**
       * @param {?} s
       * @return {?}
       */
          function (s) {
              return this.isType(s, 'string');
          };
      /**
       * @param {?} f
       * @return {?}
       */
      DateUtil.prototype.isObject = /**
       * @param {?} f
       * @return {?}
       */
          function (f) {
              return !!f && this.isType(f, 'object');
          };
      /**
       * @param {?} n
       * @return {?}
       */
      DateUtil.prototype.isNode = /**
       * @param {?} n
       * @return {?}
       */
          function (n) {
              return n && n['nodeType'];
          };
      /**
       * @param {?} n
       * @return {?}
       */
      DateUtil.prototype.isNumber = /**
       * @param {?} n
       * @return {?}
       */
          function (n) {
              return this.isType(n, 'number');
          };
      /**
       * @param {?} findFunc
       * @return {?}
       */
      DateUtil.prototype.getFindFunc = /**
       * @param {?} findFunc
       * @return {?}
       */
          function (findFunc) {
              return this.isFunction(findFunc) ? findFunc : function (obj, index) {
                  if (findFunc === obj) {
                      return index;
                  }
              };
          };
      /**
       * @param {?} list
       * @param {?} index
       * @param {?} defaultIndex
       * @return {?}
       */
      DateUtil.prototype.getFindIndex = /**
       * @param {?} list
       * @param {?} index
       * @param {?} defaultIndex
       * @return {?}
       */
          function (list, index, defaultIndex) {
              return index == null ? defaultIndex :
                  index < 0 ? Math.max(list.length + index, 0) : Math.min(list.length, index);
          };
      /**
       * @param {?} list
       * @param {?} findFunc
       * @param {?=} startIndex
       * @param {?=} endIndex
       * @return {?}
       */
      DateUtil.prototype.find = /**
       * @param {?} list
       * @param {?} findFunc
       * @param {?=} startIndex
       * @param {?=} endIndex
       * @return {?}
       */
          function (list, findFunc, startIndex, endIndex) {
              /** @type {?} */
              var f = this.getFindFunc(findFunc);
              /** @type {?} */
              var e = this.getFindIndex(list, endIndex, list.length);
              /** @type {?} */
              var r;
              for (var i = this.getFindIndex(list, startIndex, 0); i < e; i++) {
                  if ((r = f.call(list, list[i], i)) != null) {
                      return r;
                  }
              }
          };
      /**
       * @param {?} date
       * @param {?} fmt
       * @return {?}
       */
      DateUtil.prototype.parseDate = /**
       * @param {?} date
       * @param {?} fmt
       * @return {?}
       */
          function (date, fmt) {
              var _this = this;
              /** @type {?} */
              var indexMap = {};
              /** @type {?} */
              var reIndex = 1;
              /** @type {?} */
              var match;
              /** @type {?} */
              var format = this.replace(fmt, /^\?/);
              if (format != fmt && !this.replace(date, /^\s+|\s+$/g)) {
                  return null;
              }
              if (match = /^\[([+-])(\d\d)(\d\d)\]\s*(.*)/.exec(format)) {
                  format = match[4];
              }
              /** @type {?} */
              var parser = new RegExp(format.replace(/(.)(\1*)(?:\[([^\]]*)\])?/g, function (wholeMatch, placeholderChar, placeholderDigits, param) {
                  if (/[dmhkyhs]/i.test(placeholderChar)) {
                      indexMap[reIndex++] = placeholderChar;
                      /** @type {?} */
                      var plen = placeholderDigits.length + 1;
                      return '(\\d' + (plen < 2 ? '+' : ('{1,' + plen + '}')) + ')';
                  }
                  else if (placeholderChar == 'z') {
                      reIndex += 3;
                      return '([+-])(\\d\\d)(\\d\\d)';
                  }
                  else if (/[NnaA]/.test(placeholderChar)) {
                      indexMap[reIndex++] = [placeholderChar, param && param.split(',')];
                      return '([a-zA-Z\\u0080-\\u1fff]+)';
                  }
                  else if (/w/i.test(placeholderChar)) {
                      return '[a-zA-Z\\u0080-\\u1fff]+';
                  }
                  else if (/\s/.test(placeholderChar)) {
                      return '\\s+';
                  }
                  else {
                      return _this.replace(wholeMatch, /[\\\[\]\/{}()*+?.$|^-]/g, '\\$&');
                  }
              }));
              if (!(match = parser.exec(date))) {
                  return undefined;
              }
              /** @type {?} */
              var ctorArgs = [0, 0, 0, 0, 0, 0, 0];
              var _loop_1 = function (i) {
                  /** @type {?} */
                  var matchVal = match[i];
                  /** @type {?} */
                  var indexEntry = indexMap[i];
                  if (this_1.isList(indexEntry)) { // for a, n or N
                      /** @type {?} */
                      var placeholderChar = indexEntry[0];
                      /** @type {?} */
                      var mapEntry = this_1.parseDateMap[placeholderChar];
                      /** @type {?} */
                      var ctorIndex = mapEntry[0];
                      /** @type {?} */
                      var valList = indexEntry[1] || mapEntry[1];
                      /** @type {?} */
                      var listValue = this_1.find(valList, function (v, index) {
                          if (_this.startsWith(matchVal.toLowerCase(), v.toLowerCase())) {
                              return index;
                          }
                      });
                      if (listValue == null) {
                          return { value: undefined };
                      }
                      if (placeholderChar == 'a' || placeholderChar == 'A') {
                          ctorArgs[ctorIndex] += listValue * 12;
                      }
                      else {
                          ctorArgs[ctorIndex] = listValue;
                      }
                  }
                  else if (indexEntry) { // for numeric values (yHmMs)
                      /** @type {?} */
                      var value = parseFloat(matchVal);
                      /** @type {?} */
                      var mapEntry = this_1.parseDateMap[indexEntry];
                      if (this_1.isList(mapEntry)) {
                          ctorArgs[mapEntry[0]] += value - mapEntry[1];
                      }
                      else {
                          ctorArgs[mapEntry] += value;
                      }
                  }
              };
              var this_1 = this;
              for (var i = 1; i < reIndex; i++) {
                  var state_1 = _loop_1(i);
                  if (typeof state_1 === "object")
                      return state_1.value;
              }
              /** @type {?} */
              var d = new Date(ctorArgs[0], ctorArgs[1], ctorArgs[2], ctorArgs[3], ctorArgs[4], ctorArgs[5], ctorArgs[6]);
              return d;
          };
      /**
       * @return {?}
       */
      DateUtil.prototype.today = /**
       * @return {?}
       */
          function () {
              return new Date();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      DateUtil.prototype.parse = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var timestamp = typeof value == 'number' ? value : Date.parse(value);
              return isNaN(timestamp) ? null : new Date(timestamp);
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getYear = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getFullYear();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getMonth();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getDate = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDate();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getHours = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getHours();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getMinutes = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getMinutes();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getSeconds = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getSeconds();
          };
      /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @param {?} hours
       * @param {?} minutes
       * @param {?} seconds
       * @return {?}
       */
      DateUtil.prototype.createDate = /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @param {?} hours
       * @param {?} minutes
       * @param {?} seconds
       * @return {?}
       */
          function (year, month, date, hours, minutes, seconds) {
              // Check for invalid month and date (except upper bound on date which we have to check after
              // creating the Date).
              if (month < 0 || month > 11 || date < 1) {
                  return null;
              }
              /** @type {?} */
              var result = this._createDateWithOverflow(year, month, date, hours, minutes, seconds);
              // Check that the date wasn't above the upper bound for the month, causing the month to
              // overflow.
              if (result.getMonth() != month) {
                  return null;
              }
              return result;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.clone = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.createDate(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date), this.getMinutes(date), this.getSeconds(date));
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getNumDaysInMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0, 0, 0, 0));
          };
      /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
      DateUtil.prototype.addCalendarYears = /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
          function (date, years) {
              return this.addCalendarMonths(date, years * 12);
          };
      /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
      DateUtil.prototype.addCalendarMonths = /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
          function (date, months) {
              /** @type {?} */
              var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date), this.getHours(date), this.getMinutes(date), this.getSeconds(date));
              // It's possible to wind up in the wrong month if the original month has more days than the new
              // month. In this case we want to go to the last day of the desired month.
              // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
              // guarantee this.
              if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
                  newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0, this.getHours(newDate), this.getMinutes(newDate), this.getSeconds(newDate));
              }
              return newDate;
          };
      /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
      DateUtil.prototype.addCalendarDays = /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
          function (date, days) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days, this.getHours(date), this.getMinutes(date), this.getSeconds(date));
          };
      /**
       * @param {?} date
       * @param {?} hours
       * @return {?}
       */
      DateUtil.prototype.addCalendarHours = /**
       * @param {?} date
       * @param {?} hours
       * @return {?}
       */
          function (date, hours) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date) + hours, this.getMinutes(date), this.getSeconds(date));
          };
      /**
       * @param {?} date
       * @param {?} minutes
       * @return {?}
       */
      DateUtil.prototype.addCalendarMinutes = /**
       * @param {?} date
       * @param {?} minutes
       * @return {?}
       */
          function (date, minutes) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date), this.getHours(date), this.getMinutes(date) + minutes, this.getSeconds(date));
          };
      /**
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getISODateString = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return [
                  date.getUTCFullYear(),
                  this._2digit(date.getUTCMonth() + 1),
                  this._2digit(date.getUTCDate())
              ].join('-');
          };
      /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @param {?} hours
       * @param {?} minutes
       * @param {?} seconds
       * @return {?}
       */
      DateUtil.prototype._createDateWithOverflow = /**
       * Creates a date but allows the month and date to overflow.
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @param {?} hours
       * @param {?} minutes
       * @param {?} seconds
       * @return {?}
       */
          function (year, month, date, hours, minutes, seconds) {
              /** @type {?} */
              var result = new Date(year, month, date, hours, minutes, seconds);
              // We need to correct for the fact that JS native Date treats years in range [0, 99] as
              // abbreviations for 19xx.
              if (year >= 0 && year < 100) {
                  result.setFullYear(this.getYear(result) - 1900);
              }
              return result;
          };
      /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
      DateUtil.prototype._2digit = /**
       * Pads a number to make it two digits.
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
          function (n) {
              return ('00' + n).slice(-2);
          };
      /**
       * @param {?} first
       * @param {?} second
       * @return {?}
       */
      DateUtil.prototype.compareDate = /**
       * @param {?} first
       * @param {?} second
       * @return {?}
       */
          function (first, second) {
              return this.getYear(first) - this.getYear(second) ||
                  this.getMonth(first) - this.getMonth(second) ||
                  this.getDate(first) - this.getDate(second);
          };
      /**
       * Gets the first day of the month for the given date's month.
       */
      /**
       * Gets the first day of the month for the given date's month.
       * @param {?} date
       * @param {?} firstDayOfWeek
       * @return {?}
       */
      DateUtil.prototype.getFirstDateOfWeek = /**
       * Gets the first day of the month for the given date's month.
       * @param {?} date
       * @param {?} firstDayOfWeek
       * @return {?}
       */
          function (date, firstDayOfWeek) {
              /** @type {?} */
              var day = date.getDate() - ((7 + date.getDay() - firstDayOfWeek) % 7);
              return new Date(date.getFullYear(), date.getMonth(), day, date.getHours(), date.getMinutes());
          };
      /**
       * Gets the first day of the month for the given date's month.
       */
      /**
       * Gets the first day of the month for the given date's month.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getFirstDateOfMonth = /**
       * Gets the first day of the month for the given date's month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getFullYear(), date.getMonth(), 1);
          };
      /**
       * Gets the number of days in the month for the given date's month.
       */
      /**
       * Gets the number of days in the month for the given date's month.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getNumberOfDaysInMonth = /**
       * Gets the number of days in the month for the given date's month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
          };
      /**
       * Get an arbitrary date in the month after the given date's month.
       */
      /**
       * Get an arbitrary date in the month after the given date's month.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getDateInNextMonth = /**
       * Get an arbitrary date in the month after the given date's month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getFullYear(), date.getMonth() + 1, 1, date.getHours(), date.getMinutes());
          };
      /**
       * Get an arbitrary date in the month before the given date's month.
       */
      /**
       * Get an arbitrary date in the month before the given date's month.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getDateInPreviousMonth = /**
       * Get an arbitrary date in the month before the given date's month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getFullYear(), date.getMonth() - 1, 1, date.getHours(), date.getMinutes());
          };
      /**
       * Gets whether two dates have the same year.
       */
      /**
       * Gets whether two dates have the same year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.isSameYear = /**
       * Gets whether two dates have the same year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return d1 && d2 && d1.getFullYear() === d2.getFullYear();
          };
      /**
       * Gets whether two dates have the same month and year.
       */
      /**
       * Gets whether two dates have the same month and year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.isSameMonthAndYear = /**
       * Gets whether two dates have the same month and year.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return d1 && d2 && d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
          };
      /**
       * Gets whether two dates are the same day (not not necesarily the same time).
       */
      /**
       * Gets whether two dates are the same day (not not necesarily the same time).
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.isSameDay = /**
       * Gets whether two dates are the same day (not not necesarily the same time).
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return d1 && d2 && d1.getDate() == d2.getDate() && this.isSameMonthAndYear(d1, d2);
          };
      /**
       * Gets whether two dates are the same hours.
       */
      /**
       * Gets whether two dates are the same hours.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.isSameHour = /**
       * Gets whether two dates are the same hours.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return d1 && d2 && d1.getHours() == d2.getHours() && this.isSameDay(d1, d2);
          };
      /**
       * Gets whether two dates are the same minutes.
       */
      /**
       * Gets whether two dates are the same minutes.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.isSameMinute = /**
       * Gets whether two dates are the same minutes.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return d1 && d2 && d1.getMinutes() == d2.getMinutes() && this.isSameHour(d1, d2);
          };
      /**
       * Gets whether a date is in the month immediately after some date.
       * @param startDate The date from which to compare.
       * @param endDate The date to check.
       * @returns
       */
      /**
       * Gets whether a date is in the month immediately after some date.
       * @param {?} startDate The date from which to compare.
       * @param {?} endDate The date to check.
       * @return {?}
       */
      DateUtil.prototype.isInNextMonth = /**
       * Gets whether a date is in the month immediately after some date.
       * @param {?} startDate The date from which to compare.
       * @param {?} endDate The date to check.
       * @return {?}
       */
          function (startDate, endDate) {
              /** @type {?} */
              var nextMonth = this.getDateInNextMonth(startDate);
              return this.isSameMonthAndYear(nextMonth, endDate);
          };
      /**
       * Gets whether a date is in the month immediately before some date.
       * @param startDate The date from which to compare.
       * @param endDate The date to check.
       * @returns
       */
      /**
       * Gets whether a date is in the month immediately before some date.
       * @param {?} startDate The date from which to compare.
       * @param {?} endDate The date to check.
       * @return {?}
       */
      DateUtil.prototype.isInPreviousMonth = /**
       * Gets whether a date is in the month immediately before some date.
       * @param {?} startDate The date from which to compare.
       * @param {?} endDate The date to check.
       * @return {?}
       */
          function (startDate, endDate) {
              /** @type {?} */
              var previousMonth = this.getDateInPreviousMonth(startDate);
              return this.isSameMonthAndYear(endDate, previousMonth);
          };
      /**
       * Gets the midpoint between two dates.
       * @param d1
       * @param d2
       * @returns
       */
      /**
       * Gets the midpoint between two dates.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      DateUtil.prototype.getDateMidpoint = /**
       * Gets the midpoint between two dates.
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return this.createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
          };
      /**
       * Gets the week of the month that a given date occurs in.
       * @param date
       * @returns Index of the week of the month (zero-based).
       */
      /**
       * Gets the week of the month that a given date occurs in.
       * @param {?} date
       * @return {?} Index of the week of the month (zero-based).
       */
      DateUtil.prototype.getWeekOfMonth = /**
       * Gets the week of the month that a given date occurs in.
       * @param {?} date
       * @return {?} Index of the week of the month (zero-based).
       */
          function (date) {
              /** @type {?} */
              var firstDayOfMonth = this.getFirstDateOfMonth(date);
              return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
          };
      /**
       * Gets the week of the year that a given date occurs in.
       * @param date
       * @returns Index of the week according to ISO-8601.
       */
      /**
       * Gets the week of the year that a given date occurs in.
       * @param {?} date
       * @return {?} Index of the week according to ISO-8601.
       */
      DateUtil.prototype.getWeekOfYear = /**
       * Gets the week of the year that a given date occurs in.
       * @param {?} date
       * @return {?} Index of the week according to ISO-8601.
       */
          function (date) {
              /** @type {?} */
              var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
              // Set to nearest Thursday: current date + 4 - current day number
              // Make Sunday's day number 7
              d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
              /** @type {?} */
              var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
              // Calculate full weeks to nearest Thursday and return weekNo
              return Math.ceil((((+d - +yearStart) / 86400000) + 1) / 7);
          };
      /**
       * Gets a new date incremented by the given number of minutes. Number of minutes can be negative.
       * @param date
       * @param numberOfMinutes
       * @returns
       */
      /**
       * Gets a new date incremented by the given number of minutes. Number of minutes can be negative.
       * @param {?} date
       * @param {?} numberOfMinutes
       * @return {?}
       */
      DateUtil.prototype.incrementMinutes = /**
       * Gets a new date incremented by the given number of minutes. Number of minutes can be negative.
       * @param {?} date
       * @param {?} numberOfMinutes
       * @return {?}
       */
          function (date, numberOfMinutes) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes() + numberOfMinutes);
          };
      /**
       * Gets a new date incremented by the given number of hours. Number of hours can be negative.
       * @param date
       * @param numberOfHours
       * @returns
       */
      /**
       * Gets a new date incremented by the given number of hours. Number of hours can be negative.
       * @param {?} date
       * @param {?} numberOfHours
       * @return {?}
       */
      DateUtil.prototype.incrementHours = /**
       * Gets a new date incremented by the given number of hours. Number of hours can be negative.
       * @param {?} date
       * @param {?} numberOfHours
       * @return {?}
       */
          function (date, numberOfHours) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() + numberOfHours, date.getMinutes());
          };
      /**
       * Gets a new date incremented by the given number of days. Number of days can be negative.
       * @param date
       * @param numberOfDays
       * @returns
       */
      /**
       * Gets a new date incremented by the given number of days. Number of days can be negative.
       * @param {?} date
       * @param {?} numberOfDays
       * @return {?}
       */
      DateUtil.prototype.incrementDays = /**
       * Gets a new date incremented by the given number of days. Number of days can be negative.
       * @param {?} date
       * @param {?} numberOfDays
       * @return {?}
       */
          function (date, numberOfDays) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays, date.getHours(), date.getMinutes());
          };
      /**
       * Gets a new date incremented by the given number of months. Number of months can be negative.
       * If the date of the given month does not match the target month, the date will be set to the
       * last day of the month.
       * @param date
       * @param numberOfMonths
       * @returns
       */
      /**
       * Gets a new date incremented by the given number of months. Number of months can be negative.
       * If the date of the given month does not match the target month, the date will be set to the
       * last day of the month.
       * @param {?} date
       * @param {?} numberOfMonths
       * @return {?}
       */
      DateUtil.prototype.incrementMonths = /**
       * Gets a new date incremented by the given number of months. Number of months can be negative.
       * If the date of the given month does not match the target month, the date will be set to the
       * last day of the month.
       * @param {?} date
       * @param {?} numberOfMonths
       * @return {?}
       */
          function (date, numberOfMonths) {
              /** @type {?} */
              var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1, date.getHours(), date.getMinutes());
              /** @type {?} */
              var numberOfDaysInMonth = this.getNumberOfDaysInMonth(dateInTargetMonth);
              if (numberOfDaysInMonth < date.getDate()) {
                  dateInTargetMonth.setDate(numberOfDaysInMonth);
              }
              else {
                  dateInTargetMonth.setDate(date.getDate());
              }
              return dateInTargetMonth;
          };
      /**
       * Get the integer distance between two months. This *only* considers the month and year
       * portion of the Date instances.
       *
       * @param start
       * @param end
       * @returns Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
      /**
       * Get the integer distance between two months. This *only* considers the month and year
       * portion of the Date instances.
       *
       * @param {?} start
       * @param {?} end
       * @return {?} Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
      DateUtil.prototype.getMonthDistance = /**
       * Get the integer distance between two months. This *only* considers the month and year
       * portion of the Date instances.
       *
       * @param {?} start
       * @param {?} end
       * @return {?} Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
          function (start, end) {
              return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
          };
      /**
       * Gets the last day of the month for the given date.
       * @param date
       * @returns
       */
      /**
       * Gets the last day of the month for the given date.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.getLastDateOfMonth = /**
       * Gets the last day of the month for the given date.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getFullYear(), date.getMonth(), this.getNumberOfDaysInMonth(date), date.getHours(), date.getMinutes());
          };
      /**
       * Checks whether a date is valid.
       * @param date
       * @return  Whether the date is a valid Date.
       */
      /**
       * Checks whether a date is valid.
       * @param {?} date
       * @return {?} Whether the date is a valid Date.
       */
      DateUtil.prototype.isValidDate = /**
       * Checks whether a date is valid.
       * @param {?} date
       * @return {?} Whether the date is a valid Date.
       */
          function (date) {
              return date != null && date.getTime && !isNaN(date.getTime());
          };
      /**
       * Sets a date's time to midnight.
       * @param date
       */
      /**
       * Sets a date's time to midnight.
       * @param {?} date
       * @return {?}
       */
      DateUtil.prototype.setDateTimeToMidnight = /**
       * Sets a date's time to midnight.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this.isValidDate(date)) {
                  date.setHours(0, 0, 0, 0);
              }
          };
      /**
       * Creates a date with the time set to midnight.
       * Drop-in replacement for two forms of the Date constructor:
       * 1. No argument for Date representing now.
       * 2. Single-argument value representing number of seconds since Unix Epoch
       * or a Date object.
       * @param value
       * @return New date with time set to midnight.
       */
      /**
       * Creates a date with the time set to midnight.
       * Drop-in replacement for two forms of the Date constructor:
       * 1. No argument for Date representing now.
       * 2. Single-argument value representing number of seconds since Unix Epoch
       * or a Date object.
       * @param {?} value
       * @return {?} New date with time set to midnight.
       */
      DateUtil.prototype.createDateAtMidnight = /**
       * Creates a date with the time set to midnight.
       * Drop-in replacement for two forms of the Date constructor:
       * 1. No argument for Date representing now.
       * 2. Single-argument value representing number of seconds since Unix Epoch
       * or a Date object.
       * @param {?} value
       * @return {?} New date with time set to midnight.
       */
          function (value) {
              /** @type {?} */
              var date;
              if (!value) {
                  date = new Date();
              }
              else {
                  date = new Date(value);
              }
              this.setDateTimeToMidnight(date);
              return date;
          };
      /**
       * Checks if a date is within a min and max range, ignoring the time component.
       * If minDate or maxDate are not dates, they are ignored.
       * @param date
       * @param minDate
       * @param maxDate
       */
      /**
       * Checks if a date is within a min and max range, ignoring the time component.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
      DateUtil.prototype.isDateWithinRange = /**
       * Checks if a date is within a min and max range, ignoring the time component.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
          function (date, minDate, maxDate) {
              /** @type {?} */
              var dateAtMidnight = this.createDateAtMidnight(date);
              /** @type {?} */
              var minDateAtMidnight = this.isValidDate(minDate) ? this.createDateAtMidnight(minDate) : null;
              /** @type {?} */
              var maxDateAtMidnight = this.isValidDate(maxDate) ? this.createDateAtMidnight(maxDate) : null;
              return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) &&
                  (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
          };
      /**
       * Checks if a date is within a min and max range.
       * If minDate or maxDate are not dates, they are ignored.
       * @param date
       * @param minDate
       * @param maxDate
       */
      /**
       * Checks if a date is within a min and max range.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
      DateUtil.prototype.isFullDateWithinRange = /**
       * Checks if a date is within a min and max range.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
          function (date, minDate, maxDate) {
              minDate = this.isValidDate(minDate) ? minDate : null;
              maxDate = this.isValidDate(maxDate) ? maxDate : null;
              return (!minDate || minDate <= date) &&
                  (!maxDate || maxDate >= date);
          };
      /**
       * Gets a new date incremented by the given number of years. Number of years can be negative.
       * See `incrementMonths` for notes on overflow for specific dates.
       * @param date
       * @param numberOfYears
       * @returns
       */
      /**
       * Gets a new date incremented by the given number of years. Number of years can be negative.
       * See `incrementMonths` for notes on overflow for specific dates.
       * @param {?} date
       * @param {?} numberOfYears
       * @return {?}
       */
      DateUtil.prototype.incrementYears = /**
       * Gets a new date incremented by the given number of years. Number of years can be negative.
       * See `incrementMonths` for notes on overflow for specific dates.
       * @param {?} date
       * @param {?} numberOfYears
       * @return {?}
       */
          function (date, numberOfYears) {
              return this.incrementMonths(date, numberOfYears * 12);
          };
      /**
       * Get the integer distance between two years. This *only* considers the year portion of the
       * Date instances.
       *
       * @param start
       * @param end
       * @returns Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
      /**
       * Get the integer distance between two years. This *only* considers the year portion of the
       * Date instances.
       *
       * @param {?} start
       * @param {?} end
       * @return {?} Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
      DateUtil.prototype.getYearDistance = /**
       * Get the integer distance between two years. This *only* considers the year portion of the
       * Date instances.
       *
       * @param {?} start
       * @param {?} end
       * @return {?} Number of months between `start` and `end`. If `end` is before `start`
       *     chronologically, this number will be negative.
       */
          function (start, end) {
              return end.getFullYear() - start.getFullYear();
          };
      /**
       * Clamps a date between a minimum and a maximum date.
       * @param date Date to be clamped
       * @param minDate Minimum date
       * @param maxDate Maximum date
       * @return
       */
      /**
       * Clamps a date between a minimum and a maximum date.
       * @param {?} date Date to be clamped
       * @param {?} minDate Minimum date
       * @param {?} maxDate Maximum date
       * @return {?}
       */
      DateUtil.prototype.clampDate = /**
       * Clamps a date between a minimum and a maximum date.
       * @param {?} date Date to be clamped
       * @param {?} minDate Minimum date
       * @param {?} maxDate Maximum date
       * @return {?}
       */
          function (date, minDate, maxDate) {
              /** @type {?} */
              var boundDate = date;
              if (minDate && date < minDate) {
                  boundDate = new Date(minDate.getTime());
              }
              if (maxDate && date > maxDate) {
                  boundDate = new Date(maxDate.getTime());
              }
              return boundDate;
          };
      /**
       * Extracts and parses the timestamp from a DOM node.
       * @param node Node from which the timestamp will be extracted.
       * @return Time since epoch.
       */
      /**
       * Extracts and parses the timestamp from a DOM node.
       * @param {?} node Node from which the timestamp will be extracted.
       * @return {?} Time since epoch.
       */
      DateUtil.prototype.getTimestampFromNode = /**
       * Extracts and parses the timestamp from a DOM node.
       * @param {?} node Node from which the timestamp will be extracted.
       * @return {?} Time since epoch.
       */
          function (node) {
              if (node && node.hasAttribute('data-timestamp')) {
                  return Number(node.getAttribute('data-timestamp'));
              }
          };
      /**
       * Checks if a month is within a min and max range, ignoring the date and time components.
       * If minDate or maxDate are not dates, they are ignored.
       * @param date
       * @param minDate
       * @param maxDate
       */
      /**
       * Checks if a month is within a min and max range, ignoring the date and time components.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
      DateUtil.prototype.isMonthWithinRange = /**
       * Checks if a month is within a min and max range, ignoring the date and time components.
       * If minDate or maxDate are not dates, they are ignored.
       * @param {?} date
       * @param {?} minDate
       * @param {?} maxDate
       * @return {?}
       */
          function (date, minDate, maxDate) {
              /** @type {?} */
              var month = date.getMonth();
              /** @type {?} */
              var year = date.getFullYear();
              return (!minDate || minDate.getFullYear() < year || minDate.getMonth() <= month) &&
                  (!maxDate || maxDate.getFullYear() > year || maxDate.getMonth() >= month);
          };
      /**
       * Compares two dates.
       * @param first The first date to compare.
       * @param second The second date to compare.
       * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      DateUtil.prototype.compareDateAndTime = /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
          function (first, second) {
              return this.getYear(first) - this.getYear(second) ||
                  this.getMonth(first) - this.getMonth(second) ||
                  this.getDate(first) - this.getDate(second) ||
                  this.getHours(first) - this.getDate(second) ||
                  this.getMinutes(first) - this.getDate(second) ||
                  this.getSeconds(first) - this.getDate(second);
          };
      /**
       * Checks if two dates are equal.
       * @param first The first date to check.
       * @param second The second date to check.
       * @returns Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      DateUtil.prototype.sameDate = /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
          function (first, second) {
              return first && second ? !this.compareDate(first, second) : first == second;
          };
      /**
       * Checks if two dates are equal.
       * @param first The first date to check.
       * @param second The second date to check.
       * @returns Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      DateUtil.prototype.sameDateAndTime = /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
          function (first, second) {
              return first && second ? !this.compareDateAndTime(first, second) : first == second;
          };
      return DateUtil;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * This animation fades in the background color and text content of the
   * select's options. It is time delayed to occur 100ms after the overlay
   * panel has transformed in.
    @type {?} */
  var fadeInContent$1 = animations.trigger('fadeInContent', [
      animations.state('showing', animations.style({ opacity: 1 })),
      animations.transition('void => showing', [
          animations.style({ opacity: 0 }),
          animations.animate("150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
      ])
  ]);
  /** @type {?} */
  var slideCalendar = animations.trigger('slideCalendar', [
      animations.transition('* => left', [
          animations.animate(180, animations.keyframes([
              animations.style({ transform: 'translateX(100%)', offset: 0.5 }),
              animations.style({ transform: 'translateX(-100%)', offset: 0.51 }),
              animations.style({ transform: 'translateX(0)', offset: 1 })
          ]))
      ]),
      animations.transition('* => right', [
          animations.animate(180, animations.keyframes([
              animations.style({ transform: 'translateX(-100%)', offset: 0.5 }),
              animations.style({ transform: 'translateX(100%)', offset: 0.51 }),
              animations.style({ transform: 'translateX(0)', offset: 1 })
          ]))
      ])
  ]);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * A calendar that is used as part of the datepicker.
   * \@docs-private
   */
  var Md2Calendar = /** @class */ (function () {
      function Md2Calendar(_elementRef, _ngZone, _locale, _util) {
          var _this = this;
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          this._locale = _locale;
          this._util = _util;
          this.type = 'date';
          /**
           * Whether the calendar should be started in month or year view.
           */
          this.startView = 'month';
          this.timeInterval = 1;
          /**
           * Emits when the currently selected date changes.
           */
          this.selectedChange = new core.EventEmitter();
          /**
           * Date filter for the month and year views.
           */
          this._dateFilterForViews = function (date) {
              return !!date &&
                  (!_this.dateFilter || _this.dateFilter(date)) &&
                  (!_this.minDate || _this._util.compareDate(date, _this.minDate) >= 0) &&
                  (!_this.maxDate || _this._util.compareDate(date, _this.maxDate) <= 0);
          };
          /**
           * Whether the calendar is in month view.
           */
          this._currentView = 'month';
          this._clockView = 'hour';
      }
      Object.defineProperty(Md2Calendar.prototype, "_activeDate", {
          /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           */
          get: /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           * @return {?}
           */ function () { return this._clampedActiveDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._clampedActiveDate;
              this._clampedActiveDate = this._util.clampDate(value, this.minDate, this.maxDate);
              if (oldActiveDate && this._clampedActiveDate && this._currentView === 'month' &&
                  !this._util.isSameMonthAndYear(oldActiveDate, this._clampedActiveDate)) {
                  if (this._util.isInNextMonth(oldActiveDate, this._clampedActiveDate)) {
                      this.calendarState('right');
                  }
                  else {
                      this.calendarState('left');
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Calendar.prototype, "_yearLabel", {
          /** The label for the current calendar view. */
          get: /**
           * The label for the current calendar view.
           * @return {?}
           */ function () {
              return this._locale.getYearName(this._activeDate);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Calendar.prototype, "_monthYearLabel", {
          get: /**
           * @return {?}
           */ function () {
              return this._currentView === 'month' ? this._locale.getMonthLabel(this._activeDate) :
                  this._locale.getYearName(this._activeDate);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Calendar.prototype, "_dateLabel", {
          get: /**
           * @return {?}
           */ function () {
              return this._locale.getDateLabel(this._activeDate);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Calendar.prototype, "_hoursLabel", {
          get: /**
           * @return {?}
           */ function () {
              return ('0' + this._locale.getHoursLabel(this._activeDate)).slice(-2);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Calendar.prototype, "_minutesLabel", {
          get: /**
           * @return {?}
           */ function () {
              return ('0' + this._locale.getMinutesLabel(this._activeDate)).slice(-2);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Calendar.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._activeDate = this.startAt || this._util.today();
              this._elementRef.nativeElement.focus();
              if (this.type === 'month') {
                  this._currentView = 'year';
              }
              else if (this.type === 'time') {
                  this._currentView = 'clock';
              }
              else {
                  this._currentView = this.startView || 'month';
              }
          };
      /** Handles date selection in the month view. */
      /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
      Md2Calendar.prototype._dateSelected = /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this.type == 'date') {
                  if (!this._util.sameDate(date, this.selected)) {
                      this.selectedChange.emit(date);
                  }
              }
              else {
                  this._activeDate = date;
                  this._currentView = 'clock';
              }
          };
      /** Handles month selection in the year view. */
      /**
       * Handles month selection in the year view.
       * @param {?} month
       * @return {?}
       */
      Md2Calendar.prototype._monthSelected = /**
       * Handles month selection in the year view.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              if (this.type == 'month') {
                  if (!this._util.isSameMonthAndYear(month, this.selected)) {
                      this.selectedChange.emit(this._util.getFirstDateOfMonth(month));
                  }
              }
              else {
                  this._activeDate = month;
                  this._currentView = 'month';
                  this._clockView = 'hour';
              }
          };
      /**
       * @param {?} date
       * @return {?}
       */
      Md2Calendar.prototype._timeSelected = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this._clockView !== 'minute') {
                  this._activeDate = date;
                  this._clockView = 'minute';
              }
              else {
                  if (!this._util.sameDateAndTime(date, this.selected)) {
                      this.selectedChange.emit(date);
                  }
              }
          };
      /**
       * @param {?} date
       * @return {?}
       */
      Md2Calendar.prototype._onActiveDateChange = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              this._activeDate = date;
          };
      /**
       * @return {?}
       */
      Md2Calendar.prototype._yearClicked = /**
       * @return {?}
       */
          function () {
              this._currentView = 'year';
          };
      /**
       * @return {?}
       */
      Md2Calendar.prototype._dateClicked = /**
       * @return {?}
       */
          function () {
              this._currentView = 'month';
          };
      /**
       * @return {?}
       */
      Md2Calendar.prototype._hoursClicked = /**
       * @return {?}
       */
          function () {
              this._currentView = 'clock';
              this._clockView = 'hour';
          };
      /**
       * @return {?}
       */
      Md2Calendar.prototype._minutesClicked = /**
       * @return {?}
       */
          function () {
              this._currentView = 'clock';
              this._clockView = 'minute';
          };
      /** Handles user clicks on the previous button. */
      /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
      Md2Calendar.prototype._previousClicked = /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
          function () {
              this._activeDate = this._currentView === 'month' ?
                  this._util.addCalendarMonths(this._activeDate, -1) :
                  this._util.addCalendarYears(this._activeDate, -1);
          };
      /** Handles user clicks on the next button. */
      /**
       * Handles user clicks on the next button.
       * @return {?}
       */
      Md2Calendar.prototype._nextClicked = /**
       * Handles user clicks on the next button.
       * @return {?}
       */
          function () {
              this._activeDate = this._currentView === 'month' ?
                  this._util.addCalendarMonths(this._activeDate, 1) :
                  this._util.addCalendarYears(this._activeDate, 1);
          };
      /** Whether the previous period button is enabled. */
      /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
      Md2Calendar.prototype._previousEnabled = /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
          function () {
              if (!this.minDate) {
                  return true;
              }
              return !this.minDate || !this._isSameView(this._activeDate, this.minDate);
          };
      /** Whether the next period button is enabled. */
      /**
       * Whether the next period button is enabled.
       * @return {?}
       */
      Md2Calendar.prototype._nextEnabled = /**
       * Whether the next period button is enabled.
       * @return {?}
       */
          function () {
              return !this.maxDate || !this._isSameView(this._activeDate, this.maxDate);
          };
      /** Handles keydown events on the calendar body. */
      /**
       * Handles keydown events on the calendar body.
       * @param {?} event
       * @return {?}
       */
      Md2Calendar.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              if (this._currentView === 'month') {
                  this._handleCalendarBodyKeydownInMonthView(event);
              }
              else if (this._currentView === 'year') {
                  this._handleCalendarBodyKeydownInYearView(event);
              }
              else {
                  this._handleCalendarBodyKeydownInClockView(event);
              }
          };
      /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
      Md2Calendar.prototype._isSameView = /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
          function (date1, date2) {
              return this._currentView === 'month' ?
                  this._util.getYear(date1) == this._util.getYear(date2) &&
                      this._util.getMonth(date1) == this._util.getMonth(date2) :
                  this._util.getYear(date1) == this._util.getYear(date2);
          };
      /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
      Md2Calendar.prototype._handleCalendarBodyKeydownInMonthView = /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  case LEFT_ARROW:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, -1);
                      break;
                  case RIGHT_ARROW:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, 1);
                      break;
                  case UP_ARROW:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, -7);
                      break;
                  case DOWN_ARROW:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, 7);
                      break;
                  case HOME:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, 1 - this._util.getDate(this._activeDate));
                      break;
                  case END:
                      this._activeDate = this._util.addCalendarDays(this._activeDate, (this._util.getNumDaysInMonth(this._activeDate) -
                          this._util.getDate(this._activeDate)));
                      break;
                  case PAGE_UP:
                      this._activeDate = event.altKey ?
                          this._util.addCalendarYears(this._activeDate, -1) :
                          this._util.addCalendarMonths(this._activeDate, -1);
                      break;
                  case PAGE_DOWN:
                      this._activeDate = event.altKey ?
                          this._util.addCalendarYears(this._activeDate, 1) :
                          this._util.addCalendarMonths(this._activeDate, 1);
                      break;
                  case ENTER:
                      if (this._dateFilterForViews(this._activeDate)) {
                          this._dateSelected(this._activeDate);
                          // Prevent unexpected default actions such as form submission.
                          event.preventDefault();
                      }
                      return;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
      Md2Calendar.prototype._handleCalendarBodyKeydownInYearView = /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  case LEFT_ARROW:
                      this._activeDate = this._util.addCalendarMonths(this._activeDate, -1);
                      break;
                  case RIGHT_ARROW:
                      this._activeDate = this._util.addCalendarMonths(this._activeDate, 1);
                      break;
                  case UP_ARROW:
                      this._activeDate = this._prevMonthInSameCol(this._activeDate);
                      break;
                  case DOWN_ARROW:
                      this._activeDate = this._nextMonthInSameCol(this._activeDate);
                      break;
                  case HOME:
                      this._activeDate = this._util.addCalendarMonths(this._activeDate, -this._util.getMonth(this._activeDate));
                      break;
                  case END:
                      this._activeDate = this._util.addCalendarMonths(this._activeDate, 11 - this._util.getMonth(this._activeDate));
                      break;
                  case PAGE_UP:
                      this._activeDate =
                          this._util.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                      break;
                  case PAGE_DOWN:
                      this._activeDate =
                          this._util.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                      break;
                  case ENTER:
                      this._monthSelected(this._activeDate);
                      break;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
      Md2Calendar.prototype._handleCalendarBodyKeydownInClockView = /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  case UP_ARROW:
                      this._activeDate = this._clockView == 'hour' ?
                          this._util.addCalendarHours(this._activeDate, 1) :
                          this._util.addCalendarMinutes(this._activeDate, 1);
                      break;
                  case DOWN_ARROW:
                      this._activeDate = this._clockView == 'hour' ?
                          this._util.addCalendarHours(this._activeDate, -1) :
                          this._util.addCalendarMinutes(this._activeDate, -1);
                      break;
                  case ENTER:
                      this._timeSelected(this._activeDate);
                      return;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /**
       * Determine the date for the month that comes before the given month in the same column in the
       * calendar table.
       * @param {?} date
       * @return {?}
       */
      Md2Calendar.prototype._prevMonthInSameCol = /**
       * Determine the date for the month that comes before the given month in the same column in the
       * calendar table.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              /** @type {?} */
              var increment = this._util.getMonth(date) <= 4 ? -5 :
                  (this._util.getMonth(date) >= 7 ? -7 : -12);
              return this._util.addCalendarMonths(date, increment);
          };
      /**
       * Determine the date for the month that comes after the given month in the same column in the
       * calendar table.
       * @param {?} date
       * @return {?}
       */
      Md2Calendar.prototype._nextMonthInSameCol = /**
       * Determine the date for the month that comes after the given month in the same column in the
       * calendar table.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              /** @type {?} */
              var increment = this._util.getMonth(date) <= 4 ? 7 :
                  (this._util.getMonth(date) >= 7 ? 5 : 12);
              return this._util.addCalendarMonths(date, increment);
          };
      /**
       * @param {?} direction
       * @return {?}
       */
      Md2Calendar.prototype.calendarState = /**
       * @param {?} direction
       * @return {?}
       */
          function (direction) {
              this._calendarState = direction;
          };
      /**
       * @return {?}
       */
      Md2Calendar.prototype._calendarStateDone = /**
       * @return {?}
       */
          function () {
              this._calendarState = '';
          };
      Md2Calendar.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-calendar',
                      template: "<div class=\"md2-calendar-header\">\n  <div *ngIf=\"type!=='time'\"\n       class=\"md2-calendar-header-year\"\n       [class.active]=\"_currentView == 'year'\"\n       (click)=\"_yearClicked()\">{{ _yearLabel }}</div>\n  <div class=\"md2-calendar-header-date-time\">\n    <span *ngIf=\"type!=='time'\"\n          class=\"md2-calendar-header-date\"\n          [class.active]=\"_currentView == 'month'\"\n          (click)=\"_dateClicked()\">{{ _dateLabel }}</span>\n    <span *ngIf=\"type!=='date'\"\n          class=\"md2-calendar-header-time\"\n          [class.active]=\"_currentView == 'clock'\">\n      <span class=\"md2-calendar-header-hours\"\n            [class.active]=\"_clockView == 'hour'\"\n            (click)=\"_hoursClicked()\">{{ _hoursLabel }}</span>:<span class=\"md2-calendar-header-minutes\"\n                                                                     [class.active]=\"_clockView == 'minute'\"\n                                                                     (click)=\"_minutesClicked()\">{{ _minutesLabel }}</span>\n    </span>\n  </div>\n</div>\n<div class=\"md2-calendar-content\" [ngSwitch]=\"_currentView\">\n  <div class=\"md2-month-content\" *ngIf=\"_currentView === 'month' || _currentView === 'year'\">\n    <div class=\"md2-calendar-controls\">\n      <div class=\"md2-calendar-previous-button\"\n           [class.disabled]=\"!_previousEnabled()\" (click)=\"_previousClicked()\"\n           aria-label=\"Previous month\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n          <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"></path>\n        </svg>\n      </div>\n      <div class=\"md2-calendar-period-button\" [@slideCalendar]=\"_calendarState\" (@slideCalendar.done)=\"_calendarStateDone()\">\n        <strong>{{ _monthYearLabel }}</strong>\n      </div>\n      <div class=\"md2-calendar-next-button\"\n           [class.disabled]=\"!_nextEnabled()\" (click)=\"_nextClicked()\"\n           aria-label=\"Next month\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n          <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"></path>\n        </svg>\n      </div>\n    </div>\n  </div>\n  <md2-month-view *ngSwitchCase=\"'month'\"\n                  [activeDate]=\"_activeDate\"\n                  [selected]=\"selected\"\n                  [displayWeek]=\"displayWeek\"\n                  [dateFilter]=\"_dateFilterForViews\"\n                  (selectedChange)=\"_dateSelected($event)\">\n  </md2-month-view>\n  <md2-year-view *ngSwitchCase=\"'year'\"\n                 [activeDate]=\"_activeDate\"\n                 [selected]=\"selected\"\n                 [dateFilter]=\"_dateFilterForViews\"\n                 (selectedChange)=\"_monthSelected($event)\">\n  </md2-year-view>\n  <md2-clock *ngSwitchDefault\n             [startView]=\"_clockView\"\n             [interval]=\"timeInterval\"\n             [min]=\"minDate\"\n             [max]=\"maxDate\"\n             [selected]=\"_activeDate\"\n             (activeDateChange)=\"_onActiveDateChange($event)\"\n             (selectedChange)=\"_timeSelected($event)\"></md2-clock>\n</div>\n",
                      host: {
                          '[class.md2-calendar]': 'true',
                          'tabindex': '0',
                          '(keydown)': '_handleCalendarBodyKeydown($event)',
                      },
                      animations: [slideCalendar],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      styles: [".md2-calendar{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;outline:0}.md2-calendar[mode=landscape]{display:flex}.md2-calendar-header{padding:16px;font-size:14px;background-color:#106cc8;color:#fff;box-sizing:border-box}[mode=landscape] .md2-calendar-header{width:150px;min-width:150px}.md2-calendar-header-date-time,.md2-calendar-header-year{width:100%;font-weight:500;white-space:nowrap}.md2-calendar-header-date-time{font-size:30px;line-height:34px}[mode=landscape] .md2-calendar-header-date-time{white-space:normal;word-wrap:break-word}.md2-calendar-header-date:not(.active),.md2-calendar-header-hours:not(.active),.md2-calendar-header-minutes:not(.active),.md2-calendar-header-year:not(.active){cursor:pointer;opacity:.6}.md2-calendar-header-time{padding-left:8px}.md2-calendar-header-time:not(.active){opacity:.6}.md2-calendar-header-time:not(.active) .md2-calendar-header-hours,.md2-calendar-header-time:not(.active) .md2-calendar-header-minutes{cursor:pointer;opacity:1}[mode=landscape] .md2-calendar-header-time{display:block;padding-left:0}.md2-calendar-content{width:100%;padding:0 8px 8px;outline:0;box-sizing:border-box;overflow:hidden}[mode=landscape] .md2-calendar-content{padding-top:8px}.md2-calendar-controls{display:flex;justify-content:space-between}.md2-calendar-period-button{display:inline-block;height:48px;padding:12px;outline:0;border:0;background:0 0;box-sizing:border-box}.md2-calendar-next-button,.md2-calendar-previous-button{display:inline-block;width:48px;height:48px;padding:12px;outline:0;border:0;cursor:pointer;background:0 0;box-sizing:border-box}.md2-calendar-next-button.disabled,.md2-calendar-previous-button.disabled{color:rgba(0,0,0,.38);pointer-events:none}.md2-calendar-next-button svg,.md2-calendar-previous-button svg{fill:currentColor;vertical-align:top}.md2-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.md2-calendar-table-header{color:rgba(0,0,0,.38)}.md2-calendar-table-header th{text-align:center;font-size:11px;padding:0 0 8px}@media (min-width:480px){.md2-calendar[mode=auto]{display:flex}.md2-calendar[mode=auto] .md2-calendar-header{width:150px;min-width:150px}.md2-calendar[mode=auto] .md2-calendar-header-date-time{white-space:normal;word-wrap:break-word}.md2-calendar[mode=auto] .md2-calendar-header-time{display:block;padding-left:0}.md2-calendar[mode=auto] .md2-calendar-content{padding-top:8px}}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Calendar.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: DateLocale },
              { type: DateUtil }
          ];
      };
      Md2Calendar.propDecorators = {
          displayWeek: [{ type: core.Input }],
          type: [{ type: core.Input }],
          startAt: [{ type: core.Input }],
          startView: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          minDate: [{ type: core.Input }],
          maxDate: [{ type: core.Input }],
          timeInterval: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }]
      };
      return Md2Calendar;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Change event object emitted by Md2Select.
   */
  var /**
   * Change event object emitted by Md2Select.
   */ Md2DateChange = /** @class */ (function () {
      function Md2DateChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return Md2DateChange;
  }());
  /** *
   * Used to generate a unique ID for each datepicker instance.
    @type {?} */
  var datepickerUid = 0;
  /**
   * Component used as the content for the datepicker dialog and popup. We use this instead of using
   * Md2Calendar directly as the content so we can control the initial focus. This also gives us a
   * place to put additional features of the popup that are not part of the calendar itself in the
   * future. (e.g. confirmation buttons).
   * \@docs-private
   */
  var Md2DatepickerContent = /** @class */ (function () {
      function Md2DatepickerContent() {
      }
      /**
       * Handles keydown event on datepicker content.
       * @param event The event.
       */
      /**
       * Handles keydown event on datepicker content.
       * @param {?} event The event.
       * @return {?}
       */
      Md2DatepickerContent.prototype._handleKeydown = /**
       * Handles keydown event on datepicker content.
       * @param {?} event The event.
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  case ESCAPE:
                      this.datepicker.close();
                      break;
                  default:
                      /* Return so that we don't preventDefault on keys that are not explicitly handled. */
                      return;
              }
              event.preventDefault();
          };
      Md2DatepickerContent.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-datepicker-content',
                      template: "<md2-calendar cdkTrapFocus\n              [id]=\"datepicker.id\"\n              [attr.mode]=\"datepicker.mode\"\n              [startAt]=\"datepicker.startAt\"\n              [startView]=\"datepicker.startView\"\n              [type]=\"datepicker.type\"\n              [timeInterval]=\"datepicker.timeInterval\"\n              [minDate]=\"datepicker._minDate\"\n              [maxDate]=\"datepicker._maxDate\"\n              [dateFilter]=\"datepicker._dateFilter\"\n              [selected]=\"datepicker._selected\"\n              [displayWeek]=\"datepicker.displayWeek\"\n              (selectedChange)=\"datepicker._selectAndClose($event)\">\n</md2-calendar>\n",
                      host: {
                          'class': 'md2-datepicker-content',
                          '[class.md2-datepicker-content-touch]': 'datepicker?.touchUi',
                          '(keydown)': '_handleKeydown($event)',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      styles: [".md2-datepicker-content{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);display:block;background-color:#fff;border-radius:2px;overflow:hidden}.md2-calendar{width:296px;height:405px}.md2-calendar[mode=landscape]{width:446px;height:328px}@media (min-width:480px){.md2-calendar[mode=auto]{width:446px;height:328px}}.md2-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12);display:block;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.6)}"]
                  }] }
      ];
      Md2DatepickerContent.propDecorators = {
          _calendar: [{ type: core.ViewChild, args: [Md2Calendar,] }]
      };
      return Md2DatepickerContent;
  }());
  /** @type {?} */
  var MD2_DATEPICKER_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return Md2Datepicker; }),
      multi: true
  };
  /** @type {?} */
  var MD2_DATEPICKER_VALIDATORS = {
      provide: forms.NG_VALIDATORS,
      useExisting: core.forwardRef(function () { return Md2Datepicker; }),
      multi: true
  };
  var Md2Datepicker = /** @class */ (function () {
      function Md2Datepicker(_element, _overlay, _ngZone, _viewContainerRef, _locale, _util, _dir) {
          var _this = this;
          this._element = _element;
          this._overlay = _overlay;
          this._ngZone = _ngZone;
          this._viewContainerRef = _viewContainerRef;
          this._locale = _locale;
          this._util = _util;
          this._dir = _dir;
          this._onChange = function () { };
          this._onTouched = function () { };
          this._validatorOnChange = function () { };
          this._inputFocused = false;
          /**
           * The view that the calendar should start in.
           */
          this.startView = 'month';
          /**
           * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
           * than a popup and elements have more padding to allow for bigger touch targets.
           */
          this.touchUi = false;
          this.tabindex = 0;
          this.mode = 'auto';
          this.timeInterval = 1;
          this._type = 'date';
          this._required = false;
          this._disabled = false;
          this._inputValue = '';
          /**
           * Event emitted when the select has been opened.
           */
          this.onOpen = new core.EventEmitter();
          /**
           * Event emitted when the select has been closed.
           */
          this.onClose = new core.EventEmitter();
          /**
           * Event emitted when the selected date has been changed by the user.
           */
          this.change = new core.EventEmitter();
          /**
           * Emits new selected date when selected date changes.
           */
          this.selectedChanged = new core.EventEmitter();
          /**
           * Whether the calendar is open.
           */
          this.opened = false;
          /**
           * The currently selected date.
           */
          this._selected = null;
          /**
           * The form control validator for the min date.
           */
          this._minValidator = function (control) {
              return (!_this.min || !control.value ||
                  _this._util.compareDate(_this.min, control.value) <= 0) ?
                  null : { 'md2DatepickerMin': { 'min': _this.min, 'actual': control.value } };
          };
          /**
           * The form control validator for the max date.
           */
          this._maxValidator = function (control) {
              return (!_this.max || !control.value ||
                  _this._util.compareDate(_this.max, control.value) >= 0) ?
                  null : { 'md2DatepickerMax': { 'max': _this.max, 'actual': control.value } };
          };
          /**
           * The form control validator for the date filter.
           */
          this._filterValidator = function (control) {
              return !_this._dateFilter || !control.value || _this._dateFilter(control.value) ?
                  null : { 'md2DatepickerFilter': true };
          };
          /**
           * The combined form control validator for this input.
           */
          this._validator = forms.Validators.compose([this._minValidator, this._maxValidator, this._filterValidator]);
          this.id = (this.id) ? this.id : "md2-datepicker-" + datepickerUid++;
      }
      Object.defineProperty(Md2Datepicker.prototype, "type", {
          get: /**
           * @return {?}
           */ function () { return this._type; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._type = value || 'date';
              this._inputValue = this._formatDate(this._value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "format", {
          get: /**
           * @return {?}
           */ function () {
              return this._format || (this.type === 'month' ? 'MMMM y' : this.type === 'date' ?
                  'dd/MM/y' : this.type === 'time' ? 'HH:mm' : this.type === 'datetime' ?
                  'dd/MM/y HH:mm' : 'dd/MM/y');
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._format !== value) {
                  this._format = value;
                  this._inputValue = this._formatDate(this._value);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "min", {
          /** The minimum valid date. */
          get: /**
           * The minimum valid date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = value;
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "max", {
          /** The maximum valid date. */
          get: /**
           * The maximum valid date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = value;
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "dateFilter", {
          set: /**
           * @param {?} filter
           * @return {?}
           */ function (filter) {
              this._dateFilter = filter;
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "required", {
          get: /**
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "disabled", {
          get: /**
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "value", {
          get: /**
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              this._value = this.coerceDateProperty(value);
              this._selected = this._value;
              this.startAt = this._value;
              setTimeout(function () {
                  _this._inputValue = _this._formatDate(_this._value);
              });
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "openOnFocus", {
          get: /**
           * @return {?}
           */ function () { return this._openOnFocus; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._openOnFocus = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Datepicker.prototype, "isOpen", {
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value && !this.opened) {
                  this.open();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Datepicker.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.close();
              if (this._popupRef) {
                  this._popupRef.dispose();
              }
              if (this._dialogRef) {
                  this._dialogRef.dispose();
              }
              if (this._inputSubscription) {
                  this._inputSubscription.unsubscribe();
              }
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Datepicker.prototype.registerOnValidatorChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._validatorOnChange = fn;
          };
      /**
       * @param {?} c
       * @return {?}
       */
      Md2Datepicker.prototype.validate = /**
       * @param {?} c
       * @return {?}
       */
          function (c) {
              return this._validator ? this._validator(c) : null;
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Datepicker.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.value = value;
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Datepicker.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onChange = fn; };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Datepicker.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onTouched = fn; };
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      Md2Datepicker.prototype.setDisabledState = /**
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /**
       * @return {?}
       */
      Md2Datepicker.prototype._handleFocus = /**
       * @return {?}
       */
          function () {
              this._inputFocused = true;
              if (!this.opened && this.openOnFocus) {
                  this.open();
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Datepicker.prototype._handleBlur = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this._inputFocused = false;
              if (!this.opened) {
                  this._onTouched();
              }
              /** @type {?} */
              var el = event.target;
              /** @type {?} */
              var date = this._util.parseDate(el.value, this.format);
              if (!date) {
                  date = this._util.parse(el.value);
              }
              if (date != null && date.getTime && !isNaN(date.getTime())) {
                  /** @type {?} */
                  var d = new Date(this.value);
                  if (this.type !== 'time') {
                      d.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                  }
                  if (this.type !== 'date') {
                      d.setHours(date.getHours(), date.getMinutes());
                  }
                  if (!this._util.isSameMinute(this.value, d)) {
                      this.value = this._util.createDate(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds());
                      this._emitChangeEvent();
                  }
              }
              else {
                  if (this.value) {
                      this.value = null;
                      this._emitChangeEvent();
                  }
                  el.value = null;
              }
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Datepicker.prototype.coerceDateProperty = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var v = null;
              if (value != null && value.getTime && !isNaN(value.getTime())) {
                  v = value;
              }
              else {
                  if (value && this.type === 'time') {
                      /** @type {?} */
                      var t = value + '';
                      v = new Date();
                      v.setHours(parseInt(t.substring(0, 2)));
                      v.setMinutes(parseInt(t.substring(3, 5)));
                  }
                  else {
                      /** @type {?} */
                      var timestamp = Date.parse(value);
                      v = isNaN(timestamp) ? null : new Date(timestamp);
                  }
              }
              /** @type {?} */
              var d = v ? this._util.createDate(v.getFullYear(), v.getMonth(), v.getDate(), v.getHours(), v.getMinutes(), v.getSeconds()) : null;
              return d;
          };
      /**
       * format date
       * @param {?} date Date Object
       * @return {?} string with formatted date
       */
      Md2Datepicker.prototype._formatDate = /**
       * format date
       * @param {?} date Date Object
       * @return {?} string with formatted date
       */
          function (date) {
              if (!this.format || !date) {
                  return '';
              }
              /** @type {?} */
              var format = this.format;
              /* Years */
              if (format.indexOf('yy') > -1) {
                  format = format.replace('yy', ('00' + this._util.getYear(date)).slice(-2));
              }
              else if (format.indexOf('y') > -1) {
                  format = format.replace('y', '' + this._util.getYear(date));
              }
              /* Days */
              if (format.indexOf('dd') > -1) {
                  format = format.replace('dd', ('0' + this._util.getDate(date)).slice(-2));
              }
              else if (format.indexOf('d') > -1) {
                  format = format.replace('d', '' + this._util.getDate(date));
              }
              /* Hours */
              if (/[aA]/.test(format)) {
                  /* 12-hour */
                  if (format.indexOf('HH') > -1) {
                      format = format.replace('HH', ('0' + this._getHours12(this._util.getHours(date))).slice(-2));
                  }
                  else if (format.indexOf('H') > -1) {
                      format = format.replace('H', '' + this._getHours12(this._util.getHours(date)));
                  }
                  format = format.replace('A', ((this._util.getHours(date) < 12) ? 'AM' : 'PM'))
                      .replace('a', ((this._util.getHours(date) < 12) ? 'am' : 'pm'));
              }
              else {
                  /* 24-hour */
                  if (format.indexOf('HH') > -1) {
                      format = format.replace('HH', ('0' + this._util.getHours(date)).slice(-2));
                  }
                  else if (format.indexOf('H') > -1) {
                      format = format.replace('H', '' + this._util.getHours(date));
                  }
              }
              /* Minutes */
              if (format.indexOf('mm') > -1) {
                  format = format.replace('mm', ('0' + this._util.getMinutes(date)).slice(-2));
              }
              else if (format.indexOf('m') > -1) {
                  format = format.replace('m', '' + this._util.getMinutes(date));
              }
              /* Seconds */
              if (format.indexOf('ss') > -1) {
                  format = format.replace('ss', ('0' + this._util.getSeconds(date)).slice(-2));
              }
              else if (format.indexOf('s') > -1) {
                  format = format.replace('s', '' + this._util.getSeconds(date));
              }
              /* Months */
              if (format.indexOf('MMMM') > -1) {
                  format = format.replace('MMMM', this._locale.getMonthNames('long')[this._util.getMonth(date)]);
              }
              else if (format.indexOf('MMM') > -1) {
                  format = format.replace('MMM', this._locale.getMonthNames('short')[this._util.getMonth(date)]);
              }
              else if (format.indexOf('MM') > -1) {
                  format = format.replace('MM', ('0' + (this._util.getMonth(date) + 1)).slice(-2));
              }
              else if (format.indexOf('M') > -1) {
                  format = format.replace('M', '' + (this._util.getMonth(date) + 1));
              }
              return format;
          };
      /**
       * Get an hour of the date in the 12-hour format
       * @param {?} hours
       * @return {?} hour of the date in the 12-hour format
       */
      Md2Datepicker.prototype._getHours12 = /**
       * Get an hour of the date in the 12-hour format
       * @param {?} hours
       * @return {?} hour of the date in the 12-hour format
       */
          function (hours) {
              if (hours == 0) {
                  hours = 12;
              }
              else if (hours > 12) {
                  hours -= 12;
              }
              return hours;
          };
      /** Selects the given date and closes the currently open popup or dialog. */
      /**
       * Selects the given date and closes the currently open popup or dialog.
       * @param {?} date
       * @return {?}
       */
      Md2Datepicker.prototype._selectAndClose = /**
       * Selects the given date and closes the currently open popup or dialog.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              /** @type {?} */
              var oldValue = this._selected;
              this.value = date;
              if (!this._util.sameDateAndTime(oldValue, this._selected)) {
                  this._emitChangeEvent();
              }
              this.close();
          };
      /** Emits an event when the user selects a date. */
      /**
       * Emits an event when the user selects a date.
       * @return {?}
       */
      Md2Datepicker.prototype._emitChangeEvent = /**
       * Emits an event when the user selects a date.
       * @return {?}
       */
          function () {
              this._onChange(this.value);
              this.change.emit(new Md2DateChange(this, this.value));
          };
      /** Open the calendar. */
      /**
       * Open the calendar.
       * @return {?}
       */
      Md2Datepicker.prototype.open = /**
       * Open the calendar.
       * @return {?}
       */
          function () {
              if (this.opened) {
                  return;
              }
              if (!this._calendarPortal) {
                  this._calendarPortal = new ComponentPortal(Md2DatepickerContent, this._viewContainerRef);
              }
              this.touchUi ? this._openAsDialog() : this._openAsPopup();
              this.opened = true;
              this.onOpen.emit();
          };
      /** Close the calendar. */
      /**
       * Close the calendar.
       * @return {?}
       */
      Md2Datepicker.prototype.close = /**
       * Close the calendar.
       * @return {?}
       */
          function () {
              if (!this.opened) {
                  return;
              }
              if (this._popupRef && this._popupRef.hasAttached()) {
                  this._popupRef.detach();
              }
              if (this._dialogRef && this._dialogRef.hasAttached()) {
                  this._dialogRef.detach();
              }
              if (this._calendarPortal && this._calendarPortal.isAttached) {
                  this._calendarPortal.detach();
              }
              this.opened = false;
              this.onClose.emit();
          };
      /**
       * Open the calendar as a dialog.
       * @return {?}
       */
      Md2Datepicker.prototype._openAsDialog = /**
       * Open the calendar as a dialog.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._dialogRef) {
                  this._createDialog();
              }
              if (!this._dialogRef.hasAttached()) {
                  /** @type {?} */
                  var componentRef = this._dialogRef.attach(this._calendarPortal);
                  componentRef.instance.datepicker = this;
              }
              this._dialogRef.backdropClick().subscribe(function () { return _this.close(); });
          };
      /**
       * Open the calendar as a popup.
       * @return {?}
       */
      Md2Datepicker.prototype._openAsPopup = /**
       * Open the calendar as a popup.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._popupRef) {
                  this._createPopup();
              }
              if (!this._popupRef.hasAttached()) {
                  /** @type {?} */
                  var componentRef = this._popupRef.attach(this._calendarPortal);
                  componentRef.instance.datepicker = this;
                  /* Update the position once the calendar has rendered. */
                  this._ngZone.onStable.pipe(operators.first()).subscribe(function () { return _this._popupRef.updatePosition(); });
              }
              this._popupRef.backdropClick().subscribe(function () { return _this.close(); });
          };
      /**
       * Create the dialog.
       * @return {?}
       */
      Md2Datepicker.prototype._createDialog = /**
       * Create the dialog.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayState = new OverlayState();
              overlayState.positionStrategy = this._overlay.position().global()
                  .centerHorizontally()
                  .centerVertically();
              overlayState.hasBackdrop = true;
              overlayState.backdropClass = 'cdk-overlay-dark-backdrop';
              overlayState.direction = this._dir ? this._dir.value : 'ltr';
              this._dialogRef = this._overlay.create(overlayState);
          };
      /**
       * Create the popup.
       * @return {?}
       */
      Md2Datepicker.prototype._createPopup = /**
       * Create the popup.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayState = new OverlayState();
              overlayState.positionStrategy = this._createPopupPositionStrategy();
              overlayState.hasBackdrop = true;
              overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
              overlayState.direction = this._dir ? this._dir.value : 'ltr';
              overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
              this._popupRef = this._overlay.create(overlayState);
          };
      /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
      Md2Datepicker.prototype._createPopupPositionStrategy = /**
       * Create the popup PositionStrategy.
       * @return {?}
       */
          function () {
              return this._overlay.position()
                  .connectedTo(this._element, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
                  .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' });
          };
      Md2Datepicker.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-datepicker',
                      template: "<div class=\"md2-datepicker-trigger\">\n  <button type=\"button\"\n          class=\"md2-datepicker-button\"\n          tabindex=\"-1\"\n          (click)=\"open()\"\n          [ngSwitch]=\"type\">\n    <svg *ngSwitchCase=\"'time'\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22C6.47,22 2,17.5 2,12A10,10 0 0,1 12,2M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\"></path>\n    </svg>\n    <svg *ngSwitchCase=\"'datetime'\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M15,13H16.5V15.82L18.94,17.23L18.19,18.53L15,16.69V13M19,8H5V19H9.67C9.24,18.09 9,17.07 9,16A7,7 0 0,1 16,9C17.07,9 18.09,9.24 19,9.67V8M5,21C3.89,21 3,20.1 3,19V5C3,3.89 3.89,3 5,3H6V1H8V3H16V1H18V3H19A2,2 0 0,1 21,5V11.1C22.24,12.36 23,14.09 23,16A7,7 0 0,1 16,23C14.09,23 12.36,22.24 11.1,21H5M16,11.15A4.85,4.85 0 0,0 11.15,16C11.15,18.68 13.32,20.85 16,20.85A4.85,4.85 0 0,0 20.85,16C20.85,13.32 18.68,11.15 16,11.15Z\"></path>\n    </svg>\n    <svg *ngSwitchDefault width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"></path>\n    </svg>\n  </button>\n  <div class=\"md2-datepicker-input\" [class.md2-datepicker-input-focused]=\"_inputFocused\">\n    <span class=\"md2-datepicker-placeholder\" [class.md2-floating-placeholder]=\"value || _inputFocused\">{{ placeholder }}</span>\n    <input #input\n           type=\"text\"\n           class=\"md2-datepicker-value\"\n           [tabindex]=\"tabindex\"\n           [disabled]=\"disabled\"\n           autocomplete=\"off\"\n           [value]=\"_inputValue\"\n           (change)=\"$event.stopPropagation()\"\n           (click)=\"_handleFocus()\"\n           (focus)=\"_handleFocus()\"\n           (blur)=\"_handleBlur($event)\" />\n    <span class=\"md2-datepicker-arrow\" (click)=\"open()\"></span>\n  </div>\n</div>\n",
                      providers: [MD2_DATEPICKER_VALUE_ACCESSOR, MD2_DATEPICKER_VALIDATORS],
                      host: {
                          'role': 'datepicker',
                          '[class.md2-datepicker-disabled]': 'disabled',
                          '[class.md2-datepicker-opened]': 'opened',
                          '[attr.aria-label]': 'placeholder',
                          '[attr.aria-required]': 'required.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["md2-datepicker{position:relative;display:inline-block;min-width:175px;outline:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}md2-datepicker.md2-datepicker-disabled{pointer-events:none;cursor:default}.md2-datepicker-trigger{display:block;padding:18px 0 4px 46px;white-space:nowrap}.md2-datepicker-button{position:absolute;top:13px;left:0;display:inline-block;height:40px;width:40px;padding:8px;line-height:24px;color:rgba(0,0,0,.54);fill:currentColor;border:0;border-radius:50%;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;box-sizing:border-box;background:0 0;vertical-align:middle;align-items:center;text-align:center}.md2-datepicker-button:focus{background-color:rgba(158,158,158,.2)}.md2-datepicker-disabled .md2-datepicker-button{color:rgba(0,0,0,.38)}.md2-datepicker-input{color:rgba(0,0,0,.38);border-bottom:1px solid rgba(0,0,0,.12);display:flex;justify-content:space-between;align-items:center;height:30px;min-width:168px;line-height:22px;position:relative;padding-right:20px;box-sizing:border-box}[aria-disabled=true] .md2-datepicker-input{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;border-color:transparent;background-position:0 bottom;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md2-datepicker-input.md2-datepicker-input-focused{color:#106cc8;border-color:#106cc8}md2-datepicker.ng-invalid.ng-touched:not(.md2-datepicker-disabled) .md2-datepicker-input{color:#f44336;border-color:#f44336}.md2-datepicker-placeholder{position:absolute;right:18px;bottom:100%;left:0;padding:0 2px;-webkit-transform:translate3d(0,26px,0) scale(1);transform:translate3d(0,26px,0) scale(1);-webkit-transform-origin:left top;transform-origin:left top;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;transition:150ms cubic-bezier(.25,.8,.25,1)}.md2-datepicker-placeholder.md2-floating-placeholder{left:-2px;text-align:left;-webkit-transform:translate3d(0,6px,0) scale(.75);transform:translate3d(0,6px,0) scale(.75)}[dir=rtl] .md2-datepicker-placeholder{right:0;left:18px;-webkit-transform-origin:right top;transform-origin:right top}[dir=rtl] .md2-datepicker-placeholder.md2-floating-placeholder{right:-2px;text-align:right}[aria-required=true] .md2-datepicker-placeholder::after{content:'*'}.md2-datepicker-value{position:relative;width:100%;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;color:rgba(0,0,0,.87);border:0;outline:0;background:0 0}.md2-datepicker-disabled .md2-datepicker-value{color:rgba(0,0,0,.38)}[dir=rtl] .md2-datepicker-value{left:auto;right:0}.md2-datepicker-arrow{position:absolute;right:0;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px;color:rgba(0,0,0,.38)}.md2-datepicker-input-focused .md2-datepicker-arrow{color:#106cc8}md2-datepicker.ng-invalid.ng-touched:not(.md2-datepicker-disabled) .md2-datepicker-arrow{color:#f44336}.md2-calendar-years{position:absolute;top:10px;right:100%;bottom:10px;display:block;width:100%;line-height:40px;background:#fff;overflow-x:hidden;overflow-y:auto;transition:.3s}.md2-calendar-years.active{right:0}.md2-calendar-years .md2-calendar-years-content{display:flex;flex-direction:column;justify-content:center;min-height:100%}.md2-calendar-year{position:relative;display:block;margin:0 auto;padding:0;font-size:17px;font-weight:400;text-align:center;cursor:pointer}.md2-calendar-year.selected{color:#106cc8;font-size:26px;font-weight:500}.md2-datepicker-actions{text-align:right}.md2-datepicker-actions .md2-button{display:inline-block;min-width:64px;margin:4px 8px 8px 0;padding:0 12px;font-size:14px;color:#106cc8;line-height:36px;text-align:center;text-transform:uppercase;border-radius:2px;cursor:pointer;box-sizing:border-box;transition:450ms cubic-bezier(.23,1,.32,1)}.md2-datepicker-actions .md2-button:hover{background:#ebebeb}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Datepicker.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Overlay },
              { type: core.NgZone },
              { type: core.ViewContainerRef },
              { type: DateLocale },
              { type: DateUtil },
              { type: Dir, decorators: [{ type: core.Optional }] }
          ];
      };
      Md2Datepicker.propDecorators = {
          startAt: [{ type: core.Input }],
          startView: [{ type: core.Input }],
          touchUi: [{ type: core.Input }],
          displayWeek: [{ type: core.Input }],
          tabindex: [{ type: core.Input }],
          mode: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          timeInterval: [{ type: core.Input }],
          id: [{ type: core.Input }],
          type: [{ type: core.Input }],
          format: [{ type: core.Input }],
          min: [{ type: core.Input }],
          max: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          required: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          value: [{ type: core.Input }],
          openOnFocus: [{ type: core.Input }],
          isOpen: [{ type: core.Input }],
          onOpen: [{ type: core.Output }],
          onClose: [{ type: core.Output }],
          change: [{ type: core.Output }],
          selectedChanged: [{ type: core.Output }]
      };
      return Md2Datepicker;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * @template D
   */
  var Md2DatepickerToggle = /** @class */ (function () {
      function Md2DatepickerToggle() {
      }
      /**
       * @param {?} event
       * @return {?}
       */
      Md2DatepickerToggle.prototype._open = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.datepicker) {
                  this.datepicker.open();
                  event.stopPropagation();
              }
          };
      Md2DatepickerToggle.decorators = [
          { type: core.Component, args: [{
                      selector: 'button[md2DatepickerToggle]',
                      template: '',
                      host: {
                          'type': 'button',
                          'class': 'md2-datepicker-toggle',
                          'aria-label': 'Open calendar',
                          '(click)': '_open($event)',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      styles: [".md2-datepicker-toggle{display:inline-block;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iY3VycmVudENvbG9yIj48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE5IDNoLTFWMWgtMnYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOGgxNHYxMXpNNyAxMGg1djVIN3oiLz48L3N2Zz4=) 0 0/contain no-repeat;height:24px;width:24px;border:none;outline:0;vertical-align:middle}.md2-datepicker-toggle:not([disabled]){cursor:pointer}"]
                  }] }
      ];
      Md2DatepickerToggle.propDecorators = {
          datepicker: [{ type: core.Input, args: ['md2DatepickerToggle',] }]
      };
      return Md2DatepickerToggle;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */
  var /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */ Md2CalendarCell = /** @class */ (function () {
      function Md2CalendarCell(value, displayValue, ariaLabel, enabled, header) {
          this.value = value;
          this.displayValue = displayValue;
          this.ariaLabel = ariaLabel;
          this.enabled = enabled;
          this.header = header;
      }
      return Md2CalendarCell;
  }());
  /**
   * An internal component used to display calendar data in a table.
   * \@docs-private
   */
  var Md2CalendarBody = /** @class */ (function () {
      function Md2CalendarBody() {
          /**
           * The number of columns in the table.
           */
          this.numCols = 7;
          /**
           * Whether to allow selection of disabled cells.
           */
          this.allowDisabledSelection = false;
          /**
           * The cell number of the active cell in the table.
           */
          this.activeCell = 0;
          /**
           * Emits when a new value is selected.
           */
          this.selectedValueChange = new core.EventEmitter();
      }
      /**
       * @param {?} cell
       * @return {?}
       */
      Md2CalendarBody.prototype._cellClicked = /**
       * @param {?} cell
       * @return {?}
       */
          function (cell) {
              if (!this.allowDisabledSelection && !cell.enabled) {
                  return;
              }
              this.selectedValueChange.emit(cell.value);
          };
      Object.defineProperty(Md2CalendarBody.prototype, "_firstRowOffset", {
          /** The number of blank cells to put at the beginning for the first row. */
          get: /**
           * The number of blank cells to put at the beginning for the first row.
           * @return {?}
           */ function () {
              return this.rows && this.rows.length && this.rows[0].length ?
                  this.numCols - this.rows[0].length : 0;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
      Md2CalendarBody.prototype._isActiveCell = /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
          function (rowIndex, colIndex) {
              /** @type {?} */
              var cellNumber = rowIndex * this.numCols + colIndex;
              // Account for the fact that the first row may not have as many cells.
              if (rowIndex) {
                  cellNumber -= this._firstRowOffset;
              }
              return cellNumber == this.activeCell;
          };
      Md2CalendarBody.decorators = [
          { type: core.Component, args: [{
                      selector: '[md2-calendar-body]',
                      template: "<!--\n  If there's not enough space in the first row, create a separate label row. We mark this row as\n  aria-hidden because we don't want it to be read out as one of the weeks in the month.\n-->\n<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\">\n  <td class=\"md2-calendar-body-label\" [attr.colspan]=\"numCols\" >{{label}}</td>\n</tr>\n\n<!-- Create the first row separately so we can include a special spacer cell. -->\n<tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\">\n  <!--\n    We mark this cell as aria-hidden so it doesn't get read out as one of the days in the week.\n  -->\n  <th *ngIf=\"displayWeek\"\n      scope=\"row\"\n      class=\"md2-calendar-table-header\"\n      aria-hidden=\"true\">\n    {{row[0].header}}\n  </th>\n  <td *ngIf=\"rowIndex === 0 && _firstRowOffset\"\n      aria-hidden=\"true\"\n      class=\"md2-calendar-body-label\"\n      [attr.colspan]=\"_firstRowOffset\">\n    {{_firstRowOffset >= labelMinRequiredCells ? label : ''}}\n  </td>\n  <td *ngFor=\"let item of row; let colIndex = index\"\n      role=\"gridcell\"\n      class=\"md2-calendar-body-cell\"\n      [class.md2-calendar-body-disabled]=\"!item.enabled\"\n      [class.md2-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\n      [attr.aria-label]=\"item.ariaLabel\"\n      [attr.aria-disabled]=\"!item.enabled || null\"\n      (click)=\"_cellClicked(item)\">\n    <div class=\"md2-calendar-body-cell-content\"\n         [class.md2-calendar-body-selected]=\"selectedValue === item.value\"\n         [class.md2-calendar-body-today]=\"todayValue === item.value\">\n      {{item.displayValue}}\n    </div>\n  </td>\n</tr>\n",
                      host: {
                          'class': 'md2-calendar-body',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      styles: [".md2-calendar-body{font-size:13px;min-width:224px}.md2-calendar-body-label{padding:7.14286% 0 7.14286% 7.14286%;height:0;line-height:0;color:rgba(0,0,0,.54);-webkit-transform:translateX(-6px);transform:translateX(-6px);text-align:left}.md2-calendar-body-cell{position:relative;width:14.28571%;height:0;line-height:0;padding:7.14286% 0;text-align:center;outline:0;cursor:pointer}.md2-calendar-body-disabled{cursor:default;pointer-events:none}.md2-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;color:rgba(0,0,0,.87);border-radius:50%;border:1px solid transparent}.md2-calendar-body-disabled>.md2-calendar-body-cell-content:not(.md2-calendar-body-selected){color:rgba(0,0,0,.38)}.md2-calendar:focus .md2-calendar-body-active>.md2-calendar-body-cell-content:not(.md2-calendar-body-selected),:not(.md2-calendar-body-disabled):hover>.md2-calendar-body-cell-content:not(.md2-calendar-body-selected){background-color:rgba(0,0,0,.12)}.md2-calendar-body-selected{background-color:#106cc8;color:#fff}.md2-calendar-body-disabled>.md2-calendar-body-selected{background-color:rgba(16,108,200,.4)}.md2-calendar-body-today:not(.md2-calendar-body-selected){border-color:#106cc8}.md2-calendar-body-today.md2-calendar-body-selected{box-shadow:inset 0 0 0 1px md2-color(#106cc8,default-contrast)}.md2-calendar-body-disabled>.md2-calendar-body-today:not(.md2-calendar-body-selected){border-color:rgba(0,0,0,.18)}[dir=rtl] .md2-calendar-body-label{padding:0 7.14286% 0 0;-webkit-transform:translateX(6px);transform:translateX(6px);text-align:right}"]
                  }] }
      ];
      Md2CalendarBody.propDecorators = {
          label: [{ type: core.Input }],
          rows: [{ type: core.Input }],
          todayValue: [{ type: core.Input }],
          selectedValue: [{ type: core.Input }],
          labelMinRequiredCells: [{ type: core.Input }],
          numCols: [{ type: core.Input }],
          allowDisabledSelection: [{ type: core.Input }],
          activeCell: [{ type: core.Input }],
          displayWeek: [{ type: core.Input }],
          selectedValueChange: [{ type: core.Output }]
      };
      return Md2CalendarBody;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var DAYS_PER_WEEK = 7;
  /**
   * An internal component used to display a single month in the datepicker.
   * \@docs-private
   */
  var Md2MonthView = /** @class */ (function () {
      function Md2MonthView(_locale, _util, _dateFormats) {
          this._locale = _locale;
          this._util = _util;
          this._dateFormats = _dateFormats;
          /**
           * Emits when a new date is selected.
           */
          this.selectedChange = new core.EventEmitter();
          if (!this._dateFormats) {
              throw Error('MD_DATE_FORMATS');
          }
          /** @type {?} */
          var firstDayOfWeek = this._locale.getFirstDayOfWeek();
          /** @type {?} */
          var narrowWeekdays = this._locale.getDayOfWeekNames('narrow');
          /** @type {?} */
          var longWeekdays = this._locale.getDayOfWeekNames('long');
          /** @type {?} */
          var weekdays = longWeekdays.map(function (long, i) {
              return { long: long, narrow: narrowWeekdays[i] };
          });
          this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
          this._activeDate = this._util.today();
      }
      Object.defineProperty(Md2MonthView.prototype, "activeDate", {
          /**
           * The date to display in this month view (everything other than the month and year is ignored).
           */
          get: /**
           * The date to display in this month view (everything other than the month and year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              this._activeDate = value || this._util.today();
              if (oldActiveDate && this._activeDate &&
                  !this._util.isSameMonthAndYear(oldActiveDate, this._activeDate)) {
                  this._init();
                  if (this._util.isInNextMonth(oldActiveDate, this._activeDate)) {
                      this.calendarState('right');
                  }
                  else {
                      this.calendarState('left');
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2MonthView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = value;
              this._selectedDate = this._getDateInCurrentMonth(this.selected);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2MonthView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new date is selected. */
      /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
      Md2MonthView.prototype._dateSelected = /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              this.selectedChange.emit(this._util.createDate(this._util.getYear(this.activeDate), this._util.getMonth(this.activeDate), date, this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate)));
          };
      /**
       * Initializes this month view.
       * @return {?}
       */
      Md2MonthView.prototype._init = /**
       * Initializes this month view.
       * @return {?}
       */
          function () {
              this._selectedDate = this._getDateInCurrentMonth(this.selected);
              this._todayDate = this._getDateInCurrentMonth(this._util.today());
              /** @type {?} */
              var firstOfMonth = this._util.createDate(this._util.getYear(this.activeDate), this._util.getMonth(this.activeDate), 1, this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate));
              this._firstWeekOffset =
                  (DAYS_PER_WEEK + this._locale.getDayOfWeek(firstOfMonth) -
                      this._locale.getFirstDayOfWeek()) % DAYS_PER_WEEK;
              this._createWeekCells();
          };
      /**
       * Creates MdCalendarCells for the dates in this month.
       * @return {?}
       */
      Md2MonthView.prototype._createWeekCells = /**
       * Creates MdCalendarCells for the dates in this month.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var daysInMonth = this._util.getNumDaysInMonth(this.activeDate);
              /** @type {?} */
              var dateNames = this._locale.getDateNames();
              /** @type {?} */
              var oldWeek;
              this._weeks = [];
              for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                  /** @type {?} */
                  var date = this._util.createDate(this._util.getYear(this.activeDate), this._util.getMonth(this.activeDate), i + 1, this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate));
                  /** @type {?} */
                  var enabled = !this.dateFilter ||
                      this.dateFilter(date);
                  /** @type {?} */
                  var ariaLabel = this._locale.format(date, this._dateFormats.display.dateA11yLabel);
                  /** @type {?} */
                  var newWeek = this._util.getWeekOfYear(date);
                  if (oldWeek !== newWeek) {
                      this._weeks.push([]);
                      oldWeek = newWeek;
                      cell = 0;
                  }
                  this._weeks[this._weeks.length - 1]
                      .push(new Md2CalendarCell(i + 1, dateNames[i], ariaLabel, enabled, newWeek.toString()));
              }
          };
      /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @param {?} date
       * @return {?}
       */
      Md2MonthView.prototype._getDateInCurrentMonth = /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this._util.isSameMonthAndYear(date, this.activeDate) ?
                  this._util.getDate(date) : null;
          };
      /**
       * @param {?} direction
       * @return {?}
       */
      Md2MonthView.prototype.calendarState = /**
       * @param {?} direction
       * @return {?}
       */
          function (direction) {
              this._calendarState = direction;
          };
      /**
       * @return {?}
       */
      Md2MonthView.prototype._calendarStateDone = /**
       * @return {?}
       */
          function () {
              this._calendarState = '';
          };
      Md2MonthView.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-month-view',
                      template: "<table class=\"md2-calendar-table\">\n  <thead class=\"md2-calendar-table-header\">\n    <tr>\n      <th *ngIf=\"displayWeek\">#</th>\n      <th *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th>\n    </tr>\n  </thead>\n  <tbody [@slideCalendar]=\"_calendarState\"\n         (@slideCalendar.done)=\"_calendarStateDone()\"\n         md2-calendar-body\n         role=\"grid\"\n         [rows]=\"_weeks\"\n         [todayValue]=\"_todayDate\"\n         [selectedValue]=\"_selectedDate\"\n         [displayWeek]=\"displayWeek\"\n         [activeCell]=\"_util.getDate(activeDate) - 1\"\n         (selectedValueChange)=\"_dateSelected($event)\"></tbody>\n</table>\n",
                      animations: [slideCalendar],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      Md2MonthView.ctorParameters = function () {
          return [
              { type: DateLocale },
              { type: DateUtil },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MD_DATE_FORMATS,] }] }
          ];
      };
      Md2MonthView.propDecorators = {
          displayWeek: [{ type: core.Input }],
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }]
      };
      return Md2MonthView;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * An internal component used to display a single year in the datepicker.
   * \@docs-private
   */
  var Md2YearView = /** @class */ (function () {
      function Md2YearView(_locale, _util, _dateFormats) {
          this._locale = _locale;
          this._util = _util;
          this._dateFormats = _dateFormats;
          /**
           * Emits when a new month is selected.
           */
          this.selectedChange = new core.EventEmitter();
          if (!this._dateFormats) {
              throw Error('MD_DATE_FORMATS');
          }
          this._activeDate = this._util.today();
      }
      Object.defineProperty(Md2YearView.prototype, "activeDate", {
          /** The date to display in this year view (everything other than the year is ignored). */
          get: /**
           * The date to display in this year view (everything other than the year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              this._activeDate = value || this._util.today();
              if (oldActiveDate && this._activeDate &&
                  !this._util.isSameYear(oldActiveDate, this._activeDate)) {
                  this._init();
                  // if (oldActiveDate < this._activeDate) {
                  //  this.calendarState('right');
                  // } else {
                  //  this.calendarState('left');
                  // }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2YearView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = value;
              this._selectedMonth = this._getMonthInCurrentYear(this.selected);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2YearView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new month is selected. */
      /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
      Md2YearView.prototype._monthSelected = /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              this.selectedChange.emit(this._util.createDate(this._util.getYear(this.activeDate), month, this._util.getDate(this.activeDate), this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate)));
          };
      /**
       * Initializes this month view.
       * @return {?}
       */
      Md2YearView.prototype._init = /**
       * Initializes this month view.
       * @return {?}
       */
          function () {
              var _this = this;
              this._selectedMonth = this._getMonthInCurrentYear(this.selected);
              this._todayMonth = this._getMonthInCurrentYear(this._util.today());
              this._yearLabel = this._locale.getYearName(this.activeDate);
              /** @type {?} */
              var monthNames = this._locale.getMonthNames('short');
              // First row of months only contains 5 elements so we can fit the year label on the same row.
              this._months = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });
          };
      /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @param {?} date
       * @return {?}
       */
      Md2YearView.prototype._getMonthInCurrentYear = /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this._util.isSameYear(date, this.activeDate) ?
                  this._util.getMonth(date) : null;
          };
      /**
       * Creates an MdCalendarCell for the given month.
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
      Md2YearView.prototype._createCellForMonth = /**
       * Creates an MdCalendarCell for the given month.
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
          function (month, monthName) {
              /** @type {?} */
              var ariaLabel = this._locale.format(this._util.createDate(this._util.getYear(this.activeDate), month, 1, this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate)), this._dateFormats.display.monthYearA11yLabel);
              return new Md2CalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._isMonthEnabled(month));
          };
      /**
       * Whether the given month is enabled.
       * @param {?} month
       * @return {?}
       */
      Md2YearView.prototype._isMonthEnabled = /**
       * Whether the given month is enabled.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              if (!this.dateFilter) {
                  return true;
              }
              /** @type {?} */
              var firstOfMonth = this._util.createDate(this._util.getYear(this.activeDate), month, 1, this._util.getHours(this.activeDate), this._util.getMinutes(this.activeDate), this._util.getSeconds(this.activeDate));
              // If any date in the month is enabled count the month as enabled.
              for (var date = firstOfMonth; this._util.getMonth(date) == month; date = this._util.addCalendarDays(date, 1)) {
                  if (this.dateFilter(date)) {
                      return true;
                  }
              }
              return false;
          };
      /**
       * @param {?} direction
       * @return {?}
       */
      Md2YearView.prototype.calendarState = /**
       * @param {?} direction
       * @return {?}
       */
          function (direction) {
              this._calendarState = direction;
          };
      /**
       * @return {?}
       */
      Md2YearView.prototype._calendarStateDone = /**
       * @return {?}
       */
          function () {
              this._calendarState = '';
          };
      Md2YearView.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-year-view',
                      template: "<table class=\"md2-calendar-table\">\n  <thead class=\"md2-calendar-table-header\"></thead>\n  <tbody [@slideCalendar]=\"_calendarState\"\n         (@slideCalendar.done)=\"_calendarStateDone()\"\n         md2-calendar-body\n         role=\"grid\"\n         allowDisabledSelection=\"true\"\n         [label]=\"_yearLabel\"\n         [rows]=\"_months\"\n         [todayValue]=\"_todayMonth\"\n         [selectedValue]=\"_selectedMonth\"\n         [labelMinRequiredCells]=\"2\"\n         [activeCell]=\"_util.getMonth(activeDate)\"\n         (selectedValueChange)=\"_monthSelected($event)\"></tbody>\n</table>\n",
                      animations: [slideCalendar],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  }] }
      ];
      /** @nocollapse */
      Md2YearView.ctorParameters = function () {
          return [
              { type: DateLocale },
              { type: DateUtil },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MD_DATE_FORMATS,] }] }
          ];
      };
      Md2YearView.propDecorators = {
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }]
      };
      return Md2YearView;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var CLOCK_RADIUS = 50;
  /** @type {?} */
  var CLOCK_INNER_RADIUS = 27.5;
  /** @type {?} */
  var CLOCK_OUTER_RADIUS = 41.25;
  /** @type {?} */
  var CLOCK_TICK_RADIUS = 7.0833;
  /**
   * A clock that is used as part of the datepicker.
   * \@docs-private
   */
  var Md2Clock = /** @class */ (function () {
      function Md2Clock(_element, _locale, _util) {
          var _this = this;
          this._element = _element;
          this._locale = _locale;
          this._util = _util;
          this.interval = 1;
          this.twelvehour = false;
          /**
           * Emits when the currently selected date changes.
           */
          this.selectedChange = new core.EventEmitter();
          this.activeDateChange = new core.EventEmitter();
          /**
           * Hours and Minutes representing the clock view.
           */
          this._hours = [];
          this._minutes = [];
          /**
           * Whether the clock is in hour view.
           */
          this._hourView = true;
          this.mouseMoveListener = function (event) { _this._handleMousemove(event); };
          this.mouseUpListener = function () { _this._handleMouseup(); };
      }
      Object.defineProperty(Md2Clock.prototype, "activeDate", {
          /**
           * The date to display in this clock view.
           */
          get: /**
           * The date to display in this clock view.
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              this._activeDate = this._util.clampDate(value, this.min, this.max);
              if (!this._util.isSameMinute(oldActiveDate, this._activeDate)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Clock.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._util.parse(value);
              if (this._selected) {
                  this.activeDate = this._selected;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Clock.prototype, "min", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._min; },
          set: /**
           * @param {?} date
           * @return {?}
           */ function (date) { this._min = this._util.parse(date); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Clock.prototype, "max", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._max; },
          set: /**
           * @param {?} date
           * @return {?}
           */ function (date) { this._max = this._util.parse(date); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Clock.prototype, "startView", {
          /** Whether the clock should be started in hour or minute view. */
          set: /**
           * Whether the clock should be started in hour or minute view.
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hourView = value != 'minute';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Clock.prototype, "_hand", {
          get: /**
           * @return {?}
           */ function () {
              this._selectedHour = this._util.getHours(this.activeDate);
              this._selectedMinute = this._util.getMinutes(this.activeDate);
              /** @type {?} */
              var deg = 0;
              /** @type {?} */
              var radius = CLOCK_OUTER_RADIUS;
              if (this._hourView) {
                  /** @type {?} */
                  var outer = this.activeDate.getHours() > 0 && this.activeDate.getHours() < 13;
                  radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;
                  if (this.twelvehour) {
                      radius = CLOCK_OUTER_RADIUS;
                  }
                  deg = Math.round(this.activeDate.getHours() * (360 / (24 / 2)));
              }
              else {
                  deg = Math.round(this.activeDate.getMinutes() * (360 / 60));
              }
              return {
                  'transform': "rotate(" + deg + "deg)",
                  'height': radius + "%",
                  'margin-top': 50 - radius + "%"
              };
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      Md2Clock.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this.activeDate = this._activeDate || this._util.today();
              this._init();
          };
      /** Handles mousedown events on the clock body. */
      /**
       * Handles mousedown events on the clock body.
       * @param {?} event
       * @return {?}
       */
      Md2Clock.prototype._handleMousedown = /**
       * Handles mousedown events on the clock body.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this.setTime(event);
              document.addEventListener('mousemove', this.mouseMoveListener);
              document.addEventListener('touchmove', this.mouseMoveListener);
              document.addEventListener('mouseup', this.mouseUpListener);
              document.addEventListener('touchend', this.mouseUpListener);
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Clock.prototype._handleMousemove = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              event.preventDefault();
              this.setTime(event);
          };
      /**
       * @return {?}
       */
      Md2Clock.prototype._handleMouseup = /**
       * @return {?}
       */
          function () {
              document.removeEventListener('mousemove', this.mouseMoveListener);
              document.removeEventListener('touchmove', this.mouseMoveListener);
              document.removeEventListener('mouseup', this.mouseUpListener);
              document.removeEventListener('touchend', this.mouseUpListener);
              this.selectedChange.emit(this.activeDate);
          };
      /**
       * Initializes this clock view.
       * @return {?}
       */
      Md2Clock.prototype._init = /**
       * Initializes this clock view.
       * @return {?}
       */
          function () {
              this._hours.length = 0;
              this._minutes.length = 0;
              /** @type {?} */
              var hourNames = this._locale.getHourNames();
              /** @type {?} */
              var minuteNames = this._locale.getMinuteNames();
              if (this.twelvehour) {
                  for (var i = 1; i < (hourNames.length / 2) + 1; i++) {
                      /** @type {?} */
                      var radian = i / 6 * Math.PI;
                      /** @type {?} */
                      var radius = CLOCK_OUTER_RADIUS;
                      /** @type {?} */
                      var date = new Date(this.activeDate.getTime());
                      date.setHours(i + 1, 0, 0, 0);
                      /** @type {?} */
                      var enabled = this._util.isFullDateWithinRange(date, this.min, this.max);
                      this._hours.push({
                          value: i,
                          displayValue: i === 0 ? '00' : hourNames[i],
                          enabled: enabled,
                          top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,
                          left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS,
                      });
                  }
              }
              else {
                  for (var i = 0; i < hourNames.length; i++) {
                      /** @type {?} */
                      var radian = i / 6 * Math.PI;
                      /** @type {?} */
                      var outer = i > 0 && i < 13;
                      /** @type {?} */
                      var radius = outer ? CLOCK_OUTER_RADIUS : CLOCK_INNER_RADIUS;
                      /** @type {?} */
                      var date = new Date(this.activeDate.getTime());
                      date.setHours(i + 1, 0, 0, 0);
                      /** @type {?} */
                      var enabled = this._util.isFullDateWithinRange(date, this.min, this.max);
                      this._hours.push({
                          value: i,
                          displayValue: i === 0 ? '00' : hourNames[i],
                          enabled: enabled,
                          top: CLOCK_RADIUS - Math.cos(radian) * radius - CLOCK_TICK_RADIUS,
                          left: CLOCK_RADIUS + Math.sin(radian) * radius - CLOCK_TICK_RADIUS,
                          fontSize: i > 0 && i < 13 ? '' : '80%'
                      });
                  }
              }
              for (var i = 0; i < minuteNames.length; i += 5) {
                  /** @type {?} */
                  var radian = i / 30 * Math.PI;
                  /** @type {?} */
                  var date = new Date(this.activeDate.getTime());
                  date.setMinutes(i, 0, 0);
                  /** @type {?} */
                  var enabled = this._util.isFullDateWithinRange(date, this.min, this.max);
                  this._minutes.push({
                      value: i,
                      displayValue: i === 0 ? '00' : minuteNames[i],
                      enabled: enabled,
                      top: CLOCK_RADIUS - Math.cos(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS,
                      left: CLOCK_RADIUS + Math.sin(radian) * CLOCK_OUTER_RADIUS - CLOCK_TICK_RADIUS,
                  });
              }
          };
      /**
       * Set Time
       * @param {?} event
       * @return {?}
       */
      Md2Clock.prototype.setTime = /**
       * Set Time
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var trigger = this._element.nativeElement;
              /** @type {?} */
              var triggerRect = trigger.getBoundingClientRect();
              /** @type {?} */
              var width = trigger.offsetWidth;
              /** @type {?} */
              var height = trigger.offsetHeight;
              /** @type {?} */
              var pageX = event.pageX !== undefined ? event.pageX : event.touches[0].pageX;
              /** @type {?} */
              var pageY = event.pageY !== undefined ? event.pageY : event.touches[0].pageY;
              /** @type {?} */
              var x = (width / 2) - (pageX - triggerRect.left - window.pageXOffset);
              /** @type {?} */
              var y = (height / 2) - (pageY - triggerRect.top - window.pageYOffset);
              /** @type {?} */
              var radian = Math.atan2(-x, y);
              /** @type {?} */
              var unit = Math.PI / (this._hourView ? 6 : (this.interval ? (30 / this.interval) : 30));
              /** @type {?} */
              var z = Math.sqrt(x * x + y * y);
              /** @type {?} */
              var outer = this._hourView && z > ((width * (CLOCK_OUTER_RADIUS / 100)) +
                  (width * (CLOCK_INNER_RADIUS / 100))) / 2;
              /** @type {?} */
              var value = 0;
              if (radian < 0) {
                  radian = Math.PI * 2 + radian;
              }
              value = Math.round(radian / unit);
              radian = value * unit;
              /** @type {?} */
              var date = new Date(this.activeDate.getTime());
              if (this._hourView) {
                  if (this.twelvehour) {
                      value = value === 0 ? 12 : value;
                  }
                  else {
                      if (value === 12) {
                          value = 0;
                      }
                      value = outer ? (value === 0 ? 12 : value) : value === 0 ? 0 : value + 12;
                  }
                  date.setHours(value);
              }
              else {
                  if (this.interval) {
                      value *= this.interval;
                  }
                  if (value === 60) {
                      value = 0;
                  }
                  date.setMinutes(value);
              }
              this.activeDate = this._util.clampDate(date, this.min, this.max);
              this.activeDateChange.emit(this.activeDate);
          };
      Md2Clock.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-clock',
                      template: "<div class=\"md2-clock\">\n  <div class=\"md2-clock-center\"></div>\n  <div class=\"md2-clock-hand\" [ngStyle]=\"_hand\"></div>\n  <div class=\"md2-clock-hours\" [class.active]=\"_hourView\">\n    <div *ngFor=\"let item of _hours\"\n         class=\"md2-clock-cell\"\n         [class.md2-clock-cell-selected]=\"_selectedHour == item.value\"\n         [class.md2-clock-cell-disabled]=\"!item.enabled\"\n         [style.top]=\"item.top+'%'\"\n         [style.left]=\"item.left+'%'\"\n         [style.fontSize]=\"item.fontSize\">{{ item.displayValue }}</div>\n  </div>\n  <div class=\"md2-clock-minutes\" [class.active]=\"!_hourView\">\n    <div *ngFor=\"let item of _minutes\"\n         class=\"md2-clock-cell\"\n         [class.md2-clock-cell-selected]=\"_selectedMinute == item.value\"\n         [class.md2-clock-cell-disabled]=\"!item.enabled\"\n         [style.top]=\"item.top+'%'\"\n         [style.left]=\"item.left+'%'\">{{ item.displayValue }}</div>\n  </div>\n</div>",
                      host: {
                          'role': 'clock',
                          '(mousedown)': '_handleMousedown($event)',
                      },
                      styles: [":host{position:relative;display:block;min-width:224px;margin:8px;font-size:14px;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md2-clock{position:relative;width:100%;height:0;padding-top:100%;background-color:#e0e0e0;border-radius:50%}.md2-clock-center{position:absolute;top:50%;left:50%;width:2%;height:2%;margin:-1%;border-radius:50%;background-color:#106cc8}.md2-clock-hand{position:absolute;top:0;right:0;bottom:0;left:0;width:1px;margin:0 auto;background-color:#106cc8;-webkit-transform-origin:bottom;transform-origin:bottom}.md2-clock-hand::before{content:'';position:absolute;top:-4px;left:-4px;width:8px;height:8px;border-radius:50%;background-color:#106cc8}.md2-clock-hours,.md2-clock-minutes{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;visibility:hidden;transition:350ms;-webkit-transform:scale(1.2);transform:scale(1.2)}.md2-clock-hours.active,.md2-clock-minutes.active{opacity:1;visibility:visible;-webkit-transform:scale(1);transform:scale(1)}.md2-clock-minutes{-webkit-transform:scale(.8);transform:scale(.8)}.md2-clock-cell{position:absolute;display:flex;width:14.1666%;height:14.1666%;color:rgba(0,0,0,.87);justify-content:center;box-sizing:border-box;border-radius:50%;align-items:center;cursor:pointer}.md2-clock-cell:not(.md2-clock-cell-selected):not(.md2-clock-cell-disabled):hover{background-color:rgba(0,0,0,.1)}.md2-clock-cell.md2-clock-cell-disabled{color:rgba(0,0,0,.38);pointer-events:none}.md2-clock-cell.md2-clock-cell-selected{color:#fff;background-color:#1279e0}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Clock.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: DateLocale },
              { type: DateUtil }
          ];
      };
      Md2Clock.propDecorators = {
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          min: [{ type: core.Input }],
          max: [{ type: core.Input }],
          startView: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          interval: [{ type: core.Input }],
          twelvehour: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }],
          activeDateChange: [{ type: core.Output }]
      };
      return Md2Clock;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2DatepickerModule = /** @class */ (function () {
      function Md2DatepickerModule() {
      }
      Md2DatepickerModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          OverlayModule,
                          PortalModule,
                          StyleModule,
                          A11yModule,
                      ],
                      exports: [
                          Md2Datepicker,
                          Md2DatepickerToggle,
                          Md2Calendar,
                          Md2CalendarBody,
                          Md2Calendar,
                          Md2MonthView,
                          Md2YearView,
                          Md2CalendarBody,
                          Md2Clock,
                      ],
                      declarations: [
                          Md2Datepicker,
                          Md2DatepickerContent,
                          Md2DatepickerToggle,
                          Md2Calendar,
                          Md2MonthView,
                          Md2YearView,
                          Md2CalendarBody,
                          Md2Clock,
                      ],
                      providers: [DateLocale, DateUtil],
                      entryComponents: [
                          Md2DatepickerContent
                      ]
                  },] }
      ];
      return Md2DatepickerModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Extends an object with the *enumerable* and *own* properties of one or more source objects,
   * similar to Object.assign.
   *
   * @param {?} dest The object which will have properties copied to it.
   * @param {...?} sources The source objects from which properties will be copied.
   * @return {?}
   */
  function extendObject(dest) {
      var sources = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          sources[_i - 1] = arguments[_i];
      }
      var e_1, _a;
      if (dest == null) {
          throw TypeError('Cannot convert undefined or null to object');
      }
      try {
          for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
              var source = sources_1_1.value;
              if (source != null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          dest[key] = source[key];
                      }
                  }
              }
          }
      }
      catch (e_1_1) {
          e_1 = { error: e_1_1 };
      }
      finally {
          try {
              if (sources_1_1 && !sources_1_1.done && (_a = sources_1.return))
                  _a.call(sources_1);
          }
          finally {
              if (e_1)
                  throw e_1.error;
          }
      }
      return dest;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2DialogConfig = /** @class */ (function () {
      function Md2DialogConfig() {
          this.role = 'dialog';
          this.disableClose = false;
      }
      return Md2DialogConfig;
  }());
  var Md2DialogPortal = /** @class */ (function (_super) {
      __extends(Md2DialogPortal, _super);
      function Md2DialogPortal(templateRef, viewContainerRef) {
          return _super.call(this, templateRef, viewContainerRef) || this;
      }
      Md2DialogPortal.decorators = [
          { type: core.Directive, args: [{ selector: '[md2DialogPortal]' },] }
      ];
      /** @nocollapse */
      Md2DialogPortal.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.ViewContainerRef }
          ];
      };
      return Md2DialogPortal;
  }(TemplatePortalDirective));
  /**
   * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
   */
  var Md2DialogTitle = /** @class */ (function () {
      function Md2DialogTitle() {
      }
      Md2DialogTitle.decorators = [
          { type: core.Directive, args: [{ selector: 'md2-dialog-title' },] }
      ];
      return Md2DialogTitle;
  }());
  /**
   * Scrollable content container of a dialog.
   */
  var Md2DialogContent = /** @class */ (function () {
      function Md2DialogContent() {
      }
      Md2DialogContent.decorators = [
          { type: core.Directive, args: [{ selector: 'md2-dialog-content' },] }
      ];
      return Md2DialogContent;
  }());
  /**
   * Container for the bottom action buttons in a dialog.
   * Stays fixed to the bottom when scrolling.
   */
  var Md2DialogActions = /** @class */ (function () {
      function Md2DialogActions() {
      }
      Md2DialogActions.decorators = [
          { type: core.Directive, args: [{ selector: 'md2-dialog-footer, md2-dialog-actions' },] }
      ];
      return Md2DialogActions;
  }());
  var Md2Dialog = /** @class */ (function () {
      function Md2Dialog(_overlay, _parentDialog) {
          this._overlay = _overlay;
          this._parentDialog = _parentDialog;
          this._openDialogsAtThisLevel = [];
          this._boundKeydown = this._handleKeydown.bind(this);
          this._panelOpen = false;
          this._overlayRef = null;
          /**
           * Property watched by the animation framework to show or hide the dialog
           */
          this._visibility = 'initial';
          this.onOpen = new core.EventEmitter();
          this.onClose = new core.EventEmitter();
      }
      /**
       * @return {?}
       */
      Md2Dialog.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () { this.destroyPanel(); };
      Object.defineProperty(Md2Dialog.prototype, "_openDialogs", {
          get: /**
           * @return {?}
           */ function () {
              return this._parentDialog ? this._parentDialog._openDialogs : this._openDialogsAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      /** Open the dialog */
      /**
       * Open the dialog
       * @param {?=} config
       * @return {?}
       */
      Md2Dialog.prototype.open = /**
       * Open the dialog
       * @param {?=} config
       * @return {?}
       */
          function (config) {
              this.config = _applyConfigDefaults(config);
              if (this._panelOpen) {
                  return Promise.resolve(this);
              }
              this._createOverlay();
              this._overlayRef.attach(this._portal);
              this._subscribeToBackdrop();
              if (!this._openDialogs.length && !this._parentDialog) {
                  document.addEventListener('keydown', this._boundKeydown);
              }
              this._openDialogs.push(this);
              this._panelOpen = true;
              this._visibility = 'visible';
              return Promise.resolve(this);
          };
      /** Close the dialog */
      /**
       * Close the dialog
       * @return {?}
       */
      Md2Dialog.prototype.close = /**
       * Close the dialog
       * @return {?}
       */
          function () {
              this._visibility = 'hidden';
              this._panelOpen = false;
              if (this._overlayRef) {
                  this._overlayRef.detach();
                  if (this._backdropSubscription) {
                      this._backdropSubscription.unsubscribe();
                  }
              }
              /** @type {?} */
              var index = this._openDialogs.indexOf(this);
              if (index > -1) {
                  this._openDialogs.splice(index, 1);
                  // no open dialogs are left, call next on afterAllClosed Subject
                  if (!this._openDialogs.length) {
                      document.removeEventListener('keydown', this._boundKeydown);
                  }
              }
              return Promise.resolve(this);
          };
      /** Removes the panel from the DOM. */
      /**
       * Removes the panel from the DOM.
       * @return {?}
       */
      Md2Dialog.prototype.destroyPanel = /**
       * Removes the panel from the DOM.
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.dispose();
                  this._overlayRef = null;
                  this._cleanUpSubscriptions();
              }
          };
      /**
       * @return {?}
       */
      Md2Dialog.prototype._onPanelDone = /**
       * @return {?}
       */
          function () {
              if (this._panelOpen) {
                  this.onOpen.emit(this);
              }
              else {
                  this.onClose.emit(this);
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Dialog.prototype._handleKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var topDialog = this._openDialogs[this._openDialogs.length - 1];
              if (event.keyCode === ESCAPE && topDialog &&
                  !topDialog.config.disableClose) {
                  topDialog.close();
              }
          };
      /**
       * @return {?}
       */
      Md2Dialog.prototype._subscribeToBackdrop = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.config.disableClose) {
                  this._backdropSubscription = this._overlayRef.backdropClick().pipe(operators.first()).subscribe(function () {
                      return _this.close();
                  });
              }
          };
      /**
       * @return {?}
       */
      Md2Dialog.prototype._createOverlay = /**
       * @return {?}
       */
          function () {
              if (!this._overlayRef) {
                  /** @type {?} */
                  var config = new OverlayState();
                  config.positionStrategy = this._overlay.position()
                      .global()
                      .centerHorizontally()
                      .centerVertically();
                  config.hasBackdrop = true;
                  this._overlayRef = this._overlay.create(config);
              }
          };
      /**
       * @return {?}
       */
      Md2Dialog.prototype._cleanUpSubscriptions = /**
       * @return {?}
       */
          function () {
              if (this._backdropSubscription) {
                  this._backdropSubscription.unsubscribe();
              }
          };
      Md2Dialog.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-dialog',
                      template: "<ng-template md2DialogPortal>\n  <div class=\"md2-dialog-panel\" [attr.role]=\"config?.role\">\n    <!--[@state]=\"_visibility\" (@state.done)=\"_onPanelDone()\"-->\n    <div class=\"md2-dialog-content\">\n      <div class=\"md2-dialog-header\">\n        <button *ngIf=\"!config.disableClose\" type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">&times;</button>\n        <h2 *ngIf=\"dialogTitle\" class=\"md2-dialog-title\" id=\"myDialogLabel\" [innerHtml]=\"dialogTitle\"></h2>\n        <ng-content select=\"md2-dialog-title\"></ng-content>\n      </div>\n      <div class=\"md2-dialog-body\">\n        <ng-content select=\"md2-dialog-content\"></ng-content>\n        <ng-content></ng-content>\n      </div>\n      <ng-content select=\"md2-dialog-footer\"></ng-content>\n      <ng-content select=\"md2-dialog-actions\"></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                      host: {
                          'tabindex': '0',
                          '[attr.role]': 'config?.role',
                      },
                      animations: [
                          animations.trigger('state', [
                              animations.state('void', animations.style({ transform: 'scale(0.3)' })),
                              animations.state('initial', animations.style({ transform: 'scale(0.3)' })),
                              animations.state('visible', animations.style({ transform: 'scale(1)' })),
                              animations.state('hidden', animations.style({ transform: 'scale(0.3)' })),
                              animations.transition('* => visible', animations.animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
                              animations.transition('* => hidden', animations.animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
                          ])
                      ],
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'md2Dialog',
                      styles: [".md2-dialog-panel{position:relative;max-width:90vw;width:600px;border-radius:3px;background-color:#fff;overflow:hidden;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.md2-dialog-header{background:#2196f3;color:#fff;font-size:25px;line-height:1.1;font-weight:500;padding:0 48px 0 16px;border-bottom:1px solid #e5e5e5;word-wrap:break-word}.md2-dialog-header .close{position:absolute;top:21px;right:16px;display:inline-block;width:18px;height:18px;overflow:hidden;-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0;outline:0;opacity:.8;font-size:0;z-index:1;box-shadow:none;margin:0}.md2-dialog-header .close::after,.md2-dialog-header .close::before{content:'';position:absolute;top:50%;left:0;width:100%;height:2px;margin-top:-1px;background:#ccc;border-radius:2px}.md2-dialog-header .close::before{-webkit-transform:rotate(45deg);transform:rotate(45deg)}.md2-dialog-header .close::after{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.md2-dialog-header .close:hover{opacity:1}.md2-dialog-header .md2-dialog-title,.md2-dialog-header md2-dialog-title{display:block;margin:0;padding:16px 0;font-size:25px;font-weight:500}.md2-dialog-header dialog-header{line-height:33px}.md2-dialog-body{position:relative;max-height:65vh;padding:16px;overflow-y:auto}.md2-dialog-footer,md2-dialog-footer{display:block;padding:16px;text-align:right;border-top:1px solid rgba(0,0,0,.12)}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.48}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.6)}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Dialog.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: Md2Dialog, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
          ];
      };
      Md2Dialog.propDecorators = {
          onOpen: [{ type: core.Output }],
          onClose: [{ type: core.Output }],
          _portal: [{ type: core.ViewChild, args: [Md2DialogPortal,] }],
          dialogTitle: [{ type: core.Input, args: ['title',] }]
      };
      return Md2Dialog;
  }());
  /**
   * Applies default options to the dialog config.
   * @param {?} dialogConfig Config to be modified.
   * @return {?} The new configuration object.
   */
  function _applyConfigDefaults(dialogConfig) {
      return extendObject(new Md2DialogConfig(), dialogConfig);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2DialogModule = /** @class */ (function () {
      function Md2DialogModule() {
      }
      Md2DialogModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, OverlayModule, MdCommonModule, PlatformModule],
                      exports: [
                          Md2Dialog,
                          Md2DialogTitle,
                          Md2DialogContent,
                          Md2DialogActions,
                          Md2DialogPortal
                      ],
                      declarations: [
                          Md2Dialog,
                          Md2DialogTitle,
                          Md2DialogContent,
                          Md2DialogActions,
                          Md2DialogPortal
                      ]
                  },] }
      ];
      return Md2DialogModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2MenuContent = /** @class */ (function () {
      function Md2MenuContent() {
      }
      Md2MenuContent.decorators = [
          { type: core.Component, args: [{
                      selector: '[md2-menu-content]',
                      host: { 'role': 'menu' },
                      template: '<ng-content></ng-content>',
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["[md2-menu]{position:relative;display:inline-block}[md2-menu-content]{position:absolute;top:0;left:0;display:inline-block;background:#fff;list-style:none;min-width:112px;max-width:280px;max-height:calc(100vh + 48px);padding:8px 0;margin:0;z-index:1001;border-radius:2px;-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;transform-origin:left top;transition:.2s linear;box-shadow:0 2px 6px 1px rgba(0,0,0,.34)}[md2-menu-item] [md2-menu-content]{left:100%;margin:-8px 0}[md2-menu-content][x-position=before]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top}[md2-menu-item] [md2-menu-content][x-position=before]{right:100%}[md2-menu-content][y-position=above]{top:auto;bottom:0;-webkit-transform-origin:left bottom;transform-origin:left bottom}[md2-menu-content][y-position=above][x-position=before]{-webkit-transform-origin:right bottom;transform-origin:right bottom}.open>[md2-menu-content]{-webkit-transform:scale(1);transform:scale(1)}[md2-menu-item]{position:relative;width:100%;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;white-space:nowrap;text-overflow:ellipsis;display:flex;flex-direction:row;align-items:center;height:36px;padding:0 16px;font-size:16px;text-align:start;text-decoration:none;background:0 0;color:rgba(0,0,0,.87);box-sizing:border-box}[md2-menu-item][disabled]{color:rgba(0,0,0,.38)}[md2-menu-item].open,[md2-menu-item]:focus:not([disabled]),[md2-menu-item]:hover:not([disabled]){background:rgba(0,0,0,.04);text-decoration:none}[md2-menu-item]>[md2-menu-trigger]{display:block;height:36px;width:calc(100% + 32px);margin:0 -16px;padding:0 16px;font:inherit;color:inherit;text-align:left;background:0 0;outline:0;border:0;cursor:pointer;box-shadow:none}.md-overlay-container{position:fixed;pointer-events:none;top:0;left:0;height:100%;width:100%;z-index:1000}.md-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.md-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.md-overlay-transparent-backdrop{background:0 0}.md-overlay-backdrop.md-overlay-backdrop-showing{opacity:.48}"]
                  }] }
      ];
      return Md2MenuContent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2MenuItem = /** @class */ (function () {
      function Md2MenuItem() {
      }
      Md2MenuItem.decorators = [
          { type: core.Component, args: [{
                      selector: '[md2-menu-item]',
                      host: {
                          'role': 'menuitem'
                      },
                      template: '<ng-content></ng-content>'
                  }] }
      ];
      return Md2MenuItem;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2MenuTrigger = /** @class */ (function () {
      function Md2MenuTrigger(_element, _renderer) {
          this._element = _element;
          this._renderer = _renderer;
      }
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._handleClick = this._renderer.listenGlobal('document', 'click', function (event) {
                  if (!_this._hasChildMenu(event)) {
                      _this._closeMenu();
                  }
              });
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._handleClick = null;
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype._toggleMenu = /**
       * @return {?}
       */
          function () {
              if (this._hasClass(this._getParentElement(), 'open')) {
                  this._closeMenu();
              }
              else {
                  this._openMenu();
              }
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype._openMenu = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._getParentElement().classList.add('open');
              /** @type {?} */
              var siblingElements = this._getSiblingElements(this._getParentElement());
              siblingElements.forEach(function (el) {
                  el.classList.remove('open');
                  _this._closeChildrenMenu(el);
              });
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype._closeMenu = /**
       * @return {?}
       */
          function () {
              this._getParentElement().classList.remove('open');
              this._closeChildrenMenu(this._getParentElement());
          };
      /**
       * @param {?} element
       * @return {?}
       */
      Md2MenuTrigger.prototype._closeChildrenMenu = /**
       * @param {?} element
       * @return {?}
       */
          function (element) {
              [].forEach.call(element.querySelectorAll('.open'), function (el) {
                  el.classList.remove('open');
              });
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype._getHostElement = /**
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      /**
       * @return {?}
       */
      Md2MenuTrigger.prototype._getParentElement = /**
       * @return {?}
       */
          function () {
              return this._element.nativeElement.parentNode;
          };
      /**
       * @param {?} element
       * @return {?}
       */
      Md2MenuTrigger.prototype._getSiblingElements = /**
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var siblingElements = [];
              /** @type {?} */
              var el = element.parentNode.firstChild;
              for (; el; el = el.nextSibling) {
                  if (el.nodeType == 1 && el !== element) {
                      siblingElements.push(el);
                  }
              }
              return siblingElements;
          };
      /**
       * @param {?} element
       * @param {?} target
       * @return {?}
       */
      Md2MenuTrigger.prototype._getClosestElement = /**
       * @param {?} element
       * @param {?} target
       * @return {?}
       */
          function (element, target) {
              if (element.hasAttribute(target)) {
                  return element;
              }
              /** @type {?} */
              var parentEl;
              while (element) {
                  parentEl = element.parentElement;
                  if (parentEl && parentEl.hasAttribute(target)) {
                      return parentEl;
                  }
                  element = parentEl;
              }
              return null;
          };
      /**
       * @param {?} element
       * @param {?} className
       * @return {?}
       */
      Md2MenuTrigger.prototype._hasClass = /**
       * @param {?} element
       * @param {?} className
       * @return {?}
       */
          function (element, className) {
              return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2MenuTrigger.prototype._hasChildMenu = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var el = this._getClosestElement(event.target, 'md2-menu-trigger');
              if (el && el === this._getHostElement()) {
                  return true;
              }
              else if (this._getParentElement().contains(event.target)) {
                  el = this._getClosestElement(event.target, 'md2-menu-item');
                  if (el && el.querySelectorAll('[md2-menu-content]').length > 0) {
                      return true;
                  }
                  else {
                      return false;
                  }
              }
              else {
                  return false;
              }
          };
      Md2MenuTrigger.decorators = [
          { type: core.Directive, args: [{
                      selector: '[md2-menu-trigger]',
                      host: {
                          'aria-haspopup': 'true',
                          '(click)': '_toggleMenu()',
                      },
                      exportAs: 'md2MenuTrigger'
                  },] }
      ];
      /** @nocollapse */
      Md2MenuTrigger.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.Renderer }
          ];
      };
      return Md2MenuTrigger;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2Menu = /** @class */ (function () {
      function Md2Menu() {
      }
      Md2Menu.decorators = [
          { type: core.Component, args: [{
                      selector: '[md2-menu]',
                      template: '<ng-content></ng-content>',
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["[md2-menu]{position:relative;display:inline-block}[md2-menu-content]{position:absolute;top:0;left:0;display:inline-block;background:#fff;list-style:none;min-width:112px;max-width:280px;max-height:calc(100vh + 48px);padding:8px 0;margin:0;z-index:1001;border-radius:2px;-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;transform-origin:left top;transition:.2s linear;box-shadow:0 2px 6px 1px rgba(0,0,0,.34)}[md2-menu-item] [md2-menu-content]{left:100%;margin:-8px 0}[md2-menu-content][x-position=before]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top}[md2-menu-item] [md2-menu-content][x-position=before]{right:100%}[md2-menu-content][y-position=above]{top:auto;bottom:0;-webkit-transform-origin:left bottom;transform-origin:left bottom}[md2-menu-content][y-position=above][x-position=before]{-webkit-transform-origin:right bottom;transform-origin:right bottom}.open>[md2-menu-content]{-webkit-transform:scale(1);transform:scale(1)}[md2-menu-item]{position:relative;width:100%;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;white-space:nowrap;text-overflow:ellipsis;display:flex;flex-direction:row;align-items:center;height:36px;padding:0 16px;font-size:16px;text-align:start;text-decoration:none;background:0 0;color:rgba(0,0,0,.87);box-sizing:border-box}[md2-menu-item][disabled]{color:rgba(0,0,0,.38)}[md2-menu-item].open,[md2-menu-item]:focus:not([disabled]),[md2-menu-item]:hover:not([disabled]){background:rgba(0,0,0,.04);text-decoration:none}[md2-menu-item]>[md2-menu-trigger]{display:block;height:36px;width:calc(100% + 32px);margin:0 -16px;padding:0 16px;font:inherit;color:inherit;text-align:left;background:0 0;outline:0;border:0;cursor:pointer;box-shadow:none}.md-overlay-container{position:fixed;pointer-events:none;top:0;left:0;height:100%;width:100%;z-index:1000}.md-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}.md-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1;pointer-events:auto;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.md-overlay-transparent-backdrop{background:0 0}.md-overlay-backdrop.md-overlay-backdrop-showing{opacity:.48}"]
                  }] }
      ];
      return Md2Menu;
  }());
  var Md2MenuModule = /** @class */ (function () {
      function Md2MenuModule() {
      }
      Md2MenuModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule],
                      exports: [Md2Menu, Md2MenuContent, Md2MenuItem, Md2MenuTrigger],
                      declarations: [Md2Menu, Md2MenuContent, Md2MenuItem, Md2MenuTrigger],
                  },] }
      ];
      return Md2MenuModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /**
   * Change event object that is emitted when the tab has changed.
   */
  var /**
   * Change event object that is emitted when the tab has changed.
   */ Md2TabChange = /** @class */ (function () {
      function Md2TabChange(tab, index) {
          this.tab = tab;
          this.index = index;
      }
      return Md2TabChange;
  }());
  var Md2Transclude = /** @class */ (function () {
      function Md2Transclude(viewRef) {
          this.viewRef = viewRef;
      }
      Object.defineProperty(Md2Transclude.prototype, "md2Transclude", {
          get: /**
           * @return {?}
           */ function () { return this._md2Transclude; },
          set: /**
           * @param {?} templateRef
           * @return {?}
           */ function (templateRef) {
              this._md2Transclude = templateRef;
              if (templateRef) {
                  this.viewRef.createEmbeddedView(templateRef);
              }
          },
          enumerable: true,
          configurable: true
      });
      Md2Transclude.decorators = [
          { type: core.Directive, args: [{ selector: '[md2Transclude]' },] }
      ];
      /** @nocollapse */
      Md2Transclude.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef }
          ];
      };
      Md2Transclude.propDecorators = {
          md2Transclude: [{ type: core.Input }]
      };
      return Md2Transclude;
  }());
  var Md2Tab = /** @class */ (function () {
      function Md2Tab() {
      }
      Md2Tab.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-tab',
                      template: "<ng-content></ng-content>",
                      host: {
                          '[class]': 'class',
                          '[class.active]': 'active'
                      }
                  }] }
      ];
      Md2Tab.propDecorators = {
          label: [{ type: core.Input }],
          active: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          class: [{ type: core.Input }]
      };
      return Md2Tab;
  }());
  var Md2TabLabel = /** @class */ (function () {
      function Md2TabLabel(templateRef, tab) {
          this.templateRef = templateRef;
          tab.labelRef = templateRef;
      }
      Md2TabLabel.decorators = [
          { type: core.Directive, args: [{ selector: '[md2-tab-label]' },] }
      ];
      /** @nocollapse */
      Md2TabLabel.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: Md2Tab }
          ];
      };
      return Md2TabLabel;
  }());
  var Md2Tabs = /** @class */ (function () {
      function Md2Tabs(elementRef) {
          this.elementRef = elementRef;
          this._isInitialized = false;
          this._focusIndex = 0;
          this._selectedIndex = 0;
          this._shouldPaginate = false;
          this._offsetLeft = 0;
          this._inkBarLeft = '0';
          this._inkBarWidth = '0';
          this.change = new core.EventEmitter();
          this.selectedIndexChange = new core.EventEmitter();
      }
      Object.defineProperty(Md2Tabs.prototype, "selectedIndex", {
          get: /**
           * @return {?}
           */ function () { return this._selectedIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (typeof value === 'string') {
                  value = parseInt(value);
              }
              if (value !== this._selectedIndex) {
                  this._selectedIndex = value;
                  this.adjustOffset(value);
                  this._updateInkBar();
                  if (this.tabs) {
                      /** @type {?} */
                      var tabs = this.tabs.toArray();
                      if (!tabs[value].disabled) {
                          tabs.forEach(function (tab) { return tab.active = false; });
                          tabs[value].active = true;
                      }
                  }
                  if (this._isInitialized) {
                      this._emitChangeEvent();
                      this.selectedIndexChange.emit(value);
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tabs.prototype, "focusIndex", {
          get: /**
           * @return {?}
           */ function () { return this._focusIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._focusIndex = value;
              this.adjustOffset(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tabs.prototype, "element", {
          get: /**
           * @return {?}
           */ function () {
              /** @type {?} */
              var elements = {
                  root: this.elementRef.nativeElement,
                  wrapper: null,
                  canvas: null,
                  paging: null,
                  tabs: null
              };
              elements.wrapper = elements.root.querySelector('.md2-tabs-header-wrapper');
              elements.canvas = elements.wrapper.querySelector('.md2-tabs-canvas');
              elements.paging = elements.canvas.querySelector('.md2-tabs-header');
              elements.tabs = elements.paging.querySelectorAll('.md2-tab-label');
              return elements;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * After Content Init
       */
      /**
       * After Content Init
       * @return {?}
       */
      Md2Tabs.prototype.ngAfterContentInit = /**
       * After Content Init
       * @return {?}
       */
          function () {
              var _this = this;
              setTimeout(function () {
                  _this.updatePagination();
              }, 0);
              setTimeout(function () {
                  /** @type {?} */
                  var tabs = _this.tabs.toArray();
                  if (_this.selectedIndex) {
                      if (_this.selectedIndex >= tabs.length) {
                          _this.selectedIndex = 0;
                      }
                      tabs.forEach(function (tab) { return tab.active = false; });
                      tabs[_this.selectedIndex].active = true;
                      _this.adjustOffset(_this.selectedIndex);
                  }
                  else {
                      /** @type {?} */
                      var index = tabs.findIndex(function (t) { return t.active; });
                      if (index < 0) {
                          tabs[0].active = true;
                      }
                      else {
                          _this.selectedIndex = index;
                      }
                  }
                  _this._updateInkBar();
              }, 0);
              this._isInitialized = true;
          };
      /**
       * Calculates the styles from the selected tab for the ink-bar.
       * @return {?}
       */
      Md2Tabs.prototype._updateInkBar = /**
       * Calculates the styles from the selected tab for the ink-bar.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elements = this.element;
              if (!elements.tabs[this.selectedIndex]) {
                  return;
              }
              /** @type {?} */
              var tab = elements.tabs[this.selectedIndex];
              this._inkBarLeft = tab.offsetLeft + 'px';
              this._inkBarWidth = tab.offsetWidth + 'px';
          };
      /** Emits an event when the user selects an option. */
      /**
       * Emits an event when the user selects an option.
       * @return {?}
       */
      Md2Tabs.prototype._emitChangeEvent = /**
       * Emits an event when the user selects an option.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var index = this._selectedIndex;
              this.change.emit(new Md2TabChange(this.tabs.toArray()[index], index));
          };
      /**
       * Focus next Tab
       */
      /**
       * Focus next Tab
       * @return {?}
       */
      Md2Tabs.prototype.focusNextTab = /**
       * Focus next Tab
       * @return {?}
       */
          function () { this.incrementIndex(1); };
      /**
       * Focus previous Tab
       */
      /**
       * Focus previous Tab
       * @return {?}
       */
      Md2Tabs.prototype.focusPreviousTab = /**
       * Focus previous Tab
       * @return {?}
       */
          function () { this.incrementIndex(-1); };
      /**
       * Mouse Wheel scroll
       * @param event
       */
      /**
       * Mouse Wheel scroll
       * @param {?} event
       * @return {?}
       */
      Md2Tabs.prototype.scroll = /**
       * Mouse Wheel scroll
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!this._shouldPaginate) {
                  return;
              }
              event.preventDefault();
              this._offsetLeft = this.fixOffset(this._offsetLeft - event.wheelDelta);
          };
      /**
       * Next Page
       */
      /**
       * Next Page
       * @return {?}
       */
      Md2Tabs.prototype.nextPage = /**
       * Next Page
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elements = this.element;
              /** @type {?} */
              var viewportWidth = elements.canvas.clientWidth;
              /** @type {?} */
              var totalWidth = viewportWidth + this._offsetLeft;
              /** @type {?} */
              var i;
              /** @type {?} */
              var tab;
              for (i = 0; i < elements.tabs.length; i++) {
                  tab = elements.tabs[i];
                  if (tab.offsetLeft + tab.offsetWidth > totalWidth) {
                      break;
                  }
              }
              this._offsetLeft = this.fixOffset(tab.offsetLeft);
          };
      /**
       * Previous Page
       */
      /**
       * Previous Page
       * @return {?}
       */
      Md2Tabs.prototype.previousPage = /**
       * Previous Page
       * @return {?}
       */
          function () {
              /** @type {?} */
              var i;
              /** @type {?} */
              var tab;
              /** @type {?} */
              var elements = this.element;
              for (i = 0; i < elements.tabs.length; i++) {
                  tab = elements.tabs[i];
                  if (tab.offsetLeft + tab.offsetWidth >= this._offsetLeft) {
                      break;
                  }
              }
              this._offsetLeft = this.fixOffset(tab.offsetLeft +
                  tab.offsetWidth - elements.canvas.clientWidth);
          };
      /**
       * On Window Resize
       * @param event
       */
      /**
       * On Window Resize
       * @return {?}
       */
      Md2Tabs.prototype.onWindowResize = /**
       * On Window Resize
       * @return {?}
       */
          function () {
              this._offsetLeft = this.fixOffset(this._offsetLeft);
              this.updatePagination();
          };
      /**
       * Can page Back
       */
      /**
       * Can page Back
       * @return {?}
       */
      Md2Tabs.prototype.canPageBack = /**
       * Can page Back
       * @return {?}
       */
          function () { return this._offsetLeft > 0; };
      /**
       * Can page Previous
       */
      /**
       * Can page Previous
       * @return {?}
       */
      Md2Tabs.prototype.canPageForward = /**
       * Can page Previous
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elements = this.element;
              /** @type {?} */
              var lastTab = elements.tabs[elements.tabs.length - 1];
              return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth +
                  this._offsetLeft;
          };
      /**
       * Update Pagination
       */
      /**
       * Update Pagination
       * @return {?}
       */
      Md2Tabs.prototype.updatePagination = /**
       * Update Pagination
       * @return {?}
       */
          function () {
              /** @type {?} */
              var canvasWidth = this.element.root.clientWidth;
              /** @type {?} */
              var tabs = this.element.tabs ? this.element.tabs : [];
              for (var i = 0; i < tabs.length; i++) {
                  canvasWidth -= tabs[i].offsetWidth;
              }
              this._shouldPaginate = canvasWidth < 0;
          };
      /**
       * Increment Focus Tab
       * @param inc
       */
      /**
       * Increment Focus Tab
       * @param {?} inc
       * @return {?}
       */
      Md2Tabs.prototype.incrementIndex = /**
       * Increment Focus Tab
       * @param {?} inc
       * @return {?}
       */
          function (inc) {
              /** @type {?} */
              var newIndex;
              /** @type {?} */
              var index = this.focusIndex;
              for (newIndex = index + inc; this.tabs.toArray()[newIndex] && this.tabs.toArray()[newIndex].disabled; newIndex += inc) { }
              if (this.tabs.toArray()[newIndex]) {
                  this.focusIndex = newIndex;
              }
          };
      /**
       * Adjust Offset of Tab
       * @param index
       */
      /**
       * Adjust Offset of Tab
       * @param {?} index
       * @return {?}
       */
      Md2Tabs.prototype.adjustOffset = /**
       * Adjust Offset of Tab
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var elements = this.element;
              if (!elements.tabs[index]) {
                  return;
              }
              /** @type {?} */
              var tab = elements.tabs[index];
              /** @type {?} */
              var left = tab.offsetLeft;
              /** @type {?} */
              var right = tab.offsetWidth + left;
              this._offsetLeft = Math.max(this._offsetLeft, this.fixOffset(right - elements.canvas.clientWidth + 32 * 2));
              this._offsetLeft = Math.min(this._offsetLeft, this.fixOffset(left));
          };
      /**
       * Fix Offset of Tab
       * @param value
       * @return value
       */
      /**
       * Fix Offset of Tab
       * @param {?} value
       * @return {?} value
       */
      Md2Tabs.prototype.fixOffset = /**
       * Fix Offset of Tab
       * @param {?} value
       * @return {?} value
       */
          function (value) {
              /** @type {?} */
              var elements = this.element;
              if (!elements.tabs.length || !this._shouldPaginate) {
                  return 0;
              }
              /** @type {?} */
              var lastTab = elements.tabs[elements.tabs.length - 1];
              /** @type {?} */
              var totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
              value = Math.min(totalWidth - elements.canvas.clientWidth, value);
              value = Math.max(0, value);
              return value;
          };
      Md2Tabs.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-tabs',
                      template: "<div class=\"md2-tabs-header-wrapper\">\n  <div role=\"button\" class=\"md2-prev-button\" [class.disabled]=\"!canPageBack()\" *ngIf=\"_shouldPaginate\" (click)=\"previousPage()\">\n    <em class=\"prev-icon\">Prev</em>\n  </div>\n  <div role=\"button\" class=\"md2-next-button\" [class.disabled]=\"!canPageForward()\" *ngIf=\"_shouldPaginate\" (click)=\"nextPage()\">\n    <em class=\"next-icon\">Next</em>\n  </div>\n  <div class=\"md2-tabs-canvas\" [class.md2-paginated]=\"_shouldPaginate\" role=\"tablist\" tabindex=\"0\" (keydown.arrowRight)=\"focusNextTab()\" (keydown.arrowLeft)=\"focusPreviousTab()\" (keydown.enter)=\"selectedIndex = focusIndex\" (mousewheel)=\"scroll($event)\">\n    <div class=\"md2-tabs-header\" [style.marginLeft.px]=\"-_offsetLeft\">\n      <div class=\"md2-tab-label\" role=\"tab\" *ngFor=\"let tab of tabs; let i = index\" [class.focus]=\"focusIndex === i\" [class.active]=\"selectedIndex === i\" [class.disabled]=\"tab.disabled\" (click)=\"focusIndex = selectedIndex = i\">\n        <span [md2Transclude]=\"tab.labelRef\">{{tab.label}}</span>\n      </div>\n      <div class=\"md2-tab-ink-bar\" [style.left]=\"_inkBarLeft\" [style.width]=\"_inkBarWidth\"></div>\n    </div>\n  </div>\n</div>\n<div class=\"md2-tabs-body-wrapper\">\n  <ng-content></ng-content>\n</div>\n",
                      host: {
                          '[class]': 'class',
                          '(window:resize)': 'onWindowResize()'
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["md2-tabs{position:relative;overflow:hidden;display:block;margin:0;border:1px solid #e1e1e1;border-radius:2px}.md2-tabs-header-wrapper{position:relative;display:block;height:48px;background:#fff;border-width:0 0 1px;border-style:solid;border-color:rgba(0,0,0,.12);margin:0;padding:0;list-style:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md2-tabs-header-wrapper::after{content:'';display:table;clear:both}.md2-next-button,.md2-prev-button{position:absolute;top:0;height:100%;width:32px;padding:8px 0;z-index:2;cursor:pointer}.md2-next-button.disabled,.md2-prev-button.disabled{opacity:.25;cursor:default}.md2-prev-button{left:0}.md2-next-button{right:0}.md2-next-button .next-icon,.md2-prev-button .prev-icon{display:block;width:12px;height:12px;font-size:0;border-width:0 0 2px 2px;border-style:solid;border-color:#757575;border-radius:1px;-webkit-transform:rotate(45deg);transform:rotate(45deg);margin:10px}.md2-next-button .next-icon{border-width:2px 2px 0 0}.md2-tabs-canvas{position:relative;height:100%;overflow:hidden;display:block;outline:0}.md2-tabs-canvas.md2-paginated{margin:0 32px}.md2-tabs-header{position:relative;display:inline-block;height:100%;white-space:nowrap;transition:.5s cubic-bezier(.35,0,.25,1)}.md2-tab-label{position:relative;height:100%;color:rgba(0,0,0,.54);font-size:14px;text-align:center;line-height:24px;padding:12px 24px;transition:background-color 350ms cubic-bezier(.35,0,.25,1);cursor:pointer;white-space:nowrap;text-transform:uppercase;display:inline-block;font-weight:500;box-sizing:border-box;overflow:hidden;-ms-text-overflow:ellipsis;text-overflow:ellipsis}.md2-tab-label.active{color:#106cc8}.md2-tabs-canvas:focus .md2-tab-label.focus{background:rgba(0,0,0,.05)}.md2-tab-label.disabled{color:rgba(0,0,0,.26);pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none;opacity:.5;cursor:default}.md2-tab-ink-bar{position:absolute;bottom:0;height:2px;background:#ff5252;transition:250ms cubic-bezier(.35,0,.25,1)}.md2-tabs-body-wrapper{position:relative;min-height:0;display:block;clear:both}md2-tab{padding:16px;display:none;position:relative}md2-tab.active{display:block;position:relative}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Tabs.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      Md2Tabs.propDecorators = {
          tabs: [{ type: core.ContentChildren, args: [Md2Tab,] }],
          class: [{ type: core.Input }],
          selectedIndex: [{ type: core.Input }],
          change: [{ type: core.Output }],
          selectedIndexChange: [{ type: core.Output }]
      };
      return Md2Tabs;
  }());
  /** @type {?} */
  var MD2_TABS_DIRECTIVES = [Md2TabLabel, Md2Tabs, Md2Tab];
  var Md2TabsModule = /** @class */ (function () {
      function Md2TabsModule() {
      }
      Md2TabsModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule],
                      exports: MD2_TABS_DIRECTIVES,
                      declarations: [Md2Transclude, Md2TabLabel, Md2Tabs, Md2Tab],
                  },] }
      ];
      return Md2TabsModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var noop = function () { };
  /** @type {?} */
  var nextId$4 = 0;
  var Tag = /** @class */ (function () {
      function Tag(source, textKey, valueKey) {
          if (typeof source === 'string') {
              this.text = this.value = source;
          }
          if (typeof source === 'object') {
              this.text = source[textKey];
              this.value = valueKey ? source[valueKey] : source;
          }
      }
      return Tag;
  }());
  /** @type {?} */
  var MD2_TAGS_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return Md2Tags; }),
      multi: true
  };
  var Md2Tags = /** @class */ (function () {
      function Md2Tags(_element) {
          this._element = _element;
          this.change = new core.EventEmitter();
          this._value = '';
          this._disabled = false;
          this._isInitialized = false;
          this._onTouchedCallback = noop;
          this._onChangeCallback = noop;
          this._tags = [];
          this._list = [];
          this._items = [];
          this._focusedTag = 0;
          this._selectedTag = -1;
          this._inputValue = '';
          this._inputFocused = false;
          this.noBlur = true;
          this.id = 'md2-tags-' + (++nextId$4);
          this.tabindex = 0;
          this.placeholder = '';
          this.textKey = 'text';
          this.valueKey = null;
          this.selectAndFocusTagSafe = function (index) {
              if (!this._items.length) {
                  this._selectTag(-1);
                  this._handleFocus();
                  return;
              }
              if (index === this._items.length) {
                  return this._handleFocus();
              }
              index = Math.max(index, 0);
              index = Math.min(index, this._items.length - 1);
              this._selectTag(index);
          };
      }
      /**
       * @return {?}
       */
      Md2Tags.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () { this._isInitialized = true; };
      Object.defineProperty(Md2Tags.prototype, "disabled", {
          get: /**
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tags.prototype, "tags", {
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._tags = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tags.prototype, "value", {
          get: /**
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.setValue(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * setup value
       * @param {?} value
       * @return {?}
       */
      Md2Tags.prototype.setValue = /**
       * setup value
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              if (value !== this._value) {
                  this._value = value;
                  this._items = [];
                  if (value && value.length && typeof value === 'object' && Array.isArray(value)) {
                      var _loop_1 = function (i) {
                          /** @type {?} */
                          var selItm = this_1._tags.find(function (t) {
                              return _this.equals(_this.valueKey ?
                                  t[_this.valueKey] : t, value[i]);
                          });
                          if (selItm) {
                              this_1._items.push(new Tag(selItm, this_1.textKey, this_1.valueKey));
                          }
                      };
                      var this_1 = this;
                      for (var i = 0; i < value.length; i++) {
                          _loop_1(i);
                      }
                  }
                  if (this._isInitialized) {
                      this._onChangeCallback(value);
                      this.change.emit(this._value);
                  }
              }
          };
      /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
      Md2Tags.prototype.equals = /**
       * Compare two vars or objects
       * @param {?} o1 compare first object
       * @param {?} o2 compare second object
       * @return {?} boolean comparation result
       */
          function (o1, o2) {
              if (o1 === o2) {
                  return true;
              }
              if (o1 === null || o2 === null) {
                  return false;
              }
              if (o1 !== o1 && o2 !== o2) {
                  return true;
              }
              /** @type {?} */
              var t1 = typeof o1;
              /** @type {?} */
              var t2 = typeof o2;
              /** @type {?} */
              var key;
              /** @type {?} */
              var keySet;
              if (t1 === t2 && t1 === 'object') {
                  keySet = Object.create(null);
                  for (key in o1) {
                      if (!this.equals(o1[key], o2[key])) {
                          return false;
                      }
                      keySet[key] = true;
                  }
                  for (key in o2) {
                      if (!(key in keySet) && key.charAt(0) !== '$' && o2[key]) {
                          return false;
                      }
                  }
                  return true;
              }
              return false;
          };
      Object.defineProperty(Md2Tags.prototype, "isMenuVisible", {
          get: /**
           * @return {?}
           */ function () {
              return ((this._inputFocused || this.noBlur) && this._inputValue &&
                  this._list && this._list.length) ? true : false;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * update scroll of tags suggestion menu
       * @return {?}
       */
      Md2Tags.prototype.updateScroll = /**
       * update scroll of tags suggestion menu
       * @return {?}
       */
          function () {
              if (this._focusedTag < 0) {
                  return;
              }
              /** @type {?} */
              var menuContainer = this._element.nativeElement.querySelector('.md2-tags-menu');
              if (!menuContainer) {
                  return;
              }
              /** @type {?} */
              var choices = menuContainer.querySelectorAll('.md2-option');
              if (choices.length < 1) {
                  return;
              }
              /** @type {?} */
              var highlighted = choices[this._focusedTag];
              if (!highlighted) {
                  return;
              }
              /** @type {?} */
              var top = highlighted.offsetTop + highlighted.clientHeight - menuContainer.scrollTop;
              /** @type {?} */
              var height = menuContainer.offsetHeight;
              if (top > height) {
                  menuContainer.scrollTop += top - height;
              }
              else if (top < highlighted.clientHeight) {
                  menuContainer.scrollTop -= highlighted.clientHeight - top;
              }
          };
      /**
       * input key listener
       * @param event
       */
      /**
       * input key listener
       * @param {?} event
       * @return {?}
       */
      Md2Tags.prototype._handleInputKeydown = /**
       * input key listener
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var _this = this;
              // Backspace
              if (event.keyCode === 8 && !this._inputValue) {
                  event.preventDefault();
                  event.stopPropagation();
                  if (this._items.length && this._selectedTag < 0) {
                      this.selectAndFocusTagSafe(this._items.length - 1);
                  }
                  if (this._items.length && this._selectedTag > -1) {
                      this.removeAndSelectAdjacentTag(this._selectedTag);
                  }
                  return;
              }
              // Del Key
              if (event.keyCode === 46 && !this._inputValue) {
                  return;
              }
              // Left / Right Arrow
              if ((event.keyCode === 37 || event.keyCode === 39) && !this._inputValue) {
                  return;
              }
              // Down Arrow
              if (event.keyCode === 40) {
                  if (!this.isMenuVisible) {
                      return;
                  }
                  event.stopPropagation();
                  event.preventDefault();
                  this._focusedTag = (this._focusedTag === this._list.length - 1) ?
                      0 : Math.min(this._focusedTag + 1, this._list.length - 1);
                  this.updateScroll();
                  return;
              }
              // Up Arrow
              if (event.keyCode === 38) {
                  if (!this.isMenuVisible) {
                      return;
                  }
                  event.stopPropagation();
                  event.preventDefault();
                  this._focusedTag = (this._focusedTag === 0) ?
                      this._list.length - 1 : Math.max(0, this._focusedTag - 1);
                  this.updateScroll();
                  return;
              }
              // Tab Key
              if (event.keyCode === 9) {
                  return;
              }
              // Enter / Space
              if (event.keyCode === 13 || event.keyCode === 32) {
                  if (!this._inputValue || !this.isMenuVisible) {
                      event.preventDefault();
                      return;
                  }
                  event.preventDefault();
                  this._addTag(event, this._focusedTag);
                  return;
              }
              // Escape Key
              if (event.keyCode === 27) {
                  event.stopPropagation();
                  event.preventDefault();
                  if (this._inputValue) {
                      this._inputValue = '';
                  }
                  if (this._selectedTag >= 0) {
                      this._handleFocus();
                  }
                  return;
              }
              // reset selected tag
              if (this._selectedTag >= 0) {
                  this.resetselectedTag();
              }
              // filter
              setTimeout(function () {
                  _this.filterMatches();
              }, 10);
          };
      /**
       * @param {?} event
       * @return {?}
       */
      Md2Tags.prototype._handleKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled || this._inputValue) {
                  return;
              }
              switch (event.keyCode) {
                  case BACKSPACE:
                  case DELETE:
                      if (this._selectedTag < 0) {
                          return;
                      }
                      event.preventDefault();
                      this.removeAndSelectAdjacentTag(this._selectedTag);
                      break;
                  case TAB:
                  case ESCAPE:
                      if (this._selectedTag < 0) {
                          return;
                      }
                      event.preventDefault();
                      this._handleFocus();
                      break;
                  case LEFT_ARROW:
                      event.preventDefault();
                      if (this._selectedTag < 0) {
                          this._selectedTag = this._items.length;
                      }
                      if (this._items.length) {
                          this.selectAndFocusTagSafe(this._selectedTag - 1);
                      }
                      break;
                  case RIGHT_ARROW:
                      event.preventDefault();
                      if (this._selectedTag >= this._items.length) {
                          this._selectedTag = -1;
                      }
                      this.selectAndFocusTagSafe(this._selectedTag + 1);
                      break;
              }
          };
      /**
       * @param {?} index
       * @return {?}
       */
      Md2Tags.prototype.removeAndSelectAdjacentTag = /**
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var selIndex = this.getAdjacentTagIndex(index);
              this.removeTag(index);
              this.selectAndFocusTagSafe(selIndex);
          };
      /**
       * @return {?}
       */
      Md2Tags.prototype.resetselectedTag = /**
       * @return {?}
       */
          function () {
              this._selectedTag = -1;
          };
      /**
       * @param {?} index
       * @return {?}
       */
      Md2Tags.prototype.getAdjacentTagIndex = /**
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var len = this._items.length - 1;
              return (len === 0) ? -1 :
                  (index === len) ? index - 1 : index;
          };
      /**
       * add tag
       * @param event
       * @param index index of the specific tag
       */
      /**
       * add tag
       * @param {?} event
       * @param {?} index index of the specific tag
       * @return {?}
       */
      Md2Tags.prototype._addTag = /**
       * add tag
       * @param {?} event
       * @param {?} index index of the specific tag
       * @return {?}
       */
          function (event, index) {
              event.preventDefault();
              event.stopPropagation();
              this._items.push(this._list[index]);
              this._inputValue = '';
              this.updateValue();
          };
      /**
       * @param {?} index
       * @return {?}
       */
      Md2Tags.prototype._removeTagAndFocusInput = /**
       * @param {?} index
       * @return {?}
       */
          function (index) {
              this.removeTag(index);
              this._handleFocus();
          };
      /**
       * remove tag
       * @param {?} index
       * @return {?}
       */
      Md2Tags.prototype.removeTag = /**
       * remove tag
       * @param {?} index
       * @return {?}
       */
          function (index) {
              this._items.splice(index, 1);
              this.updateValue();
          };
      /**
       * update value
       * @return {?}
       */
      Md2Tags.prototype.updateValue = /**
       * update value
       * @return {?}
       */
          function () {
              this._value = new Array();
              for (var i = 0; i < this._items.length; i++) {
                  this._value.push(this._items[i].value);
              }
              this._onChangeCallback(this._value);
              this.change.emit(this._value);
          };
      /**
       * select tag
       * @param index of select tag
       */
      /**
       * select tag
       * @param {?} index of select tag
       * @return {?}
       */
      Md2Tags.prototype._selectTag = /**
       * select tag
       * @param {?} index of select tag
       * @return {?}
       */
          function (index) {
              if (index >= -1 && index <= this._items.length) {
                  this._selectedTag = index;
              }
          };
      /**
       * @return {?}
       */
      Md2Tags.prototype._handleFocus = /**
       * @return {?}
       */
          function () {
              this._element.nativeElement.querySelector('input').focus();
              this.resetselectedTag();
          };
      /**
       * @return {?}
       */
      Md2Tags.prototype._onInputFocus = /**
       * @return {?}
       */
          function () {
              this._inputFocused = true;
              this.resetselectedTag();
          };
      /**
       * @return {?}
       */
      Md2Tags.prototype._onInputBlur = /**
       * @return {?}
       */
          function () {
              this._inputFocused = false;
          };
      /**
       * @return {?}
       */
      Md2Tags.prototype._listEnter = /**
       * @return {?}
       */
          function () { this.noBlur = true; };
      /**
       * @return {?}
       */
      Md2Tags.prototype._listLeave = /**
       * @return {?}
       */
          function () { this.noBlur = false; };
      /**
       * update suggestion menu with filter
       * @return {?}
       */
      Md2Tags.prototype.filterMatches = /**
       * update suggestion menu with filter
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var tempList = this._tags.map(function (tag) { return new Tag(tag, _this.textKey, _this.valueKey); });
              this._list = tempList.filter(function (t) {
                  return (new RegExp(_this._inputValue, 'ig').test(t.text) &&
                      !_this._items.find(function (i) { return t.text === i.text; }));
              });
              if (this._list.length > 0) {
                  this._focusedTag = 0;
              }
          };
      /**
       * @param {?} value
       * @return {?}
       */
      Md2Tags.prototype.writeValue = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              if (value !== this._value) {
                  this._value = value;
                  this._items = [];
                  if (value && value.length && typeof value === 'object' && Array.isArray(value)) {
                      var _loop_2 = function (i) {
                          /** @type {?} */
                          var selItm = this_2._tags.find(function (t) {
                              return _this.equals(_this.valueKey ?
                                  t[_this.valueKey] : t, value[i]);
                          });
                          if (selItm) {
                              this_2._items.push(new Tag(selItm, this_2.textKey, this_2.valueKey));
                          }
                      };
                      var this_2 = this;
                      for (var i = 0; i < value.length; i++) {
                          _loop_2(i);
                      }
                  }
              }
          };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Tags.prototype.registerOnChange = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onChangeCallback = fn; };
      /**
       * @param {?} fn
       * @return {?}
       */
      Md2Tags.prototype.registerOnTouched = /**
       * @param {?} fn
       * @return {?}
       */
          function (fn) { this._onTouchedCallback = fn; };
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      Md2Tags.prototype.setDisabledState = /**
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      Md2Tags.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-tags',
                      template: "<div class=\"md2-tags-container\">\n  <span *ngFor=\"let t of _items; let i = index;\" class=\"md2-tag\" [class.active]=\"_selectedTag === i\" (click)=\"_selectTag(i)\">\n    <span class=\"md2-tag-text\">{{t.text}}</span>\n    <svg (click)=\"_removeTagAndFocusInput(i)\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n      <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n    </svg>\n  </span>\n  <div class=\"md2-tag-add\">\n    <input [(ngModel)]=\"_inputValue\" type=\"text\" tabs=\"false\" autocomplete=\"off\" tabindex=\"-1\" [disabled]=\"disabled\" class=\"md2-tags-input\" [placeholder]=\"placeholder\" (focus)=\"_onInputFocus()\" (blur)=\"_onInputBlur()\" (keydown)=\"_handleInputKeydown($event)\" (change)=\"$event.stopPropagation()\" />\n    <ul *ngIf=\"isMenuVisible\" class=\"md2-tags-menu\" (mouseenter)=\"_listEnter()\" (mouseleave)=\"_listLeave()\">\n      <li class=\"md2-tag-option\" *ngFor=\"let l of _list; let i = index;\" [class.focused]=\"_focusedTag === i\" (click)=\"_addTag($event, i)\">\n        <span class=\"md2-tag-option-text\" [innerHtml]=\"l.text | highlight:_inputValue\"></span>\n      </li>\n    </ul>\n  </div>\n</div>\n",
                      host: {
                          'role': 'tags',
                          '[id]': 'id',
                          '[class.focus]': '_inputFocused || _selectedTag >= 0',
                          '[class.md2-tags-disabled]': 'disabled',
                          '[tabindex]': 'disabled ? -1 : tabindex',
                          '[attr.aria-disabled]': 'disabled'
                      },
                      providers: [MD2_TAGS_CONTROL_VALUE_ACCESSOR],
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'md2Tags',
                      styles: [":host{outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-backface-visibility:hidden;backface-visibility:hidden}.md2-tags-container{position:relative;display:block;max-width:100%;padding:2px 2px 4px;border-bottom:1px solid rgba(0,0,0,.12);box-sizing:content-box;min-width:64px;min-height:26px;cursor:text}.md2-tags-container::after,.md2-tags-container::before{display:table;content:' '}.md2-tags-container::after{clear:both}.focus .md2-tags-container{padding-bottom:3px;border-bottom:2px solid #106cc8}.md2-tags-disabled .md2-tags-container{color:rgba(0,0,0,.38);cursor:default}.md2-tags-disabled.focus .md2-tags-container{padding-bottom:4px;border-bottom:1px solid rgba(0,0,0,.38)}.md2-tag{position:relative;cursor:default;border-radius:16px;display:block;height:32px;line-height:32px;margin:4px 4px 0 0;padding:0 26px 0 12px;float:left;box-sizing:border-box;max-width:100%;background:#e0e0e0;color:#424242;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.md2-tag.active{background:#106cc8;color:rgba(255,255,255,.87)}.md2-tag.active svg{color:rgba(255,255,255,.87)}.md2-tag svg{position:absolute;top:4px;right:2px;cursor:pointer;display:inline-block;overflow:hidden;fill:currentColor;color:rgba(0,0,0,.54)}.md2-tag-add{position:relative;display:inline-block;margin-left:4px}input{border:0;outline:0;margin-top:6px;height:30px;line-height:30px;padding:0;color:rgba(0,0,0,.87);background:0 0}.md2-tags-placeholder{color:rgba(0,0,0,.38)}.md2-tags-menu{position:absolute;left:0;top:100%;display:block;z-index:10;flex-direction:column;width:100%;margin:6px 0 0;padding:8px 0;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);max-height:256px;min-height:48px;overflow-y:auto;-webkit-transform:scale(1);transform:scale(1);background:#fff;-webkit-backface-visibility:hidden;backface-visibility:hidden}.md2-tags-menu .md2-tag-option{cursor:pointer;position:relative;display:block;color:#212121;align-items:center;width:auto;transition:background 150ms linear;padding:12px 16px;line-height:24px;box-sizing:border-box;word-wrap:break-word}.md2-tags-menu .md2-tag-option.focused,.md2-tags-menu .md2-tag-option:hover{background:#eee}.md2-tags-menu .md2-tag-option .md2-tag-option-text{width:auto;font-size:16px}.highlight{color:#757575}"]
                  }] }
      ];
      /** @nocollapse */
      Md2Tags.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      Md2Tags.propDecorators = {
          change: [{ type: core.Output }],
          id: [{ type: core.Input }],
          tabindex: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          textKey: [{ type: core.Input, args: ['md2-tag-text',] }],
          valueKey: [{ type: core.Input, args: ['md2-tag-value',] }],
          disabled: [{ type: core.Input }],
          tags: [{ type: core.Input, args: ['md2-tags',] }],
          value: [{ type: core.Input }],
          _handleKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
          _handleFocus: [{ type: core.HostListener, args: ['focus',] }]
      };
      return Md2Tags;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2TagsModule = /** @class */ (function () {
      function Md2TagsModule() {
      }
      Md2TagsModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [common.CommonModule, forms.FormsModule, Md2AutocompleteModule],
                      exports: [Md2Tags],
                      declarations: [Md2Tags],
                  },] }
      ];
      return Md2TagsModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Toast = /** @class */ (function () {
      function Toast(message) {
          this.message = message;
      }
      return Toast;
  }());
  var Md2ToastConfig = /** @class */ (function () {
      function Md2ToastConfig() {
          this.duration = 3000;
          this.viewContainerRef = null;
      }
      return Md2ToastConfig;
  }());
  var Md2Toast = /** @class */ (function () {
      function Md2Toast(_overlay, _config) {
          this._overlay = _overlay;
          this._config = _config;
          this.index = 0;
      }
      /**
       * toast message
       * @param toast string or object with message and other properties of toast
       */
      /**
       * toast message
       * @param {?} message
       * @param {?=} duration
       * @return {?}
       */
      Md2Toast.prototype.toast = /**
       * toast message
       * @param {?} message
       * @param {?=} duration
       * @return {?}
       */
          function (message, duration) {
              this.show(message, duration);
          };
      /**
       * show toast
       * @param toastObj string or object with message and other properties of toast
       */
      /**
       * show toast
       * @param {?} message
       * @param {?=} duration
       * @return {?}
       */
      Md2Toast.prototype.show = /**
       * show toast
       * @param {?} message
       * @param {?=} duration
       * @return {?}
       */
          function (message, duration) {
              if (!message || !message.trim()) {
                  return;
              }
              if (duration) {
                  this._config.duration = duration;
              }
              /** @type {?} */
              var toast;
              toast = new Toast(message);
              if (toast) {
                  if (!this._toastInstance) {
                      this._createToast();
                  }
                  this._setToastMessage(toast);
              }
          };
      /**
       * Create the toast to display
       * @return {?}
       */
      Md2Toast.prototype._createToast = /**
       * Create the toast to display
       * @return {?}
       */
          function () {
              this._createOverlay();
              /** @type {?} */
              var portal = new ComponentPortal(Md2ToastComponent, this._config.viewContainerRef);
              this._toastInstance = this._overlayRef.attach(portal).instance;
          };
      /**
       * Create the overlay config and position strategy
       * @return {?}
       */
      Md2Toast.prototype._createOverlay = /**
       * Create the overlay config and position strategy
       * @return {?}
       */
          function () {
              if (!this._overlayRef) {
                  /** @type {?} */
                  var config = new OverlayState();
                  config.positionStrategy = this._overlay.position()
                      .global()
                      .top('0').right('0');
                  this._overlayRef = this._overlay.create(config);
              }
          };
      /**
       * Disposes the current toast and the overlay it is attached to
       * @return {?}
       */
      Md2Toast.prototype._disposeToast = /**
       * Disposes the current toast and the overlay it is attached to
       * @return {?}
       */
          function () {
              this._overlayRef.dispose();
              this._overlayRef = null;
              this._toastInstance = null;
          };
      /**
       * Updates the toast message and repositions the overlay according to the new message length
       * @param {?} toast
       * @return {?}
       */
      Md2Toast.prototype._setToastMessage = /**
       * Updates the toast message and repositions the overlay according to the new message length
       * @param {?} toast
       * @return {?}
       */
          function (toast) {
              var _this = this;
              toast.id = ++this.index;
              this._toastInstance.addToast(toast);
              setTimeout(function () {
                  _this.clearToast(toast.id);
              }, this._config.duration);
          };
      /**
       * clear specific toast
       * @param {?} toastId
       * @return {?}
       */
      Md2Toast.prototype.clearToast = /**
       * clear specific toast
       * @param {?} toastId
       * @return {?}
       */
          function (toastId) {
              var _this = this;
              if (this._toastInstance) {
                  this._toastInstance.removeToast(toastId);
                  setTimeout(function () {
                      if (!_this._toastInstance.hasToast()) {
                          _this._disposeToast();
                      }
                  }, 250);
              }
          };
      /**
       * clear all toasts
       */
      /**
       * clear all toasts
       * @return {?}
       */
      Md2Toast.prototype.clearAllToasts = /**
       * clear all toasts
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._toastInstance) {
                  this._toastInstance.removeAllToasts();
                  setTimeout(function () {
                      if (!_this._toastInstance.hasToast()) {
                          _this._disposeToast();
                      }
                  }, 250);
              }
          };
      Md2Toast.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      Md2Toast.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: Md2ToastConfig }
          ];
      };
      return Md2Toast;
  }());
  var Md2ToastComponent = /** @class */ (function () {
      function Md2ToastComponent() {
          this.toasts = [];
          this.maxShown = 5;
      }
      /**
       * add toast
       * @param toast toast object with all parameters
       */
      /**
       * add toast
       * @param {?} toast toast object with all parameters
       * @return {?}
       */
      Md2ToastComponent.prototype.addToast = /**
       * add toast
       * @param {?} toast toast object with all parameters
       * @return {?}
       */
          function (toast) {
              var _this = this;
              setTimeout(function () {
                  toast.isVisible = true;
              }, 1);
              this.toasts.push(toast);
              if (this.toasts.length > this.maxShown) {
                  this.toasts[0].isVisible = false;
                  setTimeout(function () {
                      _this.toasts.splice(0, (_this.toasts.length - _this.maxShown));
                  }, 250);
              }
          };
      /**
       * remove toast
       * @param toastId number of toast id
       */
      /**
       * remove toast
       * @param {?} toastId number of toast id
       * @return {?}
       */
      Md2ToastComponent.prototype.removeToast = /**
       * remove toast
       * @param {?} toastId number of toast id
       * @return {?}
       */
          function (toastId) {
              var _this = this;
              this.toasts.forEach(function (t) {
                  if (t.id === toastId) {
                      t.isVisible = false;
                  }
              });
              setTimeout(function () {
                  _this.toasts = _this.toasts.filter(function (toast) { return toast.id !== toastId; });
              }, 250);
          };
      /**
       * remove all toasts
       * @param toastId number of toast id
       */
      /**
       * remove all toasts
       * @return {?}
       */
      Md2ToastComponent.prototype.removeAllToasts = /**
       * remove all toasts
       * @return {?}
       */
          function () {
              var _this = this;
              this.toasts.forEach(function (t) { t.isVisible = false; });
              setTimeout(function () {
                  _this.toasts = [];
              }, 250);
          };
      /**
       * check has any toast
       * @return boolean
       */
      /**
       * check has any toast
       * @return {?} boolean
       */
      Md2ToastComponent.prototype.hasToast = /**
       * check has any toast
       * @return {?} boolean
       */
          function () { return this.toasts.length > 0; };
      Md2ToastComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-toast',
                      template: "<div *ngFor=\"let toast of toasts\"\n     class=\"md2-toast\"\n     [class.in]=\"toast.isVisible\"\n     (click)=\"removeToast(toast.id)\"\n     [innerHTML]=\"toast.message\">\n</div>\n",
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["md2-toast{display:block;box-sizing:border-box;cursor:default;overflow:hidden;min-width:304px;max-width:100%;padding:8px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.md2-toast{position:relative;padding:14px 24px;margin-bottom:5px;display:block;margin-top:-53px;opacity:0;background-color:#323232;color:#fafafa;box-shadow:0 2px 5px 0 rgba(0,0,0,.26);border-radius:2px;font-size:14px;overflow:hidden;word-wrap:break-word;transition:250ms linear}.md2-toast.in{margin-top:0;opacity:1}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;text-transform:none;width:1px}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}"]
                  }] }
      ];
      return Md2ToastComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2ToastModule = /** @class */ (function () {
      function Md2ToastModule() {
      }
      Md2ToastModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          OverlayModule,
                          MdCommonModule,
                          PlatformModule
                      ],
                      exports: [Md2ToastComponent, MdCommonModule],
                      declarations: [Md2ToastComponent],
                      entryComponents: [Md2ToastComponent],
                      providers: [Md2Toast, Md2ToastConfig],
                  },] }
      ];
      return Md2ToastModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** *
   * Time in ms to delay before changing the tooltip visibility to hidden
    @type {?} */
  var TOUCHEND_HIDE_DELAY = 1500;
  /** *
   * Time in ms to throttle repositioning after scroll events.
    @type {?} */
  var SCROLL_THROTTLE_MS = 20;
  /**
   * Throws an error if the user supplied an invalid tooltip position.
   * @param {?} position
   * @return {?}
   */
  function throwMd2TooltipInvalidPositionError(position) {
      throw new Error("Tooltip position \"" + position + "\" is invalid.");
  }
  /**
   * Directive that attaches a material design tooltip to the host element. Animates the showing and
   * hiding of a tooltip provided position (defaults to below the element).
   *
   * https://material.google.com/components/tooltips.html
   */
  var Md2Tooltip = /** @class */ (function () {
      function Md2Tooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _renderer, _platform, _dir) {
          var _this = this;
          this._overlay = _overlay;
          this._elementRef = _elementRef;
          this._scrollDispatcher = _scrollDispatcher;
          this._viewContainerRef = _viewContainerRef;
          this._ngZone = _ngZone;
          this._renderer = _renderer;
          this._platform = _platform;
          this._dir = _dir;
          this._position = 'below';
          this._disabled = false;
          /**
           * The default delay in ms before showing the tooltip after show is called
           */
          this.showDelay = 0;
          /**
           * The default delay in ms before hiding the tooltip after hide is called
           */
          this.hideDelay = 0;
          // The mouse events shouldn't be bound on iOS devices, because
          // they can prevent the first tap from firing its click event.
          if (!_platform.IOS) {
              _renderer.listen(_elementRef.nativeElement, 'mouseenter', function () { return _this.show(); });
              _renderer.listen(_elementRef.nativeElement, 'mouseleave', function () { return _this.hide(); });
          }
      }
      Object.defineProperty(Md2Tooltip.prototype, "position", {
          /** Allows the user to define the position of the tooltip relative to the parent element */
          get: /**
           * Allows the user to define the position of the tooltip relative to the parent element
           * @return {?}
           */ function () { return this._position; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this._position) {
                  this._position = value;
                  // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy
                  // the tooltip.
                  if (this._tooltipInstance) {
                      this._disposeTooltip();
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tooltip.prototype, "disabled", {
          /** Disables the display of the tooltip. */
          get: /**
           * Disables the display of the tooltip.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              // If tooltip is disabled, hide immediately.
              if (this._disabled) {
                  this.hide(0);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Md2Tooltip.prototype, "message", {
          /** The message to be displayed in the tooltip */
          get: /**
           * The message to be displayed in the tooltip
           * @return {?}
           */ function () { return this._message; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._message = value;
              if (this._tooltipInstance) {
                  this._setTooltipMessage(this._message);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Dispose the tooltip when destroyed.
       */
      /**
       * Dispose the tooltip when destroyed.
       * @return {?}
       */
      Md2Tooltip.prototype.ngOnDestroy = /**
       * Dispose the tooltip when destroyed.
       * @return {?}
       */
          function () {
              if (this._tooltipInstance) {
                  this._disposeTooltip();
              }
          };
      /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
      /**
       * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
      Md2Tooltip.prototype.show = /**
       * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
          function (delay) {
              if (delay === void 0) {
                  delay = this.showDelay;
              }
              if (this.disabled || !this._message || !this._message.trim()) {
                  return;
              }
              if (!this._tooltipInstance) {
                  this._createTooltip();
              }
              this._setTooltipMessage(this._message);
              this._tooltipInstance.show(this._position, delay);
          };
      /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
      /**
       * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
      Md2Tooltip.prototype.hide = /**
       * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
          function (delay) {
              if (delay === void 0) {
                  delay = this.hideDelay;
              }
              if (this._tooltipInstance) {
                  this._tooltipInstance.hide(delay);
              }
          };
      /** Shows/hides the tooltip */
      /**
       * Shows/hides the tooltip
       * @return {?}
       */
      Md2Tooltip.prototype.toggle = /**
       * Shows/hides the tooltip
       * @return {?}
       */
          function () {
              this._isTooltipVisible() ? this.hide() : this.show();
          };
      /** Returns true if the tooltip is currently visible to the user */
      /**
       * Returns true if the tooltip is currently visible to the user
       * @return {?}
       */
      Md2Tooltip.prototype._isTooltipVisible = /**
       * Returns true if the tooltip is currently visible to the user
       * @return {?}
       */
          function () {
              return !!this._tooltipInstance && this._tooltipInstance.isVisible();
          };
      /**
       * Create the tooltip to display
       * @return {?}
       */
      Md2Tooltip.prototype._createTooltip = /**
       * Create the tooltip to display
       * @return {?}
       */
          function () {
              var _this = this;
              this._createOverlay();
              /** @type {?} */
              var portal = new ComponentPortal(Md2TooltipComponent, this._viewContainerRef);
              this._tooltipInstance = this._overlayRef.attach(portal).instance;
              // Dispose the overlay when finished the shown tooltip.
              this._tooltipInstance.afterHidden().subscribe(function () {
                  // Check first if the tooltip has already been removed through this components destroy.
                  if (_this._tooltipInstance) {
                      _this._disposeTooltip();
                  }
              });
          };
      /**
       * Create the overlay config and position strategy
       * @return {?}
       */
      Md2Tooltip.prototype._createOverlay = /**
       * Create the overlay config and position strategy
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var origin = this._getOrigin();
              /** @type {?} */
              var position = this._getOverlayPosition();
              /** @type {?} */
              var strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);
              strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));
              strategy.onPositionChange.subscribe(function (change) {
                  if (change.scrollableViewProperties.isOverlayClipped &&
                      _this._tooltipInstance && _this._tooltipInstance.isVisible()) {
                      _this.hide(0);
                  }
              });
              /** @type {?} */
              var config = new OverlayState();
              config.direction = this._dir ? this._dir.value : 'ltr';
              config.positionStrategy = strategy;
              config.scrollStrategy = this._overlay.scrollStrategies.reposition({
                  scrollThrottle: SCROLL_THROTTLE_MS
              });
              this._overlayRef = this._overlay.create(config);
          };
      /**
       * Disposes the current tooltip and the overlay it is attached to
       * @return {?}
       */
      Md2Tooltip.prototype._disposeTooltip = /**
       * Disposes the current tooltip and the overlay it is attached to
       * @return {?}
       */
          function () {
              this._overlayRef.dispose();
              this._overlayRef = null;
              this._tooltipInstance = null;
          };
      /** Returns the origin position based on the user's position preference */
      /**
       * Returns the origin position based on the user's position preference
       * @return {?}
       */
      Md2Tooltip.prototype._getOrigin = /**
       * Returns the origin position based on the user's position preference
       * @return {?}
       */
          function () {
              if (this.position == 'above' || this.position == 'below') {
                  return { originX: 'center', originY: this.position == 'above' ? 'top' : 'bottom' };
              }
              /** @type {?} */
              var isDirectionLtr = !this._dir || this._dir.value == 'ltr';
              if (this.position == 'left' ||
                  this.position == 'before' && isDirectionLtr ||
                  this.position == 'after' && !isDirectionLtr) {
                  return { originX: 'start', originY: 'center' };
              }
              if (this.position == 'right' ||
                  this.position == 'after' && isDirectionLtr ||
                  this.position == 'before' && !isDirectionLtr) {
                  return { originX: 'end', originY: 'center' };
              }
              throwMd2TooltipInvalidPositionError(this.position);
          };
      /** Returns the overlay position based on the user's preference */
      /**
       * Returns the overlay position based on the user's preference
       * @return {?}
       */
      Md2Tooltip.prototype._getOverlayPosition = /**
       * Returns the overlay position based on the user's preference
       * @return {?}
       */
          function () {
              if (this.position == 'above') {
                  return { overlayX: 'center', overlayY: 'bottom' };
              }
              if (this.position == 'below') {
                  return { overlayX: 'center', overlayY: 'top' };
              }
              /** @type {?} */
              var isLtr = !this._dir || this._dir.value == 'ltr';
              if (this.position == 'left' ||
                  this.position == 'before' && isLtr ||
                  this.position == 'after' && !isLtr) {
                  return { overlayX: 'end', overlayY: 'center' };
              }
              if (this.position == 'right' ||
                  this.position == 'after' && isLtr ||
                  this.position == 'before' && !isLtr) {
                  return { overlayX: 'start', overlayY: 'center' };
              }
              throwMd2TooltipInvalidPositionError(this.position);
          };
      /**
       * Updates the tooltip message and repositions the overlay according to the new message length
       * @param {?} message
       * @return {?}
       */
      Md2Tooltip.prototype._setTooltipMessage = /**
       * Updates the tooltip message and repositions the overlay according to the new message length
       * @param {?} message
       * @return {?}
       */
          function (message) {
              var _this = this;
              // Must wait for the message to be painted to the tooltip so that the overlay can properly
              // calculate the correct positioning based on the size of the text.
              this._tooltipInstance.message = message;
              this._tooltipInstance._markForCheck();
              this._ngZone.onMicrotaskEmpty.pipe(operators.first()).subscribe(function () {
                  if (_this._tooltipInstance) {
                      _this._overlayRef.updatePosition();
                  }
              });
          };
      Md2Tooltip.decorators = [
          { type: core.Directive, args: [{
                      selector: '[tooltip]',
                      host: {
                          '(longpress)': 'show()',
                          '(touchend)': 'hide(' + TOUCHEND_HIDE_DELAY + ')',
                      },
                      exportAs: 'md2Tooltip',
                  },] }
      ];
      /** @nocollapse */
      Md2Tooltip.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.ViewContainerRef },
              { type: core.NgZone },
              { type: core.Renderer2 },
              { type: Platform },
              { type: Dir, decorators: [{ type: core.Optional }] }
          ];
      };
      Md2Tooltip.propDecorators = {
          position: [{ type: core.Input, args: ['tooltip-position',] }],
          disabled: [{ type: core.Input, args: ['tooltipDisabled',] }],
          showDelay: [{ type: core.Input, args: ['tooltip-delay',] }],
          hideDelay: [{ type: core.Input, args: ['tooltip-hide-delay',] }],
          message: [{ type: core.Input, args: ['tooltip',] }]
      };
      return Md2Tooltip;
  }());
  /**
   * Internal component that wraps the tooltip's content.
   * \@docs-private
   */
  var Md2TooltipComponent = /** @class */ (function () {
      function Md2TooltipComponent(_dir, _changeDetectorRef) {
          this._dir = _dir;
          this._changeDetectorRef = _changeDetectorRef;
          /**
           * Property watched by the animation framework to show or hide the tooltip
           */
          this._visibility = 'initial';
          /**
           * Whether interactions on the page should close the tooltip
           */
          this._closeOnInteraction = false;
          /**
           * The transform origin used in the animation for showing and hiding the tooltip
           */
          this._transformOrigin = 'bottom';
          /**
           * Subject for notifying that the tooltip has been hidden from the view
           */
          this._onHide = new rxjs.Subject();
      }
      /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param position Position of the tooltip.
       * @param delay Amount of milliseconds to the delay showing the tooltip.
       */
      /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param {?} position Position of the tooltip.
       * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
       * @return {?}
       */
      Md2TooltipComponent.prototype.show = /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param {?} position Position of the tooltip.
       * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
       * @return {?}
       */
          function (position, delay) {
              var _this = this;
              // Cancel the delayed hide if it is scheduled
              if (this._hideTimeoutId) {
                  clearTimeout(this._hideTimeoutId);
              }
              // Body interactions should cancel the tooltip if there is a delay in showing.
              this._closeOnInteraction = true;
              this._setTransformOrigin(position);
              this._showTimeoutId = setTimeout(function () {
                  _this._visibility = 'visible';
                  // If this was set to true immediately, then a body click that triggers show() would
                  // trigger interaction and close the tooltip right after it was displayed.
                  // If this was set to true immediately, then a body click that triggers show() would
                  // trigger interaction and close the tooltip right after it was displayed.
                  _this._closeOnInteraction = false;
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  _this._markForCheck();
                  setTimeout(function () { return _this._closeOnInteraction = true; }, 0);
              }, delay);
          };
      /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param delay Amount of milliseconds to delay showing the tooltip.
       */
      /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param {?} delay Amount of milliseconds to delay showing the tooltip.
       * @return {?}
       */
      Md2TooltipComponent.prototype.hide = /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param {?} delay Amount of milliseconds to delay showing the tooltip.
       * @return {?}
       */
          function (delay) {
              var _this = this;
              // Cancel the delayed show if it is scheduled
              if (this._showTimeoutId) {
                  clearTimeout(this._showTimeoutId);
              }
              this._hideTimeoutId = setTimeout(function () {
                  _this._visibility = 'hidden';
                  _this._closeOnInteraction = false;
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  _this._markForCheck();
              }, delay);
          };
      /**
       * Returns an observable that notifies when the tooltip has been hidden from view
       */
      /**
       * Returns an observable that notifies when the tooltip has been hidden from view
       * @return {?}
       */
      Md2TooltipComponent.prototype.afterHidden = /**
       * Returns an observable that notifies when the tooltip has been hidden from view
       * @return {?}
       */
          function () {
              return this._onHide.asObservable();
          };
      /**
       * Whether the tooltip is being displayed
       */
      /**
       * Whether the tooltip is being displayed
       * @return {?}
       */
      Md2TooltipComponent.prototype.isVisible = /**
       * Whether the tooltip is being displayed
       * @return {?}
       */
          function () {
              return this._visibility === 'visible';
          };
      /** Sets the tooltip transform origin according to the tooltip position */
      /**
       * Sets the tooltip transform origin according to the tooltip position
       * @param {?} value
       * @return {?}
       */
      Md2TooltipComponent.prototype._setTransformOrigin = /**
       * Sets the tooltip transform origin according to the tooltip position
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var isLtr = !this._dir || this._dir.value == 'ltr';
              switch (value) {
                  case 'before':
                      this._transformOrigin = isLtr ? 'right' : 'left';
                      break;
                  case 'after':
                      this._transformOrigin = isLtr ? 'left' : 'right';
                      break;
                  case 'left':
                      this._transformOrigin = 'right';
                      break;
                  case 'right':
                      this._transformOrigin = 'left';
                      break;
                  case 'above':
                      this._transformOrigin = 'bottom';
                      break;
                  case 'below':
                      this._transformOrigin = 'top';
                      break;
                  default: throwMd2TooltipInvalidPositionError(value);
              }
          };
      /**
       * @param {?} e
       * @return {?}
       */
      Md2TooltipComponent.prototype._afterVisibilityAnimation = /**
       * @param {?} e
       * @return {?}
       */
          function (e) {
              if (e.toState === 'hidden' && !this.isVisible()) {
                  this._onHide.next();
              }
          };
      /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.google.com/components/tooltips.html#tooltips-interaction
       */
      /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.google.com/components/tooltips.html#tooltips-interaction
       * @return {?}
       */
      Md2TooltipComponent.prototype._handleBodyInteraction = /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.google.com/components/tooltips.html#tooltips-interaction
       * @return {?}
       */
          function () {
              if (this._closeOnInteraction) {
                  this.hide(0);
              }
          };
      /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       */
      /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       * @return {?}
       */
      Md2TooltipComponent.prototype._markForCheck = /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       * @return {?}
       */
          function () {
              this._changeDetectorRef.markForCheck();
          };
      Md2TooltipComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'md2-tooltip',
                      template: "<div class=\"md2-tooltip\"\n     [style.transform-origin]=\"_transformOrigin\"\n     [@state]=\"_visibility\"\n     (@state.done)=\"_afterVisibilityAnimation($event)\"\n     [innerHTML]=\"message\">\n</div>",
                      animations: [
                          animations.trigger('state', [
                              animations.state('void', animations.style({ transform: 'scale(0)' })),
                              animations.state('initial', animations.style({ transform: 'scale(0)' })),
                              animations.state('visible', animations.style({ transform: 'scale(1)' })),
                              animations.state('hidden', animations.style({ transform: 'scale(0)' })),
                              animations.transition('* => visible', animations.animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
                              animations.transition('* => hidden', animations.animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
                          ])
                      ],
                      host: {
                          '[style.zoom]': '_visibility === "visible" ? 1 : null',
                          '(body:click)': 'this._handleBodyInteraction()'
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      styles: ["md2-tooltip{pointer-events:none}.md2-tooltip{color:#fff;padding:6px 8px;border-radius:2px;font-size:10px;margin:14px;max-width:250px;background:rgba(97,97,97,.9);word-wrap:break-word}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000}"]
                  }] }
      ];
      /** @nocollapse */
      Md2TooltipComponent.ctorParameters = function () {
          return [
              { type: Dir, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef }
          ];
      };
      return Md2TooltipComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  var Md2TooltipModule = /** @class */ (function () {
      function Md2TooltipModule() {
      }
      Md2TooltipModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [OverlayModule, MdCommonModule, PlatformModule],
                      exports: [Md2Tooltip, Md2TooltipComponent, MdCommonModule],
                      declarations: [Md2Tooltip, Md2TooltipComponent],
                      entryComponents: [Md2TooltipComponent],
                  },] }
      ];
      return Md2TooltipModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MD2_MODULES = [
      Md2AccordionModule,
      Md2AutocompleteModule,
      Md2ChipsModule,
      Md2CollapseModule,
      Md2ColorpickerModule,
      Md2DataTableModule,
      Md2DatepickerModule,
      Md2DialogModule,
      Md2MenuModule,
      MdRippleModule,
      Md2SelectModule,
      Md2TabsModule,
      Md2TagsModule,
      Md2ToastModule,
      Md2TooltipModule,
      OverlayModule,
      PortalModule,
      RtlModule,
      StyleModule,
      A11yModule,
      PlatformModule,
      CompatibilityModule,
      MdNativeDateModule,
  ];
  var Md2Module = /** @class */ (function () {
      function Md2Module() {
      }
      Md2Module.decorators = [
          { type: core.NgModule, args: [{
                      imports: MD2_MODULES,
                      exports: MD2_MODULES,
                  },] }
      ];
      return Md2Module;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
   */

  exports.Dir = Dir;
  exports.RtlModule = RtlModule;
  exports.ObserveContentModule = ObserveContentModule;
  exports.ObserveContent = ObserveContent;
  exports.Portal = Portal;
  exports.BasePortalHost = BasePortalHost;
  exports.ComponentPortal = ComponentPortal;
  exports.TemplatePortal = TemplatePortal;
  exports.PortalHostDirective = PortalHostDirective;
  exports.TemplatePortalDirective = TemplatePortalDirective;
  exports.PortalModule = PortalModule;
  exports.DomPortalHost = DomPortalHost;
  exports.GestureConfig = GestureConfig;
  exports.LiveAnnouncer = LiveAnnouncer;
  exports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;
  exports.LIVE_ANNOUNCER_PROVIDER = LIVE_ANNOUNCER_PROVIDER;
  exports.InteractivityChecker = InteractivityChecker;
  exports.isFakeMousedownFromScreenReader = isFakeMousedownFromScreenReader;
  exports.A11yModule = A11yModule;
  exports.UniqueSelectionDispatcher = UniqueSelectionDispatcher;
  exports.UNIQUE_SELECTION_DISPATCHER_PROVIDER = UNIQUE_SELECTION_DISPATCHER_PROVIDER;
  exports.MdLineModule = MdLineModule;
  exports.MdLine = MdLine;
  exports.MdLineSetter = MdLineSetter;
  exports.coerceBooleanProperty = coerceBooleanProperty;
  exports.coerceNumberProperty = coerceNumberProperty;
  exports.CompatibilityModule = CompatibilityModule;
  exports.NoConflictStyleCompatibilityMode = NoConflictStyleCompatibilityMode;
  exports.MdCommonModule = MdCommonModule;
  exports.MATERIAL_SANITY_CHECKS = MATERIAL_SANITY_CHECKS;
  exports.MD_PLACEHOLDER_GLOBAL_OPTIONS = MD_PLACEHOLDER_GLOBAL_OPTIONS;
  exports.MdCoreModule = MdCoreModule;
  exports.MdOptionModule = MdOptionModule;
  exports.MdOptionSelectionChange = MdOptionSelectionChange;
  exports.MdOption = MdOption;
  exports.MdOptgroupBase = MdOptgroupBase;
  exports._MdOptgroupMixinBase = _MdOptgroupMixinBase;
  exports.MdOptgroup = MdOptgroup;
  exports.PlatformModule = PlatformModule;
  exports.Platform = Platform;
  exports.getSupportedInputTypes = getSupportedInputTypes;
  exports.Overlay = Overlay;
  exports.OVERLAY_PROVIDERS = OVERLAY_PROVIDERS;
  exports.OverlayContainer = OverlayContainer;
  exports.FullscreenOverlayContainer = FullscreenOverlayContainer;
  exports.OverlayRef = OverlayRef;
  exports.OverlayState = OverlayState;
  exports.ConnectedOverlayDirective = ConnectedOverlayDirective;
  exports.OverlayOrigin = OverlayOrigin;
  exports.OverlayModule = OverlayModule;
  exports.ViewportRuler = ViewportRuler;
  exports.GlobalPositionStrategy = GlobalPositionStrategy;
  exports.ConnectedPositionStrategy = ConnectedPositionStrategy;
  exports.ConnectionPositionPair = ConnectionPositionPair;
  exports.ScrollableViewProperties = ScrollableViewProperties;
  exports.ConnectedOverlayPositionChange = ConnectedOverlayPositionChange;
  exports.Scrollable = Scrollable;
  exports.ScrollDispatcher = ScrollDispatcher;
  exports.ScrollStrategyOptions = ScrollStrategyOptions;
  exports.RepositionScrollStrategy = RepositionScrollStrategy;
  exports.CloseScrollStrategy = CloseScrollStrategy;
  exports.NoopScrollStrategy = NoopScrollStrategy;
  exports.BlockScrollStrategy = BlockScrollStrategy;
  exports.ScrollDispatchModule = ScrollDispatchModule;
  exports.MdRipple = MdRipple;
  exports.MD_RIPPLE_GLOBAL_OPTIONS = MD_RIPPLE_GLOBAL_OPTIONS;
  exports.RippleRef = RippleRef;
  exports.RippleState = RippleState;
  exports.RIPPLE_FADE_IN_DURATION = RIPPLE_FADE_IN_DURATION;
  exports.RIPPLE_FADE_OUT_DURATION = RIPPLE_FADE_OUT_DURATION;
  exports.MdRippleModule = MdRippleModule;
  exports.SelectionModel = SelectionModel;
  exports.SelectionChange = SelectionChange;
  exports.FocusTrap = FocusTrap;
  exports.FocusTrapFactory = FocusTrapFactory;
  exports.FocusTrapDeprecatedDirective = FocusTrapDeprecatedDirective;
  exports.FocusTrapDirective = FocusTrapDirective;
  exports.StyleModule = StyleModule;
  exports.FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY = FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY;
  exports.TOUCH_BUFFER_MS = TOUCH_BUFFER_MS;
  exports.FocusOriginMonitor = FocusOriginMonitor;
  exports.CdkMonitorFocus = CdkMonitorFocus;
  exports.FOCUS_ORIGIN_MONITOR_PROVIDER = FOCUS_ORIGIN_MONITOR_PROVIDER;
  exports.applyCssTransform = applyCssTransform;
  exports.UP_ARROW = UP_ARROW;
  exports.DOWN_ARROW = DOWN_ARROW;
  exports.RIGHT_ARROW = RIGHT_ARROW;
  exports.LEFT_ARROW = LEFT_ARROW;
  exports.PAGE_UP = PAGE_UP;
  exports.PAGE_DOWN = PAGE_DOWN;
  exports.HOME = HOME;
  exports.END = END;
  exports.ENTER = ENTER;
  exports.SPACE = SPACE;
  exports.TAB = TAB;
  exports.ESCAPE = ESCAPE;
  exports.BACKSPACE = BACKSPACE;
  exports.DELETE = DELETE;
  exports.COMMA = COMMA;
  exports.getMdCompatibilityInvalidPrefixError = getMdCompatibilityInvalidPrefixError;
  exports.MATERIAL_COMPATIBILITY_MODE = MATERIAL_COMPATIBILITY_MODE;
  exports.MAT_ELEMENTS_SELECTOR = MAT_ELEMENTS_SELECTOR;
  exports.MD_ELEMENTS_SELECTOR = MD_ELEMENTS_SELECTOR;
  exports.MatPrefixRejector = MatPrefixRejector;
  exports.MdPrefixRejector = MdPrefixRejector;
  exports.AnimationCurves = AnimationCurves;
  exports.AnimationDurations = AnimationDurations;
  exports.MdSelectionModule = MdSelectionModule;
  exports.MdPseudoCheckboxBase = MdPseudoCheckboxBase;
  exports._MdPseudoCheckboxBase = _MdPseudoCheckboxBase;
  exports.MdPseudoCheckbox = MdPseudoCheckbox;
  exports.NativeDateModule = NativeDateModule;
  exports.MdNativeDateModule = MdNativeDateModule;
  exports.DateAdapter = DateAdapter;
  exports.MD_DATE_FORMATS = MD_DATE_FORMATS;
  exports.NativeDateAdapter = NativeDateAdapter;
  exports.MD_NATIVE_DATE_FORMATS = MD_NATIVE_DATE_FORMATS;
  exports.Md2AccordionModule = Md2AccordionModule;
  exports.Md2Accordion = Md2Accordion;
  exports.Md2AccordionHeader = Md2AccordionHeader;
  exports.Md2AccordionTab = Md2AccordionTab;
  exports.Md2AutocompleteModule = Md2AutocompleteModule;
  exports.Item = Item;
  exports.MD2_AUTOCOMPLETE_CONTROL_VALUE_ACCESSOR = MD2_AUTOCOMPLETE_CONTROL_VALUE_ACCESSOR;
  exports.Md2AutocompleteChange = Md2AutocompleteChange;
  exports.Md2Autocomplete = Md2Autocomplete;
  exports.HighlightPipe = HighlightPipe;
  exports.Chip = Chip;
  exports.MD2_CHIPS_CONTROL_VALUE_ACCESSOR = MD2_CHIPS_CONTROL_VALUE_ACCESSOR;
  exports.Md2ChipsChange = Md2ChipsChange;
  exports.Md2Chips = Md2Chips;
  exports.MD2_CHIPS_DIRECTIVES = MD2_CHIPS_DIRECTIVES;
  exports.Md2ChipsModule = Md2ChipsModule;
  exports.Md2CollapseModule = Md2CollapseModule;
  exports.Md2Collapse = Md2Collapse;
  exports.Md2ColorpickerModule = Md2ColorpickerModule;
  exports.SliderPosition = SliderPosition;
  exports.SliderDimension = SliderDimension;
  exports.TextDirective = TextDirective;
  exports.ColorpickerSliderDirective = ColorpickerSliderDirective;
  exports.Md2ColorChange = Md2ColorChange;
  exports.Md2Colorpicker = Md2Colorpicker;
  exports.COLOR_RGB = COLOR_RGB;
  exports.COLOR_HSL = COLOR_HSL;
  exports.Hsva = Hsva;
  exports.Hsla = Hsla;
  exports.Rgba = Rgba;
  exports.ColorUtil = ColorUtil;
  exports.Md2PaginationChange = Md2PaginationChange;
  exports.Md2DataTable = Md2DataTable;
  exports.Md2DataTableSortBy = Md2DataTableSortBy;
  exports.Md2Pagination = Md2Pagination;
  exports.MD2_DATA_TABLE_DIRECTIVES = MD2_DATA_TABLE_DIRECTIVES;
  exports.Md2DataTableModule = Md2DataTableModule;
  exports.Md2DatepickerModule = Md2DatepickerModule;
  exports.Md2DateChange = Md2DateChange;
  exports.Md2DatepickerContent = Md2DatepickerContent;
  exports.MD2_DATEPICKER_VALUE_ACCESSOR = MD2_DATEPICKER_VALUE_ACCESSOR;
  exports.MD2_DATEPICKER_VALIDATORS = MD2_DATEPICKER_VALIDATORS;
  exports.Md2Datepicker = Md2Datepicker;
  exports.Md2MonthView = Md2MonthView;
  exports.Md2YearView = Md2YearView;
  exports.Md2CalendarCell = Md2CalendarCell;
  exports.Md2CalendarBody = Md2CalendarBody;
  exports.CLOCK_RADIUS = CLOCK_RADIUS;
  exports.CLOCK_INNER_RADIUS = CLOCK_INNER_RADIUS;
  exports.CLOCK_OUTER_RADIUS = CLOCK_OUTER_RADIUS;
  exports.CLOCK_TICK_RADIUS = CLOCK_TICK_RADIUS;
  exports.Md2Clock = Md2Clock;
  exports.DateLocale = DateLocale;
  exports.DateUtil = DateUtil;
  exports.Md2DialogModule = Md2DialogModule;
  exports.Md2DialogConfig = Md2DialogConfig;
  exports.Md2DialogPortal = Md2DialogPortal;
  exports.Md2DialogTitle = Md2DialogTitle;
  exports.Md2DialogContent = Md2DialogContent;
  exports.Md2DialogActions = Md2DialogActions;
  exports.Md2Dialog = Md2Dialog;
  exports.Md2MenuContent = Md2MenuContent;
  exports.Md2MenuItem = Md2MenuItem;
  exports.Md2MenuTrigger = Md2MenuTrigger;
  exports.Md2Menu = Md2Menu;
  exports.Md2MenuModule = Md2MenuModule;
  exports.Md2SelectModule = Md2SelectModule;
  exports.fadeInContent = fadeInContent;
  exports.transformPanel = transformPanel;
  exports.transformPlaceholder = transformPlaceholder;
  exports.SELECT_ITEM_HEIGHT = SELECT_ITEM_HEIGHT;
  exports.SELECT_PANEL_MAX_HEIGHT = SELECT_PANEL_MAX_HEIGHT;
  exports.SELECT_MAX_OPTIONS_DISPLAYED = SELECT_MAX_OPTIONS_DISPLAYED;
  exports.SELECT_TRIGGER_HEIGHT = SELECT_TRIGGER_HEIGHT;
  exports.SELECT_ITEM_HEIGHT_ADJUSTMENT = SELECT_ITEM_HEIGHT_ADJUSTMENT;
  exports.SELECT_PANEL_PADDING_X = SELECT_PANEL_PADDING_X;
  exports.SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_INDENT_PADDING_X;
  exports.SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_MULTIPLE_PANEL_PADDING_X;
  exports.SELECT_PANEL_PADDING_Y = SELECT_PANEL_PADDING_Y;
  exports.SELECT_PANEL_VIEWPORT_PADDING = SELECT_PANEL_VIEWPORT_PADDING;
  exports.Md2SelectChange = Md2SelectChange;
  exports.Md2Select = Md2Select;
  exports.Md2SelectHeader = Md2SelectHeader;
  exports.Md2OptionSelectionChange = Md2OptionSelectionChange;
  exports.Md2Option = Md2Option;
  exports.Md2OptionModule = Md2OptionModule;
  exports.Md2OptgroupBase = Md2OptgroupBase;
  exports._Md2OptgroupMixinBase = _Md2OptgroupMixinBase;
  exports.Md2Optgroup = Md2Optgroup;
  exports.Md2TabChange = Md2TabChange;
  exports.Md2Transclude = Md2Transclude;
  exports.Md2Tab = Md2Tab;
  exports.Md2TabLabel = Md2TabLabel;
  exports.Md2Tabs = Md2Tabs;
  exports.MD2_TABS_DIRECTIVES = MD2_TABS_DIRECTIVES;
  exports.Md2TabsModule = Md2TabsModule;
  exports.Md2TagsModule = Md2TagsModule;
  exports.Tag = Tag;
  exports.MD2_TAGS_CONTROL_VALUE_ACCESSOR = MD2_TAGS_CONTROL_VALUE_ACCESSOR;
  exports.Md2Tags = Md2Tags;
  exports.Md2ToastModule = Md2ToastModule;
  exports.Toast = Toast;
  exports.Md2ToastConfig = Md2ToastConfig;
  exports.Md2Toast = Md2Toast;
  exports.Md2ToastComponent = Md2ToastComponent;
  exports.Md2TooltipModule = Md2TooltipModule;
  exports.throwMd2TooltipInvalidPositionError = throwMd2TooltipInvalidPositionError;
  exports.TOUCHEND_HIDE_DELAY = TOUCHEND_HIDE_DELAY;
  exports.SCROLL_THROTTLE_MS = SCROLL_THROTTLE_MS;
  exports.Md2Tooltip = Md2Tooltip;
  exports.Md2TooltipComponent = Md2TooltipComponent;
  exports.Md2Module = Md2Module;
  exports.ɵi = LIVE_ANNOUNCER_PROVIDER_FACTORY;
  exports.ɵl = mixinColor;
  exports.ɵm = mixinDisabled;
  exports.ɵj = UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY;
  exports.ɵa = MdMutationObserverFactory;
  exports.ɵc = OVERLAY_CONTAINER_PROVIDER;
  exports.ɵb = OVERLAY_CONTAINER_PROVIDER_FACTORY;
  exports.ɵk = OverlayPositionBuilder;
  exports.ɵe = VIEWPORT_RULER_PROVIDER;
  exports.ɵd = VIEWPORT_RULER_PROVIDER_FACTORY;
  exports.ɵg = SCROLL_DISPATCHER_PROVIDER;
  exports.ɵf = SCROLL_DISPATCHER_PROVIDER_FACTORY;
  exports.ɵh = RippleRenderer;
  exports.ɵo = Md2Calendar;
  exports.ɵp = slideCalendar;
  exports.ɵn = Md2DatepickerToggle;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1tZDIudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9jb21wYXRpYmlsaXR5L2NvbXBhdGliaWxpdHkudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2NvbW1vbi1iZWhhdmlvcnMvY29tbW9uLW1vZHVsZS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvbGluZS9saW5lLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9ydGwvZGlyLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vYnNlcnZlLWNvbnRlbnQvb2JzZXJ2ZS1jb250ZW50LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9yaXBwbGUvcmlwcGxlLXJlZi50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvcmlwcGxlL3JpcHBsZS1yZW5kZXJlci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvcGxhdGZvcm0vcGxhdGZvcm0udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3BsYXRmb3JtL2ZlYXR1cmVzLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9wbGF0Zm9ybS9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9zY3JvbGwvc2Nyb2xsLWRpc3BhdGNoZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvcG9zaXRpb24vdmlld3BvcnQtcnVsZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3JpcHBsZS9yaXBwbGUudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvc2Nyb2xsL3Njcm9sbGFibGUudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvc2Nyb2xsL3Njcm9sbC1zdHJhdGVneS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9zY3JvbGwvY2xvc2Utc2Nyb2xsLXN0cmF0ZWd5LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vdmVybGF5L3Njcm9sbC9ub29wLXNjcm9sbC1zdHJhdGVneS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9zY3JvbGwvYmxvY2stc2Nyb2xsLXN0cmF0ZWd5LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vdmVybGF5L3Njcm9sbC9yZXBvc2l0aW9uLXNjcm9sbC1zdHJhdGVneS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9zY3JvbGwvc2Nyb2xsLXN0cmF0ZWd5LW9wdGlvbnMudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvc2Nyb2xsL2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9yaXBwbGUvaW5kZXgudHMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9jb21tb24tYmVoYXZpb3JzL2NvbG9yLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9zZWxlY3Rpb24vcHNldWRvLWNoZWNrYm94L3BzZXVkby1jaGVja2JveC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvc2VsZWN0aW9uL2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9rZXlib2FyZC9rZXljb2Rlcy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvY29lcmNpb24vYm9vbGVhbi1wcm9wZXJ0eS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvY29tbW9uLWJlaGF2aW9ycy9kaXNhYmxlZC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3B0aW9uL29wdGdyb3VwLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vcHRpb24vb3B0aW9uLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vcHRpb24vaW5kZXgudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3BvcnRhbC9wb3J0YWwtZXJyb3JzLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9wb3J0YWwvcG9ydGFsLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9wb3J0YWwvcG9ydGFsLWRpcmVjdGl2ZXMudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvb3ZlcmxheS1zdGF0ZS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvcG9ydGFsL2RvbS1wb3J0YWwtaG9zdC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9vdmVybGF5LXJlZi50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9wb3NpdGlvbi9jb25uZWN0ZWQtcG9zaXRpb24udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvcG9zaXRpb24vY29ubmVjdGVkLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9vdmVybGF5L3Bvc2l0aW9uL2dsb2JhbC1wb3NpdGlvbi1zdHJhdGVneS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9wb3NpdGlvbi9vdmVybGF5LXBvc2l0aW9uLWJ1aWxkZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvb3ZlcmxheS1jb250YWluZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvb3ZlcmxheS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvb3ZlcmxheS9vdmVybGF5LWRpcmVjdGl2ZXMudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2ExMXkvaW50ZXJhY3Rpdml0eS1jaGVja2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9hMTF5L2ZvY3VzLXRyYXAudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2ExMXkvbGl2ZS1hbm5vdW5jZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2ExMXkvaW5kZXgudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL292ZXJsYXkvZnVsbHNjcmVlbi1vdmVybGF5LWNvbnRhaW5lci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvZ2VzdHVyZXMvZ2VzdHVyZS1jb25maWcudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3NlbGVjdGlvbi9zZWxlY3Rpb24udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2ExMXkvZmFrZS1tb3VzZWRvd24udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2Nvb3JkaW5hdGlvbi91bmlxdWUtc2VsZWN0aW9uLWRpc3BhdGNoZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3N0eWxlL2ZvY3VzLW9yaWdpbi1tb25pdG9yLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9zdHlsZS9hcHBseS10cmFuc2Zvcm0udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL3N0eWxlL2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9hbmltYXRpb24vYW5pbWF0aW9uLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9jb2VyY2lvbi9udW1iZXItcHJvcGVydHkudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb3JlL2RhdGV0aW1lL2RhdGUtYWRhcHRlci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvZGF0ZXRpbWUvbmF0aXZlLWRhdGUtYWRhcHRlci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvZGF0ZXRpbWUvZGF0ZS1mb3JtYXRzLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9kYXRldGltZS9uYXRpdmUtZGF0ZS1mb3JtYXRzLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9kYXRldGltZS9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvcGxhY2Vob2xkZXIvcGxhY2Vob2xkZXItb3B0aW9ucy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvY29yZS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2FjY29yZGlvbi9hY2NvcmRpb24udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9hY2NvcmRpb24vYWNjb3JkaW9udGFiLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvYWNjb3JkaW9uL2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS1waXBlLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2F1dG9jb21wbGV0ZS9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NoaXBzL2NoaXBzLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29sbGFwc2UvY29sbGFwc2UudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb2xsYXBzZS9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvbG9ycGlja2VyL2NvbG9yLXV0aWwudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9jb2xvcnBpY2tlci9jb2xvcnBpY2tlci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvbG9ycGlja2VyL2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvc2VsZWN0L29wdGdyb3VwLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvc2VsZWN0L29wdGlvbi50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvYTExeS9saXN0LWtleS1tYW5hZ2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvY29yZS9hMTF5L2ZvY3VzLWtleS1tYW5hZ2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvc2VsZWN0L3NlbGVjdC1hbmltYXRpb25zLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvc2VsZWN0L3NlbGVjdC1lcnJvcnMudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9zZWxlY3Qvc2VsZWN0LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvc2VsZWN0L3NlbGVjdC1oZWFkZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9zZWxlY3QvaW5kZXgudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRhLXRhYmxlL2RhdGEtdGFibGUudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRlcGlja2VyL2RhdGUtbG9jYWxlLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGF0ZXBpY2tlci9kYXRlLXV0aWwudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRlcGlja2VyL2RhdGVwaWNrZXItYW5pbWF0aW9ucy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2RhdGVwaWNrZXIvY2FsZW5kYXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRlcGlja2VyL2RhdGVwaWNrZXIudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRlcGlja2VyL2RhdGVwaWNrZXItdG9nZ2xlLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGF0ZXBpY2tlci9jYWxlbmRhci1ib2R5LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGF0ZXBpY2tlci9tb250aC12aWV3LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGF0ZXBpY2tlci95ZWFyLXZpZXcudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9kYXRlcGlja2VyL2Nsb2NrLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGF0ZXBpY2tlci9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2NvcmUvdXRpbC9vYmplY3QtZXh0ZW5kLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvZGlhbG9nL2RpYWxvZy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL2RpYWxvZy9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL21lbnUvbWVudS1jb250ZW50LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvbWVudS9tZW51LWl0ZW0udHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi9tZW51L21lbnUtdHJpZ2dlci50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL21lbnUvbWVudS50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL3RhYnMvdGFicy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL3RhZ3MvdGFncy50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL3RhZ3MvaW5kZXgudHMiLCJuZzovL2FuZ3VsYXItbWQyL2xpYi90b2FzdC90b2FzdC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL3RvYXN0L2luZGV4LnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvdG9vbHRpcC90b29sdGlwLnRzIiwibmc6Ly9hbmd1bGFyLW1kMi9saWIvdG9vbHRpcC9pbmRleC50cyIsIm5nOi8vYW5ndWxhci1tZDIvbGliL21kLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge05nTW9kdWxlLCBEaXJlY3RpdmUsIEluamVjdCwgT3B0aW9uYWwsIEVsZW1lbnRSZWYsIEluamVjdGlvblRva2VufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGNvbnN0IE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignbWQtY29tcGF0aWJpbGl0eS1tb2RlJyk7XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGNlcHRpb24gdG8gYmUgdGhyb3duIGlmIHRoZSBjb25zdW1lciBoYXMgdXNlZFxuICogYW4gaW52YWxpZCBNYXRlcmlhbCBwcmVmaXggb24gYSBjb21wb25lbnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZENvbXBhdGliaWxpdHlJbnZhbGlkUHJlZml4RXJyb3IocHJlZml4OiBzdHJpbmcsIG5vZGVOYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIEVycm9yKGBUaGUgXCIke3ByZWZpeH0tXCIgcHJlZml4IGNhbm5vdCBiZSB1c2VkIGluIG5nLW1hdGVyaWFsIHYxIGNvbXBhdGliaWxpdHkgbW9kZS4gYCArXG4gICAgICAgICAgICAgICAgICAgYEl0IHdhcyB1c2VkIG9uIGFuIFwiJHtub2RlTmFtZS50b0xvd2VyQ2FzZSgpfVwiIGVsZW1lbnQuYCk7XG59XG5cbi8qKiBTZWxlY3RvciB0aGF0IG1hdGNoZXMgYWxsIGVsZW1lbnRzIHRoYXQgbWF5IGhhdmUgc3R5bGUgY29sbGlzaW9ucyB3aXRoIEFuZ3VsYXJKUyBNYXRlcmlhbC4gKi9cbmV4cG9ydCBjb25zdCBNQVRfRUxFTUVOVFNfU0VMRUNUT1IgPSBgXG4gIFttYXQtYnV0dG9uXSxcbiAgW21hdC1mYWJdLFxuICBbbWF0LWljb24tYnV0dG9uXSxcbiAgW21hdC1taW5pLWZhYl0sXG4gIFttYXQtcmFpc2VkLWJ1dHRvbl0sXG4gIFttYXRDYXJkU3VidGl0bGVdLFxuICBbbWF0Q2FyZFRpdGxlXSxcbiAgW21hdERpYWxvZ0FjdGlvbnNdLFxuICBbbWF0RGlhbG9nQ2xvc2VdLFxuICBbbWF0RGlhbG9nQ29udGVudF0sXG4gIFttYXREaWFsb2dUaXRsZV0sXG4gIFttYXRMaW5lXSxcbiAgW21hdFRhYkxhYmVsXSxcbiAgW21hdFRhYkxpbmtdLFxuICBbbWF0VGFiTmF2XSxcbiAgW21hdFRvb2x0aXBdLFxuICBtYXQtYXV0b2NvbXBsZXRlLFxuICBtYXQtYnV0dG9uLXRvZ2dsZSxcbiAgbWF0LWJ1dHRvbi10b2dnbGUsXG4gIG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwLFxuICBtYXQtY2FyZCxcbiAgbWF0LWNhcmQtYWN0aW9ucyxcbiAgbWF0LWNhcmQtY29udGVudCxcbiAgbWF0LWNhcmQtZm9vdGVyLFxuICBtYXQtY2FyZC1oZWFkZXIsXG4gIG1hdC1jYXJkLXN1YnRpdGxlLFxuICBtYXQtY2FyZC10aXRsZSxcbiAgbWF0LWNhcmQtdGl0bGUtZ3JvdXAsXG4gIG1hdC1jaGVja2JveCxcbiAgbWF0LWNoaXAsXG4gIG1hdC1kaWFsb2ctYWN0aW9ucyxcbiAgbWF0LWRpYWxvZy1jb250YWluZXIsXG4gIG1hdC1kaWFsb2ctY29udGVudCxcbiAgbWF0LWRpdmlkZXIsXG4gIG1hdC1lcnJvcixcbiAgbWF0LWdyaWQtbGlzdCxcbiAgbWF0LWdyaWQtdGlsZSxcbiAgbWF0LWdyaWQtdGlsZS1mb290ZXIsXG4gIG1hdC1ncmlkLXRpbGUtaGVhZGVyLFxuICBtYXQtaGludCxcbiAgbWF0LWljb24sXG4gIG1hdC1saXN0LFxuICBtYXQtbGlzdC1pdGVtLFxuICBtYXQtbWVudSxcbiAgbWF0LW5hdi1saXN0LFxuICBtYXQtb3B0aW9uLFxuICBtYXQtcGxhY2Vob2xkZXIsXG4gIG1hdC1wcm9ncmVzcy1iYXIsXG4gIG1hdC1wc2V1ZG8tY2hlY2tib3gsXG4gIG1hdC1yYWRpby1idXR0b24sXG4gIG1hdC1yYWRpby1ncm91cCxcbiAgbWF0LXNlbGVjdCxcbiAgbWF0LXNpZGVuYXYsXG4gIG1hdC1zaWRlbmF2LWNvbnRhaW5lcixcbiAgbWF0LXNsaWRlcixcbiAgbWF0LXNwaW5uZXIsXG4gIG1hdC10YWIsXG4gIG1hdC10YWItZ3JvdXAsXG4gIG1hdC10b29sYmFyYDtcblxuLyoqIFNlbGVjdG9yIHRoYXQgbWF0Y2hlcyBhbGwgZWxlbWVudHMgdGhhdCBtYXkgaGF2ZSBzdHlsZSBjb2xsaXNpb25zIHdpdGggQW5ndWxhckpTIE1hdGVyaWFsLiAqL1xuZXhwb3J0IGNvbnN0IE1EX0VMRU1FTlRTX1NFTEVDVE9SID0gYFxuICBbbWQtYnV0dG9uXSxcbiAgW21kLWZhYl0sXG4gIFttZC1pY29uLWJ1dHRvbl0sXG4gIFttZC1taW5pLWZhYl0sXG4gIFttZC1yYWlzZWQtYnV0dG9uXSxcbiAgW21kQ2FyZFN1YnRpdGxlXSxcbiAgW21kQ2FyZFRpdGxlXSxcbiAgW21kRGlhbG9nQWN0aW9uc10sXG4gIFttZERpYWxvZ0Nsb3NlXSxcbiAgW21kRGlhbG9nQ29udGVudF0sXG4gIFttZERpYWxvZ1RpdGxlXSxcbiAgW21kTGluZV0sXG4gIFttZFRhYkxhYmVsXSxcbiAgW21kVGFiTGlua10sXG4gIFttZFRhYk5hdl0sXG4gIFttZFRvb2x0aXBdLFxuICBtZC1hdXRvY29tcGxldGUsXG4gIG1kLWJ1dHRvbi10b2dnbGUsXG4gIG1kLWJ1dHRvbi10b2dnbGUsXG4gIG1kLWJ1dHRvbi10b2dnbGUtZ3JvdXAsXG4gIG1kLWNhcmQsXG4gIG1kLWNhcmQtYWN0aW9ucyxcbiAgbWQtY2FyZC1jb250ZW50LFxuICBtZC1jYXJkLWZvb3RlcixcbiAgbWQtY2FyZC1oZWFkZXIsXG4gIG1kLWNhcmQtc3VidGl0bGUsXG4gIG1kLWNhcmQtdGl0bGUsXG4gIG1kLWNhcmQtdGl0bGUtZ3JvdXAsXG4gIG1kLWNoZWNrYm94LFxuICBtZC1jaGlwLFxuICBtZC1kaWFsb2ctYWN0aW9ucyxcbiAgbWQtZGlhbG9nLWNvbnRhaW5lcixcbiAgbWQtZGlhbG9nLWNvbnRlbnQsXG4gIG1kLWRpdmlkZXIsXG4gIG1kLWVycm9yLFxuICBtZC1ncmlkLWxpc3QsXG4gIG1kLWdyaWQtdGlsZSxcbiAgbWQtZ3JpZC10aWxlLWZvb3RlcixcbiAgbWQtZ3JpZC10aWxlLWhlYWRlcixcbiAgbWQtaGludCxcbiAgbWQtaWNvbixcbiAgbWQtbGlzdCxcbiAgbWQtbGlzdC1pdGVtLFxuICBtZC1tZW51LFxuICBtZC1uYXYtbGlzdCxcbiAgbWQtb3B0aW9uLFxuICBtZC1wbGFjZWhvbGRlcixcbiAgbWQtcHJvZ3Jlc3MtYmFyLFxuICBtZC1wc2V1ZG8tY2hlY2tib3gsXG4gIG1kLXJhZGlvLWJ1dHRvbixcbiAgbWQtcmFkaW8tZ3JvdXAsXG4gIG1kLXNlbGVjdCxcbiAgbWQtc2lkZW5hdixcbiAgbWQtc2lkZW5hdi1jb250YWluZXIsXG4gIG1kLXNsaWRlcixcbiAgbWQtc3Bpbm5lcixcbiAgbWQtdGFiLFxuICBtZC10YWItZ3JvdXAsXG4gIG1kLXRvb2xiYXJgO1xuXG4vKiogRGlyZWN0aXZlIHRoYXQgZW5mb3JjZXMgdGhhdCB0aGUgYG1hdC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC4gKi9cbkBEaXJlY3RpdmUoe3NlbGVjdG9yOiBNQVRfRUxFTUVOVFNfU0VMRUNUT1J9KVxuZXhwb3J0IGNsYXNzIE1hdFByZWZpeFJlamVjdG9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUpIGlzQ29tcGF0aWJpbGl0eU1vZGU6IGJvb2xlYW4sXG4gICAgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuXG4gICAgaWYgKCFpc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICB0aHJvdyBnZXRNZENvbXBhdGliaWxpdHlJbnZhbGlkUHJlZml4RXJyb3IoJ21hdCcsIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ub2RlTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBEaXJlY3RpdmUgdGhhdCBlbmZvcmNlcyB0aGF0IHRoZSBgbWQtYCBwcmVmaXggY2Fubm90IGJlIHVzZWQuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogTURfRUxFTUVOVFNfU0VMRUNUT1J9KVxuZXhwb3J0IGNsYXNzIE1kUHJlZml4UmVqZWN0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSkgaXNDb21wYXRpYmlsaXR5TW9kZTogYm9vbGVhbixcbiAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICBpZiAoaXNDb21wYXRpYmlsaXR5TW9kZSkge1xuICAgICAgdGhyb3cgZ2V0TWRDb21wYXRpYmlsaXR5SW52YWxpZFByZWZpeEVycm9yKCdtZCcsIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5ub2RlTmFtZSk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyB0aGUgZGVmYXVsdCBjb21wYXRpYmlsaXR5IG1vZGUgc2V0dGluZ3MuIFdoZW4gdGhpcyBtb2R1bGUgaXMgbG9hZGVkXG4gKiB3aXRob3V0IE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlIGFsc28gYmVpbmcgaW1wb3J0ZWQsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAqIHRoZXJlIGFyZSBhbnkgdXNlcyBvZiB0aGUgYG1hdC1gIHByZWZpeC5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbTWF0UHJlZml4UmVqZWN0b3IsIE1kUHJlZml4UmVqZWN0b3JdLFxuICBleHBvcnRzOiBbTWF0UHJlZml4UmVqZWN0b3IsIE1kUHJlZml4UmVqZWN0b3JdLFxufSlcbmV4cG9ydCBjbGFzcyBDb21wYXRpYmlsaXR5TW9kdWxlIHt9XG5cblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyBcIm5vLWNvbmZsaWN0XCIgY29tcGF0aWJpbGl0eSBtb2RlIHNldHRpbmdzLiBXaGVuIHRoaXMgbW9kdWxlIGlzIGxvYWRlZCxcbiAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSB1c2VzIG9mIHRoZSBgbWQtYCBwcmVmaXguXG4gKi9cbkBOZ01vZHVsZSh7XG4gIHByb3ZpZGVyczogW3tcbiAgICBwcm92aWRlOiBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUsIHVzZVZhbHVlOiB0cnVlLFxuICB9XSxcbn0pXG5leHBvcnQgY2xhc3MgTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUge31cbiIsImltcG9ydCB7TmdNb2R1bGUsIEluamVjdGlvblRva2VuLCBPcHRpb25hbCwgSW5qZWN0LCBpc0Rldk1vZGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtET0NVTUVOVH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQge0NvbXBhdGliaWxpdHlNb2R1bGV9IGZyb20gJy4uL2NvbXBhdGliaWxpdHkvY29tcGF0aWJpbGl0eSc7XG5cblxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNvbmZpZ3VyZXMgd2hldGhlciB0aGUgTWF0ZXJpYWwgc2FuaXR5IGNoZWNrcyBhcmUgZW5hYmxlZC4gKi9cbmV4cG9ydCBjb25zdCBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTID0gbmV3IEluamVjdGlvblRva2VuPGJvb2xlYW4+KCdtZC1zYW5pdHktY2hlY2tzJyk7XG5cblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBjYXB0dXJlcyBhbnl0aGluZyB0aGF0IHNob3VsZCBiZSBsb2FkZWQgYW5kL29yIHJ1biBmb3IgKmFsbCogQW5ndWxhciBNYXRlcmlhbFxuICogY29tcG9uZW50cy4gVGhpcyBpbmNsdWRlcyBCaWRpLCBjb21wYXRpYmlsaXR5IG1vZGUsIGV0Yy5cbiAqXG4gKiBUaGlzIG1vZHVsZSBzaG91bGQgYmUgaW1wb3J0ZWQgdG8gZWFjaCB0b3AtbGV2ZWwgY29tcG9uZW50IG1vZHVsZSAoZS5nLiwgTWRUYWJzTW9kdWxlKS5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGVdLFxuICBleHBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gIHByb3ZpZGVyczogW3tcbiAgICBwcm92aWRlOiBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTLCB1c2VWYWx1ZTogdHJ1ZSxcbiAgfV0sXG59KVxuZXhwb3J0IGNsYXNzIE1kQ29tbW9uTW9kdWxlIHtcbiAgLyoqIFdoZXRoZXIgd2UndmUgZG9uZSB0aGUgZ2xvYmFsIHNhbml0eSBjaGVja3MgKGUuZy4gYSB0aGVtZSBpcyBsb2FkZWQsIHRoZXJlIGlzIGEgZG9jdHlwZSkuICovXG4gIHByaXZhdGUgX2hhc0RvbmVHbG9iYWxDaGVja3MgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTUFURVJJQUxfU0FOSVRZX0NIRUNLUykgX3Nhbml0eUNoZWNrc0VuYWJsZWQ6IGJvb2xlYW4pIHtcblxuICAgIGlmIChfc2FuaXR5Q2hlY2tzRW5hYmxlZCAmJiAhdGhpcy5faGFzRG9uZUdsb2JhbENoZWNrcyAmJiBfZG9jdW1lbnQgJiYgaXNEZXZNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NoZWNrRG9jdHlwZSgpO1xuICAgICAgdGhpcy5fY2hlY2tUaGVtZSgpO1xuICAgICAgdGhpcy5faGFzRG9uZUdsb2JhbENoZWNrcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tEb2N0eXBlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fZG9jdW1lbnQuZG9jdHlwZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnQ3VycmVudCBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGEgZG9jdHlwZS4gVGhpcyBtYXkgY2F1c2UgJyArXG4gICAgICAgICdzb21lIEFuZ3VsYXIgTWF0ZXJpYWwgY29tcG9uZW50cyBub3QgdG8gYmVoYXZlIGFzIGV4cGVjdGVkLidcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tUaGVtZSgpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIGdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHRlc3RFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21hdC10aGVtZS1sb2FkZWQtbWFya2VyJyk7XG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGVzdEVsZW1lbnQpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIEFuZ3VsYXIgTWF0ZXJpYWwgY29yZSB0aGVtZS4gTW9zdCBNYXRlcmlhbCAnICtcbiAgICAgICAgICAnY29tcG9uZW50cyBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBtb3JlIGluZm8gcmVmZXIgJyArXG4gICAgICAgICAgJ3RvIHRoZSB0aGVtaW5nIGd1aWRlOiBodHRwczovL21hdGVyaWFsLmFuZ3VsYXIuaW8vZ3VpZGUvdGhlbWluZydcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXN0RWxlbWVudCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBOZ01vZHVsZSxcbiAgRGlyZWN0aXZlLFxuICBSZW5kZXJlcjIsXG4gIEVsZW1lbnRSZWYsXG4gIFF1ZXJ5TGlzdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge01kQ29tbW9uTW9kdWxlfSBmcm9tICcuLi9jb21tb24tYmVoYXZpb3JzL2NvbW1vbi1tb2R1bGUnO1xuXG5cbi8qKlxuICogU2hhcmVkIGRpcmVjdGl2ZSB0byBjb3VudCBsaW5lcyBpbnNpZGUgYSB0ZXh0IGFyZWEsIHN1Y2ggYXMgYSBsaXN0IGl0ZW0uXG4gKiBMaW5lIGVsZW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBhIEBDb250ZW50Q2hpbGRyZW4oTWRMaW5lKSBxdWVyeSwgdGhlblxuICogY291bnRlZCBieSBjaGVja2luZyB0aGUgcXVlcnkgbGlzdCdzIGxlbmd0aC5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW21kLWxpbmVdLCBbbWF0LWxpbmVdLCBbbWRMaW5lXSwgW21hdExpbmVdJyxcbiAgaG9zdDogeydjbGFzcyc6ICdtYXQtbGluZSd9XG59KVxuZXhwb3J0IGNsYXNzIE1kTGluZSB7fVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHRha2VzIGEgcXVlcnkgbGlzdCBvZiBsaW5lcyBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzcyBvbiB0aGUgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIE1kTGluZVNldHRlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xpbmVzOiBRdWVyeUxpc3Q8TWRMaW5lPiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgIHRoaXMuX3NldExpbmVDbGFzcyh0aGlzLl9saW5lcy5sZW5ndGgpO1xuXG4gICAgdGhpcy5fbGluZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0TGluZUNsYXNzKHRoaXMuX2xpbmVzLmxlbmd0aCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9zZXRMaW5lQ2xhc3MoY291bnQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX3Jlc2V0Q2xhc3NlcygpO1xuICAgIGlmIChjb3VudCA9PT0gMiB8fCBjb3VudCA9PT0gMykge1xuICAgICAgdGhpcy5fc2V0Q2xhc3MoYG1hdC0ke2NvdW50fS1saW5lYCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChjb3VudCA+IDMpIHtcbiAgICAgIHRoaXMuX3NldENsYXNzKGBtYXQtbXVsdGktbGluZWAsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0Q2xhc3NlcygpOiB2b2lkIHtcbiAgICB0aGlzLl9zZXRDbGFzcygnbWF0LTItbGluZScsIGZhbHNlKTtcbiAgICB0aGlzLl9zZXRDbGFzcygnbWF0LTMtbGluZScsIGZhbHNlKTtcbiAgICB0aGlzLl9zZXRDbGFzcygnbWF0LW11bHRpLWxpbmUnLCBmYWxzZSk7XG4gIH1cblxuICBwcml2YXRlIF9zZXRDbGFzcyhjbGFzc05hbWU6IHN0cmluZywgaXNBZGQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoaXNBZGQpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuXG59XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtNZExpbmUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbTWRMaW5lXSxcbn0pXG5leHBvcnQgY2xhc3MgTWRMaW5lTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtcbiAgTmdNb2R1bGUsXG4gIERpcmVjdGl2ZSxcbiAgSG9zdEJpbmRpbmcsXG4gIE91dHB1dCxcbiAgSW5wdXQsXG4gIEV2ZW50RW1pdHRlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IHR5cGUgTGF5b3V0RGlyZWN0aW9uID0gJ2x0cicgfCAncnRsJztcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9mIGRpcmVjdGlvbiBvZiBwYXJ0IG9mIHRoZSBET00uXG4gKlxuICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zdGVhZCBvZiB0aGUgbmF0aXZlIGF0dHJpYnV0ZSBzbyB0aGF0IE1hdGVyaWFsXG4gKiBjb21wb25lbnRzIGNhbiBsaXN0ZW4gb24gY2hhbmdlcyBvZiBkaXJlY3Rpb24uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tkaXJdJyxcbiAgLy8gVE9ETyhoYW5zbCk6IG1heWJlIGAkaW1wbGljaXRgIGlzbid0IHRoZSBiZXN0IG9wdGlvbiBoZXJlLCBidXQgZm9yIG5vdyB0aGF0J3MgdGhlIGJlc3Qgd2UgZ290LlxuICBleHBvcnRBczogJyRpbXBsaWNpdCdcbn0pXG5leHBvcnQgY2xhc3MgRGlyIHtcbiAgLyoqIExheW91dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuICovXG4gIEBJbnB1dCgnZGlyJykgX2RpcjogTGF5b3V0RGlyZWN0aW9uID0gJ2x0cic7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZGlyZWN0aW9uIGNoYW5nZXMuICovXG4gIEBPdXRwdXQoKSBkaXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmRpcicpXG4gIGdldCBkaXIoKTogTGF5b3V0RGlyZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyO1xuICB9XG4gIHNldCBkaXIodjogTGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgbGV0IG9sZCA9IHRoaXMuX2RpcjtcbiAgICB0aGlzLl9kaXIgPSB2O1xuICAgIGlmIChvbGQgIT0gdGhpcy5fZGlyKSB7XG4gICAgICB0aGlzLmRpckNoYW5nZS5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEN1cnJlbnQgbGF5b3V0IGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudC4gKi9cbiAgZ2V0IHZhbHVlKCk6IExheW91dERpcmVjdGlvbiB7IHJldHVybiB0aGlzLmRpcjsgfVxuICBzZXQgdmFsdWUodjogTGF5b3V0RGlyZWN0aW9uKSB7IHRoaXMuZGlyID0gdjsgfVxufVxuXG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtEaXJdLFxuICBkZWNsYXJhdGlvbnM6IFtEaXJdXG59KVxuZXhwb3J0IGNsYXNzIFJ0bE1vZHVsZSB7fVxuIiwiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBOZ01vZHVsZSxcbiAgT3V0cHV0LFxuICBJbnB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBPbkRlc3Ryb3ksXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEluamVjdGFibGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGVib3VuY2VUaW1lfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogRmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBuZXcgTXV0YXRpb25PYnNlcnZlciBhbmQgYWxsb3dzIHVzIHRvIHN0dWIgaXQgb3V0IGluIHVuaXQgdGVzdHMuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5IHtcbiAgY3JlYXRlKGNhbGxiYWNrOiBhbnkpOiBNdXRhdGlvbk9ic2VydmVyIHtcbiAgICByZXR1cm4gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IHRyaWdnZXJzIGEgY2FsbGJhY2sgd2hlbmV2ZXIgdGhlIGNvbnRlbnQgb2ZcbiAqIGl0cyBhc3NvY2lhdGVkIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjZGtPYnNlcnZlQ29udGVudF0nXG59KVxuZXhwb3J0IGNsYXNzIE9ic2VydmVDb250ZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgZm9yIGVhY2ggY2hhbmdlIGluIHRoZSBlbGVtZW50J3MgY29udGVudC4gKi9cbiAgQE91dHB1dCgnY2RrT2JzZXJ2ZUNvbnRlbnQnKSBldmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8TXV0YXRpb25SZWNvcmRbXT4oKTtcblxuICAvKiogVXNlZCBmb3IgZGVib3VuY2luZyB0aGUgZW1pdHRlZCB2YWx1ZXMgdG8gdGhlIG9ic2VydmVDb250ZW50IGV2ZW50LiAqL1xuICBwcml2YXRlIF9kZWJvdW5jZXIgPSBuZXcgU3ViamVjdDxNdXRhdGlvblJlY29yZFtdPigpO1xuXG4gIC8qKiBEZWJvdW5jZSBpbnRlcnZhbCBmb3IgZW1pdHRpbmcgdGhlIGNoYW5nZXMuICovXG4gIEBJbnB1dCgpIGRlYm91bmNlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfbXV0YXRpb25PYnNlcnZlckZhY3Rvcnk6IE1kTXV0YXRpb25PYnNlcnZlckZhY3RvcnksXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICh0aGlzLmRlYm91bmNlID4gMCkge1xuICAgICAgdGhpcy5fZGVib3VuY2VyXG4gICAgICAgIC5waXBlKGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlKSlcbiAgICAgICAgLnN1YnNjcmliZShtdXRhdGlvbnMgPT4gdGhpcy5ldmVudC5lbWl0KG11dGF0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXIuc3Vic2NyaWJlKG11dGF0aW9ucyA9PiB0aGlzLmV2ZW50LmVtaXQobXV0YXRpb25zKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5jcmVhdGUoKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSkgPT4ge1xuICAgICAgdGhpcy5fZGVib3VuY2VyLm5leHQobXV0YXRpb25zKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHtcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuX2RlYm91bmNlci5jb21wbGV0ZSgpO1xuICAgICAgdGhpcy5fZGVib3VuY2VyID0gdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtPYnNlcnZlQ29udGVudF0sXG4gIGRlY2xhcmF0aW9uczogW09ic2VydmVDb250ZW50XSxcbiAgcHJvdmlkZXJzOiBbTWRNdXRhdGlvbk9ic2VydmVyRmFjdG9yeV1cbn0pXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUge31cbiIsImltcG9ydCB7UmlwcGxlQ29uZmlnLCBSaXBwbGVSZW5kZXJlcn0gZnJvbSAnLi9yaXBwbGUtcmVuZGVyZXInO1xuXG4vKiogUG9zc2libGUgc3RhdGVzIGZvciBhIHJpcHBsZSBlbGVtZW50LiAqL1xuZXhwb3J0IGVudW0gUmlwcGxlU3RhdGUge1xuICBGQURJTkdfSU4sIFZJU0lCTEUsIEZBRElOR19PVVQsIEhJRERFTlxufVxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIHByZXZpb3VzbHkgbGF1bmNoZWQgcmlwcGxlIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSaXBwbGVSZWYge1xuXG4gIC8qKiBDdXJyZW50IHN0YXRlIG9mIHRoZSByaXBwbGUgcmVmZXJlbmNlLiAqL1xuICBzdGF0ZTogUmlwcGxlU3RhdGUgPSBSaXBwbGVTdGF0ZS5ISURERU47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJpcHBsZVJlbmRlcmVyLFxuICAgIHB1YmxpYyBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICBwdWJsaWMgY29uZmlnOiBSaXBwbGVDb25maWcpIHtcbiAgfVxuXG4gIC8qKiBGYWRlcyBvdXQgdGhlIHJpcHBsZSBlbGVtZW50LiAqL1xuICBmYWRlT3V0KCkge1xuICAgIHRoaXMuX3JlbmRlcmVyLmZhZGVPdXRSaXBwbGUodGhpcyk7XG4gIH1cbn1cbiIsImltcG9ydCB7RWxlbWVudFJlZiwgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL3BsYXRmb3JtJztcbmltcG9ydCB7Vmlld3BvcnRSdWxlcn0gZnJvbSAnLi4vb3ZlcmxheS9wb3NpdGlvbi92aWV3cG9ydC1ydWxlcic7XG5pbXBvcnQge1JpcHBsZVJlZiwgUmlwcGxlU3RhdGV9IGZyb20gJy4vcmlwcGxlLXJlZic7XG5cblxuLyoqIEZhZGUtaW4gZHVyYXRpb24gZm9yIHRoZSByaXBwbGVzLiBDYW4gYmUgbW9kaWZpZWQgd2l0aCB0aGUgc3BlZWRGYWN0b3Igb3B0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IFJJUFBMRV9GQURFX0lOX0RVUkFUSU9OID0gNDUwO1xuXG4vKiogRmFkZS1vdXQgZHVyYXRpb24gZm9yIHRoZSByaXBwbGVzIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBjYW4ndCBiZSBtb2RpZmllZCBieSB0aGUgc3BlZWRGYWN0b3IuICovXG5leHBvcnQgY29uc3QgUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OID0gNDAwO1xuXG5leHBvcnQgdHlwZSBSaXBwbGVDb25maWcgPSB7XG4gIGNvbG9yPzogc3RyaW5nO1xuICBjZW50ZXJlZD86IGJvb2xlYW47XG4gIHJhZGl1cz86IG51bWJlcjtcbiAgc3BlZWRGYWN0b3I/OiBudW1iZXI7XG4gIHBlcnNpc3RlbnQ/OiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgc2VydmljZSB0aGF0IHBlcmZvcm1zIERPTSBtYW5pcHVsYXRpb25zLiBOb3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgZGlyZWN0aXZlJ3MgaG9zdCBlbGVtZW50IGFuZCBhIG1hcCBvZiBET01cbiAqIGV2ZW50IGhhbmRsZXJzIHRvIGJlIGluc3RhbGxlZCBvbiB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHJpcHBsZSBhbmltYXRpb25zLlxuICogVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGEgY3VzdG9tIHJlbmRlcmVyIG9uY2UgQW5ndWxhciBzdXBwb3J0IGV4aXN0cy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFJpcHBsZVJlbmRlcmVyIHtcblxuICAvKiogRWxlbWVudCB3aGVyZSB0aGUgcmlwcGxlcyBhcmUgYmVpbmcgYWRkZWQgdG8uICovXG4gIHByaXZhdGUgX2NvbnRhaW5lckVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuXG4gIC8qKiBFbGVtZW50IHdoaWNoIHRyaWdnZXJzIHRoZSByaXBwbGUgZWxlbWVudHMgb24gbW91c2UgZXZlbnRzLiAqL1xuICBwcml2YXRlIF90cmlnZ2VyRWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBkb3duIG9yIG5vdC4gKi9cbiAgcHJpdmF0ZSBfaXNNb3VzZWRvd246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogRXZlbnRzIHRvIGJlIHJlZ2lzdGVyZWQgb24gdGhlIHRyaWdnZXIgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfdHJpZ2dlckV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgLyoqIFNldCBvZiBjdXJyZW50bHkgYWN0aXZlIHJpcHBsZSByZWZlcmVuY2VzLiAqL1xuICBwcml2YXRlIF9hY3RpdmVSaXBwbGVzID0gbmV3IFNldDxSaXBwbGVSZWY+KCk7XG5cbiAgLyoqIFJpcHBsZSBjb25maWcgZm9yIGFsbCByaXBwbGVzIGNyZWF0ZWQgYnkgZXZlbnRzLiAqL1xuICByaXBwbGVDb25maWc6IFJpcHBsZUNvbmZpZyA9IHt9O1xuXG4gIC8qKiBXaGV0aGVyIG1vdXNlIHJpcHBsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgb3Igbm90LiAqL1xuICByaXBwbGVEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgICAgcHJpdmF0ZSBfcnVsZXI6IFZpZXdwb3J0UnVsZXIsXG4gICAgICBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgICAvLyBPbmx5IGRvIGFueXRoaW5nIGlmIHdlJ3JlIG9uIHRoZSBicm93c2VyLlxuICAgIGlmIChwbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgIC8vIFNwZWNpZnkgZXZlbnRzIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBvbiB0aGUgdHJpZ2dlci5cbiAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5zZXQoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQgdXNlIHRoZSBob3N0IGVsZW1lbnQgYXMgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgdGhpcy5zZXRUcmlnZ2VyRWxlbWVudCh0aGlzLl9jb250YWluZXJFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKiogRmFkZXMgaW4gYSByaXBwbGUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiAqL1xuICBmYWRlSW5SaXBwbGUocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgY29uZmlnOiBSaXBwbGVDb25maWcgPSB7fSk6IFJpcHBsZVJlZiB7XG4gICAgbGV0IGNvbnRhaW5lclJlY3QgPSB0aGlzLl9jb250YWluZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgaWYgKGNvbmZpZy5jZW50ZXJlZCkge1xuICAgICAgcGFnZVggPSBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgIHBhZ2VZID0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1YnRyYWN0IHNjcm9sbCB2YWx1ZXMgZnJvbSB0aGUgY29vcmRpbmF0ZXMgYmVjYXVzZSBjYWxjdWxhdGlvbnMgYmVsb3dcbiAgICAgIC8vIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IHJlY3RhbmdsZS5cbiAgICAgIGxldCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3J1bGVyLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgIHBhZ2VYIC09IHNjcm9sbFBvc2l0aW9uLmxlZnQ7XG4gICAgICBwYWdlWSAtPSBzY3JvbGxQb3NpdGlvbi50b3A7XG4gICAgfVxuXG4gICAgbGV0IHJhZGl1cyA9IGNvbmZpZy5yYWRpdXMgfHwgZGlzdGFuY2VUb0Z1cnRoZXN0Q29ybmVyKHBhZ2VYLCBwYWdlWSwgY29udGFpbmVyUmVjdCk7XG4gICAgbGV0IGR1cmF0aW9uID0gUklQUExFX0ZBREVfSU5fRFVSQVRJT04gKiAoMSAvIChjb25maWcuc3BlZWRGYWN0b3IgfHwgMSkpO1xuICAgIGxldCBvZmZzZXRYID0gcGFnZVggLSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgbGV0IG9mZnNldFkgPSBwYWdlWSAtIGNvbnRhaW5lclJlY3QudG9wO1xuXG4gICAgbGV0IHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdtYXQtcmlwcGxlLWVsZW1lbnQnKTtcblxuICAgIHJpcHBsZS5zdHlsZS5sZWZ0ID0gYCR7b2Zmc2V0WCAtIHJhZGl1c31weGA7XG4gICAgcmlwcGxlLnN0eWxlLnRvcCA9IGAke29mZnNldFkgLSByYWRpdXN9cHhgO1xuICAgIHJpcHBsZS5zdHlsZS5oZWlnaHQgPSBgJHtyYWRpdXMgKiAyfXB4YDtcbiAgICByaXBwbGUuc3R5bGUud2lkdGggPSBgJHtyYWRpdXMgKiAyfXB4YDtcblxuICAgIC8vIElmIHRoZSBjb2xvciBpcyBub3Qgc2V0LCB0aGUgZGVmYXVsdCBDU1MgY29sb3Igd2lsbCBiZSB1c2VkLlxuICAgIHJpcHBsZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuY29sb3I7XG4gICAgcmlwcGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcblxuICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQocmlwcGxlKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVjYWxjdWxhdGUgdGhlIHN0eWxlcyBvZiBkeW5hbWljYWxseSBjcmVhdGVkXG4gICAgLy8gcmlwcGxlIGVsZW1lbnRzLiBUaGlzIGlzIGNyaXRpY2FsIGJlY2F1c2UgdGhlbiB0aGUgYHNjYWxlYCB3b3VsZCBub3QgYW5pbWF0ZSBwcm9wZXJseS5cbiAgICBlbmZvcmNlU3R5bGVSZWNhbGN1bGF0aW9uKHJpcHBsZSk7XG5cbiAgICByaXBwbGUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcblxuICAgIC8vIEV4cG9zZWQgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAgIGxldCByaXBwbGVSZWYgPSBuZXcgUmlwcGxlUmVmKHRoaXMsIHJpcHBsZSwgY29uZmlnKTtcblxuICAgIHJpcHBsZVJlZi5zdGF0ZSA9IFJpcHBsZVN0YXRlLkZBRElOR19JTjtcblxuICAgIC8vIEFkZCB0aGUgcmlwcGxlIHJlZmVyZW5jZSB0byB0aGUgbGlzdCBvZiBhbGwgYWN0aXZlIHJpcHBsZXMuXG4gICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5hZGQocmlwcGxlUmVmKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSByaXBwbGUgZWxlbWVudCB0byBiZSBjb21wbGV0ZWx5IGZhZGVkIGluLlxuICAgIC8vIE9uY2UgaXQncyBmYWRlZCBpbiwgdGhlIHJpcHBsZSBjYW4gYmUgaGlkZGVuIGltbWVkaWF0ZWx5IGlmIHRoZSBtb3VzZSBpcyByZWxlYXNlZC5cbiAgICB0aGlzLnJ1blRpbWVvdXRPdXRzaWRlWm9uZSgoKSA9PiB7XG4gICAgICByaXBwbGVSZWYuc3RhdGUgPSBSaXBwbGVTdGF0ZS5WSVNJQkxFO1xuXG4gICAgICBpZiAoIWNvbmZpZy5wZXJzaXN0ZW50ICYmICF0aGlzLl9pc01vdXNlZG93bikge1xuICAgICAgICByaXBwbGVSZWYuZmFkZU91dCgpO1xuICAgICAgfVxuICAgIH0sIGR1cmF0aW9uKTtcblxuICAgIHJldHVybiByaXBwbGVSZWY7XG4gIH1cblxuICAvKiogRmFkZXMgb3V0IGEgcmlwcGxlIHJlZmVyZW5jZS4gKi9cbiAgZmFkZU91dFJpcHBsZShyaXBwbGVSZWY6IFJpcHBsZVJlZikge1xuICAgIC8vIEZvciByaXBwbGVzIHRoYXQgYXJlIG5vdCBhY3RpdmUgYW55bW9yZSwgZG9uJ3QgcmUtdW4gdGhlIGZhZGUtb3V0IGFuaW1hdGlvbi5cbiAgICBpZiAoIXRoaXMuX2FjdGl2ZVJpcHBsZXMuZGVsZXRlKHJpcHBsZVJlZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmlwcGxlRWwgPSByaXBwbGVSZWYuZWxlbWVudDtcblxuICAgIHJpcHBsZUVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke1JJUFBMRV9GQURFX09VVF9EVVJBVElPTn1tc2A7XG4gICAgcmlwcGxlRWwuc3R5bGUub3BhY2l0eSA9ICcwJztcblxuICAgIHJpcHBsZVJlZi5zdGF0ZSA9IFJpcHBsZVN0YXRlLkZBRElOR19PVVQ7XG5cbiAgICAvLyBPbmNlIHRoZSByaXBwbGUgZmFkZWQgb3V0LCB0aGUgcmlwcGxlIGNhbiBiZSBzYWZlbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgdGhpcy5ydW5UaW1lb3V0T3V0c2lkZVpvbmUoKCkgPT4ge1xuICAgICAgcmlwcGxlUmVmLnN0YXRlID0gUmlwcGxlU3RhdGUuSElEREVOO1xuICAgICAgcmlwcGxlRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyaXBwbGVFbCk7XG4gICAgfSwgUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OKTtcbiAgfVxuXG4gIC8qKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBhY3RpdmUgcmlwcGxlcy4gKi9cbiAgZmFkZU91dEFsbCgpIHtcbiAgICB0aGlzLl9hY3RpdmVSaXBwbGVzLmZvckVhY2gocmlwcGxlID0+IHJpcHBsZS5mYWRlT3V0KCkpO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIHRyaWdnZXIgZWxlbWVudCBhbmQgcmVnaXN0ZXJzIHRoZSBtb3VzZSBldmVudHMuICovXG4gIHNldFRyaWdnZXJFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBwcmV2aW91c2x5IHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgaWYgKHRoaXMuX3RyaWdnZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLmZvckVhY2goKGZuLCB0eXBlKSA9PiB0aGlzLl90cmlnZ2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBudWxsLCByZWdpc3RlciBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLmZvckVhY2goKGZuLCB0eXBlKSA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIC8qKiBMaXN0ZW5lciBiZWluZyBjYWxsZWQgb24gbW91c2Vkb3duIGV2ZW50LiAqL1xuICBwcml2YXRlIG9uTW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnJpcHBsZURpc2FibGVkKSB7XG4gICAgICB0aGlzLl9pc01vdXNlZG93biA9IHRydWU7XG4gICAgICB0aGlzLmZhZGVJblJpcHBsZShldmVudC5wYWdlWCwgZXZlbnQucGFnZVksIHRoaXMucmlwcGxlQ29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvKiogTGlzdGVuZXIgYmVpbmcgY2FsbGVkIG9uIG1vdXNldXAgZXZlbnQuICovXG4gIHByaXZhdGUgb25Nb3VzZXVwKCkge1xuICAgIHRoaXMuX2lzTW91c2Vkb3duID0gZmFsc2U7XG5cbiAgICAvLyBGYWRlLW91dCBhbGwgcmlwcGxlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHZpc2libGUgYW5kIG5vdCBwZXJzaXN0ZW50LlxuICAgIHRoaXMuX2FjdGl2ZVJpcHBsZXMuZm9yRWFjaChyaXBwbGUgPT4ge1xuICAgICAgaWYgKCFyaXBwbGUuY29uZmlnLnBlcnNpc3RlbnQgJiYgcmlwcGxlLnN0YXRlID09PSBSaXBwbGVTdGF0ZS5WSVNJQkxFKSB7XG4gICAgICAgIHJpcHBsZS5mYWRlT3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogTGlzdGVuZXIgYmVpbmcgY2FsbGVkIG9uIG1vdXNlbGVhdmUgZXZlbnQuICovXG4gIHByaXZhdGUgb25Nb3VzZUxlYXZlKCkge1xuICAgIGlmICh0aGlzLl9pc01vdXNlZG93bikge1xuICAgICAgdGhpcy5vbk1vdXNldXAoKTtcbiAgICB9XG4gIH1cblxuICAvKiogUnVucyBhIHRpbWVvdXQgb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIGNoYW5nZSBkZXRlY3Rpb24uICovXG4gIHByaXZhdGUgcnVuVGltZW91dE91dHNpZGVab25lKGZuOiBGdW5jdGlvbiwgZGVsYXkgPSAwKSB7XG4gICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoZm4sIGRlbGF5KSk7XG4gIH1cblxufVxuXG4vKiogRW5mb3JjZXMgYSBzdHlsZSByZWNhbGN1bGF0aW9uIG9mIGEgRE9NIGVsZW1lbnQgYnkgY29tcHV0aW5nIGl0cyBzdHlsZXMuICovXG4vLyBUT0RPKGRldnZlcnNpb24pOiBNb3ZlIGludG8gZ2xvYmFsIHV0aWxpdHkgZnVuY3Rpb24uXG5mdW5jdGlvbiBlbmZvcmNlU3R5bGVSZWNhbGN1bGF0aW9uKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIC8vIEVuZm9yY2UgYSBzdHlsZSByZWNhbGN1bGF0aW9uIGJ5IGNhbGxpbmcgYGdldENvbXB1dGVkU3R5bGVgIGFuZCBhY2Nlc3NpbmcgYW55IHByb3BlcnR5LlxuICAvLyBDYWxsaW5nIGBnZXRQcm9wZXJ0eVZhbHVlYCBpcyBpbXBvcnRhbnQgdG8gbGV0IG9wdGltaXplcnMga25vdyB0aGF0IHRoaXMgaXMgbm90IGEgbm9vcC5cbiAgLy8gU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNWQ1MmZiMDgxYjM1NzBjODFlM2FcbiAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnb3BhY2l0eScpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50ICh4LCB5KSB0byB0aGUgZnVydGhlc3QgY29ybmVyIG9mIGEgcmVjdGFuZ2xlLlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIoeDogbnVtYmVyLCB5OiBudW1iZXIsIHJlY3Q6IENsaWVudFJlY3QpIHtcbiAgY29uc3QgZGlzdFggPSBNYXRoLm1heChNYXRoLmFicyh4IC0gcmVjdC5sZWZ0KSwgTWF0aC5hYnMoeCAtIHJlY3QucmlnaHQpKTtcbiAgY29uc3QgZGlzdFkgPSBNYXRoLm1heChNYXRoLmFicyh5IC0gcmVjdC50b3ApLCBNYXRoLmFicyh5IC0gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIE1hdGguc3FydChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSk7XG59XG4iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBXaGV0aGVyIHRoZSBjdXJyZW50IHBsYXRmb3JtIHN1cHBvcnRzIHRoZSBWOCBCcmVhayBJdGVyYXRvci4gVGhlIFY4IGNoZWNrXG4vLyBpcyBuZWNlc3NhcnkgdG8gZGV0ZWN0IGFsbCBCbGluayBiYXNlZCBicm93c2Vycy5cbmNvbnN0IGhhc1Y4QnJlYWtJdGVyYXRvciA9ICh0eXBlb2YoSW50bCkgIT09ICd1bmRlZmluZWQnICYmIChJbnRsIGFzIGFueSkudjhCcmVha0l0ZXJhdG9yKTtcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGRldGVjdCB0aGUgY3VycmVudCBwbGF0Zm9ybSBieSBjb21wYXJpbmcgdGhlIHVzZXJBZ2VudCBzdHJpbmdzIGFuZFxuICogY2hlY2tpbmcgYnJvd3Nlci1zcGVjaWZpYyBnbG9iYWwgcHJvcGVydGllcy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBsYXRmb3JtIHtcbiAgaXNCcm93c2VyOiBib29sZWFuID0gdHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiAhIWRvY3VtZW50O1xuXG4gIC8qKiBMYXlvdXQgRW5naW5lcyAqL1xuICBFREdFID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhlZGdlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFRSSURFTlQgPSB0aGlzLmlzQnJvd3NlciAmJiAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIC8vIEVkZ2VIVE1MIGFuZCBUcmlkZW50IG1vY2sgQmxpbmsgc3BlY2lmaWMgdGhpbmdzIGFuZCBuZWVkIHRvIGJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay5cbiAgQkxJTksgPSB0aGlzLmlzQnJvd3NlciAmJlxuICAgICAgKCEhKCh3aW5kb3cgYXMgYW55KS5jaHJvbWUgfHwgaGFzVjhCcmVha0l0ZXJhdG9yKSAmJiAhIUNTUyAmJiAhdGhpcy5FREdFICYmICF0aGlzLlRSSURFTlQpO1xuXG4gIC8vIFdlYmtpdCBpcyBwYXJ0IG9mIHRoZSB1c2VyQWdlbnQgaW4gRWRnZUhUTUwsIEJsaW5rIGFuZCBUcmlkZW50LiBUaGVyZWZvcmUgd2UgbmVlZCB0b1xuICAvLyBlbnN1cmUgdGhhdCBXZWJraXQgcnVucyBzdGFuZGFsb25lIGFuZCBpcyBub3QgdXNlZCBhcyBhbm90aGVyIGVuZ2luZSdzIGJhc2UuXG4gIFdFQktJVCA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAvQXBwbGVXZWJLaXQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLkJMSU5LICYmICF0aGlzLkVER0UgJiYgIXRoaXMuVFJJREVOVDtcblxuICAvKiogQnJvd3NlcnMgYW5kIFBsYXRmb3JtIFR5cGVzICovXG4gIElPUyA9IHRoaXMuaXNCcm93c2VyICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEod2luZG93IGFzIGFueSkuTVNTdHJlYW07XG5cbiAgLy8gSXQncyBkaWZmaWN1bHQgdG8gZGV0ZWN0IHRoZSBwbGFpbiBHZWNrbyBlbmdpbmUsIGJlY2F1c2UgbW9zdCBvZiB0aGUgYnJvd3NlcnMgaWRlbnRpZnlcbiAgLy8gdGhlbSBzZWxmIGFzIEdlY2tvLWxpa2UgYnJvd3NlcnMgYW5kIG1vZGlmeSB0aGUgdXNlckFnZW50J3MgYWNjb3JkaW5nIHRvIHRoYXQuXG4gIC8vIFNpbmNlIHdlIG9ubHkgY292ZXIgb25lIGV4cGxpY2l0IEZpcmVmb3ggY2FzZSwgd2UgY2FuIHNpbXBseSBjaGVjayBmb3IgRmlyZWZveFxuICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBhbiB1bnN0YWJsZSBjaGVjayBmb3IgR2Vja28uXG4gIEZJUkVGT1ggPSB0aGlzLmlzQnJvd3NlciAmJiAvKGZpcmVmb3h8bWluZWZpZWxkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgLy8gVHJpZGVudCBvbiBtb2JpbGUgYWRkcyB0aGUgYW5kcm9pZCBwbGF0Zm9ybSB0byB0aGUgdXNlckFnZW50IHRvIHRyaWNrIGRldGVjdGlvbnMuXG4gIEFORFJPSUQgPSB0aGlzLmlzQnJvd3NlciAmJiAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXRoaXMuVFJJREVOVDtcblxuICAvLyBTYWZhcmkgYnJvd3NlcnMgd2lsbCBpbmNsdWRlIHRoZSBTYWZhcmkga2V5d29yZCBpbiB0aGVpciB1c2VyQWdlbnQuIFNvbWUgYnJvd3NlcnMgbWF5IGZha2VcbiAgLy8gdGhpcyBhbmQganVzdCBwbGFjZSB0aGUgU2FmYXJpIGtleXdvcmQgaW4gdGhlIHVzZXJBZ2VudC4gVG8gYmUgbW9yZSBzYWZlIGFib3V0IFNhZmFyaSBldmVyeVxuICAvLyBTYWZhcmkgYnJvd3NlciBzaG91bGQgYWxzbyB1c2UgV2Via2l0IGFzIGl0cyBsYXlvdXQgZW5naW5lLlxuICBTQUZBUkkgPSB0aGlzLmlzQnJvd3NlciAmJiAvc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiB0aGlzLldFQktJVDtcbn1cbiIsIi8qKiBDYWNoZWQgcmVzdWx0IFNldCBvZiBpbnB1dCB0eXBlcyBzdXBwb3J0IGJ5IHRoZSBjdXJyZW50IGJyb3dzZXIuICovXG5sZXQgc3VwcG9ydGVkSW5wdXRUeXBlczogU2V0PHN0cmluZz47XG5cbi8qKiBUeXBlcyBvZiA8aW5wdXQ+IHRoYXQgKm1pZ2h0KiBiZSBzdXBwb3J0ZWQuICovXG5jb25zdCBjYW5kaWRhdGVJbnB1dFR5cGVzID0gW1xuICAvLyBgY29sb3JgIG11c3QgY29tZSBmaXJzdC4gQ2hyb21lIDU2IHNob3dzIGEgd2FybmluZyBpZiB3ZSBjaGFuZ2UgdGhlIHR5cGUgdG8gYGNvbG9yYCBhZnRlclxuICAvLyBmaXJzdCBjaGFuZ2luZyBpdCB0byBzb21ldGhpbmcgZWxzZTpcbiAgLy8gVGhlIHNwZWNpZmllZCB2YWx1ZSBcIlwiIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVkIGZvcm1hdC5cbiAgLy8gVGhlIGZvcm1hdCBpcyBcIiNycmdnYmJcIiB3aGVyZSByciwgZ2csIGJiIGFyZSB0d28tZGlnaXQgaGV4YWRlY2ltYWwgbnVtYmVycy5cbiAgJ2NvbG9yJyxcbiAgJ2J1dHRvbicsXG4gICdjaGVja2JveCcsXG4gICdkYXRlJyxcbiAgJ2RhdGV0aW1lLWxvY2FsJyxcbiAgJ2VtYWlsJyxcbiAgJ2ZpbGUnLFxuICAnaGlkZGVuJyxcbiAgJ2ltYWdlJyxcbiAgJ21vbnRoJyxcbiAgJ251bWJlcicsXG4gICdwYXNzd29yZCcsXG4gICdyYWRpbycsXG4gICdyYW5nZScsXG4gICdyZXNldCcsXG4gICdzZWFyY2gnLFxuICAnc3VibWl0JyxcbiAgJ3RlbCcsXG4gICd0ZXh0JyxcbiAgJ3RpbWUnLFxuICAndXJsJyxcbiAgJ3dlZWsnLFxuXTtcblxuLyoqIEByZXR1cm5zIFRoZSBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN1cHBvcnRlZElucHV0VHlwZXMoKTogU2V0PHN0cmluZz4ge1xuICAvLyBSZXN1bHQgaXMgY2FjaGVkLlxuICBpZiAoc3VwcG9ydGVkSW5wdXRUeXBlcykge1xuICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgY2hlY2sgaWYgYW4gaW5wdXQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHVudGlsIHdlJ3JlIG9uIHRoZSBicm93c2VyLCBzbyBzYXkgdGhhdFxuICAvLyBldmVyeXRoaW5nIGlzIHN1cHBvcnRlZCB3aGVuIG5vdCBvbiB0aGUgYnJvd3Nlci4gV2UgZG9uJ3QgdXNlIGBQbGF0Zm9ybWAgaGVyZSBzaW5jZSBpdCdzXG4gIC8vIGp1c3QgYSBoZWxwZXIgZnVuY3Rpb24gYW5kIGNhbid0IGluamVjdCBpdC5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ29iamVjdCcgfHwgIWRvY3VtZW50KSB7XG4gICAgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IG5ldyBTZXQoY2FuZGlkYXRlSW5wdXRUeXBlcyk7XG4gICAgcmV0dXJuIHN1cHBvcnRlZElucHV0VHlwZXM7XG4gIH1cblxuICBsZXQgZmVhdHVyZVRlc3RJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gIHN1cHBvcnRlZElucHV0VHlwZXMgPSBuZXcgU2V0KGNhbmRpZGF0ZUlucHV0VHlwZXMuZmlsdGVyKHZhbHVlID0+IHtcbiAgICBmZWF0dXJlVGVzdElucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsIHZhbHVlKTtcbiAgICByZXR1cm4gZmVhdHVyZVRlc3RJbnB1dC50eXBlID09PSB2YWx1ZTtcbiAgfSkpO1xuXG4gIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xufVxuIiwiaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BsYXRmb3JtfSBmcm9tICcuL3BsYXRmb3JtJztcblxuXG5ATmdNb2R1bGUoe1xuICBwcm92aWRlcnM6IFtQbGF0Zm9ybV1cbn0pXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1Nb2R1bGUge31cblxuXG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtJztcbmV4cG9ydCAqIGZyb20gJy4vZmVhdHVyZXMnO1xuIiwiaW1wb3J0IHtFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BsYXRmb3JtfSBmcm9tICcuLi8uLi9wbGF0Zm9ybS9pbmRleCc7XG5pbXBvcnQge1Njcm9sbGFibGV9IGZyb20gJy4vc2Nyb2xsYWJsZSc7XG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb24sIG1lcmdlLCBmcm9tRXZlbnR9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHthdWRpdFRpbWV9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuXG4vKiogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsaW5nIGV2ZW50cyBieSBkZWZhdWx0LiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0NST0xMX1RJTUUgPSAyMDtcblxuLyoqXG4gKiBTZXJ2aWNlIGNvbnRhaW5lZCBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgYW5kIGVtaXRzIGFuIGV2ZW50IHdoZW4gYW55IG9uZSBvZiB0aGVcbiAqIFNjcm9sbGFibGUgcmVmZXJlbmNlcyBlbWl0IGEgc2Nyb2xsZWQgZXZlbnQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTY3JvbGxEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgX3BsYXRmb3JtOiBQbGF0Zm9ybSkgeyB9XG5cbiAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IGEgcmVnaXN0ZXJlZCBzY3JvbGxhYmxlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBiZWVuIHNjcm9sbGVkLiAqL1xuICBfc2Nyb2xsZWQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZ2xvYmFsIGBzY3JvbGxgIGFuZCBgcmVzaXplYCBzdWJzY3JpcHRpb25zLiAqL1xuICBfZ2xvYmFsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBudWxsO1xuXG4gIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgYW1vdW50IG9mIHN1YnNjcmlwdGlvbnMgdG8gYHNjcm9sbGVkYC4gVXNlZCBmb3IgY2xlYW5pbmcgdXAgYWZ0ZXJ3YXJkcy4gKi9cbiAgcHJpdmF0ZSBfc2Nyb2xsZWRDb3VudCA9IDA7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgdGhlIHNjcm9sbGFibGUgcmVmZXJlbmNlcyB0aGF0IGFyZSByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2UgYW5kIHRoZWlyXG4gICAqIHNjcm9sbCBldmVudCBzdWJzY3JpcHRpb25zLlxuICAgKi9cbiAgc2Nyb2xsYWJsZVJlZmVyZW5jZXM6IE1hcDxTY3JvbGxhYmxlLCBTdWJzY3JpcHRpb24+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHdpdGggdGhlIHNlcnZpY2UgYW5kIGxpc3RlbnMgZm9yIGl0cyBzY3JvbGxlZCBldmVudHMuIFdoZW4gdGhlXG4gICAqIHNjcm9sbGFibGUgaXMgc2Nyb2xsZWQsIHRoZSBzZXJ2aWNlIGVtaXRzIHRoZSBldmVudCBpbiBpdHMgc2Nyb2xsZWQgb2JzZXJ2YWJsZS5cbiAgICogQHBhcmFtIHNjcm9sbGFibGUgU2Nyb2xsYWJsZSBpbnN0YW5jZSB0byBiZSByZWdpc3RlcmVkLlxuICAgKi9cbiAgcmVnaXN0ZXIoc2Nyb2xsYWJsZTogU2Nyb2xsYWJsZSk6IHZvaWQge1xuICAgIGNvbnN0IHNjcm9sbFN1YnNjcmlwdGlvbiA9IHNjcm9sbGFibGUuZWxlbWVudFNjcm9sbGVkKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX25vdGlmeSgpKTtcblxuICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuc2V0KHNjcm9sbGFibGUsIHNjcm9sbFN1YnNjcmlwdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHJlZmVyZW5jZSBhbmQgdW5zdWJzY3JpYmVzIGZyb20gaXRzIHNjcm9sbCBldmVudCBvYnNlcnZhYmxlLlxuICAgKiBAcGFyYW0gc2Nyb2xsYWJsZSBTY3JvbGxhYmxlIGluc3RhbmNlIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICovXG4gIGRlcmVnaXN0ZXIoc2Nyb2xsYWJsZTogU2Nyb2xsYWJsZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzLmhhcyhzY3JvbGxhYmxlKSkge1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5nZXQoc2Nyb2xsYWJsZSkudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZGVsZXRlKHNjcm9sbGFibGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBldmVudCB3aGVuZXZlciBhbnkgb2YgdGhlIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZVxuICAgKiByZWZlcmVuY2VzIChvciB3aW5kb3csIGRvY3VtZW50LCBvciBib2R5KSBmaXJlIGEgc2Nyb2xsZWQgZXZlbnQuIENhbiBwcm92aWRlIGEgdGltZSBpbiBtc1xuICAgKiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBcInRocm90dGxlXCIgdGltZS5cbiAgICovXG4gIHNjcm9sbGVkKGF1ZGl0VGltZUluTXM6IG51bWJlciA9IERFRkFVTFRfU0NST0xMX1RJTUUsIGNhbGxiYWNrOiAoKSA9PiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIC8vIFNjcm9sbCBldmVudHMgY2FuIG9ubHkgaGFwcGVuIG9uIHRoZSBicm93c2VyLCBzbyBkbyBub3RoaW5nIGlmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3Nlci5cbiAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIDBtcyBkZWxheSwgdXNlIGFuIG9ic2VydmFibGUgd2l0aG91dCBhdWRpdFRpbWVcbiAgICAvLyBzaW5jZSBpdCBkb2VzIGFkZCBhIHBlcmNlcHRpYmxlIGRlbGF5IGluIHByb2Nlc3Npbmcgb3ZlcmhlYWQuXG4gICAgbGV0IG9ic2VydmFibGUgPSBhdWRpdFRpbWVJbk1zID4gMCA/XG4gICAgICB0aGlzLl9zY3JvbGxlZC5hc09ic2VydmFibGUoKS5waXBlKGF1ZGl0VGltZShhdWRpdFRpbWVJbk1zKSkgOlxuICAgICAgdGhpcy5fc2Nyb2xsZWQuYXNPYnNlcnZhYmxlKCk7XG5cbiAgICB0aGlzLl9zY3JvbGxlZENvdW50Kys7XG5cbiAgICBpZiAoIXRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKFxuICAgICAgICAgIGZyb21FdmVudCh3aW5kb3cuZG9jdW1lbnQsICdzY3JvbGwnKSxcbiAgICAgICAgICBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJylcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fbm90aWZ5KCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gZG8gdGhlIHN1YnNjcmliaW5nIGZyb20gaGVyZSwgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byByZW1vdmVcbiAgICAvLyB0aGUgZ2xvYmFsIGV2ZW50IGxpc3RlbmVycyBvbmNlIHRoZXJlIGFyZSBubyBtb3JlIHN1YnNjcmlwdGlvbnMuXG4gICAgbGV0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGNhbGxiYWNrKTtcblxuICAgIHN1YnNjcmlwdGlvbi5hZGQoKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsZWRDb3VudC0tO1xuXG4gICAgICBpZiAodGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uICYmICF0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzLnNpemUgJiYgIXRoaXMuX3Njcm9sbGVkQ291bnQpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZXMgdGhhdCBjb250YWluIHRoZSBwcm92aWRlZCBlbGVtZW50LiAqL1xuICBnZXRTY3JvbGxDb250YWluZXJzKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpOiBTY3JvbGxhYmxlW10ge1xuICAgIGNvbnN0IHNjcm9sbGluZ0NvbnRhaW5lcnM6IFNjcm9sbGFibGVbXSA9IFtdO1xuXG4gICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5mb3JFYWNoKChfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24sIHNjcm9sbGFibGU6IFNjcm9sbGFibGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbGFibGVDb250YWluc0VsZW1lbnQoc2Nyb2xsYWJsZSwgZWxlbWVudFJlZikpIHtcbiAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVycy5wdXNoKHNjcm9sbGFibGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNjcm9sbGluZ0NvbnRhaW5lcnM7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNjcm9sbGFibGUuICovXG4gIHNjcm9sbGFibGVDb250YWluc0VsZW1lbnQoc2Nyb2xsYWJsZTogU2Nyb2xsYWJsZSwgZWxlbWVudFJlZjogRWxlbWVudFJlZik6IGJvb2xlYW4ge1xuICAgIGxldCBlbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGxldCBzY3JvbGxhYmxlRWxlbWVudCA9IHNjcm9sbGFibGUuZ2V0RWxlbWVudFJlZigpLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aHJvdWdoIHRoZSBlbGVtZW50IHBhcmVudHMgdW50aWwgd2UgcmVhY2ggbnVsbCwgY2hlY2tpbmcgaWYgYW55IG9mIHRoZSBlbGVtZW50c1xuICAgIC8vIGFyZSB0aGUgc2Nyb2xsYWJsZSdzIGVsZW1lbnQuXG4gICAgZG8ge1xuICAgICAgaWYgKGVsZW1lbnQgPT0gc2Nyb2xsYWJsZUVsZW1lbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKiBTZW5kcyBhIG5vdGlmaWNhdGlvbiB0aGF0IGEgc2Nyb2xsIGV2ZW50IGhhcyBiZWVuIGZpcmVkLiAqL1xuICBfbm90aWZ5KCkge1xuICAgIHRoaXMuX3Njcm9sbGVkLm5leHQoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWShcbiAgICBwYXJlbnREaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmU6IE5nWm9uZSwgcGxhdGZvcm06IFBsYXRmb3JtKSB7XG4gIHJldHVybiBwYXJlbnREaXNwYXRjaGVyIHx8IG5ldyBTY3JvbGxEaXNwYXRjaGVyKG5nWm9uZSwgcGxhdGZvcm0pO1xufVxuXG5leHBvcnQgY29uc3QgU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVIgPSB7XG4gIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBTY3JvbGxEaXNwYXRjaGVyIGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gIHByb3ZpZGU6IFNjcm9sbERpc3BhdGNoZXIsXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBTY3JvbGxEaXNwYXRjaGVyXSwgTmdab25lLCBQbGF0Zm9ybV0sXG4gIHVzZUZhY3Rvcnk6IFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4iLCJpbXBvcnQge0luamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1Njcm9sbERpc3BhdGNoZXJ9IGZyb20gJy4uL3Njcm9sbC9zY3JvbGwtZGlzcGF0Y2hlcic7XG5cblxuLyoqXG4gKiBTaW1wbGUgdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgYm91bmRzIG9mIHRoZSBicm93c2VyIHZpZXdwb3J0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmlld3BvcnRSdWxlciB7XG5cbiAgLyoqIENhY2hlZCBkb2N1bWVudCBjbGllbnQgcmVjdGFuZ2xlLiAqL1xuICBwcml2YXRlIF9kb2N1bWVudFJlY3Q/OiBDbGllbnRSZWN0O1xuXG4gIGNvbnN0cnVjdG9yKHNjcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIpIHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHJlY3RhbmdsZSBvbiBjaGFuZ2VzLlxuICAgIHNjcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQobnVsbCwgKCkgPT4gdGhpcy5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5KCkpO1xuICB9XG5cbiAgLyoqIEdldHMgYSBDbGllbnRSZWN0IGZvciB0aGUgdmlld3BvcnQncyBib3VuZHMuICovXG4gIGdldFZpZXdwb3J0UmVjdChkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3QpOiBDbGllbnRSZWN0IHtcbiAgICAvLyBDYWNoZSB0aGUgZG9jdW1lbnQgYm91bmRpbmcgcmVjdCBzbyB0aGF0IHdlIGRvbid0IHJlY29tcHV0ZSBpdCBmb3IgbXVsdGlwbGUgY2FsbHMuXG4gICAgaWYgKCFkb2N1bWVudFJlY3QpIHtcbiAgICAgIHRoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpO1xuICAgICAgZG9jdW1lbnRSZWN0ID0gdGhpcy5fZG9jdW1lbnRSZWN0O1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3QgcmF0aGVyIHRoYW4gdGhlIHdpbmRvdyBzY3JvbGwgcHJvcGVydGllc1xuICAgIC8vIChlLmcuIHBhZ2VZT2Zmc2V0LCBzY3JvbGxZKSBkdWUgdG8gaW4gaXNzdWUgaW4gQ2hyb21lIGFuZCBJRSB3aGVyZSB3aW5kb3cgc2Nyb2xsXG4gICAgLy8gcHJvcGVydGllcyBhbmQgY2xpZW50IGNvb3JkaW5hdGVzIChib3VuZGluZ0NsaWVudFJlY3QsIGNsaWVudFgvWSwgZXRjLikgYXJlIGluIGRpZmZlcmVudFxuICAgIC8vIGNvbmNlcHR1YWwgdmlld3BvcnRzLiBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgdGhlc2Ugdmlld3BvcnRzIGFyZSBlcXVpdmFsZW50LCBidXQgdGhleVxuICAgIC8vIGNhbiBkaXNhZ3JlZSB3aGVuIHRoZSBwYWdlIGlzIHBpbmNoLXpvb21lZCAob24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgdG91Y2gpLlxuICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDYjYzRcbiAgICAvLyBXZSB1c2UgdGhlIGRvY3VtZW50RWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBib2R5IGJlY2F1c2UsIGJ5IGRlZmF1bHQgKHdpdGhvdXQgYSBjc3MgcmVzZXQpXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGdpdmUgdGhlIGRvY3VtZW50IGJvZHkgYW4gOHB4IG1hcmdpbiwgd2hpY2ggaXMgbm90IGluY2x1ZGVkIGluXG4gICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oZG9jdW1lbnRSZWN0KTtcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHNjcm9sbFBvc2l0aW9uLnRvcCxcbiAgICAgIGxlZnQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQsXG4gICAgICBib3R0b206IHNjcm9sbFBvc2l0aW9uLnRvcCArIGhlaWdodCxcbiAgICAgIHJpZ2h0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0ICsgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgKHRvcCwgbGVmdCkgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIGRvY3VtZW50UmVjdFxuICAgKi9cbiAgZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbihkb2N1bWVudFJlY3QgPSB0aGlzLl9kb2N1bWVudFJlY3QpIHtcbiAgICAvLyBDYWNoZSB0aGUgZG9jdW1lbnQgYm91bmRpbmcgcmVjdCBzbyB0aGF0IHdlIGRvbid0IHJlY29tcHV0ZSBpdCBmb3IgbXVsdGlwbGUgY2FsbHMuXG4gICAgaWYgKCFkb2N1bWVudFJlY3QpIHtcbiAgICAgIHRoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpO1xuICAgICAgZG9jdW1lbnRSZWN0ID0gdGhpcy5fZG9jdW1lbnRSZWN0O1xuICAgIH1cblxuICAgIC8vIFRoZSB0b3AtbGVmdC1jb3JuZXIgb2YgdGhlIHZpZXdwb3J0IGlzIGRldGVybWluZWQgYnkgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnRcbiAgICAvLyBib2R5LCBub3JtYWxseSBqdXN0IChzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApLiBIb3dldmVyLCBDaHJvbWUgYW5kIEZpcmVmb3ggZGlzYWdyZWUgYWJvdXRcbiAgICAvLyB3aGV0aGVyIGBkb2N1bWVudC5ib2R5YCBvciBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50YCBpcyB0aGUgc2Nyb2xsZWQgZWxlbWVudCwgc28gcmVhZGluZ1xuICAgIC8vIGBzY3JvbGxUb3BgIGFuZCBgc2Nyb2xsTGVmdGAgaXMgaW5jb25zaXN0ZW50LiBIb3dldmVyLCB1c2luZyB0aGUgYm91bmRpbmcgcmVjdCBvZlxuICAgIC8vIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIHdvcmtzIGNvbnNpc3RlbnRseSwgd2hlcmUgdGhlIGB0b3BgIGFuZCBgbGVmdGAgdmFsdWVzIHdpbGxcbiAgICAvLyBlcXVhbCBuZWdhdGl2ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgIGNvbnN0IHRvcCA9IC1kb2N1bWVudFJlY3QudG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IHdpbmRvdy5zY3JvbGxZIHx8XG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG5cbiAgICBjb25zdCBsZWZ0ID0gLWRvY3VtZW50UmVjdC5sZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCB3aW5kb3cuc2Nyb2xsWCB8fFxuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcblxuICAgIHJldHVybiB7dG9wLCBsZWZ0fTtcbiAgfVxuXG4gIC8qKiBDYWNoZXMgdGhlIGxhdGVzdCBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LiAqL1xuICBfY2FjaGVWaWV3cG9ydEdlb21ldHJ5KCkge1xuICAgIHRoaXMuX2RvY3VtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudFJ1bGVyOiBWaWV3cG9ydFJ1bGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcikge1xuICByZXR1cm4gcGFyZW50UnVsZXIgfHwgbmV3IFZpZXdwb3J0UnVsZXIoc2Nyb2xsRGlzcGF0Y2hlcik7XG59XG5cbmV4cG9ydCBjb25zdCBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUiA9IHtcbiAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIFZpZXdwb3J0UnVsZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgcHJvdmlkZTogVmlld3BvcnRSdWxlcixcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFZpZXdwb3J0UnVsZXJdLCBTY3JvbGxEaXNwYXRjaGVyXSxcbiAgdXNlRmFjdG9yeTogVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIEluamVjdCxcbiAgTmdab25lLFxuICBPbkNoYW5nZXMsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIE9wdGlvbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7UmlwcGxlQ29uZmlnLCBSaXBwbGVSZW5kZXJlcn0gZnJvbSAnLi9yaXBwbGUtcmVuZGVyZXInO1xuaW1wb3J0IHtSaXBwbGVSZWZ9IGZyb20gJy4vcmlwcGxlLXJlZic7XG5pbXBvcnQge1ZpZXdwb3J0UnVsZXJ9IGZyb20gJy4uL292ZXJsYXkvcG9zaXRpb24vdmlld3BvcnQtcnVsZXInO1xuaW1wb3J0IHtQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vcGxhdGZvcm0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJpcHBsZUdsb2JhbE9wdGlvbnMge1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIGJhc2VTcGVlZEZhY3Rvcj86IG51bWJlcjtcbn1cblxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGdsb2JhbCByaXBwbGUgb3B0aW9ucy4gKi9cbmV4cG9ydCBjb25zdCBNRF9SSVBQTEVfR0xPQkFMX09QVElPTlMgPVxuICAgIG5ldyBJbmplY3Rpb25Ub2tlbjxSaXBwbGVHbG9iYWxPcHRpb25zPignbWQtcmlwcGxlLWdsb2JhbC1vcHRpb25zJyk7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttZC1yaXBwbGVdLCBbbWF0LXJpcHBsZV0sIFttZFJpcHBsZV0sIFttYXRSaXBwbGVdJyxcbiAgZXhwb3J0QXM6ICdtZFJpcHBsZScsXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbWF0LXJpcHBsZScsXG4gICAgJ1tjbGFzcy5tYXQtcmlwcGxlLXVuYm91bmRlZF0nOiAndW5ib3VuZGVkJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE1kUmlwcGxlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHRoZSByaXBwbGUgd2hlbiBjbGljayBldmVudHMgYXJlIHJlY2VpdmVkLiBEZWZhdWx0cyB0byB0aGVcbiAgICogZGlyZWN0aXZlJ3MgaG9zdCBlbGVtZW50LlxuICAgKi9cbiAgLy8gUHJldmVudCBUUyBtZXRhZGF0YSBlbWl0IGZyb20gcmVmZXJlbmNpbmcgSFRNTEVsZW1lbnQgaW4gcmlwcGxlLmpzXG4gIC8vIE90aGVyd2lzZSBydW5uaW5nIHRoaXMgY29kZSBpbiBhIE5vZGUgZW52aXJvbm1lbnQgKGUuZyBVbml2ZXJzYWwpIHdpbGwgbm90IHdvcmsuXG4gIEBJbnB1dCgnbWRSaXBwbGVUcmlnZ2VyJykgdHJpZ2dlcjogSFRNTEVsZW1lbnR8SFRNTEVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHJpcHBsZSBhbHdheXMgb3JpZ2luYXRlcyBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGhvc3QgZWxlbWVudCdzIGJvdW5kcywgcmF0aGVyXG4gICAqIHRoYW4gb3JpZ2luYXRpbmcgZnJvbSB0aGUgbG9jYXRpb24gb2YgdGhlIGNsaWNrIGV2ZW50LlxuICAgKi9cbiAgQElucHV0KCdtZFJpcHBsZUNlbnRlcmVkJykgY2VudGVyZWQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgY2xpY2sgZXZlbnRzIHdpbGwgbm90IHRyaWdnZXIgdGhlIHJpcHBsZS4gSXQgY2FuIHN0aWxsIGJlIHRyaWdnZXJlZCBieSBtYW51YWxseVxuICAgKiBjYWxsaW5nIGNyZWF0ZVJpcHBsZSgpXG4gICAqL1xuICBASW5wdXQoJ21kUmlwcGxlRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgc2V0LCB0aGUgcmFkaXVzIGluIHBpeGVscyBvZiBmb3JlZ3JvdW5kIHJpcHBsZXMgd2hlbiBmdWxseSBleHBhbmRlZC4gSWYgdW5zZXQsIHRoZSByYWRpdXNcbiAgICogd2lsbCBiZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSByaXBwbGUgdG8gdGhlIGZ1cnRoZXN0IGNvcm5lciBvZiB0aGUgaG9zdCBlbGVtZW50J3NcbiAgICogYm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgKi9cbiAgQElucHV0KCdtZFJpcHBsZVJhZGl1cycpIHJhZGl1czogbnVtYmVyID0gMDtcblxuICAvKipcbiAgICogSWYgc2V0LCB0aGUgbm9ybWFsIGR1cmF0aW9uIG9mIHJpcHBsZSBhbmltYXRpb25zIGlzIGRpdmlkZWQgYnkgdGhpcyB2YWx1ZS4gRm9yIGV4YW1wbGUsXG4gICAqIHNldHRpbmcgaXQgdG8gMC41IHdpbGwgY2F1c2UgdGhlIGFuaW1hdGlvbnMgdG8gdGFrZSB0d2ljZSBhcyBsb25nLlxuICAgKiBBIGNoYW5nZWQgc3BlZWRGYWN0b3Igd2lsbCBub3QgbW9kaWZ5IHRoZSBmYWRlLW91dCBkdXJhdGlvbiBvZiB0aGUgcmlwcGxlcy5cbiAgICovXG4gIEBJbnB1dCgnbWRSaXBwbGVTcGVlZEZhY3RvcicpIHNwZWVkRmFjdG9yOiBudW1iZXIgPSAxO1xuXG4gIC8qKiBDdXN0b20gY29sb3IgZm9yIHJpcHBsZXMuICovXG4gIEBJbnB1dCgnbWRSaXBwbGVDb2xvcicpIGNvbG9yOiBzdHJpbmc7XG5cbiAgLyoqIFdoZXRoZXIgZm9yZWdyb3VuZCByaXBwbGVzIHNob3VsZCBiZSB2aXNpYmxlIG91dHNpZGUgdGhlIGNvbXBvbmVudCdzIGJvdW5kcy4gKi9cbiAgQElucHV0KCdtZFJpcHBsZVVuYm91bmRlZCcpIHVuYm91bmRlZDogYm9vbGVhbjtcblxuICAvKiogUmVuZGVyZXIgZm9yIHRoZSByaXBwbGUgRE9NIG1hbmlwdWxhdGlvbnMuICovXG4gIHByaXZhdGUgX3JpcHBsZVJlbmRlcmVyOiBSaXBwbGVSZW5kZXJlcjtcblxuICAvKiogT3B0aW9ucyB0aGF0IGFyZSBzZXQgZ2xvYmFsbHkgZm9yIGFsbCByaXBwbGVzLiAqL1xuICBwcml2YXRlIF9nbG9iYWxPcHRpb25zOiBSaXBwbGVHbG9iYWxPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgbmdab25lOiBOZ1pvbmUsXG4gICAgcnVsZXI6IFZpZXdwb3J0UnVsZXIsXG4gICAgcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTURfUklQUExFX0dMT0JBTF9PUFRJT05TKSBnbG9iYWxPcHRpb25zOiBSaXBwbGVHbG9iYWxPcHRpb25zXG4gICkge1xuICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyID0gbmV3IFJpcHBsZVJlbmRlcmVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIsIHBsYXRmb3JtKTtcbiAgICB0aGlzLl9nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucyA/IGdsb2JhbE9wdGlvbnMgOiB7fTtcblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZVJlbmRlcmVyKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXNbJ3RyaWdnZXInXSAmJiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnNldFRyaWdnZXJFbGVtZW50KHRoaXMudHJpZ2dlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlUmVuZGVyZXIoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIC8vIFNldCB0aGUgdHJpZ2dlciBlbGVtZW50IHRvIG51bGwgdG8gY2xlYW51cCBhbGwgbGlzdGVuZXJzLlxuICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnNldFRyaWdnZXJFbGVtZW50KG51bGwpO1xuICB9XG5cbiAgLyoqIExhdW5jaGVzIGEgbWFudWFsIHJpcHBsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiAqL1xuICBsYXVuY2gocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgY29uZmlnID0gdGhpcy5yaXBwbGVDb25maWcpOiBSaXBwbGVSZWYge1xuICAgIHJldHVybiB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlSW5SaXBwbGUocGFnZVgsIHBhZ2VZLCBjb25maWcpO1xuICB9XG5cbiAgLyoqIEZhZGVzIG91dCBhbGwgY3VycmVudGx5IHNob3dpbmcgcmlwcGxlIGVsZW1lbnRzLiAqL1xuICBmYWRlT3V0QWxsKCkge1xuICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLmZhZGVPdXRBbGwoKTtcbiAgfVxuXG4gIC8qKiBSaXBwbGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBkaXJlY3RpdmUncyBpbnB1dCB2YWx1ZXMuICovXG4gIGdldCByaXBwbGVDb25maWcoKTogUmlwcGxlQ29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyZWQ6IHRoaXMuY2VudGVyZWQsXG4gICAgICBzcGVlZEZhY3RvcjogdGhpcy5zcGVlZEZhY3RvciAqICh0aGlzLl9nbG9iYWxPcHRpb25zLmJhc2VTcGVlZEZhY3RvciB8fCAxKSxcbiAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICBjb2xvcjogdGhpcy5jb2xvclxuICAgIH07XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgcmlwcGxlIHJlbmRlcmVyIHdpdGggdGhlIGxhdGVzdCByaXBwbGUgY29uZmlndXJhdGlvbi4gKi9cbiAgcHJpdmF0ZSBfdXBkYXRlUmlwcGxlUmVuZGVyZXIoKSB7XG4gICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIucmlwcGxlRGlzYWJsZWQgPSB0aGlzLl9nbG9iYWxPcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIucmlwcGxlQ29uZmlnID0gdGhpcy5yaXBwbGVDb25maWc7XG4gIH1cbn1cbiIsImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkluaXQsIE9uRGVzdHJveSwgTmdab25lLCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7U2Nyb2xsRGlzcGF0Y2hlcn0gZnJvbSAnLi9zY3JvbGwtZGlzcGF0Y2hlcic7XG5cblxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB3aGVuIHRoZSBkaXJlY3RpdmUncyBlbGVtZW50IGlzIHNjcm9sbGVkLiBSZWdpc3RlcnMgaXRzZWxmIHdpdGggdGhlXG4gKiBTY3JvbGxEaXNwYXRjaGVyIHNlcnZpY2UgdG8gaW5jbHVkZSBpdHNlbGYgYXMgcGFydCBvZiBpdHMgY29sbGVjdGlvbiBvZiBzY3JvbGxpbmcgZXZlbnRzIHRoYXQgaXRcbiAqIGNhbiBiZSBsaXN0ZW5lZCB0byB0aHJvdWdoIHRoZSBzZXJ2aWNlLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2RrLXNjcm9sbGFibGVdLCBbY2RrU2Nyb2xsYWJsZV0nXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbGFibGUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX2VsZW1lbnRTY3JvbGxlZDogU3ViamVjdDxFdmVudD4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9zY3JvbGxMaXN0ZW5lcjogRnVuY3Rpb247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfc2Nyb2xsOiBTY3JvbGxEaXNwYXRjaGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuZ2V0RWxlbWVudFJlZigpLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTY3JvbGxlZC5uZXh0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2Nyb2xsLnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc2Nyb2xsLmRlcmVnaXN0ZXIodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3Njcm9sbExpc3RlbmVyKCk7XG4gICAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gYSBzY3JvbGwgZXZlbnQgaXMgZmlyZWQgb24gdGhlIGhvc3QgZWxlbWVudC5cbiAgICovXG4gIGVsZW1lbnRTY3JvbGxlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50U2Nyb2xsZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXRFbGVtZW50UmVmKCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICB9XG59XG4iLCJpbXBvcnQge092ZXJsYXlSZWZ9IGZyb20gJy4uL292ZXJsYXktcmVmJztcblxuLyoqXG4gKiBEZXNjcmliZXMgYSBzdHJhdGVneSB0aGF0IHdpbGwgYmUgdXNlZCBieSBhbiBvdmVybGF5XG4gKiB0byBoYW5kbGUgc2Nyb2xsIGV2ZW50cyB3aGlsZSBpdCBpcyBvcGVuLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbFN0cmF0ZWd5IHtcbiAgZW5hYmxlOiAoKSA9PiB2b2lkO1xuICBkaXNhYmxlOiAoKSA9PiB2b2lkO1xuICBhdHRhY2g6IChvdmVybGF5UmVmOiBPdmVybGF5UmVmKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYW4gYWxyZWFkeS1hdHRhY2hlZCBzY3JvbGwgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZFNjcm9sbFN0cmF0ZWd5QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gRXJyb3IoYFNjcm9sbCBzdHJhdGVneSBoYXMgYWxyZWFkeSBiZWVuIGF0dGFjaGVkLmApO1xufVxuIiwiaW1wb3J0IHtTY3JvbGxTdHJhdGVneSwgZ2V0TWRTY3JvbGxTdHJhdGVneUFscmVhZHlBdHRhY2hlZEVycm9yfSBmcm9tICcuL3Njcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQge092ZXJsYXlSZWZ9IGZyb20gJy4uL292ZXJsYXktcmVmJztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7U2Nyb2xsRGlzcGF0Y2hlcn0gZnJvbSAnLi9zY3JvbGwtZGlzcGF0Y2hlcic7XG5cblxuLyoqXG4gKiBTdHJhdGVneSB0aGF0IHdpbGwgY2xvc2UgdGhlIG92ZXJsYXkgYXMgc29vbiBhcyB0aGUgdXNlciBzdGFydHMgc2Nyb2xsaW5nLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvc2VTY3JvbGxTdHJhdGVneSBpbXBsZW1lbnRzIFNjcm9sbFN0cmF0ZWd5IHtcbiAgcHJpdmF0ZSBfc2Nyb2xsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb258bnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcikgeyB9XG5cbiAgYXR0YWNoKG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYpIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhyb3cgZ2V0TWRTY3JvbGxTdHJhdGVneUFscmVhZHlBdHRhY2hlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheVJlZiA9IG92ZXJsYXlSZWY7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQobnVsbCwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1Njcm9sbFN0cmF0ZWd5fSBmcm9tICcuL3Njcm9sbC1zdHJhdGVneSc7XG5cbi8qKlxuICogU2Nyb2xsIHN0cmF0ZWd5IHRoYXQgZG9lc24ndCBkbyBhbnl0aGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vb3BTY3JvbGxTdHJhdGVneSBpbXBsZW1lbnRzIFNjcm9sbFN0cmF0ZWd5IHtcbiAgZW5hYmxlKCkgeyB9XG4gIGRpc2FibGUoKSB7IH1cbiAgYXR0YWNoKCkgeyB9XG59XG4iLCJpbXBvcnQge1Njcm9sbFN0cmF0ZWd5fSBmcm9tICcuL3Njcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQge1ZpZXdwb3J0UnVsZXJ9IGZyb20gJy4uL3Bvc2l0aW9uL3ZpZXdwb3J0LXJ1bGVyJztcblxuLyoqXG4gKiBTdHJhdGVneSB0aGF0IHdpbGwgcHJldmVudCB0aGUgdXNlciBmcm9tIHNjcm9sbGluZyB3aGlsZSB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tTY3JvbGxTdHJhdGVneSBpbXBsZW1lbnRzIFNjcm9sbFN0cmF0ZWd5IHtcbiAgcHJpdmF0ZSBfcHJldmlvdXNIVE1MU3R5bGVzID0geyB0b3A6ICcnLCBsZWZ0OiAnJyB9O1xuICBwcml2YXRlIF9wcmV2aW91c1Njcm9sbFBvc2l0aW9uOiB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfTtcbiAgcHJpdmF0ZSBfaXNFbmFibGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdmlld3BvcnRSdWxlcjogVmlld3BvcnRSdWxlcikgeyB9XG5cbiAgYXR0YWNoKCkgeyB9XG5cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLl9jYW5CZUVuYWJsZWQoKSkge1xuICAgICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcHJldmlvdXMgaW5saW5lIHN0eWxlcyBpbiBjYXNlIHRoZSB1c2VyIGhhZCBzZXQgdGhlbS5cbiAgICAgIHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy5sZWZ0ID0gcm9vdC5zdHlsZS5sZWZ0O1xuICAgICAgdGhpcy5fcHJldmlvdXNIVE1MU3R5bGVzLnRvcCA9IHJvb3Quc3R5bGUudG9wO1xuXG4gICAgICAvLyBOb3RlOiB3ZSdyZSB1c2luZyB0aGUgYGh0bWxgIG5vZGUsIGluc3RlYWQgb2YgdGhlIGBib2R5YCwgYmVjYXVzZSB0aGUgYGJvZHlgIG1heVxuICAgICAgLy8gaGF2ZSB0aGUgdXNlciBhZ2VudCBtYXJnaW4sIHdoZXJlYXMgdGhlIGBodG1sYCBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIG9uZS5cbiAgICAgIHJvb3Quc3R5bGUubGVmdCA9IGAkey10aGlzLl9wcmV2aW91c1Njcm9sbFBvc2l0aW9uLmxlZnR9cHhgO1xuICAgICAgcm9vdC5zdHlsZS50b3AgPSBgJHstdGhpcy5fcHJldmlvdXNTY3JvbGxQb3NpdGlvbi50b3B9cHhgO1xuICAgICAgcm9vdC5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLXNjcm9sbGJsb2NrJyk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUubGVmdCA9IHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy5sZWZ0O1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuX3ByZXZpb3VzSFRNTFN0eWxlcy50b3A7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnY2RrLWdsb2JhbC1zY3JvbGxibG9jaycpO1xuICAgICAgd2luZG93LnNjcm9sbCh0aGlzLl9wcmV2aW91c1Njcm9sbFBvc2l0aW9uLmxlZnQsIHRoaXMuX3ByZXZpb3VzU2Nyb2xsUG9zaXRpb24udG9wKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jYW5CZUVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gU2luY2UgdGhlIHNjcm9sbCBzdHJhdGVnaWVzIGNhbid0IGJlIHNpbmdsZXRvbnMsIHdlIGhhdmUgdG8gdXNlIGEgZ2xvYmFsIENTUyBjbGFzc1xuICAgIC8vIChgY2RrLWdsb2JhbC1zY3JvbGxibG9ja2ApIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyeSB0byBkaXNhYmxlIGdsb2JhbFxuICAgIC8vIHNjcm9sbGluZyBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnY2RrLWdsb2JhbC1zY3JvbGxibG9jaycpIHx8IHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICByZXR1cm4gYm9keS5zY3JvbGxIZWlnaHQgPiB2aWV3cG9ydC5oZWlnaHQgfHwgYm9keS5zY3JvbGxXaWR0aCA+IHZpZXdwb3J0LndpZHRoO1xuICB9XG59XG4iLCJpbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1Njcm9sbFN0cmF0ZWd5LCBnZXRNZFNjcm9sbFN0cmF0ZWd5QWxyZWFkeUF0dGFjaGVkRXJyb3J9IGZyb20gJy4vc2Nyb2xsLXN0cmF0ZWd5JztcbmltcG9ydCB7T3ZlcmxheVJlZn0gZnJvbSAnLi4vb3ZlcmxheS1yZWYnO1xuaW1wb3J0IHtTY3JvbGxEaXNwYXRjaGVyfSBmcm9tICcuL3Njcm9sbC1kaXNwYXRjaGVyJztcblxuLyoqXG4gKiBDb25maWcgb3B0aW9ucyBmb3IgdGhlIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXBvc2l0aW9uU2Nyb2xsU3RyYXRlZ3lDb25maWcge1xuICBzY3JvbGxUaHJvdHRsZT86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBTdHJhdGVneSB0aGF0IHdpbGwgdXBkYXRlIHRoZSBlbGVtZW50IHBvc2l0aW9uIGFzIHRoZSB1c2VyIGlzIHNjcm9sbGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSBpbXBsZW1lbnRzIFNjcm9sbFN0cmF0ZWd5IHtcbiAgcHJpdmF0ZSBfc2Nyb2xsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb258bnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICBwcml2YXRlIF9jb25maWc6IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneUNvbmZpZykgeyB9XG5cbiAgYXR0YWNoKG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYpIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhyb3cgZ2V0TWRTY3JvbGxTdHJhdGVneUFscmVhZHlBdHRhY2hlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheVJlZiA9IG92ZXJsYXlSZWY7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24pIHtcbiAgICAgIGxldCB0aHJvdHRsZSA9IHRoaXMuX2NvbmZpZyA/IHRoaXMuX2NvbmZpZy5zY3JvbGxUaHJvdHRsZSA6IDA7XG5cbiAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQodGhyb3R0bGUsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuX3Njcm9sbFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTY3JvbGxTdHJhdGVneX0gZnJvbSAnLi9zY3JvbGwtc3RyYXRlZ3knO1xuaW1wb3J0IHtDbG9zZVNjcm9sbFN0cmF0ZWd5fSBmcm9tICcuL2Nsb3NlLXNjcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQge05vb3BTY3JvbGxTdHJhdGVneX0gZnJvbSAnLi9ub29wLXNjcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQge0Jsb2NrU2Nyb2xsU3RyYXRlZ3l9IGZyb20gJy4vYmxvY2stc2Nyb2xsLXN0cmF0ZWd5JztcbmltcG9ydCB7U2Nyb2xsRGlzcGF0Y2hlcn0gZnJvbSAnLi9zY3JvbGwtZGlzcGF0Y2hlcic7XG5pbXBvcnQge1ZpZXdwb3J0UnVsZXJ9IGZyb20gJy4uL3Bvc2l0aW9uL3ZpZXdwb3J0LXJ1bGVyJztcbmltcG9ydCB7XG4gIFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSxcbiAgUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5Q29uZmlnLFxufSBmcm9tICcuL3JlcG9zaXRpb24tc2Nyb2xsLXN0cmF0ZWd5JztcblxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGhvdyBhbiBvdmVybGF5IHdpbGwgaGFuZGxlIHNjcm9sbGluZy5cbiAqXG4gKiBVc2VycyBjYW4gcHJvdmlkZSBhIGN1c3RvbSB2YWx1ZSBmb3IgYFNjcm9sbFN0cmF0ZWd5T3B0aW9uc2AgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdFxuICogYmVoYXZpb3JzLiBUaGlzIGNsYXNzIHByaW1hcmlseSBhY3RzIGFzIGEgZmFjdG9yeSBmb3IgU2Nyb2xsU3RyYXRlZ3kgaW5zdGFuY2VzLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2Nyb2xsU3RyYXRlZ3lPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc2Nyb2xsRGlzcGF0Y2hlcjogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICBwcml2YXRlIF92aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyKSB7IH1cblxuICAvKiogRG8gbm90aGluZyBvbiBzY3JvbGwuICovXG4gIG5vb3AgPSAoKSA9PiBuZXcgTm9vcFNjcm9sbFN0cmF0ZWd5KCk7XG5cbiAgLyoqIENsb3NlIHRoZSBvdmVybGF5IGFzIHNvb24gYXMgdGhlIHVzZXIgc2Nyb2xscy4gKi9cbiAgY2xvc2UgPSAoKSA9PiBuZXcgQ2xvc2VTY3JvbGxTdHJhdGVneSh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyKTtcblxuICAvKiogQmxvY2sgc2Nyb2xsaW5nLiAqL1xuICBibG9jayA9ICgpID0+IG5ldyBCbG9ja1Njcm9sbFN0cmF0ZWd5KHRoaXMuX3ZpZXdwb3J0UnVsZXIpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBvbiBzY3JvbGwuXG4gICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiB0byBiZSB1c2VkIGluc2lkZSB0aGUgc2Nyb2xsIHN0cmF0ZWd5LlxuICAgKiBBbGxvd3MgZGVib3VuY2luZyB0aGUgcmVwb3NpdGlvbiBjYWxscy5cbiAgICovXG4gIHJlcG9zaXRpb24gPSAoY29uZmlnPzogUmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5Q29uZmlnKSA9PlxuICAgICAgbmV3IFJlcG9zaXRpb25TY3JvbGxTdHJhdGVneSh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyLCBjb25maWcpXG59XG4iLCJpbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJ9IGZyb20gJy4vc2Nyb2xsLWRpc3BhdGNoZXInO1xuaW1wb3J0IHtTY3JvbGxhYmxlfSBmcm9tICcuL3Njcm9sbGFibGUnO1xuaW1wb3J0IHtQbGF0Zm9ybU1vZHVsZX0gZnJvbSAnLi4vLi4vcGxhdGZvcm0vaW5kZXgnO1xuaW1wb3J0IHtTY3JvbGxTdHJhdGVneU9wdGlvbnN9IGZyb20gJy4vc2Nyb2xsLXN0cmF0ZWd5LW9wdGlvbnMnO1xuXG5leHBvcnQge1Njcm9sbGFibGV9IGZyb20gJy4vc2Nyb2xsYWJsZSc7XG5leHBvcnQge1Njcm9sbERpc3BhdGNoZXJ9IGZyb20gJy4vc2Nyb2xsLWRpc3BhdGNoZXInO1xuXG4vLyBFeHBvcnQgcHJlLWRlZmluZWQgc2Nyb2xsIHN0cmF0ZWdpZXMgYW5kIGludGVyZmFjZSB0byBidWlsZCBjdXN0b20gb25lcy5cbmV4cG9ydCB7U2Nyb2xsU3RyYXRlZ3l9IGZyb20gJy4vc2Nyb2xsLXN0cmF0ZWd5JztcbmV4cG9ydCB7U2Nyb2xsU3RyYXRlZ3lPcHRpb25zfSBmcm9tICcuL3Njcm9sbC1zdHJhdGVneS1vcHRpb25zJztcbmV4cG9ydCB7UmVwb3NpdGlvblNjcm9sbFN0cmF0ZWd5fSBmcm9tICcuL3JlcG9zaXRpb24tc2Nyb2xsLXN0cmF0ZWd5JztcbmV4cG9ydCB7Q2xvc2VTY3JvbGxTdHJhdGVneX0gZnJvbSAnLi9jbG9zZS1zY3JvbGwtc3RyYXRlZ3knO1xuZXhwb3J0IHtOb29wU2Nyb2xsU3RyYXRlZ3l9IGZyb20gJy4vbm9vcC1zY3JvbGwtc3RyYXRlZ3knO1xuZXhwb3J0IHtCbG9ja1Njcm9sbFN0cmF0ZWd5fSBmcm9tICcuL2Jsb2NrLXNjcm9sbC1zdHJhdGVneSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtQbGF0Zm9ybU1vZHVsZV0sXG4gIGV4cG9ydHM6IFtTY3JvbGxhYmxlXSxcbiAgZGVjbGFyYXRpb25zOiBbU2Nyb2xsYWJsZV0sXG4gIHByb3ZpZGVyczogW1NDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSLCBTY3JvbGxTdHJhdGVneU9wdGlvbnNdLFxufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxEaXNwYXRjaE1vZHVsZSB7IH1cbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtNZFJpcHBsZX0gZnJvbSAnLi9yaXBwbGUnO1xuaW1wb3J0IHtNZENvbW1vbk1vZHVsZX0gZnJvbSAnLi4vY29tbW9uLWJlaGF2aW9ycy9jb21tb24tbW9kdWxlJztcbmltcG9ydCB7VklFV1BPUlRfUlVMRVJfUFJPVklERVJ9IGZyb20gJy4uL292ZXJsYXkvcG9zaXRpb24vdmlld3BvcnQtcnVsZXInO1xuaW1wb3J0IHtTY3JvbGxEaXNwYXRjaE1vZHVsZX0gZnJvbSAnLi4vb3ZlcmxheS9zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHtQbGF0Zm9ybU1vZHVsZX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXgnO1xuXG5leHBvcnQge01kUmlwcGxlLCBSaXBwbGVHbG9iYWxPcHRpb25zLCBNRF9SSVBQTEVfR0xPQkFMX09QVElPTlN9IGZyb20gJy4vcmlwcGxlJztcbmV4cG9ydCB7UmlwcGxlUmVmLCBSaXBwbGVTdGF0ZX0gZnJvbSAnLi9yaXBwbGUtcmVmJztcbmV4cG9ydCB7UmlwcGxlQ29uZmlnLCBSSVBQTEVfRkFERV9JTl9EVVJBVElPTiwgUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OfSBmcm9tICcuL3JpcHBsZS1yZW5kZXJlcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtNZENvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGUsIFNjcm9sbERpc3BhdGNoTW9kdWxlXSxcbiAgZXhwb3J0czogW01kUmlwcGxlLCBNZENvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW01kUmlwcGxlXSxcbiAgcHJvdmlkZXJzOiBbVklFV1BPUlRfUlVMRVJfUFJPVklERVJdLFxufSlcbmV4cG9ydCBjbGFzcyBNZFJpcHBsZU1vZHVsZSB7fVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQge0NvbnN0cnVjdG9yfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcbmltcG9ydCB7RWxlbWVudFJlZiwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuQ29sb3Ige1xuICBjb2xvcjogc3RyaW5nO1xufVxuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGludGVyZmFjZSBIYXNSZW5kZXJlciB7XG4gIF9yZW5kZXJlcjogUmVuZGVyZXIyO1xuICBfZWxlbWVudFJlZjogRWxlbWVudFJlZjtcbn1cblxuLyoqIFBvc3NpYmxlIGNvbG9yIHBhbGV0dGUgdmFsdWVzLiAgKi9cbmV4cG9ydCB0eXBlIFRoZW1lUGFsZXR0ZSA9ICdwcmltYXJ5JyB8ICdhY2NlbnQnIHwgJ3dhcm4nIHwgbnVsbDtcblxuLyoqIE1peGluIHRvIGF1Z21lbnQgYSBkaXJlY3RpdmUgd2l0aCBhIGBjb2xvcmAgcHJvcGVydHkuICovXG5leHBvcnQgZnVuY3Rpb24gbWl4aW5Db2xvcjxUIGV4dGVuZHMgQ29uc3RydWN0b3I8SGFzUmVuZGVyZXI+PihiYXNlOiBULCBkZWZhdWx0Q29sb3I/OiBUaGVtZVBhbGV0dGUpXG4gICAgOiBDb25zdHJ1Y3RvcjxDYW5Db2xvcj4gJiBUIHtcbiAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgYmFzZSB7XG4gICAgcHJpdmF0ZSBfY29sb3I6IFRoZW1lUGFsZXR0ZSA9IG51bGw7XG5cbiAgICBnZXQgY29sb3IoKTogVGhlbWVQYWxldHRlIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9XG4gICAgc2V0IGNvbG9yKHZhbHVlOiBUaGVtZVBhbGV0dGUpIHtcbiAgICAgIGNvbnN0IGNvbG9yUGFsZXR0ZSA9IHZhbHVlIHx8IGRlZmF1bHRDb2xvcjtcblxuICAgICAgaWYgKGNvbG9yUGFsZXR0ZSAhPT0gdGhpcy5fY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBgbWF0LSR7dGhpcy5fY29sb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yUGFsZXR0ZSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgYG1hdC0ke2NvbG9yUGFsZXR0ZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3JQYWxldHRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGNvbG9yIHRoYXQgY2FuIGJlIHNwZWNpZmllZCBmcm9tIHRoZSBtaXhpbi5cbiAgICAgIHRoaXMuY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgfVxuICB9O1xufVxuXG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBJbnB1dCxcbiAgRWxlbWVudFJlZixcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q2FuQ29sb3IsIG1peGluQ29sb3J9IGZyb20gJy4uLy4uL2NvbW1vbi1iZWhhdmlvcnMvY29sb3InO1xuXG5leHBvcnQgdHlwZSBNZFBzZXVkb0NoZWNrYm94U3RhdGUgPSAndW5jaGVja2VkJyB8ICdjaGVja2VkJyB8ICdpbmRldGVybWluYXRlJztcblxuXG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1kQ2hpcC5cbmV4cG9ydCBjbGFzcyBNZFBzZXVkb0NoZWNrYm94QmFzZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxufVxuZXhwb3J0IGNvbnN0IF9NZFBzZXVkb0NoZWNrYm94QmFzZSA9IG1peGluQ29sb3IoTWRQc2V1ZG9DaGVja2JveEJhc2UsICdhY2NlbnQnKTtcblxuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHNob3dzIGEgc2ltcGxpZmllZCBjaGVja2JveCB3aXRob3V0IGluY2x1ZGluZyBhbnkga2luZCBvZiBcInJlYWxcIiBjaGVja2JveC5cbiAqIE1lYW50IHRvIGJlIHVzZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgcHVyZWx5IGRlY29yYXRpdmUgYW5kIGEgbGFyZ2UgbnVtYmVyIG9mIHRoZW0gd2lsbCBiZVxuICogaW5jbHVkZWQsIHN1Y2ggYXMgZm9yIHRoZSBvcHRpb25zIGluIGEgbXVsdGktc2VsZWN0LiBVc2VzIG5vIFNWR3Mgb3IgY29tcGxleCBhbmltYXRpb25zLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIGNvbXBsZXRlbHkgaW52aXNpYmxlIHRvIHNjcmVlbi1yZWFkZXIgdXNlcnMuIFRoaXMgaXMgKm5vdCpcbiAqIGludGVyY2hhbmdlYWJsZSB3aXRoIDxtZC1jaGVja2JveD4gYW5kIHNob3VsZCAqbm90KiBiZSB1c2VkIGlmIHRoZSB1c2VyIHdvdWxkIGRpcmVjdGx5IGludGVyYWN0XG4gKiB3aXRoIHRoZSBjaGVja2JveC4gVGhlIHBzZXVkby1jaGVja2JveCBzaG91bGQgb25seSBiZSB1c2VkIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZlxuICogbW9yZSBjb21wbGV4IGNvbXBvbmVudHMgdGhhdCBhcHByb3ByaWF0ZWx5IGhhbmRsZSBzZWxlY3RlZCAvIGNoZWNrZWQgc3RhdGUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgc2VsZWN0b3I6ICdtZC1wc2V1ZG8tY2hlY2tib3gsIG1hdC1wc2V1ZG8tY2hlY2tib3gnLFxuICBzdHlsZVVybHM6IFsncHNldWRvLWNoZWNrYm94LnNjc3MnXSxcbiAgaW5wdXRzOiBbJ2NvbG9yJ10sXG4gIHRlbXBsYXRlOiAnJyxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdtYXQtcHNldWRvLWNoZWNrYm94JyxcbiAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZV0nOiAnc3RhdGUgPT09IFwiaW5kZXRlcm1pbmF0ZVwiJyxcbiAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZF0nOiAnc3RhdGUgPT09IFwiY2hlY2tlZFwiJyxcbiAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTWRQc2V1ZG9DaGVja2JveCBleHRlbmRzIF9NZFBzZXVkb0NoZWNrYm94QmFzZSBpbXBsZW1lbnRzIENhbkNvbG9yIHtcbiAgLyoqIERpc3BsYXkgc3RhdGUgb2YgdGhlIGNoZWNrYm94LiAqL1xuICBASW5wdXQoKSBzdGF0ZTogTWRQc2V1ZG9DaGVja2JveFN0YXRlID0gJ3VuY2hlY2tlZCc7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkLiAqL1xuICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICBzdXBlcihyZW5kZXJlciwgZWxlbWVudFJlZik7XG4gIH1cbn1cbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtNZFBzZXVkb0NoZWNrYm94fSBmcm9tICcuL3BzZXVkby1jaGVja2JveC9wc2V1ZG8tY2hlY2tib3gnO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtNZFBzZXVkb0NoZWNrYm94XSxcbiAgZGVjbGFyYXRpb25zOiBbTWRQc2V1ZG9DaGVja2JveF1cbn0pXG5leHBvcnQgY2xhc3MgTWRTZWxlY3Rpb25Nb2R1bGUgeyB9XG5cblxuZXhwb3J0ICogZnJvbSAnLi9wc2V1ZG8tY2hlY2tib3gvcHNldWRvLWNoZWNrYm94JztcbiIsIlxuLy8gRHVlIHRvIGEgYnVnIGluIHRoZSBDaHJvbWVEcml2ZXIsIEFuZ3VsYXIga2V5Ym9hcmQgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGJ5IGBzZW5kS2V5c2Bcbi8vIGR1cmluZyBFMkUgdGVzdHMgd2hlbiB1c2luZyBkb3Qgbm90YXRpb24gc3VjaCBhcyBgKGtleWRvd24ucmlnaHRBcnJvdylgLiBUbyBnZXQgYXJvdW5kIHRoaXMsXG4vLyB3ZSBhcmUgdGVtcG9yYXJpbHkgdXNpbmcgYSBzaW5nbGUgKGtleWRvd24pIGhhbmRsZXIuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzk0MTlcblxuZXhwb3J0IGNvbnN0IFVQX0FSUk9XID0gMzg7XG5leHBvcnQgY29uc3QgRE9XTl9BUlJPVyA9IDQwO1xuZXhwb3J0IGNvbnN0IFJJR0hUX0FSUk9XID0gMzk7XG5leHBvcnQgY29uc3QgTEVGVF9BUlJPVyA9IDM3O1xuXG5leHBvcnQgY29uc3QgUEFHRV9VUCA9IDMzO1xuZXhwb3J0IGNvbnN0IFBBR0VfRE9XTiA9IDM0O1xuXG5leHBvcnQgY29uc3QgSE9NRSA9IDM2O1xuZXhwb3J0IGNvbnN0IEVORCA9IDM1O1xuXG5leHBvcnQgY29uc3QgRU5URVIgPSAxMztcbmV4cG9ydCBjb25zdCBTUEFDRSA9IDMyO1xuZXhwb3J0IGNvbnN0IFRBQiA9IDk7XG5cbmV4cG9ydCBjb25zdCBFU0NBUEUgPSAyNztcbmV4cG9ydCBjb25zdCBCQUNLU1BBQ0UgPSA4O1xuZXhwb3J0IGNvbnN0IERFTEVURSA9IDQ2O1xuXG5leHBvcnQgY29uc3QgQ09NTUEgPSAxODg7XG4iLCIvKiogQ29lcmNlcyBhIGRhdGEtYm91bmQgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZykgdG8gYSBib29sZWFuLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGAke3ZhbHVlfWAgIT09ICdmYWxzZSc7XG59XG4iLCJpbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnLi4vY29lcmNpb24vYm9vbGVhbi1wcm9wZXJ0eSc7XG5pbXBvcnQge0NvbnN0cnVjdG9yfSBmcm9tICcuL2NvbnN0cnVjdG9yJztcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuRGlzYWJsZSB7XG4gIGRpc2FibGVkOiBib29sZWFuO1xufVxuXG4vKiogTWl4aW4gdG8gYXVnbWVudCBhIGRpcmVjdGl2ZSB3aXRoIGEgYGRpc2FibGVkYCBwcm9wZXJ0eS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaXhpbkRpc2FibGVkPFQgZXh0ZW5kcyBDb25zdHJ1Y3Rvcjx7fT4+KGJhc2U6IFQpOiBDb25zdHJ1Y3RvcjxDYW5EaXNhYmxlPiAmIFQge1xuICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBiYXNlIHtcbiAgICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IGFueSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3M6IGFueVtdKSB7IHN1cGVyKC4uLmFyZ3MpOyB9XG4gIH07XG59XG4iLCJpbXBvcnQge0NvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge21peGluRGlzYWJsZWQsIENhbkRpc2FibGV9IGZyb20gJy4uL2NvbW1vbi1iZWhhdmlvcnMvZGlzYWJsZWQnO1xuXG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1kT3B0Z3JvdXAuXG5leHBvcnQgY2xhc3MgTWRPcHRncm91cEJhc2UgeyB9XG5leHBvcnQgY29uc3QgX01kT3B0Z3JvdXBNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kT3B0Z3JvdXBCYXNlKTtcblxuLy8gQ291bnRlciBmb3IgdW5pcXVlIGdyb3VwIGlkcy5cbmxldCBfdW5pcXVlT3B0Z3JvdXBJZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGlzIHVzZWQgdG8gZ3JvdXAgaW5zdGFuY2VzIG9mIGBtZC1vcHRpb25gLlxuICovXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQtb3B0Z3JvdXAsIG1hdC1vcHRncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnb3B0Z3JvdXAuaHRtbCcsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGlucHV0czogWydkaXNhYmxlZCddLFxuICBob3N0OiB7XG4gICAgJ2NsYXNzJzogJ21hdC1vcHRncm91cCcsXG4gICAgJ3JvbGUnOiAnZ3JvdXAnLFxuICAgICdbY2xhc3MubWF0LW9wdGdyb3VwLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ19sYWJlbElkJyxcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZE9wdGdyb3VwIGV4dGVuZHMgX01kT3B0Z3JvdXBNaXhpbkJhc2UgaW1wbGVtZW50cyBDYW5EaXNhYmxlIHtcbiAgLyoqIExhYmVsIGZvciB0aGUgb3B0aW9uIGdyb3VwLiAqL1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBVbmlxdWUgaWQgZm9yIHRoZSB1bmRlcmx5aW5nIGxhYmVsLiAqL1xuICBfbGFiZWxJZDogc3RyaW5nID0gYG1hdC1vcHRncm91cC1sYWJlbC0ke191bmlxdWVPcHRncm91cElkQ291bnRlcisrfWA7XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgTmdNb2R1bGUsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBJbmplY3QsXG4gIE9wdGlvbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RU5URVIsIFNQQUNFfSBmcm9tICcuLi9rZXlib2FyZC9rZXljb2Rlcyc7XG5pbXBvcnQge2NvZXJjZUJvb2xlYW5Qcm9wZXJ0eX0gZnJvbSAnLi4vY29lcmNpb24vYm9vbGVhbi1wcm9wZXJ0eSc7XG5pbXBvcnQge01BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERX0gZnJvbSAnLi4vLi4vY29yZS9jb21wYXRpYmlsaXR5L2NvbXBhdGliaWxpdHknO1xuaW1wb3J0IHtNZE9wdGdyb3VwfSBmcm9tICcuL29wdGdyb3VwJztcblxuLyoqXG4gKiBPcHRpb24gSURzIG5lZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyBjb21wb25lbnRzLCBzbyB0aGlzIGNvdW50ZXIgZXhpc3RzIG91dHNpZGUgb2ZcbiAqIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xubGV0IF91bmlxdWVJZENvdW50ZXIgPSAwO1xuXG4vKiogRXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRPcHRpb24gd2hlbiBzZWxlY3RlZCBvciBkZXNlbGVjdGVkLiAqL1xuZXhwb3J0IGNsYXNzIE1kT3B0aW9uU2VsZWN0aW9uQ2hhbmdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogTWRPcHRpb24sIHB1YmxpYyBpc1VzZXJJbnB1dCA9IGZhbHNlKSB7IH1cbn1cblxuXG4vKipcbiAqIFNpbmdsZSBvcHRpb24gaW5zaWRlIG9mIGEgYDxtZC1zZWxlY3Q+YCBlbGVtZW50LlxuICovXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQtb3B0aW9uLCBtYXQtb3B0aW9uJyxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgJ1tjbGFzcy5tYXQtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAnW2NsYXNzLm1hdC1vcHRpb24tbXVsdGlwbGVdJzogJ211bHRpcGxlJyxcbiAgICAnW2NsYXNzLm1hdC1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZC50b1N0cmluZygpJyxcbiAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgJ1tjbGFzcy5tYXQtb3B0aW9uLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJyhjbGljayknOiAnX3NlbGVjdFZpYUludGVyYWN0aW9uKCknLFxuICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgJ1tjbGFzcy5tYXQtb3B0aW9uXSc6ICd0cnVlJyxcbiAgfSxcbiAgdGVtcGxhdGVVcmw6ICdvcHRpb24uaHRtbCcsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTWRPcHRpb24ge1xuICBwcml2YXRlIF9zZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9hY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAgKi9cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9pZDogc3RyaW5nID0gYG1kLW9wdGlvbi0ke191bmlxdWVJZENvdW50ZXIrK31gO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSB3cmFwcGluZyBjb21wb25lbnQgaXMgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuICovXG4gIG11bHRpcGxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFRoZSB1bmlxdWUgSUQgb2YgdGhlIG9wdGlvbi4gKi9cbiAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5faWQ7IH1cblxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICovXG4gIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG5cbiAgLyoqIFRoZSBmb3JtIHZhbHVlIG9mIHRoZSBvcHRpb24uICovXG4gIEBJbnB1dCgpIHZhbHVlOiBhbnk7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5kaXNhYmxlZCkgfHwgdGhpcy5fZGlzYWJsZWQ7IH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSBvblNlbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8TWRPcHRpb25TZWxlY3Rpb25DaGFuZ2U+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwdWJsaWMgcmVhZG9ubHkgZ3JvdXA6IE1kT3B0Z3JvdXAsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUpIHB1YmxpYyBfaXNDb21wYXRpYmlsaXR5TW9kZTogYm9vbGVhbikge31cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCByZWFkeSB0byBiZSBzZWxlY3RlZC5cbiAgICogQW4gYWN0aXZlIG9wdGlvbiBkaXNwbGF5cyBzdHlsZXMgYXMgaWYgaXQgaXMgZm9jdXNlZCwgYnV0IHRoZVxuICAgKiBmb2N1cyBpcyBhY3R1YWxseSByZXRhaW5lZCBzb21ld2hlcmUgZWxzZS4gVGhpcyBjb21lcyBpbiBoYW5keVxuICAgKiBmb3IgY29tcG9uZW50cyBsaWtlIGF1dG9jb21wbGV0ZSB3aGVyZSBmb2N1cyBtdXN0IHJlbWFpbiBvbiB0aGUgaW5wdXQuXG4gICAqL1xuICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgb3B0aW9uLiBJdCBpcyBuZWNlc3NhcnkgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZVxuICAgKiBzZWxlY3QncyB0cmlnZ2VyLlxuICAgKi9cbiAgZ2V0IHZpZXdWYWx1ZSgpOiBzdHJpbmcge1xuICAgIC8vIFRPRE8oa2FyYSk6IEFkZCBpbnB1dCBwcm9wZXJ0eSBhbHRlcm5hdGl2ZSBmb3Igbm9kZSBlbnZzLlxuICAgIHJldHVybiB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLnRleHRDb250ZW50LnRyaW0oKTtcbiAgfVxuXG4gIC8qKiBTZWxlY3RzIHRoZSBvcHRpb24uICovXG4gIHNlbGVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gIH1cblxuICAvKiogRGVzZWxlY3RzIHRoZSBvcHRpb24uICovXG4gIGRlc2VsZWN0KCk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gIH1cblxuICAvKiogU2V0cyBmb2N1cyBvbnRvIHRoaXMgb3B0aW9uLiAqL1xuICBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2V0cyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRvIG1ha2UgaXQgYXBwZWFyXG4gICAqIGFjdGl2ZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBzbyBrZXlcbiAgICogZXZlbnRzIHdpbGwgZGlzcGxheSB0aGUgcHJvcGVyIG9wdGlvbnMgYXMgYWN0aXZlIG9uIGFycm93IGtleSBldmVudHMuXG4gICAqL1xuICBzZXRBY3RpdmVTdHlsZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIGRpc3BsYXkgc3R5bGVzIG9uIHRoZSBvcHRpb24gdGhhdCBtYWRlIGl0IGFwcGVhclxuICAgKiBhY3RpdmUuIFRoaXMgaXMgdXNlZCBieSB0aGUgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgc28ga2V5XG4gICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgKi9cbiAgc2V0SW5hY3RpdmVTdHlsZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIH1cblxuICAvKiogRW5zdXJlcyB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIHdoZW4gYWN0aXZhdGVkIGZyb20gdGhlIGtleWJvYXJkLiAqL1xuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgdGhpcy5fc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgb3B0aW9uIHdoaWxlIGluZGljYXRpbmcgdGhlIHNlbGVjdGlvbiBjYW1lIGZyb20gdGhlIHVzZXIuIFVzZWQgdG9cbiAgICogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QncyB2aWV3IC0+IG1vZGVsIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLlxuICAgKi9cbiAgX3NlbGVjdFZpYUludGVyYWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gIXRoaXMuX3NlbGVjdGVkIDogdHJ1ZTtcbiAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuICovXG4gIF9nZXRUYWJJbmRleCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJztcbiAgfVxuXG4gIC8qKiBGZXRjaGVzIHRoZSBob3N0IERPTSBlbGVtZW50LiAqL1xuICBfZ2V0SG9zdEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICAvKiogRW1pdHMgdGhlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQuICovXG4gIHByaXZhdGUgX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudChpc1VzZXJJbnB1dCA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5lbWl0KG5ldyBNZE9wdGlvblNlbGVjdGlvbkNoYW5nZSh0aGlzLCBpc1VzZXJJbnB1dCkpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge01kUmlwcGxlTW9kdWxlfSBmcm9tICcuLi9yaXBwbGUvaW5kZXgnO1xuaW1wb3J0IHtNZFNlbGVjdGlvbk1vZHVsZX0gZnJvbSAnLi4vc2VsZWN0aW9uL2luZGV4JztcbmltcG9ydCB7TWRPcHRpb259IGZyb20gJy4vb3B0aW9uJztcbmltcG9ydCB7TWRPcHRncm91cH0gZnJvbSAnLi9vcHRncm91cCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW01kUmlwcGxlTW9kdWxlLCBDb21tb25Nb2R1bGUsIE1kU2VsZWN0aW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW01kT3B0aW9uLCBNZE9wdGdyb3VwXSxcbiAgZGVjbGFyYXRpb25zOiBbTWRPcHRpb24sIE1kT3B0Z3JvdXBdXG59KVxuZXhwb3J0IGNsYXNzIE1kT3B0aW9uTW9kdWxlIHt9XG5cblxuZXhwb3J0ICogZnJvbSAnLi9vcHRpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9vcHRncm91cCc7XG4iLCIvKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIG51bGwgcG9ydGFsIHRvIGEgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93TnVsbFBvcnRhbEVycm9yKCkge1xuICB0aHJvdyBFcnJvcignTXVzdCBwcm92aWRlIGEgcG9ydGFsIHRvIGF0dGFjaCcpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIGhvc3QgdGhhdCBpcyBhbHJlYWR5IGF0dGFjaGVkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgdGhyb3cgRXJyb3IoJ0hvc3QgYWxyZWFkeSBoYXMgYSBwb3J0YWwgYXR0YWNoZWQnKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYW4gYWxyZWFkeS1kaXNwb3NlZCBob3N0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IoKSB7XG4gIHRocm93IEVycm9yKCdUaGlzIFBvcnRhbEhvc3QgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCcpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIHBvcnRhbCB0eXBlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dVbmtub3duUG9ydGFsVHlwZUVycm9yKCkge1xuICB0aHJvdyBFcnJvcignQXR0ZW1wdGluZyB0byBhdHRhY2ggYW4gdW5rbm93biBQb3J0YWwgdHlwZS4gQmFzZVBvcnRhbEhvc3QgYWNjZXB0cyBlaXRoZXInICtcbiAgICAgICAgICAgICAgICAgICdhIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLicpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIG51bGwgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcigpIHtcbiAgdGhyb3cgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGEgbnVsbCBQb3J0YWxIb3N0Jyk7XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGF0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkLlxuICogQGRvY3MtcHJpdmF0ZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93Tm9Qb3J0YWxBdHRhY2hlZEVycm9yKCkge1xuICB0aHJvdyBFcnJvcignQXR0ZW1wdGluZyB0byBkZXRhY2ggYSBwb3J0YWwgdGhhdCBpcyBub3QgYXR0YWNoZWQgdG8gYSBob3N0Jyk7XG59XG4iLCJpbXBvcnQge1xuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG4gICAgRWxlbWVudFJlZixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgSW5qZWN0b3Jcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcixcbiAgICB0aHJvd1BvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yLFxuICAgIHRocm93Tm9Qb3J0YWxBdHRhY2hlZEVycm9yLFxuICAgIHRocm93TnVsbFBvcnRhbEVycm9yLFxuICAgIHRocm93UG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yLFxuICAgIHRocm93VW5rbm93blBvcnRhbFR5cGVFcnJvclxufSBmcm9tICcuL3BvcnRhbC1lcnJvcnMnO1xuaW1wb3J0IHtDb21wb25lbnRUeXBlfSBmcm9tICcuLi9vdmVybGF5L2dlbmVyaWMtY29tcG9uZW50LXR5cGUnO1xuXG5cblxuLyoqXG4gKiBBIGBQb3J0YWxgIGlzIHNvbWV0aGluZyB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21ld2hlcmUgZWxzZS5cbiAqIEl0IGNhbiBiZSBhdHRhY2ggdG8gLyBkZXRhY2hlZCBmcm9tIGEgYFBvcnRhbEhvc3RgLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUG9ydGFsPFQ+IHtcbiAgcHJpdmF0ZSBfYXR0YWNoZWRIb3N0OiBQb3J0YWxIb3N0O1xuXG4gIC8qKiBBdHRhY2ggdGhpcyBwb3J0YWwgdG8gYSBob3N0LiAqL1xuICBhdHRhY2goaG9zdDogUG9ydGFsSG9zdCk6IFQge1xuICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgIHRocm93TnVsbFBvcnRhbEhvc3RFcnJvcigpO1xuICAgIH1cblxuICAgIGlmIChob3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHRocm93UG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgIHJldHVybiA8VD4gaG9zdC5hdHRhY2godGhpcyk7XG4gIH1cblxuICAvKiogRGV0YWNoIHRoaXMgcG9ydGFsIGZyb20gaXRzIGhvc3QgKi9cbiAgZGV0YWNoKCk6IHZvaWQge1xuICAgIGxldCBob3N0ID0gdGhpcy5fYXR0YWNoZWRIb3N0O1xuICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgIHRocm93Tm9Qb3J0YWxBdHRhY2hlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gbnVsbDtcbiAgICByZXR1cm4gaG9zdC5kZXRhY2goKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoaXMgcG9ydGFsIGlzIGF0dGFjaGVkIHRvIGEgaG9zdC4gKi9cbiAgZ2V0IGlzQXR0YWNoZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkSG9zdCAhPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFBvcnRhbEhvc3QgcmVmZXJlbmNlIHdpdGhvdXQgcGVyZm9ybWluZyBgYXR0YWNoKClgLiBUaGlzIGlzIHVzZWQgZGlyZWN0bHkgYnlcbiAgICogdGhlIFBvcnRhbEhvc3Qgd2hlbiBpdCBpcyBwZXJmb3JtaW5nIGFuIGBhdHRhY2goKWAgb3IgYGRldGFjaCgpYC5cbiAgICovXG4gIHNldEF0dGFjaGVkSG9zdChob3N0OiBQb3J0YWxIb3N0KSB7XG4gICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gaG9zdDtcbiAgfVxufVxuXG5cbi8qKlxuICogQSBgQ29tcG9uZW50UG9ydGFsYCBpcyBhIHBvcnRhbCB0aGF0IGluc3RhbnRpYXRlcyBzb21lIENvbXBvbmVudCB1cG9uIGF0dGFjaG1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRQb3J0YWw8VD4gZXh0ZW5kcyBQb3J0YWw8Q29tcG9uZW50UmVmPFQ+PiB7XG4gIC8qKiBUaGUgdHlwZSBvZiB0aGUgY29tcG9uZW50IHRoYXQgd2lsbCBiZSBpbnN0YW50aWF0ZWQgZm9yIGF0dGFjaG1lbnQuICovXG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZTxUPjtcblxuICAvKipcbiAgICogW09wdGlvbmFsXSBXaGVyZSB0aGUgYXR0YWNoZWQgY29tcG9uZW50IHNob3VsZCBsaXZlIGluIEFuZ3VsYXIncyAqbG9naWNhbCogY29tcG9uZW50IHRyZWUuXG4gICAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gd2hlcmUgdGhlIGNvbXBvbmVudCAqcmVuZGVycyosIHdoaWNoIGlzIGRldGVybWluZWQgYnkgdGhlIFBvcnRhbEhvc3QuXG4gICAqIFRoZSBvcmlnaW4gaXMgbmVjZXNzYXJ5IHdoZW4gdGhlIGhvc3QgaXMgb3V0c2lkZSBvZiB0aGUgQW5ndWxhciBhcHBsaWNhdGlvbiBjb250ZXh0LlxuICAgKi9cbiAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAvKiogW09wdGlvbmFsXSBJbmplY3RvciB1c2VkIGZvciB0aGUgaW5zdGFudGlhdGlvbiBvZiB0aGUgY29tcG9uZW50LiAqL1xuICBpbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGU8VD4sXG4gICAgICB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmID0gbnVsbCxcbiAgICAgIGluamVjdG9yOiBJbmplY3RvciA9IG51bGwpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICB9XG59XG5cblxuLyoqXG4gKiBBIGBUZW1wbGF0ZVBvcnRhbGAgaXMgYSBwb3J0YWwgdGhhdCByZXByZXNlbnRzIHNvbWUgZW1iZWRkZWQgdGVtcGxhdGUgKFRlbXBsYXRlUmVmKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUG9ydGFsIGV4dGVuZHMgUG9ydGFsPE1hcDxzdHJpbmcsIGFueT4+IHtcbiAgLyoqIFRoZSBlbWJlZGRlZCB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbnN0YW50aWF0ZSBhbiBlbWJlZGRlZCBWaWV3IGluIHRoZSBob3N0LiAqL1xuICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogUmVmZXJlbmNlIHRvIHRoZSBWaWV3Q29udGFpbmVyIGludG8gd2hpY2ggdGhlIHRlbXBsYXRlIHdpbGwgYmUgc3RhbXBlZCBvdXQuICovXG4gIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgbG9jYWxzIGZvciB0aGUgaW5zdGFudGlhdGVkIGVtYmVkZGVkIHZpZXcuXG4gICAqIFRoZXNlIGxvY2FscyBjYW4gYmUgc2VlbiBhcyBcImV4cG9ydHNcIiBmb3IgdGhlIHRlbXBsYXRlLCBzdWNoIGFzIGhvdyBuZ0ZvciBoYXNcbiAgICogaW5kZXggLyBldmVudCAvIG9kZC5cbiAgICogU2VlIGh0dHBzOi8vYW5ndWxhci5pby9kb2NzL3RzL2xhdGVzdC9hcGkvY29yZS9FbWJlZGRlZFZpZXdSZWYtY2xhc3MuaHRtbFxuICAgKi9cbiAgbG9jYWxzOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Piwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gIH1cblxuICBnZXQgb3JpZ2luKCk6IEVsZW1lbnRSZWYge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUmVmLmVsZW1lbnRSZWY7XG4gIH1cblxuICBhdHRhY2goaG9zdDogUG9ydGFsSG9zdCwgbG9jYWxzPzogTWFwPHN0cmluZywgYW55Pik6IE1hcDxzdHJpbmcsIGFueT4ge1xuICAgIHRoaXMubG9jYWxzID0gbG9jYWxzID09IG51bGwgPyBuZXcgTWFwPHN0cmluZywgYW55PigpIDogbG9jYWxzO1xuICAgIHJldHVybiBzdXBlci5hdHRhY2goaG9zdCk7XG4gIH1cblxuICBkZXRhY2goKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbHMgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgIHJldHVybiBzdXBlci5kZXRhY2goKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQSBgUG9ydGFsSG9zdGAgaXMgYW4gc3BhY2UgdGhhdCBjYW4gY29udGFpbiBhIHNpbmdsZSBgUG9ydGFsYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQb3J0YWxIb3N0IHtcbiAgYXR0YWNoKHBvcnRhbDogUG9ydGFsPGFueT4pOiBhbnk7XG5cbiAgZGV0YWNoKCk6IGFueTtcblxuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgaGFzQXR0YWNoZWQoKTogYm9vbGVhbjtcbn1cblxuXG4vKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgUG9ydGFsSG9zdCB0aGF0IG9ubHkgZGVhbHMgd2l0aCBhdHRhY2hpbmcgZWl0aGVyIGFcbiAqIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVBvcnRhbEhvc3QgaW1wbGVtZW50cyBQb3J0YWxIb3N0IHtcbiAgLyoqIFRoZSBwb3J0YWwgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoZSBob3N0LiAqL1xuICBwcml2YXRlIF9hdHRhY2hlZFBvcnRhbDogUG9ydGFsPGFueT47XG5cbiAgLyoqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHBlcm1hbmVudGx5IGRpc3Bvc2UgdGhpcyBob3N0LiAqL1xuICBwcml2YXRlIF9kaXNwb3NlRm46ICgpID0+IHZvaWQ7XG5cbiAgLyoqIFdoZXRoZXIgdGhpcyBob3N0IGhhcyBhbHJlYWR5IGJlZW4gcGVybWFuZW50bHkgZGlzcG9zZWQuICovXG4gIHByaXZhdGUgX2lzRGlzcG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFuIGF0dGFjaGVkIHBvcnRhbC4gKi9cbiAgaGFzQXR0YWNoZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fYXR0YWNoZWRQb3J0YWw7XG4gIH1cblxuICBhdHRhY2gocG9ydGFsOiBQb3J0YWw8YW55Pik6IGFueSB7XG4gICAgaWYgKCFwb3J0YWwpIHtcbiAgICAgIHRocm93TnVsbFBvcnRhbEVycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgdGhyb3dQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aHJvd1BvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpO1xuICAgIH1cblxuICAgIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBDb21wb25lbnRQb3J0YWwpIHtcbiAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgfSBlbHNlIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBUZW1wbGF0ZVBvcnRhbCkge1xuICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBwb3J0YWw7XG4gICAgICByZXR1cm4gdGhpcy5hdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpO1xuICAgIH1cblxuICAgIHRocm93VW5rbm93blBvcnRhbFR5cGVFcnJvcigpO1xuICB9XG5cbiAgYWJzdHJhY3QgYXR0YWNoQ29tcG9uZW50UG9ydGFsPFQ+KHBvcnRhbDogQ29tcG9uZW50UG9ydGFsPFQ+KTogQ29tcG9uZW50UmVmPFQ+O1xuXG4gIGFic3RyYWN0IGF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbDogVGVtcGxhdGVQb3J0YWwpOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gIGRldGFjaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fYXR0YWNoZWRQb3J0YWwpIHtcbiAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsLnNldEF0dGFjaGVkSG9zdChudWxsKTtcbiAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2VEaXNwb3NlRm4oKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2VEaXNwb3NlRm4oKTtcbiAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHNldERpc3Bvc2VGbihmbjogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2Rpc3Bvc2VGbiA9IGZuO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW52b2tlRGlzcG9zZUZuKCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlRm4pIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VGbigpO1xuICAgICAgdGhpcy5fZGlzcG9zZUZuID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gICAgTmdNb2R1bGUsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBPbkRlc3Ryb3ksXG4gICAgSW5wdXQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQb3J0YWwsIFRlbXBsYXRlUG9ydGFsLCBDb21wb25lbnRQb3J0YWwsIEJhc2VQb3J0YWxIb3N0fSBmcm9tICcuL3BvcnRhbCc7XG5cblxuLyoqXG4gKiBEaXJlY3RpdmUgdmVyc2lvbiBvZiBhIGBUZW1wbGF0ZVBvcnRhbGAuIEJlY2F1c2UgdGhlIGRpcmVjdGl2ZSAqaXMqIGEgVGVtcGxhdGVQb3J0YWwsXG4gKiB0aGUgZGlyZWN0aXZlIGluc3RhbmNlIGl0c2VsZiBjYW4gYmUgYXR0YWNoZWQgdG8gYSBob3N0LCBlbmFibGluZyBkZWNsYXJhdGl2ZSB1c2Ugb2YgcG9ydGFscy5cbiAqXG4gKiBVc2FnZTpcbiAqIDxuZy10ZW1wbGF0ZSBwb3J0YWwgI2dyZWV0aW5nPlxuICogICA8cD4gSGVsbG8ge3tuYW1lfX0gPC9wPlxuICogPC9uZy10ZW1wbGF0ZT5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2Nkay1wb3J0YWxdLCBbY2RrUG9ydGFsXSwgW3BvcnRhbF0nLFxuICBleHBvcnRBczogJ2Nka1BvcnRhbCcsXG59KVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlIGV4dGVuZHMgVGVtcGxhdGVQb3J0YWwge1xuICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Piwgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuICAgIHN1cGVyKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgfVxufVxuXG5cbi8qKlxuICogRGlyZWN0aXZlIHZlcnNpb24gb2YgYSBQb3J0YWxIb3N0LiBCZWNhdXNlIHRoZSBkaXJlY3RpdmUgKmlzKiBhIFBvcnRhbEhvc3QsIHBvcnRhbHMgY2FuIGJlXG4gKiBkaXJlY3RseSBhdHRhY2hlZCB0byBpdCwgZW5hYmxpbmcgZGVjbGFyYXRpdmUgdXNlLlxuICpcbiAqIFVzYWdlOlxuICogPG5nLXRlbXBsYXRlIFtjZGtQb3J0YWxIb3N0XT1cImdyZWV0aW5nXCI+PC9uZy10ZW1wbGF0ZT5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2Nka1BvcnRhbEhvc3RdLCBbcG9ydGFsSG9zdF0nLFxuICBpbnB1dHM6IFsncG9ydGFsOiBjZGtQb3J0YWxIb3N0J11cbn0pXG5leHBvcnQgY2xhc3MgUG9ydGFsSG9zdERpcmVjdGl2ZSBleHRlbmRzIEJhc2VQb3J0YWxIb3N0IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqIFRoZSBhdHRhY2hlZCBwb3J0YWwuICovXG4gIHByaXZhdGUgX3BvcnRhbDogUG9ydGFsPGFueT47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIEBJbnB1dCgncG9ydGFsSG9zdCcpXG4gIGdldCBfZGVwcmVjYXRlZFBvcnRhbCgpIHsgcmV0dXJuIHRoaXMucG9ydGFsOyB9XG4gIHNldCBfZGVwcmVjYXRlZFBvcnRhbCh2KSB7IHRoaXMucG9ydGFsID0gdjsgfVxuXG4gIC8qKiBQb3J0YWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBQb3J0YWwgaG9zdC4gKi9cbiAgZ2V0IHBvcnRhbCgpOiBQb3J0YWw8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcnRhbDtcbiAgfVxuXG4gIHNldCBwb3J0YWwocG9ydGFsOiBQb3J0YWw8YW55Pikge1xuICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHN1cGVyLmRldGFjaCgpO1xuICAgIH1cblxuICAgIGlmIChwb3J0YWwpIHtcbiAgICAgIHN1cGVyLmF0dGFjaChwb3J0YWwpO1xuICAgIH1cblxuICAgIHRoaXMuX3BvcnRhbCA9IHBvcnRhbDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9wb3J0YWwgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIHRoaXMgUG9ydGFsSG9zdCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZCB0byB0aGUgcG9ydGFsIGhvc3QuXG4gICAqL1xuICBhdHRhY2hDb21wb25lbnRQb3J0YWw8VD4ocG9ydGFsOiBDb21wb25lbnRQb3J0YWw8VD4pOiBDb21wb25lbnRSZWY8VD4ge1xuICAgIHBvcnRhbC5zZXRBdHRhY2hlZEhvc3QodGhpcyk7XG5cbiAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhbiBvcmlnaW4sIHVzZSB0aGF0IGFzIHRoZSBsb2dpY2FsIGxvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICAvLyBpbiB0aGUgYXBwbGljYXRpb24gdHJlZS4gT3RoZXJ3aXNlIHVzZSB0aGUgbG9jYXRpb24gb2YgdGhpcyBQb3J0YWxIb3N0LlxuICAgIGxldCB2aWV3Q29udGFpbmVyUmVmID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWYgIT0gbnVsbCA/XG4gICAgICAgIHBvcnRhbC52aWV3Q29udGFpbmVyUmVmIDpcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcblxuICAgIGxldCBjb21wb25lbnRGYWN0b3J5ID1cbiAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KHBvcnRhbC5jb21wb25lbnQpO1xuICAgIGxldCByZWYgPSB2aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChcbiAgICAgICAgY29tcG9uZW50RmFjdG9yeSwgdmlld0NvbnRhaW5lclJlZi5sZW5ndGgsXG4gICAgICAgIHBvcnRhbC5pbmplY3RvciB8fCB2aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcblxuICAgIHN1cGVyLnNldERpc3Bvc2VGbigoKSA9PiByZWYuZGVzdHJveSgpKTtcbiAgICB0aGlzLl9wb3J0YWwgPSBwb3J0YWw7XG5cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCB0aGUgZ2l2ZW4gVGVtcGxhdGVQb3J0YWwgdG8gdGhpcyBQb3J0bEhvc3QgYXMgYW4gZW1iZWRkZWQgVmlldy5cbiAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQuXG4gICAqL1xuICBhdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWw6IFRlbXBsYXRlUG9ydGFsKTogTWFwPHN0cmluZywgYW55PiB7XG4gICAgcG9ydGFsLnNldEF0dGFjaGVkSG9zdCh0aGlzKTtcblxuICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHBvcnRhbC50ZW1wbGF0ZVJlZik7XG4gICAgc3VwZXIuc2V0RGlzcG9zZUZuKCgpID0+IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY2xlYXIoKSk7XG5cbiAgICB0aGlzLl9wb3J0YWwgPSBwb3J0YWw7XG5cbiAgICAvLyBUT0RPKGplbGJvdXJuKTogcmV0dXJuIGxvY2FscyBmcm9tIHZpZXdcbiAgICByZXR1cm4gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgfVxufVxuXG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsSG9zdERpcmVjdGl2ZV0sXG4gIGRlY2xhcmF0aW9uczogW1RlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBQb3J0YWxIb3N0RGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgUG9ydGFsTW9kdWxlIHt9XG4iLCJpbXBvcnQge1Bvc2l0aW9uU3RyYXRlZ3l9IGZyb20gJy4vcG9zaXRpb24vcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHtMYXlvdXREaXJlY3Rpb259IGZyb20gJy4uL3J0bC9kaXInO1xuaW1wb3J0IHtTY3JvbGxTdHJhdGVneX0gZnJvbSAnLi9zY3JvbGwvc2Nyb2xsLXN0cmF0ZWd5JztcblxuXG4vKipcbiAqIE92ZXJsYXlTdGF0ZSBpcyBhIGJhZyBvZiB2YWx1ZXMgZm9yIGVpdGhlciB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIG9yIGN1cnJlbnQgc3RhdGUgb2YgYW5cbiAqIG92ZXJsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBPdmVybGF5U3RhdGUge1xuICAvKiogU3RyYXRlZ3kgd2l0aCB3aGljaCB0byBwb3NpdGlvbiB0aGUgb3ZlcmxheS4gKi9cbiAgcG9zaXRpb25TdHJhdGVneTogUG9zaXRpb25TdHJhdGVneTtcblxuICAvKiogU3RyYXRlZ3kgdG8gYmUgdXNlZCB3aGVuIGhhbmRsaW5nIHNjcm9sbCBldmVudHMgd2hpbGUgdGhlIG92ZXJsYXkgaXMgb3Blbi4gKi9cbiAgc2Nyb2xsU3RyYXRlZ3k6IFNjcm9sbFN0cmF0ZWd5O1xuXG4gIC8qKiBDdXN0b20gY2xhc3MgdG8gYWRkIHRvIHRoZSBvdmVybGF5IHBhbmUuICovXG4gIHBhbmVsQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBvdmVybGF5IGhhcyBhIGJhY2tkcm9wLiAqL1xuICBoYXNCYWNrZHJvcDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBDdXN0b20gY2xhc3MgdG8gYWRkIHRvIHRoZSBiYWNrZHJvcCAqL1xuICBiYWNrZHJvcENsYXNzOiBzdHJpbmcgPSAnY2RrLW92ZXJsYXktZGFyay1iYWNrZHJvcCc7XG5cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gSWYgYSBudW1iZXIgaXMgcHJvdmlkZWQsIHBpeGVsIHVuaXRzIGFyZSBhc3N1bWVkLiAqL1xuICB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IHBhbmVsLiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCwgcGl4ZWwgdW5pdHMgYXJlIGFzc3VtZWQuICovXG4gIGhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKiBUaGUgbWluLXdpZHRoIG9mIHRoZSBvdmVybGF5IHBhbmVsLiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCwgcGl4ZWwgdW5pdHMgYXJlIGFzc3VtZWQuICovXG4gIG1pbldpZHRoOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgLyoqIFRoZSBtaW4taGVpZ2h0IG9mIHRoZSBvdmVybGF5IHBhbmVsLiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCwgcGl4ZWwgdW5pdHMgYXJlIGFzc3VtZWQuICovXG4gIG1pbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKiBUaGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0IGluIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBkaXJlY3Rpb246IExheW91dERpcmVjdGlvbiA9ICdsdHInO1xuXG4gIC8vIFRPRE8oamVsYm91cm4pOiBjb25maWd1cmF0aW9uIHN0aWxsIHRvIGFkZFxuICAvLyAtIGZvY3VzIHRyYXBcbiAgLy8gLSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzXG4gIC8vIC0gei1pbmRleFxufVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBDb21wb25lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgQXBwbGljYXRpb25SZWYsXG4gIEluamVjdG9yLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZVBvcnRhbEhvc3QsIENvbXBvbmVudFBvcnRhbCwgVGVtcGxhdGVQb3J0YWx9IGZyb20gJy4vcG9ydGFsJztcblxuXG4vKipcbiAqIEEgUG9ydGFsSG9zdCBmb3IgYXR0YWNoaW5nIHBvcnRhbHMgdG8gYW4gYXJiaXRyYXJ5IERPTSBlbGVtZW50IG91dHNpZGUgb2YgdGhlIEFuZ3VsYXJcbiAqIGFwcGxpY2F0aW9uIGNvbnRleHQuXG4gKlxuICogVGhpcyBpcyB0aGUgb25seSBwYXJ0IG9mIHRoZSBwb3J0YWwgY29yZSB0aGF0IGRpcmVjdGx5IHRvdWNoZXMgdGhlIERPTS5cbiAqL1xuZXhwb3J0IGNsYXNzIERvbVBvcnRhbEhvc3QgZXh0ZW5kcyBCYXNlUG9ydGFsSG9zdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBfaG9zdERvbUVsZW1lbnQ6IEVsZW1lbnQsXG4gICAgICBwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgIHByaXZhdGUgX2FwcFJlZjogQXBwbGljYXRpb25SZWYsXG4gICAgICBwcml2YXRlIF9kZWZhdWx0SW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIGdpdmVuIENvbXBvbmVudFBvcnRhbCB0byBET00gZWxlbWVudCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZFxuICAgKi9cbiAgYXR0YWNoQ29tcG9uZW50UG9ydGFsPFQ+KHBvcnRhbDogQ29tcG9uZW50UG9ydGFsPFQ+KTogQ29tcG9uZW50UmVmPFQ+IHtcbiAgICBsZXQgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICBsZXQgY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8VD47XG5cbiAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhIFZpZXdDb250YWluZXJSZWYsIHdlIHdpbGwgdXNlIHRoYXQgYXMgdGhlIGF0dGFjaG1lbnQgcG9pbnRcbiAgICAvLyBmb3IgdGhlIGNvbXBvbmVudCAoaW4gdGVybXMgb2YgQW5ndWxhcidzIGNvbXBvbmVudCB0cmVlLCBub3QgcmVuZGVyaW5nKS5cbiAgICAvLyBXaGVuIHRoZSBWaWV3Q29udGFpbmVyUmVmIGlzIG1pc3NpbmcsIHdlIHVzZSB0aGUgZmFjdG9yeSB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCBkaXJlY3RseVxuICAgIC8vIGFuZCB0aGVuIG1hbnVhbGx5IGF0dGFjaCB0aGUgdmlldyB0byB0aGUgYXBwbGljYXRpb24uXG4gICAgaWYgKHBvcnRhbC52aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICBjb21wb25lbnRSZWYgPSBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoXG4gICAgICAgICAgY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5sZW5ndGgsXG4gICAgICAgICAgcG9ydGFsLmluamVjdG9yIHx8IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcblxuICAgICAgdGhpcy5zZXREaXNwb3NlRm4oKCkgPT4gY29tcG9uZW50UmVmLmRlc3Ryb3koKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHBvcnRhbC5pbmplY3RvciB8fCB0aGlzLl9kZWZhdWx0SW5qZWN0b3IpO1xuICAgICAgdGhpcy5fYXBwUmVmLmF0dGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYXBwUmVmLmRldGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaW5zdGFudGlhdGVkLCBzbyB3ZSBtb3ZlIGl0IHRvIHRoZSBsb2NhdGlvbiBpbiB0aGUgRE9NXG4gICAgLy8gd2hlcmUgd2Ugd2FudCBpdCB0byBiZSByZW5kZXJlZC5cbiAgICB0aGlzLl9ob3N0RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpKTtcblxuICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgYSB0ZW1wbGF0ZSBwb3J0YWwgdG8gdGhlIERPTSBhcyBhbiBlbWJlZGRlZCB2aWV3LlxuICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZC5cbiAgICovXG4gIGF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbDogVGVtcGxhdGVQb3J0YWwpOiBNYXA8c3RyaW5nLCBhbnk+IHtcbiAgICBsZXQgdmlld0NvbnRhaW5lciA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmO1xuICAgIGxldCB2aWV3UmVmID0gdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcocG9ydGFsLnRlbXBsYXRlUmVmKTtcbiAgICB2aWV3UmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgIC8vIFRoZSBtZXRob2QgYGNyZWF0ZUVtYmVkZGVkVmlld2Agd2lsbCBhZGQgdGhlIHZpZXcgYXMgYSBjaGlsZCBvZiB0aGUgdmlld0NvbnRhaW5lci5cbiAgICAvLyBCdXQgZm9yIHRoZSBEb21Qb3J0YWxIb3N0IHRoZSB2aWV3IGNhbiBiZSBhZGRlZCBldmVyeXdoZXJlIGluIHRoZSBET00gKGUuZyBPdmVybGF5IENvbnRhaW5lcilcbiAgICAvLyBUbyBtb3ZlIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgaG9zdCBlbGVtZW50LiBXZSBqdXN0IHJlLWFwcGVuZCB0aGUgZXhpc3Rpbmcgcm9vdCBub2Rlcy5cbiAgICB2aWV3UmVmLnJvb3ROb2Rlcy5mb3JFYWNoKHJvb3ROb2RlID0+IHRoaXMuX2hvc3REb21FbGVtZW50LmFwcGVuZENoaWxkKHJvb3ROb2RlKSk7XG5cbiAgICB0aGlzLnNldERpc3Bvc2VGbigoKCkgPT4ge1xuICAgICAgbGV0IGluZGV4ID0gdmlld0NvbnRhaW5lci5pbmRleE9mKHZpZXdSZWYpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB2aWV3Q29udGFpbmVyLnJlbW92ZShpbmRleCk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gVE9ETyhqZWxib3Vybik6IFJldHVybiBsb2NhbHMgZnJvbSB2aWV3LlxuICAgIHJldHVybiBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXQgYSBwb3J0YWwgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgaWYgKHRoaXMuX2hvc3REb21FbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5faG9zdERvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ob3N0RG9tRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldHMgdGhlIHJvb3QgSFRNTEVsZW1lbnQgZm9yIGFuIGluc3RhbnRpYXRlZCBjb21wb25lbnQuICovXG4gIHByaXZhdGUgX2dldENvbXBvbmVudFJvb3ROb2RlKGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPGFueT4pOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIChjb21wb25lbnRSZWYuaG9zdFZpZXcgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT4pLnJvb3ROb2Rlc1swXSBhcyBIVE1MRWxlbWVudDtcbiAgfVxufVxuIiwiaW1wb3J0IHtOZ1pvbmV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQb3J0YWxIb3N0LCBQb3J0YWx9IGZyb20gJy4uL3BvcnRhbC9wb3J0YWwnO1xuaW1wb3J0IHtPdmVybGF5U3RhdGV9IGZyb20gJy4vb3ZlcmxheS1zdGF0ZSc7XG5pbXBvcnQge1Njcm9sbFN0cmF0ZWd5fSBmcm9tICcuL3Njcm9sbC9zY3JvbGwtc3RyYXRlZ3knO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhbiBvdmVybGF5IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBPdmVybGF5IHNlcnZpY2UuXG4gKiBVc2VkIHRvIG1hbmlwdWxhdGUgb3IgZGlzcG9zZSBvZiBzYWlkIG92ZXJsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBPdmVybGF5UmVmIGltcGxlbWVudHMgUG9ydGFsSG9zdCB7XG4gIHByaXZhdGUgX2JhY2tkcm9wRWxlbWVudDogSFRNTEVsZW1lbnQgPSBudWxsO1xuICBwcml2YXRlIF9iYWNrZHJvcENsaWNrOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9hdHRhY2htZW50cyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX2RldGFjaG1lbnRzID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX3BvcnRhbEhvc3Q6IFBvcnRhbEhvc3QsXG4gICAgICBwcml2YXRlIF9wYW5lOiBIVE1MRWxlbWVudCxcbiAgICAgIHByaXZhdGUgX3N0YXRlOiBPdmVybGF5U3RhdGUsXG4gICAgICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneTogU2Nyb2xsU3RyYXRlZ3ksXG4gICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge1xuXG4gICAgX3Njcm9sbFN0cmF0ZWd5LmF0dGFjaCh0aGlzKTtcbiAgfVxuXG4gIC8qKiBUaGUgb3ZlcmxheSdzIEhUTUwgZWxlbWVudCAqL1xuICBnZXQgb3ZlcmxheUVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9wYW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIHRoZSBvdmVybGF5IHRvIGEgcG9ydGFsIGluc3RhbmNlIGFuZCBhZGRzIHRoZSBiYWNrZHJvcC5cbiAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgaW5zdGFuY2UgdG8gd2hpY2ggdG8gYXR0YWNoIHRoZSBvdmVybGF5LlxuICAgKiBAcmV0dXJucyBUaGUgcG9ydGFsIGF0dGFjaG1lbnQgcmVzdWx0LlxuICAgKi9cbiAgYXR0YWNoKHBvcnRhbDogUG9ydGFsPGFueT4pOiBhbnkge1xuICAgIGxldCBhdHRhY2hSZXN1bHQgPSB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaChwb3J0YWwpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBwYW5lIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc3RhdGUgY29uZmlndXJhdGlvbi5cbiAgICB0aGlzLl91cGRhdGVTdGFja2luZ09yZGVyKCk7XG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kuZW5hYmxlKCk7XG5cbiAgICAvLyBFbmFibGUgcG9pbnRlciBldmVudHMgZm9yIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudC5cbiAgICB0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlLmhhc0JhY2tkcm9wKSB7XG4gICAgICB0aGlzLl9hdHRhY2hCYWNrZHJvcCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZS5wYW5lbENsYXNzKSB7XG4gICAgICB0aGlzLl9wYW5lLmNsYXNzTGlzdC5hZGQodGhpcy5fc3RhdGUucGFuZWxDbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gT25seSBlbWl0IHRoZSBgYXR0YWNobWVudHNgIGV2ZW50IG9uY2UgYWxsIG90aGVyIHNldHVwIGlzIGRvbmUuXG4gICAgdGhpcy5fYXR0YWNobWVudHMubmV4dCgpO1xuXG4gICAgcmV0dXJuIGF0dGFjaFJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhbiBvdmVybGF5IGZyb20gYSBwb3J0YWwuXG4gICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gZGV0YWNoZWQuXG4gICAqL1xuICBkZXRhY2goKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aGlzLmRldGFjaEJhY2tkcm9wKCk7XG5cbiAgICAvLyBXaGVuIHRoZSBvdmVybGF5IGlzIGRldGFjaGVkLCB0aGUgcGFuZSBlbGVtZW50IHNob3VsZCBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBwYW5lIGVsZW1lbnQgd2lsbCBjb3ZlciB0aGUgcGFnZSBhbmQgZGlzYWJsZVxuICAgIC8vIHBvaW50ZXIgZXZlbnRzIHRoZXJlZm9yZS4gRGVwZW5kcyBvbiB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgYW5kIHRoZSBhcHBsaWVkIHBhbmUgYm91bmRhcmllcy5cbiAgICB0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS5kaXNhYmxlKCk7XG5cbiAgICBsZXQgZGV0YWNobWVudFJlc3VsdCA9IHRoaXMuX3BvcnRhbEhvc3QuZGV0YWNoKCk7XG5cbiAgICAvLyBPbmx5IGVtaXQgYWZ0ZXIgZXZlcnl0aGluZyBpcyBkZXRhY2hlZC5cbiAgICB0aGlzLl9kZXRhY2htZW50cy5uZXh0KCk7XG5cbiAgICByZXR1cm4gZGV0YWNobWVudFJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhlIG92ZXJsYXkgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgdGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Njcm9sbFN0cmF0ZWd5KSB7XG4gICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kZXRhY2hCYWNrZHJvcCgpO1xuICAgIHRoaXMuX3BvcnRhbEhvc3QuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2F0dGFjaG1lbnRzLmNvbXBsZXRlKCk7XG4gICAgdGhpcy5fYmFja2Ryb3BDbGljay5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX2RldGFjaG1lbnRzLm5leHQoKTtcbiAgICB0aGlzLl9kZXRhY2htZW50cy5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBvdmVybGF5IGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgKi9cbiAgaGFzQXR0YWNoZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBoYXMgYmVlbiBjbGlja2VkLlxuICAgKi9cbiAgYmFja2Ryb3BDbGljaygpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fYmFja2Ryb3BDbGljay5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuIHRoZSBvdmVybGF5IGhhcyBiZWVuIGF0dGFjaGVkLiAqL1xuICBhdHRhY2htZW50cygpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fYXR0YWNobWVudHMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKiogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC4gKi9cbiAgZGV0YWNobWVudHMoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGFjaG1lbnRzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgY29uZmlnIG9mIHRoZSBvdmVybGF5LlxuICAgKi9cbiAgZ2V0U3RhdGUoKTogT3ZlcmxheVN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xuICB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgdGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneS5hcHBseSh0aGlzLl9wYW5lKTtcbiAgICB9XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIHByaXZhdGUgdXBkYXRlRGlyZWN0aW9uKCkge1xuICAgIHRoaXMuX3BhbmUuc2V0QXR0cmlidXRlKCdkaXInLCB0aGlzLl9zdGF0ZS5kaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIG92ZXJsYXkgY29uZmlnLiAqL1xuICB1cGRhdGVTaXplKCkge1xuICAgIGlmICh0aGlzLl9zdGF0ZS53aWR0aCB8fCB0aGlzLl9zdGF0ZS53aWR0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcGFuZS5zdHlsZS53aWR0aCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUud2lkdGgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZS5oZWlnaHQgfHwgdGhpcy5fc3RhdGUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICB0aGlzLl9wYW5lLnN0eWxlLmhlaWdodCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUubWluV2lkdGggfHwgdGhpcy5fc3RhdGUubWluV2lkdGggPT09IDApIHtcbiAgICAgIHRoaXMuX3BhbmUuc3R5bGUubWluV2lkdGggPSBmb3JtYXRDc3NVbml0KHRoaXMuX3N0YXRlLm1pbldpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUubWluSGVpZ2h0IHx8IHRoaXMuX3N0YXRlLm1pbkhlaWdodCA9PT0gMCkge1xuICAgICAgdGhpcy5fcGFuZS5zdHlsZS5taW5IZWlnaHQgPSBmb3JtYXRDc3NVbml0KHRoaXMuX3N0YXRlLm1pbkhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRvZ2dsZXMgdGhlIHBvaW50ZXIgZXZlbnRzIGZvciB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQuICovXG4gIHByaXZhdGUgX3RvZ2dsZVBvaW50ZXJFdmVudHMoZW5hYmxlUG9pbnRlcjogYm9vbGVhbikge1xuICAgIHRoaXMuX3BhbmUuc3R5bGUucG9pbnRlckV2ZW50cyA9IGVuYWJsZVBvaW50ZXIgPyAnYXV0bycgOiAnbm9uZSc7XG4gIH1cblxuICAvKiogQXR0YWNoZXMgYSBiYWNrZHJvcCBmb3IgdGhpcyBvdmVybGF5LiAqL1xuICBwcml2YXRlIF9hdHRhY2hCYWNrZHJvcCgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktYmFja2Ryb3AnKTtcbiAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9zdGF0ZS5iYWNrZHJvcENsYXNzKTtcblxuICAgIC8vIEluc2VydCB0aGUgYmFja2Ryb3AgYmVmb3JlIHRoZSBwYW5lIGluIHRoZSBET00gb3JkZXIsXG4gICAgLy8gaW4gb3JkZXIgdG8gaGFuZGxlIHN0YWNrZWQgb3ZlcmxheXMgcHJvcGVybHkuXG4gICAgdGhpcy5fcGFuZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9iYWNrZHJvcEVsZW1lbnQsIHRoaXMuX3BhbmUpO1xuXG4gICAgLy8gRm9yd2FyZCBiYWNrZHJvcCBjbGlja3Mgc3VjaCB0aGF0IHRoZSBjb25zdW1lciBvZiB0aGUgb3ZlcmxheSBjYW4gcGVyZm9ybSB3aGF0ZXZlclxuICAgIC8vIGFjdGlvbiBkZXNpcmVkIHdoZW4gc3VjaCBhIGNsaWNrIG9jY3VycyAodXN1YWxseSBjbG9zaW5nIHRoZSBvdmVybGF5KS5cbiAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLl9iYWNrZHJvcENsaWNrLm5leHQobnVsbCkpO1xuXG4gICAgLy8gQWRkIGNsYXNzIHRvIGZhZGUtaW4gdGhlIGJhY2tkcm9wIGFmdGVyIG9uZSBmcmFtZS5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YWNraW5nIG9yZGVyIG9mIHRoZSBlbGVtZW50LCBtb3ZpbmcgaXQgdG8gdGhlIHRvcCBpZiBuZWNlc3NhcnkuXG4gICAqIFRoaXMgaXMgcmVxdWlyZWQgaW4gY2FzZXMgd2hlcmUgb25lIG92ZXJsYXkgd2FzIGRldGFjaGVkLCB3aGlsZSBhbm90aGVyIG9uZSxcbiAgICogdGhhdCBzaG91bGQgYmUgYmVoaW5kIGl0LCB3YXMgZGVzdHJveWVkLiBUaGUgbmV4dCB0aW1lIGJvdGggb2YgdGhlbSBhcmUgb3BlbmVkLFxuICAgKiB0aGUgc3RhY2tpbmcgd2lsbCBiZSB3cm9uZywgYmVjYXVzZSB0aGUgZGV0YWNoZWQgZWxlbWVudCdzIHBhbmUgd2lsbCBzdGlsbCBiZVxuICAgKiBpbiBpdHMgb3JpZ2luYWwgRE9NIHBvc2l0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfdXBkYXRlU3RhY2tpbmdPcmRlcigpIHtcbiAgICBpZiAodGhpcy5fcGFuZS5uZXh0U2libGluZykge1xuICAgICAgdGhpcy5fcGFuZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX3BhbmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEZXRhY2hlcyB0aGUgYmFja2Ryb3AgKGlmIGFueSkgYXNzb2NpYXRlZCB3aXRoIHRoZSBvdmVybGF5LiAqL1xuICBkZXRhY2hCYWNrZHJvcCgpOiB2b2lkIHtcbiAgICBsZXQgYmFja2Ryb3BUb0RldGFjaCA9IHRoaXMuX2JhY2tkcm9wRWxlbWVudDtcblxuICAgIGlmIChiYWNrZHJvcFRvRGV0YWNoKSB7XG4gICAgICBsZXQgZmluaXNoRGV0YWNoID0gKCkgPT4ge1xuICAgICAgICAvLyBJdCBtYXkgbm90IGJlIGF0dGFjaGVkIHRvIGFueXRoaW5nIGluIGNlcnRhaW4gY2FzZXMgKGUuZy4gdW5pdCB0ZXN0cykuXG4gICAgICAgIGlmIChiYWNrZHJvcFRvRGV0YWNoICYmIGJhY2tkcm9wVG9EZXRhY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZHJvcFRvRGV0YWNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSBuZXcgcG9ydGFsIGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoaXMgb3ZlcmxheSBzaW5jZSB3ZSBzdGFydGVkXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBiYWNrZHJvcC4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgb25seSBjbGVhciB0aGUgYmFja2Ryb3AgcmVmZXJlbmNlIGlmIGl0XG4gICAgICAgIC8vIGlzIHN0aWxsIHRoZSBzYW1lIGluc3RhbmNlIHRoYXQgd2Ugc3RhcnRlZCB0byByZW1vdmUuXG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPT0gYmFja2Ryb3BUb0RldGFjaCkge1xuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGJhY2tkcm9wVG9EZXRhY2guY2xhc3NMaXN0LnJlbW92ZSgnY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZycpO1xuICAgICAgYmFja2Ryb3BUb0RldGFjaC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX3N0YXRlLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgYmFja2Ryb3BUb0RldGFjaC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZmluaXNoRGV0YWNoKTtcblxuICAgICAgLy8gSWYgdGhlIGJhY2tkcm9wIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zaXRpb24sIHRoZSBgdHJhbnNpdGlvbmVuZGAgZXZlbnQgd29uJ3QgZmlyZS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBtYWtlIGl0IHVuY2xpY2thYmxlIGFuZCB3ZSB0cnkgdG8gcmVtb3ZlIGl0IGFmdGVyIGEgZGVsYXkuXG4gICAgICBiYWNrZHJvcFRvRGV0YWNoLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgIC8vIFJ1biB0aGlzIG91dHNpZGUgdGhlIEFuZ3VsYXIgem9uZSBiZWNhdXNlIHRoZXJlJ3Mgbm90aGluZyB0aGF0IEFuZ3VsYXIgY2FyZXMgYWJvdXQuXG4gICAgICAvLyBJZiBpdCB3ZXJlIHRvIHJ1biBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZSwgZXZlcnkgdGVzdCB0aGF0IHVzZWQgT3ZlcmxheSB3b3VsZCBoYXZlIHRvIGJlXG4gICAgICAvLyBlaXRoZXIgYXN5bmMgb3IgZmFrZUFzeW5jLlxuICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChmaW5pc2hEZXRhY2gsIDUwMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0Q3NzVW5pdCh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgYXMgc3RyaW5nIDogYCR7dmFsdWV9cHhgO1xufVxuIiwiLyoqIEhvcml6b250YWwgZGltZW5zaW9uIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgcGVyaW1ldGVyIG9mIHRoZSBvcmlnaW4gb3Igb3ZlcmxheSBlbGVtZW50LiAqL1xuaW1wb3J0IHtPcHRpb25hbH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5leHBvcnQgdHlwZSBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyA9ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnO1xuXG4vKiogVmVydGljYWwgZGltZW5zaW9uIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgcGVyaW1ldGVyIG9mIHRoZSBvcmlnaW4gb3Igb3ZlcmxheSBlbGVtZW50LiAqL1xuZXhwb3J0IHR5cGUgVmVydGljYWxDb25uZWN0aW9uUG9zID0gJ3RvcCcgfCAnY2VudGVyJyB8ICdib3R0b20nO1xuXG5cbi8qKiBBIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIG9yaWdpbiBlbGVtZW50LiAqL1xuZXhwb3J0IGludGVyZmFjZSBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24ge1xuICBvcmlnaW5YOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcztcbiAgb3JpZ2luWTogVmVydGljYWxDb25uZWN0aW9uUG9zO1xufVxuXG4vKiogQSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSBvdmVybGF5IGVsZW1lbnQuICovXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24ge1xuICBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3M7XG4gIG92ZXJsYXlZOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3M7XG59XG5cbi8qKiBUaGUgcG9pbnRzIG9mIHRoZSBvcmlnaW4gZWxlbWVudCBhbmQgdGhlIG92ZXJsYXkgZWxlbWVudCB0byBjb25uZWN0LiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIge1xuICBvcmlnaW5YOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvcztcbiAgb3JpZ2luWTogVmVydGljYWxDb25uZWN0aW9uUG9zO1xuICBvdmVybGF5WDogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3M7XG4gIG92ZXJsYXlZOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3M7XG5cbiAgY29uc3RydWN0b3Iob3JpZ2luOiBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sIG92ZXJsYXk6IE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm9yaWdpblggPSBvcmlnaW4ub3JpZ2luWDtcbiAgICB0aGlzLm9yaWdpblkgPSBvcmlnaW4ub3JpZ2luWTtcbiAgICB0aGlzLm92ZXJsYXlYID0gb3ZlcmxheS5vdmVybGF5WDtcbiAgICB0aGlzLm92ZXJsYXlZID0gb3ZlcmxheS5vdmVybGF5WTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBvZiBwcm9wZXJ0aWVzIHJlZ2FyZGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG9yaWdpbiBhbmQgb3ZlcmxheSByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAqIHdpdGggcmVzcGVjdCB0byB0aGUgY29udGFpbmluZyBTY3JvbGxhYmxlIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBvdmVybGF5IGFuZCBvcmlnaW4gYXJlIGNsaXBwZWQgaWYgYW55IHBhcnQgb2YgdGhlaXIgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZSBleGNlZWRzIHRoZVxuICogYm91bmRzIG9mIGFueSBvbmUgb2YgdGhlIHN0cmF0ZWd5J3MgU2Nyb2xsYWJsZSdzIGJvdW5kaW5nIGNsaWVudCByZWN0YW5nbGUuXG4gKlxuICogVGhlIG92ZXJsYXkgYW5kIG9yaWdpbiBhcmUgb3V0c2lkZSB2aWV3IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiB0aGVpciBib3VuZGluZyBjbGllbnRcbiAqIHJlY3RhbmdsZSBhbmQgYW55IG9uZSBvZiB0aGUgc3RyYXRlZ3kncyBTY3JvbGxhYmxlJ3MgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZS5cbiAqXG4gKiAgICAgICAtLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS1cbiAqICAgICAgIHwgb3V0c2lkZSB8ICAgICAgICAgICAgICAgICAgICB8IGNsaXBwZWQgfFxuICogICAgICAgfCAgdmlldyAgIHwgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgICAgICB8ICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfCAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgIC0tLS0tLS0tLS0gICAgICAgICAgICAgICB8ICAgICAtLS0tLS0tLS0tLSAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfCAgICAgIFNjcm9sbGFibGUgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICBTY3JvbGxhYmxlICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5leHBvcnQgY2xhc3MgU2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzIHtcbiAgaXNPcmlnaW5DbGlwcGVkOiBib29sZWFuO1xuICBpc09yaWdpbk91dHNpZGVWaWV3OiBib29sZWFuO1xuICBpc092ZXJsYXlDbGlwcGVkOiBib29sZWFuO1xuICBpc092ZXJsYXlPdXRzaWRlVmlldzogYm9vbGVhbjtcbn1cblxuLyoqIFRoZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSB0aGUgc3RyYXRlZ3kgd2hlbiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbm5lY3Rpb25QYWlyOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwdWJsaWMgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzOiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMpIHt9XG59XG4iLCJpbXBvcnQge1Bvc2l0aW9uU3RyYXRlZ3l9IGZyb20gJy4vcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHtFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Vmlld3BvcnRSdWxlcn0gZnJvbSAnLi92aWV3cG9ydC1ydWxlcic7XG5pbXBvcnQge1xuICBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sXG4gIE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24sXG4gIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSwgU2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzXG59IGZyb20gJy4vY29ubmVjdGVkLXBvc2l0aW9uJztcbmltcG9ydCB7U3ViamVjdCwgT2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1Njcm9sbGFibGV9IGZyb20gJy4uL3Njcm9sbC9zY3JvbGxhYmxlJztcblxuLyoqXG4gKiBDb250YWluZXIgdG8gaG9sZCB0aGUgYm91bmRpbmcgcG9zaXRpb25zIG9mIGEgcGFydGljdWxhciBlbGVtZW50IHdpdGggcmVzcGVjdCB0byB0aGUgdmlld3BvcnQsXG4gKiB3aGVyZSB0b3AgYW5kIGJvdHRvbSBhcmUgdGhlIHktYXhpcyBjb29yZGluYXRlcyBvZiB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGFuZCBsZWZ0IGFuZCByaWdodCBhcmVcbiAqIHRoZSB4LWF4aXMgY29vcmRpbmF0ZXMuXG4gKi9cbnR5cGUgRWxlbWVudEJvdW5kaW5nUG9zaXRpb25zID0ge1xuICB0b3A6IG51bWJlcjtcbiAgcmlnaHQ6IG51bWJlcjtcbiAgYm90dG9tOiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbn07XG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgcG9zaXRpb25pbmcgb3ZlcmxheXMuIFVzaW5nIHRoaXMgc3RyYXRlZ3ksIGFuIG92ZXJsYXkgaXMgZ2l2ZW4gYW5cbiAqIGltcGxpY2l0IHBvc2l0aW9uIHJlbGF0aXZlIHNvbWUgb3JpZ2luIGVsZW1lbnQuIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gKiBhIHBvaW50IG9uIHRoZSBvcmlnaW4gZWxlbWVudCB0aGF0IGlzIGNvbm5lY3RlZCB0byBhIHBvaW50IG9uIHRoZSBvdmVybGF5IGVsZW1lbnQuIEZvciBleGFtcGxlLFxuICogYSBiYXNpYyBkcm9wZG93biBpcyBjb25uZWN0aW5nIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIG9yaWdpbiB0byB0aGUgdG9wLWxlZnQgY29ybmVyXG4gKiBvZiB0aGUgb3ZlcmxheS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgaW1wbGVtZW50cyBQb3NpdGlvblN0cmF0ZWd5IHtcbiAgcHJpdmF0ZSBfZGlyID0gJ2x0cic7XG5cbiAgLyoqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB4LWF4aXMgKi9cbiAgcHJpdmF0ZSBfb2Zmc2V0WDogbnVtYmVyID0gMDtcblxuICAvKiogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHktYXhpcyAqL1xuICBwcml2YXRlIF9vZmZzZXRZOiBudW1iZXIgPSAwO1xuXG4gIC8qKiBUaGUgU2Nyb2xsYWJsZSBjb250YWluZXJzIHVzZWQgdG8gY2hlY2sgc2Nyb2xsYWJsZSB2aWV3IHByb3BlcnRpZXMgb24gcG9zaXRpb24gY2hhbmdlLiAqL1xuICBwcml2YXRlIHNjcm9sbGFibGVzOiBTY3JvbGxhYmxlW10gPSBbXTtcblxuICAvKiogV2hldGhlciB0aGUgd2UncmUgZGVhbGluZyB3aXRoIGFuIFJUTCBjb250ZXh0ICovXG4gIGdldCBfaXNSdGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpciA9PT0gJ3J0bCc7XG4gIH1cblxuICAvKiogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuICovXG4gIF9wcmVmZXJyZWRQb3NpdGlvbnM6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuXG4gIC8qKiBUaGUgb3JpZ2luIGVsZW1lbnQgYWdhaW5zdCB3aGljaCB0aGUgb3ZlcmxheSB3aWxsIGJlIHBvc2l0aW9uZWQuICovXG4gIHByaXZhdGUgX29yaWdpbjogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFRoZSBvdmVybGF5IHBhbmUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfcGFuZTogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFRoZSBsYXN0IHBvc2l0aW9uIHRvIGhhdmUgYmVlbiBjYWxjdWxhdGVkIGFzIHRoZSBiZXN0IGZpdCBwb3NpdGlvbi4gKi9cbiAgcHJpdmF0ZSBfbGFzdENvbm5lY3RlZFBvc2l0aW9uOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyO1xuXG4gIF9vblBvc2l0aW9uQ2hhbmdlOlxuICAgICAgU3ViamVjdDxDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2U+ID0gbmV3IFN1YmplY3Q8Q29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlPigpO1xuXG4gIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBjb25uZWN0aW9uIHBvaW50IGNoYW5nZXMuICovXG4gIGdldCBvblBvc2l0aW9uQ2hhbmdlKCk6IE9ic2VydmFibGU8Q29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlPiB7XG4gICAgcmV0dXJuIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2Nvbm5lY3RlZFRvOiBFbGVtZW50UmVmLFxuICAgICAgcHJpdmF0ZSBfb3JpZ2luUG9zOiBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sXG4gICAgICBwcml2YXRlIF9vdmVybGF5UG9zOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uLFxuICAgICAgcHJpdmF0ZSBfdmlld3BvcnRSdWxlcjogVmlld3BvcnRSdWxlcikge1xuICAgIHRoaXMuX29yaWdpbiA9IHRoaXMuX2Nvbm5lY3RlZFRvLm5hdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy53aXRoRmFsbGJhY2tQb3NpdGlvbihfb3JpZ2luUG9zLCBfb3ZlcmxheVBvcyk7XG4gIH1cblxuICAvKiogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuICovXG4gIGdldCBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBUbyBiZSB1c2VkIHRvIGZvciBhbnkgY2xlYW51cCBhZnRlciB0aGUgZWxlbWVudCBnZXRzIGRlc3Ryb3llZC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7IH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgZWxlbWVudCwgdXNpbmcgd2hpY2hldmVyIHByZWZlcnJlZCBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiB0byB0aGUgb3JpZ2luIGZpdHMgb24tc2NyZWVuLlxuICAgKiBAZG9jcy1wcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gd2hpY2ggdG8gYXBwbHkgdGhlIENTUyBzdHlsZXMuXG4gICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdGhlIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICovXG4gIGFwcGx5KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gQ2FjaGUgdGhlIG92ZXJsYXkgcGFuZSBlbGVtZW50IGluIGNhc2UgcmUtY2FsY3VsYXRpbmcgcG9zaXRpb24gaXMgbmVjZXNzYXJ5XG4gICAgdGhpcy5fcGFuZSA9IGVsZW1lbnQ7XG5cbiAgICAvLyBXZSBuZWVkIHRoZSBib3VuZGluZyByZWN0cyBmb3IgdGhlIG9yaWdpbiBhbmQgdGhlIG92ZXJsYXkgdG8gZGV0ZXJtaW5lIGhvdyB0byBwb3NpdGlvblxuICAgIC8vIHRoZSBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4uXG4gICAgY29uc3Qgb3JpZ2luUmVjdCA9IHRoaXMuX29yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBvdmVybGF5UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyBXZSB1c2UgdGhlIHZpZXdwb3J0IHJlY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwb3NpdGlvbiB3b3VsZCBnbyBvZmYtc2NyZWVuLlxuICAgIGNvbnN0IHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG5cbiAgICAvLyBGYWxsYmFjayBwb2ludCBpZiBub25lIG9mIHRoZSBmYWxsYmFja3MgZml0IGludG8gdGhlIHZpZXdwb3J0LlxuICAgIGxldCBmYWxsYmFja1BvaW50OiBPdmVybGF5UG9pbnQgPSBudWxsO1xuICAgIGxldCBmYWxsYmFja1Bvc2l0aW9uOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyID0gbnVsbDtcblxuICAgIC8vIFdlIHdhbnQgdG8gcGxhY2UgdGhlIG92ZXJsYXkgaW4gdGhlIGZpcnN0IG9mIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zIHN1Y2ggdGhhdCB0aGVcbiAgICAvLyBvdmVybGF5IGZpdHMgb24tc2NyZWVuLlxuICAgIGZvciAobGV0IHBvcyBvZiB0aGlzLl9wcmVmZXJyZWRQb3NpdGlvbnMpIHtcbiAgICAgIC8vIEdldCB0aGUgKHgsIHkpIHBvaW50IG9mIGNvbm5lY3Rpb24gb24gdGhlIG9yaWdpbiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gZ2V0IHRoZVxuICAgICAgLy8gKHRvcCwgbGVmdCkgY29vcmRpbmF0ZSBmb3IgdGhlIG92ZXJsYXkgYXQgYHBvc2AuXG4gICAgICBsZXQgb3JpZ2luUG9pbnQgPSB0aGlzLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdCwgcG9zKTtcbiAgICAgIGxldCBvdmVybGF5UG9pbnQgPSB0aGlzLl9nZXRPdmVybGF5UG9pbnQob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIHBvcyk7XG5cbiAgICAgIC8vIElmIHRoZSBvdmVybGF5IGluIHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uIGZpdHMgb24tc2NyZWVuLCBwdXQgaXQgdGhlcmUgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAob3ZlcmxheVBvaW50LmZpdHNJblZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvdmVybGF5UmVjdCwgb3ZlcmxheVBvaW50LCBwb3MpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgY29ubmVjdGVkIHBvc2l0aW9uIGluIGNhc2UgdGhlIHBvc2l0aW9uIG5lZWRzIHRvIGJlIHJlLWNhbGN1bGF0ZWQuXG4gICAgICAgIHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbiA9IHBvcztcblxuICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgcG9zaXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhbG9uZyB3aXRoIGl0cyBjaGFuZ2UgcHJvcGVydGllcy5cbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gdGhpcy5nZXRTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0gbmV3IENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZShwb3MsIHNjcm9sbGFibGVWaWV3UHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UubmV4dChwb3NpdGlvbkNoYW5nZSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZhbGxiYWNrUG9pbnQgfHwgZmFsbGJhY2tQb2ludC52aXNpYmxlQXJlYSA8IG92ZXJsYXlQb2ludC52aXNpYmxlQXJlYSkge1xuICAgICAgICBmYWxsYmFja1BvaW50ID0gb3ZlcmxheVBvaW50O1xuICAgICAgICBmYWxsYmFja1Bvc2l0aW9uID0gcG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vbmUgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgd2VyZSBpbiB0aGUgdmlld3BvcnQsIHRha2UgdGhlIG9uZVxuICAgIC8vIHdpdGggdGhlIGxhcmdlc3QgdmlzaWJsZSBhcmVhLlxuICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvdmVybGF5UmVjdCwgZmFsbGJhY2tQb2ludCwgZmFsbGJhY2tQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgcmUtYWxpZ25zIHRoZSBvdmVybGF5IGVsZW1lbnQgd2l0aCB0aGUgdHJpZ2dlciBpbiBpdHMgbGFzdCBjYWxjdWxhdGVkIHBvc2l0aW9uLFxuICAgKiBldmVuIGlmIGEgcG9zaXRpb24gaGlnaGVyIGluIHRoZSBcInByZWZlcnJlZCBwb3NpdGlvbnNcIiBsaXN0IHdvdWxkIG5vdyBmaXQuIFRoaXNcbiAgICogYWxsb3dzIG9uZSB0byByZS1hbGlnbiB0aGUgcGFuZWwgd2l0aG91dCBjaGFuZ2luZyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBhbmVsLlxuICAgKi9cbiAgcmVjYWxjdWxhdGVMYXN0UG9zaXRpb24oKTogdm9pZCB7XG4gICAgY29uc3Qgb3JpZ2luUmVjdCA9IHRoaXMuX29yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBvdmVybGF5UmVjdCA9IHRoaXMuX3BhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgdmlld3BvcnRSZWN0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICBjb25zdCBsYXN0UG9zaXRpb24gPSB0aGlzLl9sYXN0Q29ubmVjdGVkUG9zaXRpb24gfHwgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zWzBdO1xuXG4gICAgbGV0IG9yaWdpblBvaW50ID0gdGhpcy5fZ2V0T3JpZ2luQ29ubmVjdGlvblBvaW50KG9yaWdpblJlY3QsIGxhc3RQb3NpdGlvbik7XG4gICAgbGV0IG92ZXJsYXlQb2ludCA9IHRoaXMuX2dldE92ZXJsYXlQb2ludChvcmlnaW5Qb2ludCwgb3ZlcmxheVJlY3QsIHZpZXdwb3J0UmVjdCwgbGFzdFBvc2l0aW9uKTtcbiAgICB0aGlzLl9zZXRFbGVtZW50UG9zaXRpb24odGhpcy5fcGFuZSwgb3ZlcmxheVJlY3QsIG92ZXJsYXlQb2ludCwgbGFzdFBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IG9mIFNjcm9sbGFibGUgY29udGFpbmVycyB0aGF0IGhvc3QgdGhlIG9yaWdpbiBlbGVtZW50IHNvIHRoYXRcbiAgICogb24gcmVwb3NpdGlvbiB3ZSBjYW4gZXZhbHVhdGUgaWYgaXQgb3IgdGhlIG92ZXJsYXkgaGFzIGJlZW4gY2xpcHBlZCBvciBvdXRzaWRlIHZpZXcuIEV2ZXJ5XG4gICAqIFNjcm9sbGFibGUgbXVzdCBiZSBhbiBhbmNlc3RvciBlbGVtZW50IG9mIHRoZSBzdHJhdGVneSdzIG9yaWdpbiBlbGVtZW50LlxuICAgKi9cbiAgd2l0aFNjcm9sbGFibGVDb250YWluZXJzKHNjcm9sbGFibGVzOiBTY3JvbGxhYmxlW10pIHtcbiAgICB0aGlzLnNjcm9sbGFibGVzID0gc2Nyb2xsYWJsZXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwcmVmZXJyZWQgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAqIEBwYXJhbSBvcmlnaW5Qb3NcbiAgICogQHBhcmFtIG92ZXJsYXlQb3NcbiAgICovXG4gIHdpdGhGYWxsYmFja1Bvc2l0aW9uKFxuICAgICAgb3JpZ2luUG9zOiBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sXG4gICAgICBvdmVybGF5UG9zOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uKTogdGhpcyB7XG4gICAgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zLnB1c2gobmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIob3JpZ2luUG9zLCBvdmVybGF5UG9zKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5b3V0IGRpcmVjdGlvbiBzbyB0aGUgb3ZlcmxheSdzIHBvc2l0aW9uIGNhbiBiZSBhZGp1c3RlZCB0byBtYXRjaC5cbiAgICogQHBhcmFtIGRpciBOZXcgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICovXG4gIHdpdGhEaXJlY3Rpb24oZGlyOiAnbHRyJyB8ICdydGwnKTogdGhpcyB7XG4gICAgdGhpcy5fZGlyID0gZGlyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gb2Zmc2V0IGZvciB0aGUgb3ZlcmxheSdzIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpc1xuICAgKiBAcGFyYW0gb2Zmc2V0IE5ldyBvZmZzZXQgaW4gdGhlIFggYXhpcy5cbiAgICovXG4gIHdpdGhPZmZzZXRYKG9mZnNldDogbnVtYmVyKTogdGhpcyB7XG4gICAgdGhpcy5fb2Zmc2V0WCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIG9mZnNldCBmb3IgdGhlIG92ZXJsYXkncyBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXNcbiAgICogQHBhcmFtICBvZmZzZXQgTmV3IG9mZnNldCBpbiB0aGUgWSBheGlzLlxuICAgKi9cbiAgd2l0aE9mZnNldFkob2Zmc2V0OiBudW1iZXIpOiB0aGlzIHtcbiAgICB0aGlzLl9vZmZzZXRZID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwic3RhcnRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHJlY3RcbiAgICovXG4gIHByaXZhdGUgX2dldFN0YXJ0WChyZWN0OiBDbGllbnRSZWN0KTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5faXNSdGwgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwiZW5kXCIgZGltZW5zaW9uIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgaW4gYW4gUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSByZWN0XG4gICAqL1xuICBwcml2YXRlIF9nZXRFbmRYKHJlY3Q6IENsaWVudFJlY3QpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9pc1J0bCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSAoeCwgeSkgY29vcmRpbmF0ZSBvZiBhIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIG9yaWdpbiBiYXNlZCBvbiBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gb3JpZ2luUmVjdFxuICAgKiBAcGFyYW0gcG9zXG4gICAqL1xuICBwcml2YXRlIF9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdDogQ2xpZW50UmVjdCwgcG9zOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKTogUG9pbnQge1xuICAgIGNvbnN0IG9yaWdpblN0YXJ0WCA9IHRoaXMuX2dldFN0YXJ0WChvcmlnaW5SZWN0KTtcbiAgICBjb25zdCBvcmlnaW5FbmRYID0gdGhpcy5fZ2V0RW5kWChvcmlnaW5SZWN0KTtcblxuICAgIGxldCB4OiBudW1iZXI7XG4gICAgaWYgKHBvcy5vcmlnaW5YID09ICdjZW50ZXInKSB7XG4gICAgICB4ID0gb3JpZ2luU3RhcnRYICsgKG9yaWdpblJlY3Qud2lkdGggLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBvcy5vcmlnaW5YID09ICdzdGFydCcgPyBvcmlnaW5TdGFydFggOiBvcmlnaW5FbmRYO1xuICAgIH1cblxuICAgIGxldCB5OiBudW1iZXI7XG4gICAgaWYgKHBvcy5vcmlnaW5ZID09ICdjZW50ZXInKSB7XG4gICAgICB5ID0gb3JpZ2luUmVjdC50b3AgKyAob3JpZ2luUmVjdC5oZWlnaHQgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IHBvcy5vcmlnaW5ZID09ICd0b3AnID8gb3JpZ2luUmVjdC50b3AgOiBvcmlnaW5SZWN0LmJvdHRvbTtcbiAgICB9XG5cbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgKHgsIHkpIGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgb3ZlcmxheSBnaXZlbiBhIGdpdmVuIHBvc2l0aW9uIGFuZFxuICAgKiBvcmlnaW4gcG9pbnQgdG8gd2hpY2ggdGhlIG92ZXJsYXkgc2hvdWxkIGJlIGNvbm5lY3RlZCwgYXMgd2VsbCBhcyBob3cgbXVjaCBvZiB0aGUgZWxlbWVudFxuICAgKiB3b3VsZCBiZSBpbnNpZGUgdGhlIHZpZXdwb3J0IGF0IHRoYXQgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9nZXRPdmVybGF5UG9pbnQoXG4gICAgICBvcmlnaW5Qb2ludDogUG9pbnQsXG4gICAgICBvdmVybGF5UmVjdDogQ2xpZW50UmVjdCxcbiAgICAgIHZpZXdwb3J0UmVjdDogQ2xpZW50UmVjdCxcbiAgICAgIHBvczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcik6IE92ZXJsYXlQb2ludCB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSAob3ZlcmxheVN0YXJ0WCwgb3ZlcmxheVN0YXJ0WSksIHRoZSBzdGFydCBvZiB0aGUgcG90ZW50aWFsIG92ZXJsYXkgcG9zaXRpb25cbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgb3JpZ2luIHBvaW50LlxuICAgIGxldCBvdmVybGF5U3RhcnRYOiBudW1iZXI7XG4gICAgaWYgKHBvcy5vdmVybGF5WCA9PSAnY2VudGVyJykge1xuICAgICAgb3ZlcmxheVN0YXJ0WCA9IC1vdmVybGF5UmVjdC53aWR0aCAvIDI7XG4gICAgfSBlbHNlIGlmIChwb3Mub3ZlcmxheVggPT09ICdzdGFydCcpIHtcbiAgICAgIG92ZXJsYXlTdGFydFggPSB0aGlzLl9pc1J0bCA/IC1vdmVybGF5UmVjdC53aWR0aCA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJsYXlTdGFydFggPSB0aGlzLl9pc1J0bCA/IDAgOiAtb3ZlcmxheVJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgbGV0IG92ZXJsYXlTdGFydFk6IG51bWJlcjtcbiAgICBpZiAocG9zLm92ZXJsYXlZID09ICdjZW50ZXInKSB7XG4gICAgICBvdmVybGF5U3RhcnRZID0gLW92ZXJsYXlSZWN0LmhlaWdodCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJsYXlTdGFydFkgPSBwb3Mub3ZlcmxheVkgPT0gJ3RvcCcgPyAwIDogLW92ZXJsYXlSZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBUaGUgKHgsIHkpIGNvb3JkaW5hdGVzIG9mIHRoZSBvdmVybGF5LlxuICAgIGxldCB4ID0gb3JpZ2luUG9pbnQueCArIG92ZXJsYXlTdGFydFggKyB0aGlzLl9vZmZzZXRYO1xuICAgIGxldCB5ID0gb3JpZ2luUG9pbnQueSArIG92ZXJsYXlTdGFydFkgKyB0aGlzLl9vZmZzZXRZO1xuXG4gICAgLy8gSG93IG11Y2ggdGhlIG92ZXJsYXkgd291bGQgb3ZlcmZsb3cgYXQgdGhpcyBwb3NpdGlvbiwgb24gZWFjaCBzaWRlLlxuICAgIGxldCBsZWZ0T3ZlcmZsb3cgPSAwIC0geDtcbiAgICBsZXQgcmlnaHRPdmVyZmxvdyA9ICh4ICsgb3ZlcmxheVJlY3Qud2lkdGgpIC0gdmlld3BvcnRSZWN0LndpZHRoO1xuICAgIGxldCB0b3BPdmVyZmxvdyA9IDAgLSB5O1xuICAgIGxldCBib3R0b21PdmVyZmxvdyA9ICh5ICsgb3ZlcmxheVJlY3QuaGVpZ2h0KSAtIHZpZXdwb3J0UmVjdC5oZWlnaHQ7XG5cbiAgICAvLyBWaXNpYmxlIHBhcnRzIG9mIHRoZSBlbGVtZW50IG9uIGVhY2ggYXhpcy5cbiAgICBsZXQgdmlzaWJsZVdpZHRoID0gdGhpcy5fc3VidHJhY3RPdmVyZmxvd3Mob3ZlcmxheVJlY3Qud2lkdGgsIGxlZnRPdmVyZmxvdywgcmlnaHRPdmVyZmxvdyk7XG4gICAgbGV0IHZpc2libGVIZWlnaHQgPSB0aGlzLl9zdWJ0cmFjdE92ZXJmbG93cyhvdmVybGF5UmVjdC5oZWlnaHQsIHRvcE92ZXJmbG93LCBib3R0b21PdmVyZmxvdyk7XG5cbiAgICAvLyBUaGUgYXJlYSBvZiB0aGUgZWxlbWVudCB0aGF0J3Mgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICBsZXQgdmlzaWJsZUFyZWEgPSB2aXNpYmxlV2lkdGggKiB2aXNpYmxlSGVpZ2h0O1xuICAgIGxldCBmaXRzSW5WaWV3cG9ydCA9IChvdmVybGF5UmVjdC53aWR0aCAqIG92ZXJsYXlSZWN0LmhlaWdodCkgPT09IHZpc2libGVBcmVhO1xuXG4gICAgcmV0dXJuIHt4LCB5LCBmaXRzSW5WaWV3cG9ydCwgdmlzaWJsZUFyZWF9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZpZXcgcHJvcGVydGllcyBvZiB0aGUgdHJpZ2dlciBhbmQgb3ZlcmxheSwgaW5jbHVkaW5nIHdoZXRoZXIgdGhleSBhcmUgY2xpcHBlZFxuICAgKiBvciBjb21wbGV0ZWx5IG91dHNpZGUgdGhlIHZpZXcgb2YgYW55IG9mIHRoZSBzdHJhdGVneSdzIHNjcm9sbGFibGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMob3ZlcmxheTogSFRNTEVsZW1lbnQpOiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMge1xuICAgIGNvbnN0IG9yaWdpbkJvdW5kcyA9IHRoaXMuX2dldEVsZW1lbnRCb3VuZHModGhpcy5fb3JpZ2luKTtcbiAgICBjb25zdCBvdmVybGF5Qm91bmRzID0gdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyhvdmVybGF5KTtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJCb3VuZHMgPSB0aGlzLnNjcm9sbGFibGVzLm1hcCgoc2Nyb2xsYWJsZTogU2Nyb2xsYWJsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEVsZW1lbnRCb3VuZHMoc2Nyb2xsYWJsZS5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNPcmlnaW5DbGlwcGVkOiB0aGlzLmlzRWxlbWVudENsaXBwZWQob3JpZ2luQm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgaXNPcmlnaW5PdXRzaWRlVmlldzogdGhpcy5pc0VsZW1lbnRPdXRzaWRlVmlldyhvcmlnaW5Cb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICBpc092ZXJsYXlDbGlwcGVkOiB0aGlzLmlzRWxlbWVudENsaXBwZWQob3ZlcmxheUJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgIGlzT3ZlcmxheU91dHNpZGVWaWV3OiB0aGlzLmlzRWxlbWVudE91dHNpZGVWaWV3KG92ZXJsYXlCb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGNvbXBsZXRlbHkgb3V0IG9mIHRoZSB2aWV3IG9mIGFueSBvZiB0aGUgY29udGFpbmVycy4gKi9cbiAgcHJpdmF0ZSBpc0VsZW1lbnRPdXRzaWRlVmlldyhcbiAgICAgIGVsZW1lbnRCb3VuZHM6IEVsZW1lbnRCb3VuZGluZ1Bvc2l0aW9ucyxcbiAgICAgIGNvbnRhaW5lcnNCb3VuZHM6IEVsZW1lbnRCb3VuZGluZ1Bvc2l0aW9uc1tdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcnNCb3VuZHMuc29tZSgoY29udGFpbmVyQm91bmRzOiBFbGVtZW50Qm91bmRpbmdQb3NpdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IG91dHNpZGVBYm92ZSA9IGVsZW1lbnRCb3VuZHMuYm90dG9tIDwgY29udGFpbmVyQm91bmRzLnRvcDtcbiAgICAgIGNvbnN0IG91dHNpZGVCZWxvdyA9IGVsZW1lbnRCb3VuZHMudG9wID4gY29udGFpbmVyQm91bmRzLmJvdHRvbTtcbiAgICAgIGNvbnN0IG91dHNpZGVMZWZ0ID0gZWxlbWVudEJvdW5kcy5yaWdodCA8IGNvbnRhaW5lckJvdW5kcy5sZWZ0O1xuICAgICAgY29uc3Qgb3V0c2lkZVJpZ2h0ID0gZWxlbWVudEJvdW5kcy5sZWZ0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0O1xuXG4gICAgICByZXR1cm4gb3V0c2lkZUFib3ZlIHx8IG91dHNpZGVCZWxvdyB8fCBvdXRzaWRlTGVmdCB8fCBvdXRzaWRlUmlnaHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyBjbGlwcGVkIGJ5IGFueSBvZiB0aGUgY29udGFpbmVycy4gKi9cbiAgcHJpdmF0ZSBpc0VsZW1lbnRDbGlwcGVkKFxuICAgICAgZWxlbWVudEJvdW5kczogRWxlbWVudEJvdW5kaW5nUG9zaXRpb25zLFxuICAgICAgY29udGFpbmVyc0JvdW5kczogRWxlbWVudEJvdW5kaW5nUG9zaXRpb25zW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gY29udGFpbmVyc0JvdW5kcy5zb21lKChjb250YWluZXJCb3VuZHM6IEVsZW1lbnRCb3VuZGluZ1Bvc2l0aW9ucykgPT4ge1xuICAgICAgY29uc3QgY2xpcHBlZEFib3ZlID0gZWxlbWVudEJvdW5kcy50b3AgPCBjb250YWluZXJCb3VuZHMudG9wO1xuICAgICAgY29uc3QgY2xpcHBlZEJlbG93ID0gZWxlbWVudEJvdW5kcy5ib3R0b20gPiBjb250YWluZXJCb3VuZHMuYm90dG9tO1xuICAgICAgY29uc3QgY2xpcHBlZExlZnQgPSBlbGVtZW50Qm91bmRzLmxlZnQgPCBjb250YWluZXJCb3VuZHMubGVmdDtcbiAgICAgIGNvbnN0IGNsaXBwZWRSaWdodCA9IGVsZW1lbnRCb3VuZHMucmlnaHQgPiBjb250YWluZXJCb3VuZHMucmlnaHQ7XG5cbiAgICAgIHJldHVybiBjbGlwcGVkQWJvdmUgfHwgY2xpcHBlZEJlbG93IHx8IGNsaXBwZWRMZWZ0IHx8IGNsaXBwZWRSaWdodDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBQaHlzaWNhbGx5IHBvc2l0aW9ucyB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlLiAqL1xuICBwcml2YXRlIF9zZXRFbGVtZW50UG9zaXRpb24oXG4gICAgICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICAgIG92ZXJsYXlSZWN0OiBDbGllbnRSZWN0LFxuICAgICAgb3ZlcmxheVBvaW50OiBQb2ludCxcbiAgICAgIHBvczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuXG4gICAgLy8gV2Ugd2FudCB0byBzZXQgZWl0aGVyIGB0b3BgIG9yIGBib3R0b21gIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgd2FudHMgdG8gYXBwZWFyIGFib3ZlXG4gICAgLy8gb3IgYmVsb3cgdGhlIG9yaWdpbiBhbmQgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGV4cGFuZC5cbiAgICBsZXQgdmVydGljYWxTdHlsZVByb3BlcnR5OiBhbnkgPSBwb3Mub3ZlcmxheVkgPT09ICdib3R0b20nID8gJ2JvdHRvbScgOiAndG9wJztcblxuICAgIC8vIFdoZW4gdXNpbmcgYGJvdHRvbWAsIHdlIGFkanVzdCB0aGUgeSBwb3NpdGlvbiBzdWNoIHRoYXQgaXQgaXMgdGhlIGRpc3RhbmNlXG4gICAgLy8gZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydCByYXRoZXIgdGhhbiB0aGUgdG9wLlxuICAgIGxldCB5ID0gdmVydGljYWxTdHlsZVByb3BlcnR5ID09PSAndG9wJyA/XG4gICAgICAgIG92ZXJsYXlQb2ludC55IDpcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIChvdmVybGF5UG9pbnQueSArIG92ZXJsYXlSZWN0LmhlaWdodCk7XG5cbiAgICAvLyBXZSB3YW50IHRvIHNldCBlaXRoZXIgYGxlZnRgIG9yIGByaWdodGAgYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSB3YW50cyB0byBhcHBlYXIgXCJiZWZvcmVcIlxuICAgIC8vIG9yIFwiYWZ0ZXJcIiB0aGUgb3JpZ2luLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBleHBhbmQuXG4gICAgLy8gRm9yIHRoZSBob3Jpem9udGFsIGF4aXMsIHRoZSBtZWFuaW5nIG9mIFwiYmVmb3JlXCIgYW5kIFwiYWZ0ZXJcIiBjaGFuZ2UgYmFzZWQgb24gd2hldGhlciB0aGVcbiAgICAvLyBwYWdlIGlzIGluIFJUTCBvciBMVFIuXG4gICAgbGV0IGhvcml6b250YWxTdHlsZVByb3BlcnR5OiBhbnk7XG4gICAgaWYgKHRoaXMuX2RpciA9PT0gJ3J0bCcpIHtcbiAgICAgIGhvcml6b250YWxTdHlsZVByb3BlcnR5ID0gcG9zLm92ZXJsYXlYID09PSAnZW5kJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvcml6b250YWxTdHlsZVByb3BlcnR5ID0gcG9zLm92ZXJsYXlYID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB3ZSdyZSBzZXR0aW5nIGByaWdodGAsIHdlIGFkanVzdCB0aGUgeCBwb3NpdGlvbiBzdWNoIHRoYXQgaXQgaXMgdGhlIGRpc3RhbmNlXG4gICAgLy8gZnJvbSB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQgcmF0aGVyIHRoYW4gdGhlIGxlZnQgZWRnZS5cbiAgICBsZXQgeCA9IGhvcml6b250YWxTdHlsZVByb3BlcnR5ID09PSAnbGVmdCcgP1xuICAgICAgb3ZlcmxheVBvaW50LnggOlxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gKG92ZXJsYXlQb2ludC54ICsgb3ZlcmxheVJlY3Qud2lkdGgpO1xuXG5cbiAgICAvLyBSZXNldCBhbnkgZXhpc3Rpbmcgc3R5bGVzLiBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBjYXNlIHRoZSBwcmVmZXJyZWQgcG9zaXRpb24gaGFzXG4gICAgLy8gY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgYXBwbHlgLlxuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaCgocDogYW55KSA9PiBlbGVtZW50LnN0eWxlW3BdID0gbnVsbCk7XG5cbiAgICBlbGVtZW50LnN0eWxlW3ZlcnRpY2FsU3R5bGVQcm9wZXJ0eV0gPSBgJHt5fXB4YDtcbiAgICBlbGVtZW50LnN0eWxlW2hvcml6b250YWxTdHlsZVByb3BlcnR5XSA9IGAke3h9cHhgO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGJvdW5kaW5nIHBvc2l0aW9ucyBvZiB0aGUgcHJvdmlkZWQgZWxlbWVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIHZpZXdwb3J0LiAqL1xuICBwcml2YXRlIF9nZXRFbGVtZW50Qm91bmRzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogRWxlbWVudEJvdW5kaW5nUG9zaXRpb25zIHtcbiAgICBjb25zdCBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AsXG4gICAgICByaWdodDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgKyBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGgsXG4gICAgICBib3R0b206IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgbGVmdDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyB0aGUgYW1vdW50IHRoYXQgYW4gZWxlbWVudCBpcyBvdmVyZmxvd2luZyBvbiBhbiBheGlzIGZyb20gaXQncyBsZW5ndGguXG4gICAqL1xuICBwcml2YXRlIF9zdWJ0cmFjdE92ZXJmbG93cyhsZW5ndGg6IG51bWJlciwgLi4ub3ZlcmZsb3dzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIG92ZXJmbG93cy5yZWR1Y2UoKGN1cnJlbnRWYWx1ZTogbnVtYmVyLCBjdXJyZW50T3ZlcmZsb3c6IG51bWJlcikgPT4ge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSAtIE1hdGgubWF4KGN1cnJlbnRPdmVyZmxvdywgMCk7XG4gICAgfSwgbGVuZ3RoKTtcbiAgfVxufVxuXG4vKiogQSBzaW1wbGUgKHgsIHkpIGNvb3JkaW5hdGUuICovXG5pbnRlcmZhY2UgUG9pbnQge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBFeHBhbmRzIHRoZSBzaW1wbGUgKHgsIHkpIGNvb3JkaW5hdGUgYnkgYWRkaW5nIGluZm8gYWJvdXQgd2hldGhlciB0aGVcbiAqIGVsZW1lbnQgd291bGQgZml0IGluc2lkZSB0aGUgdmlld3BvcnQgYXQgdGhhdCBwb3NpdGlvbiwgYXMgd2VsbCBhc1xuICogaG93IG11Y2ggb2YgdGhlIGVsZW1lbnQgd291bGQgYmUgdmlzaWJsZS5cbiAqL1xuaW50ZXJmYWNlIE92ZXJsYXlQb2ludCBleHRlbmRzIFBvaW50IHtcbiAgdmlzaWJsZUFyZWE/OiBudW1iZXI7XG4gIGZpdHNJblZpZXdwb3J0PzogYm9vbGVhbjtcbn1cbiIsImltcG9ydCB7UG9zaXRpb25TdHJhdGVneX0gZnJvbSAnLi9wb3NpdGlvbi1zdHJhdGVneSc7XG5cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBwb3NpdGlvbmluZyBvdmVybGF5cy4gVXNpbmcgdGhpcyBzdHJhdGVneSwgYW4gb3ZlcmxheSBpcyBnaXZlbiBhblxuICogZXhwbGljaXQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJyb3dzZXIncyB2aWV3cG9ydC4gV2UgdXNlIGZsZXhib3gsIGluc3RlYWQgb2ZcbiAqIHRyYW5zZm9ybXMsIGluIG9yZGVyIHRvIGF2b2lkIGlzc3VlcyB3aXRoIHN1YnBpeGVsIHJlbmRlcmluZyB3aGljaCBjYW4gY2F1c2UgdGhlXG4gKiBlbGVtZW50IHRvIGJlY29tZSBibHVycnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgUG9zaXRpb25TdHJhdGVneSB7XG4gIHByaXZhdGUgX2Nzc1Bvc2l0aW9uOiBzdHJpbmcgPSAnc3RhdGljJztcbiAgcHJpdmF0ZSBfdG9wT2Zmc2V0OiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBfYm90dG9tT2Zmc2V0OiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBfbGVmdE9mZnNldDogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgX3JpZ2h0T2Zmc2V0OiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBfYWxpZ25JdGVtczogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgX2p1c3RpZnlDb250ZW50OiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBfd2lkdGg6IHN0cmluZyA9ICcnO1xuICBwcml2YXRlIF9oZWlnaHQ6IHN0cmluZyA9ICcnO1xuXG4gIC8qIEEgbGF6aWx5LWNyZWF0ZWQgd3JhcHBlciBmb3IgdGhlIG92ZXJsYXkgZWxlbWVudCB0aGF0IGlzIHVzZWQgYXMgYSBmbGV4IGNvbnRhaW5lci4gICovXG4gIHByaXZhdGUgX3dyYXBwZXI6IEhUTUxFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB2YWx1ZSBOZXcgdG9wIG9mZnNldC5cbiAgICovXG4gIHRvcCh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5fYm90dG9tT2Zmc2V0ID0gJyc7XG4gICAgdGhpcy5fdG9wT2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdmbGV4LXN0YXJ0JztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB2YWx1ZSBOZXcgbGVmdCBvZmZzZXQuXG4gICAqL1xuICBsZWZ0KHZhbHVlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLl9yaWdodE9mZnNldCA9ICcnO1xuICAgIHRoaXMuX2xlZnRPZmZzZXQgPSB2YWx1ZTtcbiAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICdmbGV4LXN0YXJ0JztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB2YWx1ZSBOZXcgYm90dG9tIG9mZnNldC5cbiAgICovXG4gIGJvdHRvbSh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5fdG9wT2Zmc2V0ID0gJyc7XG4gICAgdGhpcy5fYm90dG9tT2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHZhbHVlIE5ldyByaWdodCBvZmZzZXQuXG4gICAqL1xuICByaWdodCh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5fbGVmdE9mZnNldCA9ICcnO1xuICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG92ZXJsYXkgd2lkdGggYW5kIGNsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgd2lkdGguXG4gICAqIEBwYXJhbSB2YWx1ZSBOZXcgd2lkdGggZm9yIHRoZSBvdmVybGF5XG4gICAqL1xuICB3aWR0aCh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcblxuICAgIC8vIFdoZW4gdGhlIHdpZHRoIGlzIDEwMCUsIHdlIHNob3VsZCByZXNldCB0aGUgYGxlZnRgIGFuZCB0aGUgb2Zmc2V0LFxuICAgIC8vIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGZsdXNoIGFnYWluc3QgdGhlIHZpZXdwb3J0IGVkZ2UuXG4gICAgaWYgKHZhbHVlID09PSAnMTAwJScpIHtcbiAgICAgIHRoaXMubGVmdCgnMHB4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3ZlcmxheSBoZWlnaHQgYW5kIGNsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gdmFsdWUgTmV3IGhlaWdodCBmb3IgdGhlIG92ZXJsYXlcbiAgICovXG4gIGhlaWdodCh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG5cbiAgICAvLyBXaGVuIHRoZSBoZWlnaHQgaXMgMTAwJSwgd2Ugc2hvdWxkIHJlc2V0IHRoZSBgdG9wYCBhbmQgdGhlIG9mZnNldCxcbiAgICAvLyBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBmbHVzaCBhZ2FpbnN0IHRoZSB2aWV3cG9ydCBlZGdlLlxuICAgIGlmICh2YWx1ZSA9PT0gJzEwMCUnKSB7XG4gICAgICB0aGlzLnRvcCgnMHB4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2VudGVycyB0aGUgb3ZlcmxheSBob3Jpem9udGFsbHkgd2l0aCBhbiBvcHRpb25hbCBvZmZzZXQuXG4gICAqIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCBPdmVybGF5IG9mZnNldCBmcm9tIHRoZSBob3Jpem9udGFsIGNlbnRlci5cbiAgICovXG4gIGNlbnRlckhvcml6b250YWxseShvZmZzZXQgPSAnJyk6IHRoaXMge1xuICAgIHRoaXMubGVmdChvZmZzZXQpO1xuICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2VudGVycyB0aGUgb3ZlcmxheSB2ZXJ0aWNhbGx5IHdpdGggYW4gb3B0aW9uYWwgb2Zmc2V0LlxuICAgKiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHZlcnRpY2FsIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IE92ZXJsYXkgb2Zmc2V0IGZyb20gdGhlIHZlcnRpY2FsIGNlbnRlci5cbiAgICovXG4gIGNlbnRlclZlcnRpY2FsbHkob2Zmc2V0ID0gJycpOiB0aGlzIHtcbiAgICB0aGlzLnRvcChvZmZzZXQpO1xuICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIGVsZW1lbnQuXG4gICAqIEBkb2NzLXByaXZhdGVcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhcHBseSB0aGUgQ1NTLlxuICAgKiBAcmV0dXJucyBSZXNvbHZlZCB3aGVuIHRoZSBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAqL1xuICBhcHBseShlbGVtZW50OiBIVE1MRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5fd3JhcHBlcikge1xuICAgICAgdGhpcy5fd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLW92ZXJsYXktd3JhcHBlcicpO1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl93cmFwcGVyLCBlbGVtZW50KTtcbiAgICAgIHRoaXMuX3dyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IHBhcmVudFN0eWxlcyA9IChlbGVtZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlO1xuXG4gICAgc3R5bGVzLnBvc2l0aW9uID0gdGhpcy5fY3NzUG9zaXRpb247XG4gICAgc3R5bGVzLm1hcmdpblRvcCA9IHRoaXMuX3RvcE9mZnNldDtcbiAgICBzdHlsZXMubWFyZ2luTGVmdCA9IHRoaXMuX2xlZnRPZmZzZXQ7XG4gICAgc3R5bGVzLm1hcmdpbkJvdHRvbSA9IHRoaXMuX2JvdHRvbU9mZnNldDtcbiAgICBzdHlsZXMubWFyZ2luUmlnaHQgPSB0aGlzLl9yaWdodE9mZnNldDtcbiAgICBzdHlsZXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICBzdHlsZXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgcGFyZW50U3R5bGVzLmp1c3RpZnlDb250ZW50ID0gdGhpcy5fanVzdGlmeUNvbnRlbnQ7XG4gICAgcGFyZW50U3R5bGVzLmFsaWduSXRlbXMgPSB0aGlzLl9hbGlnbkl0ZW1zO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB3cmFwcGVyIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fd3JhcHBlciAmJiB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgICAgIHRoaXMuX3dyYXBwZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtWaWV3cG9ydFJ1bGVyfSBmcm9tICcuL3ZpZXdwb3J0LXJ1bGVyJztcbmltcG9ydCB7Q29ubmVjdGVkUG9zaXRpb25TdHJhdGVneX0gZnJvbSAnLi9jb25uZWN0ZWQtcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHtFbGVtZW50UmVmLCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7R2xvYmFsUG9zaXRpb25TdHJhdGVneX0gZnJvbSAnLi9nbG9iYWwtcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHtPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uLCBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb259IGZyb20gJy4vY29ubmVjdGVkLXBvc2l0aW9uJztcblxuXG5cbi8qKiBCdWlsZGVyIGZvciBvdmVybGF5IHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF92aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyKSB7IH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGdsb2JhbCBwb3NpdGlvbiBzdHJhdGVneS5cbiAgICovXG4gIGdsb2JhbCgpOiBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICByZXR1cm4gbmV3IEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXRpdmUgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAqIEBwYXJhbSBlbGVtZW50UmVmXG4gICAqIEBwYXJhbSBvcmlnaW5Qb3NcbiAgICogQHBhcmFtIG92ZXJsYXlQb3NcbiAgICovXG4gIGNvbm5lY3RlZFRvKFxuICAgICAgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgIG9yaWdpblBvczogT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uLFxuICAgICAgb3ZlcmxheVBvczogT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbik6IENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHJldHVybiBuZXcgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneShlbGVtZW50UmVmLCBvcmlnaW5Qb3MsIG92ZXJsYXlQb3MsIHRoaXMuX3ZpZXdwb3J0UnVsZXIpO1xuICB9XG59XG4iLCJpbXBvcnQge0luamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cblxuLyoqXG4gKiBUaGUgT3ZlcmxheUNvbnRhaW5lciBpcyB0aGUgY29udGFpbmVyIGluIHdoaWNoIGFsbCBvdmVybGF5cyB3aWxsIGxvYWQuXG4gKiBJdCBzaG91bGQgYmUgcHJvdmlkZWQgaW4gdGhlIHJvb3QgY29tcG9uZW50IHRvIGVuc3VyZSBpdCBpcyBwcm9wZXJseSBzaGFyZWQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBPdmVybGF5Q29udGFpbmVyIHtcbiAgcHJvdGVjdGVkIF9jb250YWluZXJFbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICBwcml2YXRlIF90aGVtZUNsYXNzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEJhc2UgdGhlbWUgdG8gYmUgYXBwbGllZCB0byBhbGwgb3ZlcmxheS1iYXNlZCBjb21wb25lbnRzLlxuICAgKi9cbiAgZ2V0IHRoZW1lQ2xhc3MoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3RoZW1lQ2xhc3M7IH1cbiAgc2V0IHRoZW1lQ2xhc3ModmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fdGhlbWVDbGFzcyk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3RoZW1lQ2xhc3MgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LiAgSXQgd2lsbCBsYXppbHlcbiAgICogY3JlYXRlIHRoZSBlbGVtZW50IHRoZSBmaXJzdCB0aW1lICBpdCBpcyBjYWxsZWQgdG8gZmFjaWxpdGF0ZSB1c2luZ1xuICAgKiB0aGUgY29udGFpbmVyIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgICogQHJldHVybnMgdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAqL1xuICBnZXRDb250YWluZXJFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHsgdGhpcy5fY3JlYXRlQ29udGFpbmVyKCk7IH1cbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29udGFpbmVyIGVsZW1lbnQsIHdoaWNoIGlzIHNpbXBseSBhIGRpdlxuICAgKiB3aXRoIHRoZSAnY2RrLW92ZXJsYXktY29udGFpbmVyJyBjbGFzcyBvbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICovXG4gIHByb3RlY3RlZCBfY3JlYXRlQ29udGFpbmVyKCk6IHZvaWQge1xuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktY29udGFpbmVyJyk7XG5cbiAgICBpZiAodGhpcy5fdGhlbWVDbGFzcykge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5fdGhlbWVDbGFzcyk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXI7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50Q29udGFpbmVyOiBPdmVybGF5Q29udGFpbmVyKSB7XG4gIHJldHVybiBwYXJlbnRDb250YWluZXIgfHwgbmV3IE92ZXJsYXlDb250YWluZXIoKTtcbn1cblxuZXhwb3J0IGNvbnN0IE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSID0ge1xuICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE92ZXJsYXlDb250YWluZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgcHJvdmlkZTogT3ZlcmxheUNvbnRhaW5lcixcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIE92ZXJsYXlDb250YWluZXJdXSxcbiAgdXNlRmFjdG9yeTogT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVJfRkFDVE9SWVxufTtcbiIsImltcG9ydCB7XG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgSW5qZWN0YWJsZSxcbiAgQXBwbGljYXRpb25SZWYsXG4gIEluamVjdG9yLFxuICBOZ1pvbmUsXG4gIFByb3ZpZGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T3ZlcmxheVN0YXRlfSBmcm9tICcuL292ZXJsYXktc3RhdGUnO1xuaW1wb3J0IHtEb21Qb3J0YWxIb3N0fSBmcm9tICcuLi9wb3J0YWwvZG9tLXBvcnRhbC1ob3N0JztcbmltcG9ydCB7T3ZlcmxheVJlZn0gZnJvbSAnLi9vdmVybGF5LXJlZic7XG5pbXBvcnQge092ZXJsYXlQb3NpdGlvbkJ1aWxkZXJ9IGZyb20gJy4vcG9zaXRpb24vb3ZlcmxheS1wb3NpdGlvbi1idWlsZGVyJztcbmltcG9ydCB7VklFV1BPUlRfUlVMRVJfUFJPVklERVJ9IGZyb20gJy4vcG9zaXRpb24vdmlld3BvcnQtcnVsZXInO1xuaW1wb3J0IHtPdmVybGF5Q29udGFpbmVyLCBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUn0gZnJvbSAnLi9vdmVybGF5LWNvbnRhaW5lcic7XG5pbXBvcnQge1Njcm9sbFN0cmF0ZWd5LCBTY3JvbGxTdHJhdGVneU9wdGlvbnN9IGZyb20gJy4vc2Nyb2xsL2luZGV4JztcblxuXG4vKiogTmV4dCBvdmVybGF5IHVuaXF1ZSBJRC4gKi9cbmxldCBuZXh0VW5pcXVlSWQgPSAwO1xuXG4vKiogVGhlIGRlZmF1bHQgc3RhdGUgZm9yIG5ld2x5IGNyZWF0ZWQgb3ZlcmxheXMuICovXG5sZXQgZGVmYXVsdFN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuXG5cbi8qKlxuICogU2VydmljZSB0byBjcmVhdGUgT3ZlcmxheXMuIE92ZXJsYXlzIGFyZSBkeW5hbWljYWxseSBhZGRlZCBwaWVjZXMgb2YgZmxvYXRpbmcgVUksIG1lYW50IHRvIGJlXG4gKiB1c2VkIGFzIGEgbG93LWxldmVsIGJ1aWxkaW5nIGJ1aWxkaW5nIGJsb2NrIGZvciBvdGhlciBjb21wb25lbnRzLiBEaWFsb2dzLCB0b29sdGlwcywgbWVudXMsXG4gKiBzZWxlY3RzLCBldGMuIGNhbiBhbGwgYmUgYnVpbHQgdXNpbmcgb3ZlcmxheXMuIFRoZSBzZXJ2aWNlIHNob3VsZCBwcmltYXJpbHkgYmUgdXNlZCBieSBhdXRob3JzXG4gKiBvZiByZS11c2FibGUgY29tcG9uZW50cyByYXRoZXIgdGhhbiBkZXZlbG9wZXJzIGJ1aWxkaW5nIGVuZC11c2VyIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBBbiBvdmVybGF5ICppcyogYSBQb3J0YWxIb3N0LCBzbyBhbnkga2luZCBvZiBQb3J0YWwgY2FuIGJlIGxvYWRlZCBpbnRvIG9uZS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE92ZXJsYXkge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2Nyb2xsU3RyYXRlZ2llczogU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLFxuICAgICAgICAgICAgICBwcml2YXRlIF9vdmVybGF5Q29udGFpbmVyOiBPdmVybGF5Q29udGFpbmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfcG9zaXRpb25CdWlsZGVyOiBPdmVybGF5UG9zaXRpb25CdWlsZGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIF9hcHBSZWY6IEFwcGxpY2F0aW9uUmVmLFxuICAgICAgICAgICAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgICAgICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7IH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvdmVybGF5LlxuICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXkuXG4gICAqIEByZXR1cm5zIFJlZmVyZW5jZSB0byB0aGUgY3JlYXRlZCBvdmVybGF5LlxuICAgKi9cbiAgY3JlYXRlKHN0YXRlOiBPdmVybGF5U3RhdGUgPSBkZWZhdWx0U3RhdGUpOiBPdmVybGF5UmVmIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlT3ZlcmxheVJlZih0aGlzLl9jcmVhdGVQYW5lRWxlbWVudCgpLCBzdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBvc2l0aW9uIGJ1aWxkZXIgdGhhdCBjYW4gYmUgdXNlZCwgdmlhIGZsdWVudCBBUEksXG4gICAqIHRvIGNvbnN0cnVjdCBhbmQgY29uZmlndXJlIGEgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAqL1xuICBwb3NpdGlvbigpOiBPdmVybGF5UG9zaXRpb25CdWlsZGVyIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25CdWlsZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIERPTSBlbGVtZW50IGZvciBhbiBvdmVybGF5IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvdmVybGF5IGNvbnRhaW5lci5cbiAgICogQHJldHVybnMgTmV3bHktY3JlYXRlZCBwYW5lIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgX2NyZWF0ZVBhbmVFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICBsZXQgcGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgcGFuZS5pZCA9IGBjZGstb3ZlcmxheS0ke25leHRVbmlxdWVJZCsrfWA7XG4gICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1wYW5lJyk7XG4gICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lci5nZXRDb250YWluZXJFbGVtZW50KCkuYXBwZW5kQ2hpbGQocGFuZSk7XG5cbiAgICByZXR1cm4gcGFuZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEb21Qb3J0YWxIb3N0IGludG8gd2hpY2ggdGhlIG92ZXJsYXkgY29udGVudCBjYW4gYmUgbG9hZGVkLlxuICAgKiBAcGFyYW0gcGFuZSBUaGUgRE9NIGVsZW1lbnQgdG8gdHVybiBpbnRvIGEgcG9ydGFsIGhvc3QuXG4gICAqIEByZXR1cm5zIEEgcG9ydGFsIGhvc3QgZm9yIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICovXG4gIHByaXZhdGUgX2NyZWF0ZVBvcnRhbEhvc3QocGFuZTogSFRNTEVsZW1lbnQpOiBEb21Qb3J0YWxIb3N0IHtcbiAgICByZXR1cm4gbmV3IERvbVBvcnRhbEhvc3QocGFuZSwgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCB0aGlzLl9hcHBSZWYsIHRoaXMuX2luamVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE92ZXJsYXlSZWYgZm9yIGFuIG92ZXJsYXkgaW4gdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0gcGFuZSBET00gZWxlbWVudCBmb3IgdGhlIG92ZXJsYXlcbiAgICogQHBhcmFtIHN0YXRlXG4gICAqL1xuICBwcml2YXRlIF9jcmVhdGVPdmVybGF5UmVmKHBhbmU6IEhUTUxFbGVtZW50LCBzdGF0ZTogT3ZlcmxheVN0YXRlKTogT3ZlcmxheVJlZiB7XG4gICAgbGV0IHNjcm9sbFN0cmF0ZWd5ID0gc3RhdGUuc2Nyb2xsU3RyYXRlZ3kgfHwgdGhpcy5zY3JvbGxTdHJhdGVnaWVzLm5vb3AoKTtcbiAgICBsZXQgcG9ydGFsSG9zdCA9IHRoaXMuX2NyZWF0ZVBvcnRhbEhvc3QocGFuZSk7XG4gICAgcmV0dXJuIG5ldyBPdmVybGF5UmVmKHBvcnRhbEhvc3QsIHBhbmUsIHN0YXRlLCBzY3JvbGxTdHJhdGVneSwgdGhpcy5fbmdab25lKTtcbiAgfVxufVxuXG4vKiogUHJvdmlkZXJzIGZvciBPdmVybGF5IGFuZCBpdHMgcmVsYXRlZCBpbmplY3RhYmxlcy4gKi9cbmV4cG9ydCBjb25zdCBPVkVSTEFZX1BST1ZJREVSUzogUHJvdmlkZXJbXSA9IFtcbiAgT3ZlcmxheSxcbiAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgVklFV1BPUlRfUlVMRVJfUFJPVklERVIsXG4gIE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSLFxuXTtcbiIsImltcG9ydCB7XG4gICAgTmdNb2R1bGUsXG4gICAgRGlyZWN0aXZlLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIE9wdGlvbmFsLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPdXRwdXQsXG4gICAgRWxlbWVudFJlZixcbiAgICBSZW5kZXJlcjIsXG4gICAgT25DaGFuZ2VzLFxuICAgIFNpbXBsZUNoYW5nZXMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPdmVybGF5LCBPVkVSTEFZX1BST1ZJREVSU30gZnJvbSAnLi9vdmVybGF5JztcbmltcG9ydCB7T3ZlcmxheVJlZn0gZnJvbSAnLi9vdmVybGF5LXJlZic7XG5pbXBvcnQge1RlbXBsYXRlUG9ydGFsfSBmcm9tICcuLi9wb3J0YWwvcG9ydGFsJztcbmltcG9ydCB7T3ZlcmxheVN0YXRlfSBmcm9tICcuL292ZXJsYXktc3RhdGUnO1xuaW1wb3J0IHtcbiAgICBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICAgIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZVxufSBmcm9tICcuL3Bvc2l0aW9uL2Nvbm5lY3RlZC1wb3NpdGlvbic7XG5pbXBvcnQge1BvcnRhbE1vZHVsZX0gZnJvbSAnLi4vcG9ydGFsL3BvcnRhbC1kaXJlY3RpdmVzJztcbmltcG9ydCB7Q29ubmVjdGVkUG9zaXRpb25TdHJhdGVneX0gZnJvbSAnLi9wb3NpdGlvbi9jb25uZWN0ZWQtcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHtEaXIsIExheW91dERpcmVjdGlvbn0gZnJvbSAnLi4vcnRsL2Rpcic7XG5pbXBvcnQge1Njcm9sbGFibGV9IGZyb20gJy4vc2Nyb2xsL3Njcm9sbGFibGUnO1xuaW1wb3J0IHtTY3JvbGxTdHJhdGVneX0gZnJvbSAnLi9zY3JvbGwvc2Nyb2xsLXN0cmF0ZWd5JztcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICcuLi9jb2VyY2lvbi9ib29sZWFuLXByb3BlcnR5JztcbmltcG9ydCB7RVNDQVBFfSBmcm9tICcuLi9rZXlib2FyZC9rZXljb2Rlcyc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1Njcm9sbERpc3BhdGNoTW9kdWxlfSBmcm9tICcuL3Njcm9sbC9pbmRleCc7XG5cblxuLyoqIERlZmF1bHQgc2V0IG9mIHBvc2l0aW9ucyBmb3IgdGhlIG92ZXJsYXkuIEZvbGxvd3MgdGhlIGJlaGF2aW9yIG9mIGEgZHJvcGRvd24uICovXG5sZXQgZGVmYXVsdFBvc2l0aW9uTGlzdCA9IFtcbiAgbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoXG4gICAgICB7b3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbSd9LFxuICAgICAge292ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ3RvcCd9KSxcbiAgbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoXG4gICAgICB7b3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCd9LFxuICAgICAge292ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbSd9KSxcbl07XG5cblxuLyoqXG4gKiBEaXJlY3RpdmUgYXBwbGllZCB0byBhbiBlbGVtZW50IHRvIG1ha2UgaXQgdXNhYmxlIGFzIGFuIG9yaWdpbiBmb3IgYW4gT3ZlcmxheSB1c2luZyBhXG4gKiBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2RrLW92ZXJsYXktb3JpZ2luXSwgW292ZXJsYXktb3JpZ2luXSwgW2Nka092ZXJsYXlPcmlnaW5dJyxcbiAgZXhwb3J0QXM6ICdjZGtPdmVybGF5T3JpZ2luJyxcbn0pXG5leHBvcnQgY2xhc3MgT3ZlcmxheU9yaWdpbiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cbn1cblxuXG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGZhY2lsaXRhdGUgZGVjbGFyYXRpdmUgY3JlYXRpb24gb2YgYW4gT3ZlcmxheSB1c2luZyBhIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjZGstY29ubmVjdGVkLW92ZXJsYXldLCBbY29ubmVjdGVkLW92ZXJsYXldLCBbY2RrQ29ubmVjdGVkT3ZlcmxheV0nLFxuICBleHBvcnRBczogJ2Nka0Nvbm5lY3RlZE92ZXJsYXknXG59KVxuZXhwb3J0IGNsYXNzIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG4gIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG4gIHByaXZhdGUgX3RlbXBsYXRlUG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDtcbiAgcHJpdmF0ZSBfaGFzQmFja2Ryb3AgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfYmFja2Ryb3BTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfb2Zmc2V0WDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfb2Zmc2V0WTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfcG9zaXRpb246IENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gIHByaXZhdGUgX2VzY2FwZUxpc3RlbmVyOiBGdW5jdGlvbjtcblxuICAvKiogT3JpZ2luIGZvciB0aGUgY29ubmVjdGVkIG92ZXJsYXkuICovXG4gIEBJbnB1dCgpIG9yaWdpbjogT3ZlcmxheU9yaWdpbjtcblxuICAvKiogUmVnaXN0ZXJlZCBjb25uZWN0ZWQgcG9zaXRpb24gcGFpcnMuICovXG4gIEBJbnB1dCgpIHBvc2l0aW9uczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdO1xuXG4gIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeC1heGlzICovXG4gIEBJbnB1dCgpXG4gIGdldCBvZmZzZXRYKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldFg7XG4gIH1cblxuICBzZXQgb2Zmc2V0WChvZmZzZXRYOiBudW1iZXIpIHtcbiAgICB0aGlzLl9vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICBpZiAodGhpcy5fcG9zaXRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uLndpdGhPZmZzZXRYKG9mZnNldFgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeS1heGlzICovXG4gIEBJbnB1dCgpXG4gIGdldCBvZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRZO1xuICB9XG5cbiAgc2V0IG9mZnNldFkob2Zmc2V0WTogbnVtYmVyKSB7XG4gICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgaWYgKHRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbi53aXRoT2Zmc2V0WShvZmZzZXRZKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGhlIHdpZHRoIG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBASW5wdXQoKSB3aWR0aDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlciB8IHN0cmluZztcblxuICAvKiogVGhlIG1pbiB3aWR0aCBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gKi9cbiAgQElucHV0KCkgbWluV2lkdGg6IG51bWJlciB8IHN0cmluZztcblxuICAvKiogVGhlIG1pbiBoZWlnaHQgb2YgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIEBJbnB1dCgpIG1pbkhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKiBUaGUgY3VzdG9tIGNsYXNzIHRvIGJlIHNldCBvbiB0aGUgYmFja2Ryb3AgZWxlbWVudC4gKi9cbiAgQElucHV0KCkgYmFja2Ryb3BDbGFzczogc3RyaW5nO1xuXG4gIC8qKiBTdHJhdGVneSB0byBiZSB1c2VkIHdoZW4gaGFuZGxpbmcgc2Nyb2xsIGV2ZW50cyB3aGlsZSB0aGUgb3ZlcmxheSBpcyBvcGVuLiAqL1xuICBASW5wdXQoKSBzY3JvbGxTdHJhdGVneTogU2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBvdmVybGF5IGlzIG9wZW4uICovXG4gIEBJbnB1dCgpIG9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgc2hvdWxkIGF0dGFjaCBhIGJhY2tkcm9wLiAqL1xuICBASW5wdXQoKVxuICBnZXQgaGFzQmFja2Ryb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc0JhY2tkcm9wO1xuICB9XG5cbiAgc2V0IGhhc0JhY2tkcm9wKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9oYXNCYWNrZHJvcCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICBAT3V0cHV0KCkgYmFja2Ryb3BDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgY2hhbmdlZC4gKi9cbiAgQE91dHB1dCgpIHBvc2l0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2U+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBhdHRhY2hlZC4gKi9cbiAgQE91dHB1dCgpIGF0dGFjaCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvdmVybGF5IGhhcyBiZWVuIGRldGFjaGVkLiAqL1xuICBAT3V0cHV0KCkgZGV0YWNoID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8vIFRPRE8oamVsYm91cm4pOiBpbnB1dHMgZm9yIHNpemUsIHNjcm9sbCBiZWhhdmlvciwgYW5pbWF0aW9uLCBldGMuXG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyKSB7XG4gICAgdGhpcy5fdGVtcGxhdGVQb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpO1xuICB9XG5cbiAgLyoqIFRoZSBhc3NvY2lhdGVkIG92ZXJsYXkgcmVmZXJlbmNlLiAqL1xuICBnZXQgb3ZlcmxheVJlZigpOiBPdmVybGF5UmVmIHtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgfVxuXG4gIC8qKiBUaGUgZWxlbWVudCdzIGxheW91dCBkaXJlY3Rpb24uICovXG4gIGdldCBkaXIoKTogTGF5b3V0RGlyZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95T3ZlcmxheSgpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzWydvcGVuJ10pIHtcbiAgICAgIHRoaXMub3BlbiA/IHRoaXMuX2F0dGFjaE92ZXJsYXkoKSA6IHRoaXMuX2RldGFjaE92ZXJsYXkoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhbiBvdmVybGF5ICovXG4gIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKSB7XG4gICAgaWYgKCF0aGlzLnBvc2l0aW9ucyB8fCAhdGhpcy5wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnBvc2l0aW9ucyA9IGRlZmF1bHRQb3NpdGlvbkxpc3Q7XG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHRoaXMuX2J1aWxkQ29uZmlnKCkpO1xuICB9XG5cbiAgLyoqIEJ1aWxkcyB0aGUgb3ZlcmxheSBjb25maWcgYmFzZWQgb24gdGhlIGRpcmVjdGl2ZSdzIGlucHV0cyAqL1xuICBwcml2YXRlIF9idWlsZENvbmZpZygpOiBPdmVybGF5U3RhdGUge1xuICAgIGxldCBvdmVybGF5Q29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMud2lkdGggfHwgdGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgb3ZlcmxheUNvbmZpZy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICBvdmVybGF5Q29uZmlnLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbldpZHRoIHx8IHRoaXMubWluV2lkdGggPT09IDApIHtcbiAgICAgIG92ZXJsYXlDb25maWcubWluV2lkdGggPSB0aGlzLm1pbldpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbkhlaWdodCB8fCB0aGlzLm1pbkhlaWdodCA9PT0gMCkge1xuICAgICAgb3ZlcmxheUNvbmZpZy5taW5IZWlnaHQgPSB0aGlzLm1pbkhlaWdodDtcbiAgICB9XG5cbiAgICBvdmVybGF5Q29uZmlnLmhhc0JhY2tkcm9wID0gdGhpcy5oYXNCYWNrZHJvcDtcblxuICAgIGlmICh0aGlzLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgIG92ZXJsYXlDb25maWcuYmFja2Ryb3BDbGFzcyA9IHRoaXMuYmFja2Ryb3BDbGFzcztcbiAgICB9XG5cbiAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2NyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKSBhcyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICAgIG92ZXJsYXlDb25maWcucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgIG92ZXJsYXlDb25maWcuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLnNjcm9sbFN0cmF0ZWd5O1xuXG4gICAgcmV0dXJuIG92ZXJsYXlDb25maWc7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgb2YgdGhlIG92ZXJsYXkgdG8gYmUgc2V0IG9uIHRoZSBvdmVybGF5IGNvbmZpZyAqL1xuICBwcml2YXRlIF9jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk6IENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMucG9zaXRpb25zWzBdO1xuICAgIGNvbnN0IG9yaWdpblBvaW50ID0ge29yaWdpblg6IHBvcy5vcmlnaW5YLCBvcmlnaW5ZOiBwb3Mub3JpZ2luWX07XG4gICAgY29uc3Qgb3ZlcmxheVBvaW50ID0ge292ZXJsYXlYOiBwb3Mub3ZlcmxheVgsIG92ZXJsYXlZOiBwb3Mub3ZlcmxheVl9O1xuXG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLm9yaWdpbi5lbGVtZW50UmVmLCBvcmlnaW5Qb2ludCwgb3ZlcmxheVBvaW50KVxuICAgICAgLndpdGhPZmZzZXRYKHRoaXMub2Zmc2V0WClcbiAgICAgIC53aXRoT2Zmc2V0WSh0aGlzLm9mZnNldFkpO1xuXG4gICAgdGhpcy5faGFuZGxlUG9zaXRpb25DaGFuZ2VzKHN0cmF0ZWd5KTtcblxuICAgIHJldHVybiBzdHJhdGVneTtcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVBvc2l0aW9uQ2hhbmdlcyhzdHJhdGVneTogQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk6IHZvaWQge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0cmF0ZWd5LndpdGhGYWxsYmFja1Bvc2l0aW9uKFxuICAgICAgICAgIHtvcmlnaW5YOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5YLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5ZfSxcbiAgICAgICAgICB7b3ZlcmxheVg6IHRoaXMucG9zaXRpb25zW2ldLm92ZXJsYXlYLCBvdmVybGF5WTogdGhpcy5wb3NpdGlvbnNbaV0ub3ZlcmxheVl9XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID1cbiAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoKHBvczogYW55KSA9PiB0aGlzLnBvc2l0aW9uQ2hhbmdlLmVtaXQocG9zKSk7XG4gIH1cblxuICAvKiogQXR0YWNoZXMgdGhlIG92ZXJsYXkgYW5kIHN1YnNjcmliZXMgdG8gYmFja2Ryb3AgY2xpY2tzIGlmIGJhY2tkcm9wIGV4aXN0cyAqL1xuICBwcml2YXRlIF9hdHRhY2hPdmVybGF5KCkge1xuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc2l0aW9uLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpO1xuICAgIHRoaXMuX292ZXJsYXlSZWYuZ2V0U3RhdGUoKS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICB0aGlzLl9pbml0RXNjYXBlTGlzdGVuZXIoKTtcblxuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl90ZW1wbGF0ZVBvcnRhbCk7XG4gICAgICB0aGlzLmF0dGFjaC5lbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzQmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrLmVtaXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEZXRhY2hlcyB0aGUgb3ZlcmxheSBhbmQgdW5zdWJzY3JpYmVzIHRvIGJhY2tkcm9wIGNsaWNrcyBpZiBiYWNrZHJvcCBleGlzdHMgKi9cbiAgcHJpdmF0ZSBfZGV0YWNoT3ZlcmxheSgpIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgIHRoaXMuZGV0YWNoLmVtaXQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VzY2FwZUxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9lc2NhcGVMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEZXN0cm95cyB0aGUgb3ZlcmxheSBjcmVhdGVkIGJ5IHRoaXMgZGlyZWN0aXZlLiAqL1xuICBwcml2YXRlIF9kZXN0cm95T3ZlcmxheSgpIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXNjYXBlTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2VzY2FwZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFNldHMgdGhlIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2xvc2VzIHRoZSBvdmVybGF5IHdoZW4gcHJlc3NpbmcgRXNjYXBlLiAqL1xuICBwcml2YXRlIF9pbml0RXNjYXBlTGlzdGVuZXIoKSB7XG4gICAgdGhpcy5fZXNjYXBlTGlzdGVuZXIgPSB0aGlzLl9yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2tleWRvd24nLCAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1BvcnRhbE1vZHVsZSwgU2Nyb2xsRGlzcGF0Y2hNb2R1bGVdLFxuICBleHBvcnRzOiBbQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSwgT3ZlcmxheU9yaWdpbiwgU2Nyb2xsRGlzcGF0Y2hNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLCBPdmVybGF5T3JpZ2luXSxcbiAgcHJvdmlkZXJzOiBbT1ZFUkxBWV9QUk9WSURFUlNdLFxufSlcbmV4cG9ydCBjbGFzcyBPdmVybGF5TW9kdWxlIHt9XG4iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vcGxhdGZvcm0nO1xuXG4vKipcbiAqIFRoZSBJbnRlcmFjdGl2aXR5Q2hlY2tlciBsZWFucyBoZWF2aWx5IG9uIHRoZSBhbGx5LmpzIGFjY2Vzc2liaWxpdHkgdXRpbGl0aWVzLlxuICogTWV0aG9kcyBsaWtlIGBpc1RhYmJhYmxlYCBhcmUgb25seSBjb3ZlcmluZyBzcGVjaWZpYyBlZGdlLWNhc2VzIGZvciB0aGUgYnJvd3NlcnMgd2hpY2ggYXJlXG4gKiBzdXBwb3J0ZWQuXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZvciBjaGVja2luZyB0aGUgaW50ZXJhY3Rpdml0eSBvZiBhbiBlbGVtZW50LCBzdWNoIGFzIHdoZXRoZXIgaXMgaXMgZm9jdXNhYmxlIG9yXG4gKiB0YWJiYWJsZS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEludGVyYWN0aXZpdHlDaGVja2VyIHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wbGF0Zm9ybTogUGxhdGZvcm0pIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGRpc2FibGVkLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0Rpc2FibGVkKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjYXB0dXJlIHNvbWUgY2FzZXMsIHN1Y2ggYXMgYSBub24tZm9ybSBjb250cm9sIHdpdGggYSBkaXNhYmxlZCBhdHRyaWJ1dGUgb3JcbiAgICAvLyBhIGZvcm0gY29udHJvbCBpbnNpZGUgb2YgYSBkaXNhYmxlZCBmb3JtLCBidXQgc2hvdWxkIGNhcHR1cmUgdGhlIG1vc3QgY29tbW9uIGNhc2VzLlxuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyB2aXNpYmxlIGZvciB0aGUgcHVycG9zZXMgb2YgaW50ZXJhY3Rpdml0eS5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhcHR1cmUgc3RhdGVzIGxpa2UgYGRpc3BsYXk6IG5vbmVgIGFuZCBgdmlzaWJpbGl0eTogaGlkZGVuYCwgYnV0IG5vdCB0aGluZ3MgbGlrZVxuICAgKiBiZWluZyBjbGlwcGVkIGJ5IGFuIGBvdmVyZmxvdzogaGlkZGVuYCBwYXJlbnQgb3IgYmVpbmcgb3V0c2lkZSB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICovXG4gIGlzVmlzaWJsZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBoYXNHZW9tZXRyeShlbGVtZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnZpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBjYW4gYmUgcmVhY2hlZCB2aWEgVGFiIGtleS5cbiAgICogQXNzdW1lcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCB3aXRoIGlzRm9jdXNhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGFiYmFibGUuXG4gICAqL1xuICBpc1RhYmJhYmxlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgLy8gTm90aGluZyBpcyB0YWJiYWJsZSBvbiB0aGUgdGhlIHNlcnZlciDDsMKfwpjCjlxuICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGZyYW1lRWxlbWVudCA9IGdldFdpbmRvdyhlbGVtZW50KS5mcmFtZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG5cbiAgICAgIGxldCBmcmFtZVR5cGUgPSBmcmFtZUVsZW1lbnQgJiYgZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIC8vIEZyYW1lIGVsZW1lbnRzIGluaGVyaXQgdGhlaXIgdGFiaW5kZXggb250byBhbGwgY2hpbGQgZWxlbWVudHMuXG4gICAgICBpZiAoZ2V0VGFiSW5kZXhWYWx1ZShmcmFtZUVsZW1lbnQpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlYmtpdCBhbmQgQmxpbmsgY29uc2lkZXIgYW55dGhpbmcgaW5zaWRlIG9mIGFuIDxvYmplY3Q+IGVsZW1lbnQgYXMgbm9uLXRhYmJhYmxlLlxuICAgICAgaWYgKCh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpICYmIGZyYW1lVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGRpc2FibGUgdGFiYmluZyB0byBhbiBlbGVtZW50IGluc2lkZSBvZiBhbiBpbnZpc2libGUgZnJhbWUuXG4gICAgICBpZiAoKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLldFQktJVCkgJiYgIXRoaXMuaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgbGV0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCB0YWJJbmRleFZhbHVlID0gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgIHJldHVybiB0YWJJbmRleFZhbHVlICE9PSAtMTtcbiAgICB9XG5cbiAgICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAvLyBUaGUgZnJhbWVzIG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gY29udGVudCwgYnV0IGl0J3Mgbm90IHBvc3NpYmx5IHRvIHJlbGlhYmx5XG4gICAgICAvLyBpbnZlc3RpZ2F0ZSB0aGUgY29udGVudCBvZiB0aGUgZnJhbWVzLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xuICAgICAgICAvLyBCeSBkZWZhdWx0IGFuIDxhdWRpbz4gZWxlbWVudCB3aXRob3V0IHRoZSBjb250cm9scyBlbmFibGVkIGlzIG5vdCB0YWJiYWJsZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9wbGF0Zm9ybS5CTElOSykge1xuICAgICAgICAvLyBJbiBCbGluayA8YXVkaW8gY29udHJvbHM+IGVsZW1lbnRzIGFyZSBhbHdheXMgdGFiYmFibGUuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSAmJiB0aGlzLl9wbGF0Zm9ybS5UUklERU5UKSB7XG4gICAgICAgIC8vIEluIFRyaWRlbnQgYSA8dmlkZW8+IGVsZW1lbnQgd2l0aG91dCB0aGUgY29udHJvbHMgZW5hYmxlZCBpcyBub3QgdGFiYmFibGUuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uRklSRUZPWCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzPiBlbGVtZW50cyBhcmUgYWx3YXlzIHRhYmJhYmxlLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZU5hbWUgPT09ICdvYmplY3QnICYmICh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpKSB7XG4gICAgICAvLyBJbiBhbGwgQmxpbmsgYW5kIFdlYktpdCBiYXNlZCBicm93c2VycyA8b2JqZWN0PiBlbGVtZW50cyBhcmUgbmV2ZXIgdGFiYmFibGUuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSW4gaU9TIHRoZSBicm93c2VyIG9ubHkgY29uc2lkZXJzIHNvbWUgc3BlY2lmaWMgZWxlbWVudHMgYXMgdGFiYmFibGUuXG4gICAgaWYgKHRoaXMuX3BsYXRmb3JtLldFQktJVCAmJiB0aGlzLl9wbGF0Zm9ybS5JT1MgJiYgIWlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWQgYnkgdGhlIHVzZXIuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAqL1xuICBpc0ZvY3VzYWJsZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIC8vIFBlcmZvcm0gY2hlY2tzIGluIG9yZGVyIG9mIGxlZnQgdG8gbW9zdCBleHBlbnNpdmUuXG4gICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgIHJldHVybiBpc1BvdGVudGlhbGx5Rm9jdXNhYmxlKGVsZW1lbnQpICYmICF0aGlzLmlzRGlzYWJsZWQoZWxlbWVudCkgJiYgdGhpcy5pc1Zpc2libGUoZWxlbWVudCk7XG4gIH1cblxufVxuXG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGhhcyBhbnkgZ2VvbWV0cnkgLyByZWN0YW5nbGVzLiAqL1xuZnVuY3Rpb24gaGFzR2VvbWV0cnkoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgLy8gVXNlIGxvZ2ljIGZyb20galF1ZXJ5IHRvIGNoZWNrIGZvciBhbiBpbnZpc2libGUgZWxlbWVudC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9jc3MvaGlkZGVuVmlzaWJsZVNlbGVjdG9ycy5qcyNMMTJcbiAgcmV0dXJuICEhKGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG59XG5cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCdzICAqL1xuZnVuY3Rpb24gaXNOYXRpdmVGb3JtRWxlbWVudChlbGVtZW50OiBOb2RlKSB7XG4gIGxldCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnaW5wdXQnIHx8XG4gICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgIG5vZGVOYW1lID09PSAnYnV0dG9uJyB8fFxuICAgICAgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYSc7XG59XG5cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiA8aW5wdXQgdHlwZT1cImhpZGRlblwiPi4gKi9cbmZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQudHlwZSA9PSAnaGlkZGVuJztcbn1cblxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciB0aGF0IGhhcyBhbiBocmVmIGF0dHJpYnV0ZS4gKi9cbmZ1bmN0aW9uIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzQW5jaG9yRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xufVxuXG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gaW5wdXQgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MSW5wdXRFbGVtZW50IHtcbiAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnaW5wdXQnO1xufVxuXG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gYW5jaG9yIGVsZW1lbnQuICovXG5mdW5jdGlvbiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxBbmNob3JFbGVtZW50IHtcbiAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnYSc7XG59XG5cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYSB2YWxpZCB0YWJpbmRleC4gKi9cbmZ1bmN0aW9uIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCBlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAvLyBJRTExIHBhcnNlcyB0YWJpbmRleD1cIlwiIGFzIHRoZSB2YWx1ZSBcIi0zMjc2OFwiXG4gIGlmICh0YWJJbmRleCA9PSAnLTMyNzY4Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhISh0YWJJbmRleCAmJiAhaXNOYU4ocGFyc2VJbnQodGFiSW5kZXgsIDEwKSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcnNlZCB0YWJpbmRleCBmcm9tIHRoZSBlbGVtZW50IGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlXG4gKiBldmFsdWF0ZWQgdGFiaW5kZXggZnJvbSB0aGUgYnJvd3NlcnMgZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFRhYkluZGV4VmFsdWUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICBpZiAoIWhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFNlZSBicm93c2VyIGlzc3VlIGluIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuXG4gIHJldHVybiBpc05hTih0YWJJbmRleCkgPyAtMSA6IHRhYkluZGV4O1xufVxuXG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGlzIHBvdGVudGlhbGx5IHRhYmJhYmxlIG9uIGlPUyAqL1xuZnVuY3Rpb24gaXNQb3RlbnRpYWxseVRhYmJhYmxlSU9TKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gIGxldCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGlucHV0VHlwZSA9IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIChlbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnR5cGU7XG5cbiAgcmV0dXJuIGlucHV0VHlwZSA9PT0gJ3RleHQnXG4gICAgICB8fCBpbnB1dFR5cGUgPT09ICdwYXNzd29yZCdcbiAgICAgIHx8IG5vZGVOYW1lID09PSAnc2VsZWN0J1xuICAgICAgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYSc7XG59XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgZm9jdXNhYmxlIHdpdGhvdXQgdGFraW5nIGN1cnJlbnQgdmlzaWJsZS9kaXNhYmxlZCBzdGF0ZVxuICogaW50byBhY2NvdW50LlxuICovXG5mdW5jdGlvbiBpc1BvdGVudGlhbGx5Rm9jdXNhYmxlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gIC8vIElucHV0cyBhcmUgcG90ZW50aWFsbHkgZm9jdXNhYmxlICp1bmxlc3MqIHRoZXkncmUgdHlwZT1cImhpZGRlblwiLlxuICBpZiAoaXNIaWRkZW5JbnB1dChlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05hdGl2ZUZvcm1FbGVtZW50KGVsZW1lbnQpIHx8XG4gICAgICBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHx8XG4gICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgfHxcbiAgICAgIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCk7XG59XG5cbi8qKiBHZXRzIHRoZSBwYXJlbnQgd2luZG93IG9mIGEgRE9NIG5vZGUgd2l0aCByZWdhcmRzIG9mIGJlaW5nIGluc2lkZSBvZiBhbiBpZnJhbWUuICovXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZTogSFRNTEVsZW1lbnQpOiBXaW5kb3cge1xuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBBZnRlckNvbnRlbnRJbml0LFxuICBJbmplY3RhYmxlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW50ZXJhY3Rpdml0eUNoZWNrZXJ9IGZyb20gJy4vaW50ZXJhY3Rpdml0eS1jaGVja2VyJztcbmltcG9ydCB7UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL3BsYXRmb3JtJztcbmltcG9ydCB7Y29lcmNlQm9vbGVhblByb3BlcnR5fSBmcm9tICcuLi9jb2VyY2lvbi9ib29sZWFuLXByb3BlcnR5JztcbmltcG9ydCB7Zmlyc3R9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGFsbG93cyBmb3IgdHJhcHBpbmcgZm9jdXMgd2l0aGluIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBjdXJyZW50bHkgdXNlcyBhIHZlcnkgc2ltcGxlIChuYWl2ZSkgYXBwcm9hY2ggdG8gZm9jdXMgdHJhcHBpbmcuXG4gKiBJdCBhc3N1bWVzIHRoYXQgdGhlIHRhYiBvcmRlciBpcyB0aGUgc2FtZSBhcyBET00gb3JkZXIsIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0cnVlLlxuICogVGhpbmdzIGxpa2UgdGFiSW5kZXggPiAwLCBmbGV4IGBvcmRlcmAsIGFuZCBzaGFkb3cgcm9vdHMgY2FuIGNhdXNlIHRvIHR3byB0byBtaXNhbGlnbi5cbiAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgbW9yZSBpbnRlbGxpZ2VudCBzb2x1dGlvbiBiZWZvcmUgdGhlIGxpYnJhcnkgaXMgY29uc2lkZXJlZCBzdGFibGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXAge1xuICBwcml2YXRlIF9zdGFydEFuY2hvcjogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgX2VuZEFuY2hvcjogSFRNTEVsZW1lbnQ7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLiAqL1xuICBnZXQgZW5hYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7IH1cbiAgc2V0IGVuYWJsZWQodmFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZW5hYmxlZCA9IHZhbDtcblxuICAgIGlmICh0aGlzLl9zdGFydEFuY2hvciAmJiB0aGlzLl9lbmRBbmNob3IpIHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5jaG9yLnRhYkluZGV4ID0gdGhpcy5fZW5kQW5jaG9yLnRhYkluZGV4ID0gdGhpcy5fZW5hYmxlZCA/IDAgOiAtMTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgIHByaXZhdGUgX2NoZWNrZXI6IEludGVyYWN0aXZpdHlDaGVja2VyLFxuICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgIGRlZmVyQW5jaG9ycyA9IGZhbHNlKSB7XG5cbiAgICBpZiAoIWRlZmVyQW5jaG9ycykge1xuICAgICAgdGhpcy5hdHRhY2hBbmNob3JzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIERlc3Ryb3lzIHRoZSBmb2N1cyB0cmFwIGJ5IGNsZWFuaW5nIHVwIHRoZSBhbmNob3JzLiAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9zdGFydEFuY2hvciAmJiB0aGlzLl9zdGFydEFuY2hvci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9zdGFydEFuY2hvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3N0YXJ0QW5jaG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW5kQW5jaG9yICYmIHRoaXMuX2VuZEFuY2hvci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9lbmRBbmNob3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9lbmRBbmNob3IpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0QW5jaG9yID0gdGhpcy5fZW5kQW5jaG9yID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIHRoZSBhbmNob3JzIGludG8gdGhlIERPTS4gVGhpcyBpcyB1c3VhbGx5IGRvbmUgYXV0b21hdGljYWxseVxuICAgKiBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBjYW4gYmUgZGVmZXJyZWQgZm9yIGNhc2VzIGxpa2UgZGlyZWN0aXZlcyB3aXRoIGAqbmdJZmAuXG4gICAqL1xuICBhdHRhY2hBbmNob3JzKCk6IHZvaWQge1xuICAgIC8vIElmIHdlJ3JlIG5vdCBvbiB0aGUgYnJvd3NlciwgdGhlcmUgY2FuIGJlIG5vIGZvY3VzIHRvIHRyYXAuXG4gICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3N0YXJ0QW5jaG9yKSB7XG4gICAgICB0aGlzLl9zdGFydEFuY2hvciA9IHRoaXMuX2NyZWF0ZUFuY2hvcigpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZW5kQW5jaG9yKSB7XG4gICAgICB0aGlzLl9lbmRBbmNob3IgPSB0aGlzLl9jcmVhdGVBbmNob3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmNob3IuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB0aGlzLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCgpKTtcbiAgICAgIHRoaXMuX2VuZEFuY2hvci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHRoaXMuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCgpKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9zdGFydEFuY2hvciwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX2VuZEFuY2hvciwgdGhpcy5fZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdHMgZm9yIHRoZSB6b25lIHRvIHN0YWJpbGl6ZSwgdGhlbiBlaXRoZXIgZm9jdXNlcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHRoZVxuICAgKiB1c2VyIHNwZWNpZmllZCwgb3IgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQuLlxuICAgKi9cbiAgZm9jdXNJbml0aWFsRWxlbWVudFdoZW5SZWFkeSgpIHtcbiAgICB0aGlzLl9leGVjdXRlT25TdGFibGUoKCkgPT4gdGhpcy5mb2N1c0luaXRpYWxFbGVtZW50KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzdGFiaWxpemUsIHRoZW4gZm9jdXNlc1xuICAgKiB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCB3aXRoaW4gdGhlIGZvY3VzIHRyYXAgcmVnaW9uLlxuICAgKi9cbiAgZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSgpIHtcbiAgICB0aGlzLl9leGVjdXRlT25TdGFibGUoKCkgPT4gdGhpcy5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzdGFiaWxpemUsIHRoZW4gZm9jdXNlc1xuICAgKiB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAqL1xuICBmb2N1c0xhc3RUYWJiYWJsZUVsZW1lbnRXaGVuUmVhZHkoKSB7XG4gICAgdGhpcy5fZXhlY3V0ZU9uU3RhYmxlKCgpID0+IHRoaXMuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3BlY2lmaWVkIGJvdW5kYXJ5IGVsZW1lbnQgb2YgdGhlIHRyYXBwZWQgcmVnaW9uLlxuICAgKiBAcGFyYW0gYm91bmQgVGhlIGJvdW5kYXJ5IHRvIGdldCAoc3RhcnQgb3IgZW5kIG9mIHRyYXBwZWQgcmVnaW9uKS5cbiAgICogQHJldHVybnMgVGhlIGJvdW5kYXJ5IGVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9nZXRSZWdpb25Cb3VuZGFyeShib3VuZDogJ3N0YXJ0JyB8ICdlbmQnKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICAvLyBDb250YWlucyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIHNlbGVjdG9yLCBmb3IgdGVtcG9yYXJ5IGJhY2t3YXJkcyBjb21wYXJhYmlsaXR5LlxuICAgIGxldCBtYXJrZXJzID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbY2RrLWZvY3VzLXJlZ2lvbi0ke2JvdW5kfV0sIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBbY2RrLWZvY3VzLSR7Ym91bmR9XWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWFya2Vyc1tpXS5oYXNBdHRyaWJ1dGUoYGNkay1mb2N1cy0ke2JvdW5kfWApKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRm91bmQgdXNlIG9mIGRlcHJlY2F0ZWQgYXR0cmlidXRlICdjZGstZm9jdXMtJHtib3VuZH0nLGAgK1xuICAgICAgICAgICAgICAgICAgICAgYCB1c2UgJ2Nkay1mb2N1cy1yZWdpb24tJHtib3VuZH0nIGluc3RlYWQuYCwgbWFya2Vyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kID09ICdzdGFydCcpIHtcbiAgICAgIHJldHVybiBtYXJrZXJzLmxlbmd0aCA/IG1hcmtlcnNbMF0gOiB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcnMubGVuZ3RoID9cbiAgICAgICAgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdIDogdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIGZvY3VzZWQgd2hlbiB0aGUgZm9jdXMgdHJhcCBpcyBpbml0aWFsaXplZC4gKi9cbiAgZm9jdXNJbml0aWFsRWxlbWVudCgpIHtcbiAgICBsZXQgcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tjZGstZm9jdXMtaW5pdGlhbF0nKSBhcyBIVE1MRWxlbWVudDtcbiAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uICovXG4gIGZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKSB7XG4gICAgbGV0IHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZ2V0UmVnaW9uQm91bmRhcnkoJ3N0YXJ0Jyk7XG4gICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBsYXN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi4gKi9cbiAgZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCkge1xuICAgIGxldCByZWRpcmVjdFRvRWxlbWVudCA9IHRoaXMuX2dldFJlZ2lvbkJvdW5kYXJ5KCdlbmQnKTtcbiAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBmcm9tIGEgRE9NIHN1YnRyZWUgKGluY2x1c2l2ZSkuICovXG4gIHByaXZhdGUgX2dldEZpcnN0VGFiYmFibGVFbGVtZW50KHJvb3Q6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xuICAgIGlmICh0aGlzLl9jaGVja2VyLmlzRm9jdXNhYmxlKHJvb3QpICYmIHRoaXMuX2NoZWNrZXIuaXNUYWJiYWJsZShyb290KSkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBpbiBET00gb3JkZXIuIE5vdGUgdGhhdCBJRSBkb2Vzbid0IGhhdmUgYGNoaWxkcmVuYCBmb3IgU1ZHIHNvIHdlIGZhbGxcbiAgICAvLyBiYWNrIHRvIGBjaGlsZE5vZGVzYCB3aGljaCBpbmNsdWRlcyB0ZXh0IG5vZGVzLCBjb21tZW50cyBldGMuXG4gICAgbGV0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbiB8fCByb290LmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdGFiYmFibGVDaGlsZCA9IGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA/XG4gICAgICAgIHRoaXMuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50KGNoaWxkcmVuW2ldIGFzIEhUTUxFbGVtZW50KSA6XG4gICAgICAgIG51bGw7XG5cbiAgICAgIGlmICh0YWJiYWJsZUNoaWxkKSB7XG4gICAgICAgIHJldHVybiB0YWJiYWJsZUNoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqIEdldCB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS4gKi9cbiAgcHJpdmF0ZSBfZ2V0TGFzdFRhYmJhYmxlRWxlbWVudChyb290OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcbiAgICBpZiAodGhpcy5fY2hlY2tlci5pc0ZvY3VzYWJsZShyb290KSAmJiB0aGlzLl9jaGVja2VyLmlzVGFiYmFibGUocm9vdCkpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSBET00gb3JkZXIuXG4gICAgbGV0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbiB8fCByb290LmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCB0YWJiYWJsZUNoaWxkID0gY2hpbGRyZW5baV0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFID9cbiAgICAgICAgdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudChjaGlsZHJlbltpXSBhcyBIVE1MRWxlbWVudCkgOlxuICAgICAgICBudWxsO1xuXG4gICAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGFuIGFuY2hvciBlbGVtZW50LiAqL1xuICBwcml2YXRlIF9jcmVhdGVBbmNob3IoKTogSFRNTEVsZW1lbnQge1xuICAgIGxldCBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhbmNob3IudGFiSW5kZXggPSB0aGlzLl9lbmFibGVkID8gMCA6IC0xO1xuICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgYW5jaG9yLmNsYXNzTGlzdC5hZGQoJ2Nkay1mb2N1cy10cmFwLWFuY2hvcicpO1xuICAgIHJldHVybiBhbmNob3I7XG4gIH1cblxuICAvKiogRXhlY3V0ZXMgYSBmdW5jdGlvbiB3aGVuIHRoZSB6b25lIGlzIHN0YWJsZS4gKi9cbiAgcHJpdmF0ZSBfZXhlY3V0ZU9uU3RhYmxlKGZuOiAoKSA9PiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbmdab25lLmlzU3RhYmxlKSB7XG4gICAgICBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uZ1pvbmUub25TdGFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoZm4pO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKiBGYWN0b3J5IHRoYXQgYWxsb3dzIGVhc3kgaW5zdGFudGlhdGlvbiBvZiBmb2N1cyB0cmFwcy4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIF9jaGVja2VyOiBJbnRlcmFjdGl2aXR5Q2hlY2tlcixcbiAgICAgIHByaXZhdGUgX3BsYXRmb3JtOiBQbGF0Zm9ybSxcbiAgICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7IH1cblxuICBjcmVhdGUoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRlZmVyQW5jaG9ycyA9IGZhbHNlKTogRm9jdXNUcmFwIHtcbiAgICByZXR1cm4gbmV3IEZvY3VzVHJhcChlbGVtZW50LCB0aGlzLl9wbGF0Zm9ybSwgdGhpcy5fY2hlY2tlciwgdGhpcy5fbmdab25lLCBkZWZlckFuY2hvcnMpO1xuICB9XG59XG5cblxuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2Nkay1mb2N1cy10cmFwJyxcbn0pXG5leHBvcnQgY2xhc3MgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIGZvY3VzVHJhcDogRm9jdXNUcmFwO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBmb2N1cyB0cmFwIGlzIGFjdGl2ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gIXRoaXMuZm9jdXNUcmFwLmVuYWJsZWQ7IH1cbiAgc2V0IGRpc2FibGVkKHZhbDogYm9vbGVhbikge1xuICAgIHRoaXMuZm9jdXNUcmFwLmVuYWJsZWQgPSAhY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9mb2N1c1RyYXBGYWN0b3J5OiBGb2N1c1RyYXBGYWN0b3J5KSB7XG4gICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5LmNyZWF0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRydWUpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5mb2N1c1RyYXAuZGVzdHJveSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuZm9jdXNUcmFwLmF0dGFjaEFuY2hvcnMoKTtcbiAgfVxufVxuXG5cbi8qKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjZGtUcmFwRm9jdXNdJyxcbiAgZXhwb3J0QXM6ICdjZGtUcmFwRm9jdXMnLFxufSlcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQge1xuICBmb2N1c1RyYXA6IEZvY3VzVHJhcDtcblxuICAvKiogV2hldGhlciB0aGUgZm9jdXMgdHJhcCBpcyBhY3RpdmUuICovXG4gIEBJbnB1dCgnY2RrVHJhcEZvY3VzJylcbiAgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLmZvY3VzVHJhcC5lbmFibGVkOyB9XG4gIHNldCBlbmFibGVkKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuZm9jdXNUcmFwLmVuYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfZm9jdXNUcmFwRmFjdG9yeTogRm9jdXNUcmFwRmFjdG9yeSkge1xuICAgIHRoaXMuZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0cnVlKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZm9jdXNUcmFwLmRlc3Ryb3koKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLmZvY3VzVHJhcC5hdHRhY2hBbmNob3JzKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEluamVjdGFibGUsXG4gIEluamVjdGlvblRva2VuLFxuICBPcHRpb25hbCxcbiAgSW5qZWN0LFxuICBTa2lwU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BsYXRmb3JtfSBmcm9tICcuLi9wbGF0Zm9ybS9wbGF0Zm9ybSc7XG5cblxuZXhwb3J0IGNvbnN0IExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48SFRNTEVsZW1lbnQ+KCdsaXZlQW5ub3VuY2VyRWxlbWVudCcpO1xuXG4vKiogUG9zc2libGUgcG9saXRlbmVzcyBsZXZlbHMuICovXG5leHBvcnQgdHlwZSBBcmlhTGl2ZVBvbGl0ZW5lc3MgPSAnb2ZmJyB8ICdwb2xpdGUnIHwgJ2Fzc2VydGl2ZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMaXZlQW5ub3VuY2VyIHtcblxuICBwcml2YXRlIF9saXZlRWxlbWVudDogRWxlbWVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTikgZWxlbWVudFRva2VuOiBhbnksXG4gICAgICBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgICAvLyBPbmx5IGRvIGFueXRoaW5nIGlmIHdlJ3JlIG9uIHRoZSBicm93c2VyIHBsYXRmb3JtLlxuICAgIGlmIChwbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgIC8vIFdlIGluamVjdCB0aGUgbGl2ZSBlbGVtZW50IGFzIGBhbnlgIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBjYW5ub3QgcmVmZXJlbmNlXG4gICAgICAvLyBicm93c2VyIGdsb2JhbHMgKEhUTUxFbGVtZW50KSBvbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMsIHNpbmNlIGhhdmluZyBhIGNsYXNzIGRlY29yYXRvclxuICAgICAgLy8gY2F1c2VzIFR5cGVTY3JpcHQgdG8gcHJlc2VydmUgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSB0eXBlcy5cbiAgICAgIHRoaXMuX2xpdmVFbGVtZW50ID0gZWxlbWVudFRva2VuIHx8IHRoaXMuX2NyZWF0ZUxpdmVFbGVtZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFubm91bmNlcyBhIG1lc3NhZ2UgdG8gc2NyZWVucmVhZGVycy5cbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSB0byBiZSBhbm5vdW5jZWQgdG8gdGhlIHNjcmVlbnJlYWRlclxuICAgKiBAcGFyYW0gcG9saXRlbmVzcyBUaGUgcG9saXRlbmVzcyBvZiB0aGUgYW5ub3VuY2VyIGVsZW1lbnRcbiAgICovXG4gIGFubm91bmNlKG1lc3NhZ2U6IHN0cmluZywgcG9saXRlbmVzczogQXJpYUxpdmVQb2xpdGVuZXNzID0gJ3BvbGl0ZScpOiB2b2lkIHtcbiAgICB0aGlzLl9saXZlRWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gVE9ETzogZW5zdXJlIGNoYW5naW5nIHRoZSBwb2xpdGVuZXNzIHdvcmtzIG9uIGFsbCBlbnZpcm9ubWVudHMgd2Ugc3VwcG9ydC5cbiAgICB0aGlzLl9saXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIHBvbGl0ZW5lc3MpO1xuXG4gICAgLy8gVGhpcyAxMDBtcyB0aW1lb3V0IGlzIG5lY2Vzc2FyeSBmb3Igc29tZSBicm93c2VyICsgc2NyZWVuLXJlYWRlciBjb21iaW5hdGlvbnM6XG4gICAgLy8gLSBCb3RoIEpBV1MgYW5kIE5WREEgb3ZlciBJRTExIHdpbGwgbm90IGFubm91bmNlIGFueXRoaW5nIHdpdGhvdXQgYSBub24temVybyB0aW1lb3V0LlxuICAgIC8vIC0gV2l0aCBDaHJvbWUgYW5kIElFMTEgd2l0aCBOVkRBIG9yIEpBV1MsIGEgcmVwZWF0ZWQgKGlkZW50aWNhbCkgbWVzc2FnZSB3b24ndCBiZSByZWFkIGFcbiAgICAvLyAgIHNlY29uZCB0aW1lIHdpdGhvdXQgY2xlYXJpbmcgYW5kIHRoZW4gdXNpbmcgYSBub24temVybyBkZWxheS5cbiAgICAvLyAodXNpbmcgSkFXUyAxNyBhdCB0aW1lIG9mIHRoaXMgd3JpdGluZykuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9saXZlRWxlbWVudC50ZXh0Q29udGVudCA9IG1lc3NhZ2UsIDEwMCk7XG4gIH1cblxuICAvKiogUmVtb3ZlcyB0aGUgYXJpYS1saXZlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiAqL1xuICBfcmVtb3ZlTGl2ZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX2xpdmVFbGVtZW50ICYmIHRoaXMuX2xpdmVFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fbGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NyZWF0ZUxpdmVFbGVtZW50KCk6IEVsZW1lbnQge1xuICAgIGxldCBsaXZlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGxpdmVFbC5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgbGl2ZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIGxpdmVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZUVsKTtcblxuICAgIHJldHVybiBsaXZlRWw7XG4gIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gTElWRV9BTk5PVU5DRVJfUFJPVklERVJfRkFDVE9SWShcbiAgICBwYXJlbnREaXNwYXRjaGVyOiBMaXZlQW5ub3VuY2VyLCBsaXZlRWxlbWVudDogYW55LCBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IExpdmVBbm5vdW5jZXIobGl2ZUVsZW1lbnQsIHBsYXRmb3JtKTtcbn1cblxuZXhwb3J0IGNvbnN0IExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSID0ge1xuICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgTGl2ZUFubm91bmNlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICBwcm92aWRlOiBMaXZlQW5ub3VuY2VyLFxuICBkZXBzOiBbXG4gICAgW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgTGl2ZUFubm91bmNlcl0sXG4gICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4pXSxcbiAgICBQbGF0Zm9ybSxcbiAgXSxcbiAgdXNlRmFjdG9yeTogTElWRV9BTk5PVU5DRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb2N1c1RyYXBEaXJlY3RpdmUsIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmUsIEZvY3VzVHJhcEZhY3Rvcnl9IGZyb20gJy4vZm9jdXMtdHJhcCc7XG5pbXBvcnQge0xJVkVfQU5OT1VOQ0VSX1BST1ZJREVSfSBmcm9tICcuL2xpdmUtYW5ub3VuY2VyJztcbmltcG9ydCB7SW50ZXJhY3Rpdml0eUNoZWNrZXJ9IGZyb20gJy4vaW50ZXJhY3Rpdml0eS1jaGVja2VyJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQbGF0Zm9ybU1vZHVsZX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBQbGF0Zm9ybU1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0ZvY3VzVHJhcERpcmVjdGl2ZSwgRm9jdXNUcmFwRGVwcmVjYXRlZERpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtGb2N1c1RyYXBEaXJlY3RpdmUsIEZvY3VzVHJhcERlcHJlY2F0ZWREaXJlY3RpdmVdLFxuICBwcm92aWRlcnM6IFtJbnRlcmFjdGl2aXR5Q2hlY2tlciwgRm9jdXNUcmFwRmFjdG9yeSwgTElWRV9BTk5PVU5DRVJfUFJPVklERVJdXG59KVxuZXhwb3J0IGNsYXNzIEExMXlNb2R1bGUge31cbiIsImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge092ZXJsYXlDb250YWluZXJ9IGZyb20gJy4vb3ZlcmxheS1jb250YWluZXInO1xuXG4vKipcbiAqIFRoZSBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciBpcyB0aGUgYWx0ZXJuYXRpdmUgdG8gT3ZlcmxheUNvbnRhaW5lclxuICogdGhhdCBzdXBwb3J0cyBjb3JyZWN0IGRpc3BsYXlpbmcgb2Ygb3ZlcmxheSBlbGVtZW50cyBpbiBGdWxsc2NyZWVuIG1vZGVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3JlcXVlc3RGdWxsU2NyZWVuXG4gKiBJdCBzaG91bGQgYmUgcHJvdmlkZWQgaW4gdGhlIHJvb3QgY29tcG9uZW50IHRoYXQgd2F5OlxuICogcHJvdmlkZXJzOiBbXG4gKiAgIHtwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLCB1c2VDbGFzczogRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXJ9XG4gKiBdLFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIgZXh0ZW5kcyBPdmVybGF5Q29udGFpbmVyIHtcbiAgcHJvdGVjdGVkIF9jcmVhdGVDb250YWluZXIoKTogdm9pZCB7XG4gICAgc3VwZXIuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICAgIHRoaXMuX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgICB0aGlzLl9hZGRGdWxsc2NyZWVuQ2hhbmdlTGlzdGVuZXIoKCkgPT4gdGhpcy5fYWRqdXN0UGFyZW50Rm9yRnVsbHNjcmVlbkNoYW5nZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmdWxsc2NyZWVuRWxlbWVudCA9IHRoaXMuZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKTtcbiAgICBsZXQgcGFyZW50ID0gZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyRWxlbWVudCk7XG4gIH1cblxuICBwcml2YXRlIF9hZGRGdWxsc2NyZWVuQ2hhbmdlTGlzdGVuZXIoZm46ICgpID0+IHZvaWQpIHtcbiAgICBpZiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGZuKTtcbiAgICB9IGVsc2UgaWYgKChkb2N1bWVudCBhcyBhbnkpLm1vekZ1bGxTY3JlZW5FbmFibGVkKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgZm4pO1xuICAgIH0gZWxzZSBpZiAoKGRvY3VtZW50IGFzIGFueSkubXNGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNGdWxsc2NyZWVuQ2hhbmdlJywgZm4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwYWdlIGlzIHB1dCBpbnRvIGZ1bGxzY3JlZW4gbW9kZSwgYSBzcGVjaWZpYyBlbGVtZW50IGlzIHNwZWNpZmllZC5cbiAgICogT25seSB0aGF0IGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbiBhcmUgdmlzaWJsZSB3aGVuIGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgKi9cbiAgZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKTogRWxlbWVudCB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIChkb2N1bWVudCBhcyBhbnkpLm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgIChkb2N1bWVudCBhcyBhbnkpLm1zRnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHtJbmplY3RhYmxlLCBpc0Rldk1vZGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIYW1tZXJHZXN0dXJlQ29uZmlnfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7SGFtbWVyU3RhdGljLCBIYW1tZXJJbnN0YW5jZSwgUmVjb2duaXplciwgUmVjb2duaXplclN0YXRpY30gZnJvbSAnLi9nZXN0dXJlLWFubm90YXRpb25zJztcblxuLyogQWRqdXN0cyBjb25maWd1cmF0aW9uIG9mIG91ciBnZXN0dXJlIGxpYnJhcnksIEhhbW1lci4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHZXN0dXJlQ29uZmlnIGV4dGVuZHMgSGFtbWVyR2VzdHVyZUNvbmZpZyB7XG4gIHByaXZhdGUgX2hhbW1lcjogSGFtbWVyU3RhdGljID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAod2luZG93IGFzIGFueSkuSGFtbWVyIDogbnVsbDtcblxuICAvKiBMaXN0IG9mIG5ldyBldmVudCBuYW1lcyB0byBhZGQgdG8gdGhlIGdlc3R1cmUgc3VwcG9ydCBsaXN0ICovXG4gIGV2ZW50czogc3RyaW5nW10gPSB0aGlzLl9oYW1tZXIgPyBbXG4gICAgJ2xvbmdwcmVzcycsXG4gICAgJ3NsaWRlJyxcbiAgICAnc2xpZGVzdGFydCcsXG4gICAgJ3NsaWRlZW5kJyxcbiAgICAnc2xpZGVyaWdodCcsXG4gICAgJ3NsaWRlbGVmdCdcbiAgXSA6IFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAoIXRoaXMuX2hhbW1lciAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnQ291bGQgbm90IGZpbmQgSGFtbWVySlMuIENlcnRhaW4gQW5ndWxhciBNYXRlcmlhbCAnICtcbiAgICAgICAgJ2NvbXBvbmVudHMgbWF5IG5vdCB3b3JrIGNvcnJlY3RseS4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgSGFtbWVyIGluc3RhbmNlIG1hbnVhbGx5IHRvIGFkZCBjdXN0b20gcmVjb2duaXplcnMgdGhhdCBtYXRjaCB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAqXG4gICAqIE91ciBnZXN0dXJlIG5hbWVzIGNvbWUgZnJvbSB0aGUgTWF0ZXJpYWwgRGVzaWduIGdlc3R1cmVzIHNwZWM6XG4gICAqIGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvcGF0dGVybnMvZ2VzdHVyZXMuaHRtbCNnZXN0dXJlcy10b3VjaC1tZWNoYW5pY3NcbiAgICpcbiAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZhdWx0IHJlY29nbml6ZXJzIGNhbiBiZSBmb3VuZCBpbiBIYW1tZXIgZG9jczpcbiAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXBhbi9cbiAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXByZXNzL1xuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFzc2lnbiB0aGUgbmV3IEhhbW1lckpTIGdlc3R1cmVzLlxuICAgKiBAcmV0dXJucyBOZXdseS1jcmVhdGVkIEhhbW1lckpTIGluc3RhbmNlLlxuICAgKi9cbiAgYnVpbGRIYW1tZXIoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBIYW1tZXJJbnN0YW5jZSB7XG4gICAgY29uc3QgbWMgPSBuZXcgdGhpcy5faGFtbWVyKGVsZW1lbnQpO1xuXG4gICAgLy8gRGVmYXVsdCBIYW1tZXIgUmVjb2duaXplcnMuXG4gICAgbGV0IHBhbiA9IG5ldyB0aGlzLl9oYW1tZXIuUGFuKCk7XG4gICAgbGV0IHN3aXBlID0gbmV3IHRoaXMuX2hhbW1lci5Td2lwZSgpO1xuICAgIGxldCBwcmVzcyA9IG5ldyB0aGlzLl9oYW1tZXIuUHJlc3MoKTtcblxuICAgIC8vIE5vdGljZSB0aGF0IGEgSGFtbWVySlMgcmVjb2duaXplciBjYW4gb25seSBkZXBlbmQgb24gb25lIG90aGVyIHJlY29nbml6ZXIgb25jZS5cbiAgICAvLyBPdGhlcndpc2UgdGhlIHByZXZpb3VzIGByZWNvZ25pemVXaXRoYCB3aWxsIGJlIGRyb3BwZWQuXG4gICAgLy8gVE9ETzogQ29uZmlybSB0aHJlc2hvbGQgbnVtYmVycyB3aXRoIE1hdGVyaWFsIERlc2lnbiBVWCBUZWFtXG4gICAgbGV0IHNsaWRlID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwYW4sIHtldmVudDogJ3NsaWRlJywgdGhyZXNob2xkOiAwfSwgc3dpcGUpO1xuICAgIGxldCBsb25ncHJlc3MgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHByZXNzLCB7ZXZlbnQ6ICdsb25ncHJlc3MnLCB0aW1lOiA1MDB9KTtcblxuICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBgcGFuYCBldmVudCB0byB1c2UgdGhlIHN3aXBlIGV2ZW50LlxuICAgIHBhbi5yZWNvZ25pemVXaXRoKHN3aXBlKTtcblxuICAgIC8vIEFkZCBjdXN0b21pemVkIGdlc3R1cmVzIHRvIEhhbW1lciBtYW5hZ2VyXG4gICAgbWMuYWRkKFtzd2lwZSwgcHJlc3MsIHBhbiwgc2xpZGUsIGxvbmdwcmVzc10pO1xuXG4gICAgcmV0dXJuIG1jIGFzIEhhbW1lckluc3RhbmNlO1xuICB9XG5cbiAgLyoqIENyZWF0ZXMgYSBuZXcgcmVjb2duaXplciwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGRlZmF1bHQgcmVjb2duaXplcnMgb2YgSGFtbWVySlMgKi9cbiAgcHJpdmF0ZSBfY3JlYXRlUmVjb2duaXplcihiYXNlOiBSZWNvZ25pemVyLCBvcHRpb25zOiBhbnksIC4uLmluaGVyaXRhbmNlczogUmVjb2duaXplcltdKSB7XG4gICAgbGV0IHJlY29nbml6ZXIgPSBuZXcgKGJhc2UuY29uc3RydWN0b3IgYXMgUmVjb2duaXplclN0YXRpYykob3B0aW9ucyk7XG5cbiAgICBpbmhlcml0YW5jZXMucHVzaChiYXNlKTtcbiAgICBpbmhlcml0YW5jZXMuZm9yRWFjaChpdGVtID0+IHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtKSk7XG5cbiAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgfVxuXG59XG4iLCJpbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5cbi8qKlxuICogQ2xhc3MgdG8gYmUgdXNlZCB0byBwb3dlciBzZWxlY3Rpbmcgb25lIG9yIG1vcmUgb3B0aW9ucyBmcm9tIGEgbGlzdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNlbGVjdGlvbk1vZGVsPFQ+IHtcbiAgLyoqIEN1cnJlbnRseS1zZWxlY3RlZCB2YWx1ZXMuICovXG4gIHByaXZhdGUgX3NlbGVjdGlvbjogU2V0PFQ+ID0gbmV3IFNldCgpO1xuXG4gIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZGVzZWxlY3RlZCBvcHRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGVtaXR0ZWQgYnkgdGhlIGNoYW5nZSBldmVudC4gKi9cbiAgcHJpdmF0ZSBfZGVzZWxlY3RlZFRvRW1pdDogVFtdID0gW107XG5cbiAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24gdGhhdCBoYXZlbid0IGJlZW4gZW1pdHRlZCBieSB0aGUgY2hhbmdlIGV2ZW50LiAqL1xuICBwcml2YXRlIF9zZWxlY3RlZFRvRW1pdDogVFtdID0gW107XG5cbiAgLyoqIENhY2hlIGZvciB0aGUgYXJyYXkgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIGl0ZW1zLiAqL1xuICBwcml2YXRlIF9zZWxlY3RlZDogVFtdO1xuXG4gIC8qKiBTZWxlY3RlZCB2YWx1ZShzKS4gKi9cbiAgZ2V0IHNlbGVjdGVkKCk6IFRbXSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBBcnJheS5mcm9tKHRoaXMuX3NlbGVjdGlvbi52YWx1ZXMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICB9XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuICovXG4gIG9uQ2hhbmdlOiBTdWJqZWN0PFNlbGVjdGlvbkNoYW5nZTxUPj4gPSB0aGlzLl9lbWl0Q2hhbmdlcyA/IG5ldyBTdWJqZWN0KCkgOiBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2lzTXVsdGkgPSBmYWxzZSxcbiAgICBpbml0aWFsbHlTZWxlY3RlZFZhbHVlcz86IFRbXSxcbiAgICBwcml2YXRlIF9lbWl0Q2hhbmdlcyA9IHRydWUpIHtcblxuICAgIGlmIChpbml0aWFsbHlTZWxlY3RlZFZhbHVlcykge1xuICAgICAgaWYgKF9pc011bHRpKSB7XG4gICAgICAgIGluaXRpYWxseVNlbGVjdGVkVmFsdWVzLmZvckVhY2godmFsdWUgPT4gdGhpcy5fbWFya1NlbGVjdGVkKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tYXJrU2VsZWN0ZWQoaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgYXJyYXkgaW4gb3JkZXIgdG8gYXZvaWQgZmlyaW5nIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHByZXNlbGVjdGVkIHZhbHVlcy5cbiAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAqL1xuICBzZWxlY3QodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLl9tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0cyBhIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICovXG4gIGRlc2VsZWN0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgYSB2YWx1ZSBiZXR3ZWVuIHNlbGVjdGVkIGFuZCBkZXNlbGVjdGVkLlxuICAgKi9cbiAgdG9nZ2xlKHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdGhpcy5pc1NlbGVjdGVkKHZhbHVlKSA/IHRoaXMuZGVzZWxlY3QodmFsdWUpIDogdGhpcy5zZWxlY3QodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgb2YgdGhlIHNlbGVjdGVkIHZhbHVlcy5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX3VubWFya0FsbCgpO1xuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIHNlbGVjdGVkLlxuICAgKi9cbiAgaXNTZWxlY3RlZCh2YWx1ZTogVCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb24uaGFzKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vZGVsIGRvZXMgbm90IGhhdmUgYSB2YWx1ZS5cbiAgICovXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbi5zaXplID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbW9kZWwgaGFzIGEgdmFsdWUuXG4gICAqL1xuICBoYXNWYWx1ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSBzZWxlY3RlZCB2YWx1ZXMgYmFzZWQgb24gYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqL1xuICBzb3J0KHByZWRpY2F0ZT86IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faXNNdWx0aSAmJiB0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZC5zb3J0KHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEVtaXRzIGEgY2hhbmdlIGV2ZW50IGFuZCBjbGVhcnMgdGhlIHJlY29yZHMgb2Ygc2VsZWN0ZWQgYW5kIGRlc2VsZWN0ZWQgdmFsdWVzLiAqL1xuICBwcml2YXRlIF9lbWl0Q2hhbmdlRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCB8fCB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0Lmxlbmd0aCkge1xuICAgICAgbGV0IGV2ZW50RGF0YSA9IG5ldyBTZWxlY3Rpb25DaGFuZ2UodGhpcy5fc2VsZWN0ZWRUb0VtaXQsIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQpO1xuXG4gICAgICB0aGlzLm9uQ2hhbmdlLm5leHQoZXZlbnREYXRhKTtcbiAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgLyoqIFNlbGVjdHMgYSB2YWx1ZS4gKi9cbiAgcHJpdmF0ZSBfbWFya1NlbGVjdGVkKHZhbHVlOiBUKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQodmFsdWUpKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzTXVsdGkpIHtcbiAgICAgICAgdGhpcy5fdW5tYXJrQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlbGVjdGlvbi5hZGQodmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy5fZW1pdENoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIERlc2VsZWN0cyBhIHZhbHVlLiAqL1xuICBwcml2YXRlIF91bm1hcmtTZWxlY3RlZCh2YWx1ZTogVCkge1xuICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQodmFsdWUpKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb24uZGVsZXRlKHZhbHVlKTtcblxuICAgICAgaWYgKHRoaXMuX2VtaXRDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIENsZWFycyBvdXQgdGhlIHNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgcHJpdmF0ZSBfdW5tYXJrQWxsKCkge1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbi5mb3JFYWNoKHZhbHVlID0+IHRoaXMuX3VubWFya1NlbGVjdGVkKHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgb2YgYSBNZFNlbGVjdGlvbk1vZGVsIGhhcyBjaGFuZ2VkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uQ2hhbmdlPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIGFkZGVkPzogVFtdLCBwdWJsaWMgcmVtb3ZlZD86IFRbXSkgeyB9XG59XG4iLCJcbi8qKlxuICogU2NyZWVucmVhZGVycyB3aWxsIG9mdGVuIGZpcmUgZmFrZSBtb3VzZWRvd24gZXZlbnRzIHdoZW4gYSBmb2N1c2FibGUgZWxlbWVudFxuICogaXMgYWN0aXZhdGVkIHVzaW5nIHRoZSBrZXlib2FyZC4gV2UgY2FuIHR5cGljYWxseSBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZXNlIGZha2VkXG4gKiBtb3VzZWRvd24gZXZlbnRzIGFuZCByZWFsIG1vdXNlZG93biBldmVudHMgdXNpbmcgdGhlIFwiYnV0dG9uc1wiIHByb3BlcnR5LiBXaGlsZVxuICogcmVhbCBtb3VzZWRvd25zIHdpbGwgaW5kaWNhdGUgdGhlIG1vdXNlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkIChlLmcuIFwiMVwiIGZvclxuICogdGhlIGxlZnQgbW91c2UgYnV0dG9uKSwgZmFrZWQgbW91c2Vkb3ducyB3aWxsIHVzdWFsbHkgc2V0IHRoZSBwcm9wZXJ0eSB2YWx1ZSB0byAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudDogTW91c2VFdmVudCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZXZlbnQuYnV0dG9ucyA9PT0gMDtcbn1cbiIsImltcG9ydCB7SW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vLyBVc2VycyBvZiB0aGUgRGlzcGF0Y2hlciBuZXZlciBuZWVkIHRvIHNlZSB0aGlzIHR5cGUsIGJ1dCBUeXBlU2NyaXB0IHJlcXVpcmVzIGl0IHRvIGJlIGV4cG9ydGVkLlxuZXhwb3J0IHR5cGUgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlckxpc3RlbmVyID0gKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gdm9pZDtcblxuLyoqXG4gKiBDbGFzcyB0byBjb29yZGluYXRlIHVuaXF1ZSBzZWxlY3Rpb24gYmFzZWQgb24gbmFtZS5cbiAqIEludGVuZGVkIHRvIGJlIGNvbnN1bWVkIGFzIGFuIEFuZ3VsYXIgc2VydmljZS5cbiAqIFRoaXMgc2VydmljZSBpcyBuZWVkZWQgYmVjYXVzZSBuYXRpdmUgcmFkaW8gY2hhbmdlIGV2ZW50cyBhcmUgb25seSBmaXJlZCBvbiB0aGUgaXRlbSBjdXJyZW50bHlcbiAqIGJlaW5nIHNlbGVjdGVkLCBhbmQgd2Ugc3RpbGwgbmVlZCB0byB1bmNoZWNrIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gKlxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90ICpzdG9yZSogYW55IElEcyBhbmQgbmFtZXMgYmVjYXVzZSB0aGV5IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUsIHNvIGl0IGlzXG4gKiBsZXNzIGVycm9yLXByb25lIGlmIHRoZXkgYXJlIHNpbXBseSBwYXNzZWQgdGhyb3VnaCB3aGVuIHRoZSBldmVudHMgb2NjdXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyIHtcbiAgcHJpdmF0ZSBfbGlzdGVuZXJzOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyTGlzdGVuZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBOb3RpZnkgb3RoZXIgaXRlbXMgdGhhdCBzZWxlY3Rpb24gZm9yIHRoZSBnaXZlbiBuYW1lIGhhcyBiZWVuIHNldC5cbiAgICogQHBhcmFtIGlkIElEIG9mIHRoZSBpdGVtLlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBpdGVtLlxuICAgKi9cbiAgbm90aWZ5KGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoaWQsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBMaXN0ZW4gZm9yIGZ1dHVyZSBjaGFuZ2VzIHRvIGl0ZW0gc2VsZWN0aW9uLiAqL1xuICBsaXN0ZW4obGlzdGVuZXI6IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXJMaXN0ZW5lcikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSX0ZBQ1RPUlkoXG4gICAgcGFyZW50RGlzcGF0Y2hlcjogVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcikge1xuICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcigpO1xufVxuXG5leHBvcnQgY29uc3QgVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSID0ge1xuICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgZGlzcGF0Y2hlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICBwcm92aWRlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLFxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcl1dLFxuICB1c2VGYWN0b3J5OiBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWVxufTtcbiIsImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3RhYmxlLFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUmVuZGVyZXIyLFxuICBTa2lwU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL3BsYXRmb3JtJztcblxuXG4vLyBUaGlzIGlzIHRoZSB2YWx1ZSB1c2VkIGJ5IEFuZ3VsYXJKUyBNYXRlcmlhbC4gVGhyb3VnaCB0cmlhbCBhbmQgZXJyb3IgKG9uIGlQaG9uZSA2UykgdGhleSBmb3VuZFxuLy8gdGhhdCBhIHZhbHVlIG9mIGFyb3VuZCA2NTBtcyBzZWVtcyBhcHByb3ByaWF0ZS5cbmV4cG9ydCBjb25zdCBUT1VDSF9CVUZGRVJfTVMgPSA2NTA7XG5cblxuZXhwb3J0IHR5cGUgRm9jdXNPcmlnaW4gPSAndG91Y2gnIHwgJ21vdXNlJyB8ICdrZXlib2FyZCcgfCAncHJvZ3JhbSc7XG5cblxudHlwZSBNb25pdG9yZWRFbGVtZW50SW5mbyA9IHtcbiAgdW5saXN0ZW46IEZ1bmN0aW9uLFxuICBjaGVja0NoaWxkcmVuOiBib29sZWFuLFxuICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICBzdWJqZWN0OiBTdWJqZWN0PEZvY3VzT3JpZ2luPlxufTtcblxuXG4vKiogTW9uaXRvcnMgbW91c2UgYW5kIGtleWJvYXJkIGV2ZW50cyB0byBkZXRlcm1pbmUgdGhlIGNhdXNlIG9mIGZvY3VzIGV2ZW50cy4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGb2N1c09yaWdpbk1vbml0b3Ige1xuICAvKiogVGhlIGZvY3VzIG9yaWdpbiB0aGF0IHRoZSBuZXh0IGZvY3VzIGV2ZW50IGlzIGEgcmVzdWx0IG9mLiAqL1xuICBwcml2YXRlIF9vcmlnaW46IEZvY3VzT3JpZ2luID0gbnVsbDtcblxuICAvKiogVGhlIEZvY3VzT3JpZ2luIG9mIHRoZSBsYXN0IGZvY3VzIGV2ZW50IHRyYWNrZWQgYnkgdGhlIEZvY3VzT3JpZ2luTW9uaXRvci4gKi9cbiAgcHJpdmF0ZSBfbGFzdEZvY3VzT3JpZ2luOiBGb2N1c09yaWdpbjtcblxuICAvKiogV2hldGhlciB0aGUgd2luZG93IGhhcyBqdXN0IGJlZW4gZm9jdXNlZC4gKi9cbiAgcHJpdmF0ZSBfd2luZG93Rm9jdXNlZCA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgdGFyZ2V0IG9mIHRoZSBsYXN0IHRvdWNoIGV2ZW50LiAqL1xuICBwcml2YXRlIF9sYXN0VG91Y2hUYXJnZXQ6IEV2ZW50VGFyZ2V0O1xuXG4gIC8qKiBUaGUgdGltZW91dCBpZCBvZiB0aGUgdG91Y2ggdGltZW91dCwgdXNlZCB0byBjYW5jZWwgdGltZW91dCBsYXRlci4gKi9cbiAgcHJpdmF0ZSBfdG91Y2hUaW1lb3V0OiBhbnk7XG5cbiAgLyoqIFdlYWsgbWFwIG9mIGVsZW1lbnRzIGJlaW5nIG1vbml0b3JlZCB0byB0aGVpciBpbmZvLiAqL1xuICBwcml2YXRlIF9lbGVtZW50SW5mbyA9IG5ldyBXZWFrTWFwPEVsZW1lbnQsIE1vbml0b3JlZEVsZW1lbnRJbmZvPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nWm9uZTogTmdab25lLCBwcml2YXRlIF9wbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5fcmVnaXN0ZXJEb2N1bWVudEV2ZW50cygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9ycyBmb2N1cyBvbiBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIGFwcHJvcHJpYXRlIENTUyBjbGFzc2VzLlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSByZW5kZXJlciBUaGUgcmVuZGVyZXIgdG8gdXNlIHRvIGFwcGx5IENTUyBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2hlY2tDaGlsZHJlbiBXaGV0aGVyIHRvIGNvdW50IHRoZSBlbGVtZW50IGFzIGZvY3VzZWQgd2hlbiBpdHMgY2hpbGRyZW4gYXJlIGZvY3VzZWQuXG4gICAqIEByZXR1cm5zIEFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuIHRoZSBmb2N1cyBzdGF0ZSBvZiB0aGUgZWxlbWVudCBjaGFuZ2VzLlxuICAgKiAgICAgV2hlbiB0aGUgZWxlbWVudCBpcyBibHVycmVkLCBudWxsIHdpbGwgYmUgZW1pdHRlZC5cbiAgICovXG4gIG1vbml0b3IoXG4gICAgICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICBjaGVja0NoaWxkcmVuOiBib29sZWFuKTogT2JzZXJ2YWJsZTxGb2N1c09yaWdpbj4ge1xuICAgIC8vIERvIG5vdGhpbmcgaWYgd2UncmUgbm90IG9uIHRoZSBicm93c2VyIHBsYXRmb3JtLlxuICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm4gb2YoKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWxyZWFkeSBtb25pdG9yaW5nIHRoaXMgZWxlbWVudC5cbiAgICBpZiAodGhpcy5fZWxlbWVudEluZm8uaGFzKGVsZW1lbnQpKSB7XG4gICAgICBsZXQgaW5mbyA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChlbGVtZW50KTtcbiAgICAgIGluZm8uY2hlY2tDaGlsZHJlbiA9IGNoZWNrQ2hpbGRyZW47XG4gICAgICByZXR1cm4gaW5mby5zdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBtb25pdG9yZWQgZWxlbWVudCBpbmZvLlxuICAgIGxldCBpbmZvOiBNb25pdG9yZWRFbGVtZW50SW5mbyA9IHtcbiAgICAgIHVubGlzdGVuOiBudWxsLFxuICAgICAgY2hlY2tDaGlsZHJlbjogY2hlY2tDaGlsZHJlbixcbiAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgIHN1YmplY3Q6IG5ldyBTdWJqZWN0PEZvY3VzT3JpZ2luPigpXG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50SW5mby5zZXQoZWxlbWVudCwgaW5mbyk7XG5cbiAgICAvLyBTdGFydCBsaXN0ZW5pbmcuIFdlIG5lZWQgdG8gbGlzdGVuIGluIGNhcHR1cmUgcGhhc2Ugc2luY2UgZm9jdXMgZXZlbnRzIGRvbid0IGJ1YmJsZS5cbiAgICBsZXQgZm9jdXNMaXN0ZW5lciA9IChldmVudDogRm9jdXNFdmVudCkgPT4gdGhpcy5fb25Gb2N1cyhldmVudCwgZWxlbWVudCk7XG4gICAgbGV0IGJsdXJMaXN0ZW5lciA9IChldmVudDogRm9jdXNFdmVudCkgPT4gdGhpcy5fb25CbHVyKGV2ZW50LCBlbGVtZW50KTtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZvY3VzTGlzdGVuZXIsIHRydWUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckxpc3RlbmVyLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhbiB1bmxpc3RlbiBmdW5jdGlvbiBmb3IgbGF0ZXIuXG4gICAgaW5mby51bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmb2N1c0xpc3RlbmVyLCB0cnVlKTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbmZvLnN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbW9uaXRvcmluZyBhbiBlbGVtZW50IGFuZCByZW1vdmVzIGFsbCBmb2N1cyBjbGFzc2VzLlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzdG9wIG1vbml0b3JpbmcuXG4gICAqL1xuICBzdG9wTW9uaXRvcmluZyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgIGxldCBlbGVtZW50SW5mbyA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50SW5mbykge1xuICAgICAgZWxlbWVudEluZm8udW5saXN0ZW4oKTtcbiAgICAgIGVsZW1lbnRJbmZvLnN1YmplY3QuY29tcGxldGUoKTtcblxuICAgICAgdGhpcy5fc2V0Q2xhc3NlcyhlbGVtZW50LCBudWxsKTtcbiAgICAgIHRoaXMuX2VsZW1lbnRJbmZvLmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgZWxlbWVudCB2aWEgdGhlIHNwZWNpZmllZCBmb2N1cyBvcmlnaW4uXG4gICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGZvY3VzLlxuICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBmb2N1cyBvcmlnaW4uXG4gICAqL1xuICBmb2N1c1ZpYShlbGVtZW50OiBIVE1MRWxlbWVudCwgb3JpZ2luOiBGb2N1c09yaWdpbik6IHZvaWQge1xuICAgIHRoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKG9yaWdpbik7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLyoqIFJlZ2lzdGVyIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGRvY3VtZW50IGFuZCB3aW5kb3cuICovXG4gIHByaXZhdGUgX3JlZ2lzdGVyRG9jdW1lbnRFdmVudHMoKSB7XG4gICAgLy8gRG8gbm90aGluZyBpZiB3ZSdyZSBub3Qgb24gdGhlIGJyb3dzZXIgcGxhdGZvcm0uXG4gICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiB3ZSBsaXN0ZW4gdG8gZXZlbnRzIGluIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHdlIGNhbiBkZXRlY3QgdGhlbSBldmVuIGlmIHRoZSB1c2VyIHN0b3BzXG4gICAgLy8gcHJvcGFnYXRpb24uXG5cbiAgICAvLyBPbiBrZXlkb3duIHJlY29yZCB0aGUgb3JpZ2luIGFuZCBjbGVhciBhbnkgdG91Y2ggZXZlbnQgdGhhdCBtYXkgYmUgaW4gcHJvZ3Jlc3MuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsICgpID0+IHtcbiAgICAgIHRoaXMuX2xhc3RUb3VjaFRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZSgna2V5Ym9hcmQnKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIE9uIG1vdXNlZG93biByZWNvcmQgdGhlIG9yaWdpbiBvbmx5IGlmIHRoZXJlIGlzIG5vdCB0b3VjaCB0YXJnZXQsIHNpbmNlIGEgbW91c2Vkb3duIGNhblxuICAgIC8vIGhhcHBlbiBhcyBhIHJlc3VsdCBvZiBhIHRvdWNoIGV2ZW50LlxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fbGFzdFRvdWNoVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKCdtb3VzZScpO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuXG4gICAgLy8gV2hlbiB0aGUgdG91Y2hzdGFydCBldmVudCBmaXJlcyB0aGUgZm9jdXMgZXZlbnQgaXMgbm90IHlldCBpbiB0aGUgZXZlbnQgcXVldWUuIFRoaXMgbWVhbnNcbiAgICAvLyB3ZSBjYW4ndCByZWx5IG9uIHRoZSB0cmljayB1c2VkIGFib3ZlIChzZXR0aW5nIHRpbWVvdXQgb2YgMG1zKS4gSW5zdGVhZCB3ZSB3YWl0IDY1MG1zIHRvXG4gICAgLy8gc2VlIGlmIGEgZm9jdXMgaGFwcGVucy5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3RvdWNoVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90b3VjaFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdFRvdWNoVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgdGhpcy5fdG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9sYXN0VG91Y2hUYXJnZXQgPSBudWxsLCBUT1VDSF9CVUZGRVJfTVMpO1xuICAgIH0sIHRydWUpO1xuXG4gICAgLy8gTWFrZSBhIG5vdGUgb2Ygd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXMsIHNvIHdlIGNhbiByZXN0b3JlIHRoZSBvcmlnaW4gaW5mbyBmb3IgdGhlXG4gICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgIHRoaXMuX3dpbmRvd0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl93aW5kb3dGb2N1c2VkID0gZmFsc2UsIDApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZvY3VzIGNsYXNzZXMgb24gdGhlIGVsZW1lbnQgYmFzZWQgb24gdGhlIGdpdmVuIGZvY3VzIG9yaWdpbi5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdXBkYXRlIHRoZSBjbGFzc2VzIG9uLlxuICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBmb2N1cyBvcmlnaW4uXG4gICAqL1xuICBwcml2YXRlIF9zZXRDbGFzc2VzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBvcmlnaW46IEZvY3VzT3JpZ2luKTogdm9pZCB7XG4gICAgbGV0IHJlbmRlcmVyID0gdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpLnJlbmRlcmVyO1xuICAgIGxldCB0b2dnbGVDbGFzcyA9IChjbGFzc05hbWU6IHN0cmluZywgc2hvdWxkU2V0OiBib29sZWFuKSA9PiB7XG4gICAgICBzaG91bGRTZXQgPyByZW5kZXJlci5hZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIDogcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9O1xuXG4gICAgdG9nZ2xlQ2xhc3MoJ2Nkay1mb2N1c2VkJywgISFvcmlnaW4pO1xuICAgIHRvZ2dsZUNsYXNzKCdjZGstdG91Y2gtZm9jdXNlZCcsIG9yaWdpbiA9PT0gJ3RvdWNoJyk7XG4gICAgdG9nZ2xlQ2xhc3MoJ2Nkay1rZXlib2FyZC1mb2N1c2VkJywgb3JpZ2luID09PSAna2V5Ym9hcmQnKTtcbiAgICB0b2dnbGVDbGFzcygnY2RrLW1vdXNlLWZvY3VzZWQnLCBvcmlnaW4gPT09ICdtb3VzZScpO1xuICAgIHRvZ2dsZUNsYXNzKCdjZGstcHJvZ3JhbS1mb2N1c2VkJywgb3JpZ2luID09PSAncHJvZ3JhbScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9yaWdpbiBhbmQgc2NoZWR1bGVzIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNsZWFyIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IHF1ZXVlLlxuICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gdG8gc2V0LlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0T3JpZ2luRm9yQ3VycmVudEV2ZW50UXVldWUob3JpZ2luOiBGb2N1c09yaWdpbik6IHZvaWQge1xuICAgIHRoaXMuX29yaWdpbiA9IG9yaWdpbjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX29yaWdpbiA9IG51bGwsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBmb2N1cyBldmVudCB3YXMgY2F1c2VkIGJ5IGEgdG91Y2hzdGFydCBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50IFRoZSBmb2N1cyBldmVudCB0byBjaGVjay5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgZXZlbnQgd2FzIGNhdXNlZCBieSBhIHRvdWNoLlxuICAgKi9cbiAgcHJpdmF0ZSBfd2FzQ2F1c2VkQnlUb3VjaChldmVudDogRm9jdXNFdmVudCk6IGJvb2xlYW4ge1xuICAgIC8vIE5vdGUobW1hbGVyYmEpOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCBxdWl0ZSBwZXJmZWN0LCB0aGVyZSBpcyBhIHNtYWxsIGVkZ2UgY2FzZS5cbiAgICAvLyBDb25zaWRlciB0aGUgZm9sbG93aW5nIGRvbSBzdHJ1Y3R1cmU6XG4gICAgLy9cbiAgICAvLyA8ZGl2ICNwYXJlbnQgdGFiaW5kZXg9XCIwXCIgY2RrRm9jdXNDbGFzc2VzPlxuICAgIC8vICAgPGRpdiAjY2hpbGQgKGNsaWNrKT1cIiNwYXJlbnQuZm9jdXMoKVwiPjwvZGl2PlxuICAgIC8vIDwvZGl2PlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIHVzZXIgdG91Y2hlcyB0aGUgI2NoaWxkIGVsZW1lbnQgYW5kIHRoZSAjcGFyZW50IGlzIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNlZCBhcyBhXG4gICAgLy8gcmVzdWx0LCB0aGlzIGNvZGUgd2lsbCBzdGlsbCBjb25zaWRlciBpdCB0byBoYXZlIGJlZW4gY2F1c2VkIGJ5IHRoZSB0b3VjaCBldmVudCBhbmQgd2lsbFxuICAgIC8vIGFwcGx5IHRoZSBjZGstdG91Y2gtZm9jdXNlZCBjbGFzcyByYXRoZXIgdGhhbiB0aGUgY2RrLXByb2dyYW0tZm9jdXNlZCBjbGFzcy4gVGhpcyBpcyBhXG4gICAgLy8gcmVsYXRpdmVseSBzbWFsbCBlZGdlLWNhc2UgdGhhdCBjYW4gYmUgd29ya2VkIGFyb3VuZCBieSB1c2luZ1xuICAgIC8vIGZvY3VzVmlhKHBhcmVudEVsLCByZW5kZXJlciwgICdwcm9ncmFtJykgdG8gZm9jdXMgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gSWYgd2UgZGVjaWRlIHRoYXQgd2UgYWJzb2x1dGVseSBtdXN0IGhhbmRsZSB0aGlzIGNhc2UgY29ycmVjdGx5LCB3ZSBjYW4gZG8gc28gYnkgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHRoZSBmaXJzdCBmb2N1cyBldmVudCBhZnRlciB0aGUgdG91Y2hzdGFydCwgYW5kIHRoZW4gdGhlIGZpcnN0IGJsdXIgZXZlbnQgYWZ0ZXIgdGhhdFxuICAgIC8vIGZvY3VzIGV2ZW50LiBXaGVuIHRoYXQgYmx1ciBldmVudCBmaXJlcyB3ZSBrbm93IHRoYXQgd2hhdGV2ZXIgZm9sbG93cyBpcyBub3QgYSByZXN1bHQgb2YgdGhlXG4gICAgLy8gdG91Y2hzdGFydC5cbiAgICBsZXQgZm9jdXNUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RUb3VjaFRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiYgZm9jdXNUYXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmXG4gICAgICAgIChmb2N1c1RhcmdldCA9PT0gdGhpcy5fbGFzdFRvdWNoVGFyZ2V0IHx8IGZvY3VzVGFyZ2V0LmNvbnRhaW5zKHRoaXMuX2xhc3RUb3VjaFRhcmdldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZm9jdXMgZXZlbnRzIG9uIGEgcmVnaXN0ZXJlZCBlbGVtZW50LlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGZvY3VzIGV2ZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgbW9uaXRvcmVkIGVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9vbkZvY3VzKGV2ZW50OiBGb2N1c0V2ZW50LCBlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIC8vIE5PVEUobW1hbGVyYmEpOiBXZSBjdXJyZW50bHkgc2V0IHRoZSBjbGFzc2VzIGJhc2VkIG9uIHRoZSBmb2N1cyBvcmlnaW4gb2YgdGhlIG1vc3QgcmVjZW50XG4gICAgLy8gZm9jdXMgZXZlbnQgYWZmZWN0aW5nIHRoZSBtb25pdG9yZWQgZWxlbWVudC4gSWYgd2Ugd2FudCB0byB1c2UgdGhlIG9yaWdpbiBvZiB0aGUgZmlyc3QgZXZlbnRcbiAgICAvLyBpbnN0ZWFkIHdlIHNob3VsZCBjaGVjayBmb3IgdGhlIGNkay1mb2N1c2VkIGNsYXNzIGhlcmUgYW5kIHJldHVybiBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhc1xuICAgIC8vIGl0LiAoVGhpcyBvbmx5IG1hdHRlcnMgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBpbmNsdWRlc0NoaWxkcmVuID0gdHJ1ZSkuXG5cbiAgICAvLyBJZiB3ZSBhcmUgbm90IGNvdW50aW5nIGNoaWxkLWVsZW1lbnQtZm9jdXMgYXMgZm9jdXNlZCwgbWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IHRhcmdldCBpcyB0aGVcbiAgICAvLyBtb25pdG9yZWQgZWxlbWVudCBpdHNlbGYuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCkuY2hlY2tDaGlsZHJlbiAmJiBlbGVtZW50ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjb3VsZG4ndCBkZXRlY3QgYSBjYXVzZSBmb3IgdGhlIGZvY3VzIGV2ZW50LCBpdCdzIGR1ZSB0byBvbmUgb2YgdGhyZWUgcmVhc29uczpcbiAgICAvLyAxKSBUaGUgd2luZG93IGhhcyBqdXN0IHJlZ2FpbmVkIGZvY3VzLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gcmVzdG9yZSB0aGUgZm9jdXNlZCBzdGF0ZSBvZlxuICAgIC8vICAgIHRoZSBlbGVtZW50IGZyb20gYmVmb3JlIHRoZSB3aW5kb3cgYmx1cnJlZC5cbiAgICAvLyAyKSBJdCB3YXMgY2F1c2VkIGJ5IGEgdG91Y2ggZXZlbnQsIGluIHdoaWNoIGNhc2Ugd2UgbWFyayB0aGUgb3JpZ2luIGFzICd0b3VjaCcuXG4gICAgLy8gMykgVGhlIGVsZW1lbnQgd2FzIHByb2dyYW1tYXRpY2FsbHkgZm9jdXNlZCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgbWFyayB0aGUgb3JpZ2luIGFzXG4gICAgLy8gICAgJ3Byb2dyYW0nLlxuICAgIGlmICghdGhpcy5fb3JpZ2luKSB7XG4gICAgICBpZiAodGhpcy5fd2luZG93Rm9jdXNlZCAmJiB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fbGFzdEZvY3VzT3JpZ2luO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YXNDYXVzZWRCeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSAndG91Y2gnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gJ3Byb2dyYW0nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NldENsYXNzZXMoZWxlbWVudCwgdGhpcy5fb3JpZ2luKTtcbiAgICB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCkuc3ViamVjdC5uZXh0KHRoaXMuX29yaWdpbik7XG4gICAgdGhpcy5fbGFzdEZvY3VzT3JpZ2luID0gdGhpcy5fb3JpZ2luO1xuICAgIHRoaXMuX29yaWdpbiA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBibHVyIGV2ZW50cyBvbiBhIHJlZ2lzdGVyZWQgZWxlbWVudC5cbiAgICogQHBhcmFtIGV2ZW50IFRoZSBibHVyIGV2ZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgbW9uaXRvcmVkIGVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9vbkJsdXIoZXZlbnQ6IEZvY3VzRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gSWYgd2UgYXJlIGNvdW50aW5nIGNoaWxkLWVsZW1lbnQtZm9jdXMgYXMgZm9jdXNlZCwgbWFrZSBzdXJlIHRoYXQgd2UgYXJlbid0IGp1c3QgYmx1cnJpbmcgaW5cbiAgICAvLyBvcmRlciB0byBmb2N1cyBhbm90aGVyIGNoaWxkIG9mIHRoZSBtb25pdG9yZWQgZWxlbWVudC5cbiAgICBpZiAodGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpLmNoZWNrQ2hpbGRyZW4gJiYgZXZlbnQucmVsYXRlZFRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiZcbiAgICAgICAgZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NldENsYXNzZXMoZWxlbWVudCwgbnVsbCk7XG4gICAgdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpLnN1YmplY3QubmV4dChudWxsKTtcbiAgfVxufVxuXG5cbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBwYXJ0aWN1bGFyIGVsZW1lbnQgd2FzIGZvY3VzZWQgKHZpYSBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBvclxuICogcHJvZ3JhbW1hdGljYWxseSkgYW5kIGFkZHMgY29ycmVzcG9uZGluZyBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gdmFyaWFudHMgb2YgdGhpcyBkaXJlY3RpdmU6XG4gKiAxKSBjZGtNb25pdG9yRWxlbWVudEZvY3VzOiBkb2VzIG5vdCBjb25zaWRlciBhbiBlbGVtZW50IHRvIGJlIGZvY3VzZWQgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICogICAgZm9jdXNlZC5cbiAqIDIpIGNka01vbml0b3JTdWJ0cmVlRm9jdXM6IGNvbnNpZGVycyBhbiBlbGVtZW50IGZvY3VzZWQgaWYgaXQgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBhcmUgZm9jdXNlZC5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2Nka01vbml0b3JFbGVtZW50Rm9jdXNdLCBbY2RrTW9uaXRvclN1YnRyZWVGb2N1c10nLFxufSlcbmV4cG9ydCBjbGFzcyBDZGtNb25pdG9yRm9jdXMgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBAT3V0cHV0KCkgY2RrRm9jdXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEZvY3VzT3JpZ2luPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX2ZvY3VzT3JpZ2luTW9uaXRvcjogRm9jdXNPcmlnaW5Nb25pdG9yLFxuICAgICAgICAgICAgICByZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLm1vbml0b3IoXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgcmVuZGVyZXIsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Nka01vbml0b3JTdWJ0cmVlRm9jdXMnKSlcbiAgICAgICAgLnN1YnNjcmliZShvcmlnaW4gPT4gdGhpcy5jZGtGb2N1c0NoYW5nZS5lbWl0KG9yaWdpbikpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZm9jdXNPcmlnaW5Nb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJfRkFDVE9SWShcbiAgICBwYXJlbnREaXNwYXRjaGVyOiBGb2N1c09yaWdpbk1vbml0b3IsIG5nWm9uZTogTmdab25lLCBwbGF0Zm9ybTogUGxhdGZvcm0pIHtcbiAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IEZvY3VzT3JpZ2luTW9uaXRvcihuZ1pvbmUsIHBsYXRmb3JtKTtcbn1cblxuXG5leHBvcnQgY29uc3QgRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVIgPSB7XG4gIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBGb2N1c09yaWdpbk1vbml0b3IgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgcHJvdmlkZTogRm9jdXNPcmlnaW5Nb25pdG9yLFxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgRm9jdXNPcmlnaW5Nb25pdG9yXSwgTmdab25lLCBQbGF0Zm9ybV0sXG4gIHVzZUZhY3Rvcnk6IEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUllcbn07XG4iLCIvKipcbiAqIEFwcGxpZXMgYSBDU1MgdHJhbnNmb3JtIHRvIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBicm93c2VyLXByZWZpeGVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHBhcmFtIHRyYW5zZm9ybVZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNzc1RyYW5zZm9ybShlbGVtZW50OiBIVE1MRWxlbWVudCwgdHJhbnNmb3JtVmFsdWU6IHN0cmluZykge1xuICAvLyBJdCdzIGltcG9ydGFudCB0byB0cmltIHRoZSByZXN1bHQsIGJlY2F1c2UgdGhlIGJyb3dzZXIgd2lsbCBpZ25vcmUgdGhlIHNldCBvcGVyYXRpb25cbiAgLy8gaWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2UuXG4gIGxldCB2YWx1ZSA9IHRyYW5zZm9ybVZhbHVlLnRyaW0oKTtcblxuICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlO1xuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlO1xufVxuIiwiaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Nka01vbml0b3JGb2N1cywgRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJ9IGZyb20gJy4vZm9jdXMtb3JpZ2luLW1vbml0b3InO1xuaW1wb3J0IHtQbGF0Zm9ybU1vZHVsZX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXgnO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtQbGF0Zm9ybU1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0Nka01vbml0b3JGb2N1c10sXG4gIGV4cG9ydHM6IFtDZGtNb25pdG9yRm9jdXNdLFxuICBwcm92aWRlcnM6IFtGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIFN0eWxlTW9kdWxlIHt9XG5cblxuZXhwb3J0ICogZnJvbSAnLi9mb2N1cy1vcmlnaW4tbW9uaXRvcic7XG5leHBvcnQgKiBmcm9tICcuL2FwcGx5LXRyYW5zZm9ybSc7XG4iLCIvKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkN1cnZlcyB7XG4gIHN0YXRpYyBTVEFOREFSRF9DVVJWRSA9ICdjdWJpYy1iZXppZXIoMC40LDAuMCwwLjIsMSknO1xuICBzdGF0aWMgREVDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjAsMC4wLDAuMiwxKSc7XG4gIHN0YXRpYyBBQ0NFTEVSQVRJT05fQ1VSVkUgPSAnY3ViaWMtYmV6aWVyKDAuNCwwLjAsMSwxKSc7XG4gIHN0YXRpYyBTSEFSUF9DVVJWRSA9ICdjdWJpYy1iZXppZXIoMC40LDAuMCwwLjYsMSknO1xufVxuXG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRHVyYXRpb25zIHtcbiAgc3RhdGljIENPTVBMRVggPSAnMzc1bXMnO1xuICBzdGF0aWMgRU5URVJJTkcgPSAnMjI1bXMnO1xuICBzdGF0aWMgRVhJVElORyA9ICcxOTVtcyc7XG59XG4iLCIvKiogQ29lcmNlcyBhIGRhdGEtYm91bmQgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZykgdG8gYSBudW1iZXIuICovXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWU6IGFueSwgZmFsbGJhY2tWYWx1ZSA9IDApIHtcbiAgLy8gcGFyc2VGbG9hdCh2YWx1ZSkgaGFuZGxlcyBtb3N0IG9mIHRoZSBjYXNlcyB3ZSdyZSBpbnRlcmVzdGVkIGluIChpdCB0cmVhdHMgbnVsbCwgZW1wdHkgc3RyaW5nLFxuICAvLyBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMgYXMgTmFOLCB3aGVyZSBOdW1iZXIganVzdCB1c2VzIDApIGJ1dCBpdCBjb25zaWRlcnMgdGhlIHN0cmluZ1xuICAvLyAnMTIzaGVsbG8nIHRvIGJlIGEgdmFsaWQgbnVtYmVyLiBUaGVyZWZvcmUgd2UgYWxzbyBjaGVjayBpZiBOdW1iZXIodmFsdWUpIGlzIE5hTi5cbiAgcmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQodmFsdWUgYXMgYW55KSkgfHwgaXNOYU4oTnVtYmVyKHZhbHVlKSkgPyBmYWxsYmFja1ZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbn1cbiIsIi8qKiBBZGFwdHMgdHlwZSBgRGAgdG8gYmUgdXNhYmxlIGFzIGEgZGF0ZSBieSBjZGstYmFzZWQgY29tcG9uZW50cyB0aGF0IHdvcmsgd2l0aCBkYXRlcy4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlQWRhcHRlcjxEPiB7XG4gIC8qKiBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgYWxsIGRhdGVzLiAqL1xuICBwcm90ZWN0ZWQgbG9jYWxlOiBhbnk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHllYXIgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSB5ZWFyIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSB5ZWFyIGNvbXBvbmVudC5cbiAgICovXG4gIGFic3RyYWN0IGdldFllYXIoZGF0ZTogRCk6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGggY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBtb250aCBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgbW9udGggY29tcG9uZW50ICgwLWluZGV4ZWQsIDAgPSBKYW51YXJ5KS5cbiAgICovXG4gIGFic3RyYWN0IGdldE1vbnRoKGRhdGU6IEQpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGUgb2YgdGhlIG1vbnRoIGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZXh0cmFjdCB0aGUgZGF0ZSBvZiB0aGUgbW9udGggZnJvbS5cbiAgICogQHJldHVybnMgVGhlIG1vbnRoIGNvbXBvbmVudCAoMS1pbmRleGVkLCAxID0gZmlyc3Qgb2YgbW9udGgpLlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0RGF0ZShkYXRlOiBEKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXkgb2YgdGhlIHdlZWsgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBleHRyYWN0IHRoZSBkYXkgb2YgdGhlIHdlZWsgZnJvbS5cbiAgICogQHJldHVybnMgVGhlIG1vbnRoIGNvbXBvbmVudCAoMC1pbmRleGVkLCAwID0gU3VuZGF5KS5cbiAgICovXG4gIGFic3RyYWN0IGdldERheU9mV2VlayhkYXRlOiBEKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgbGlzdCBvZiBuYW1lcyBmb3IgdGhlIG1vbnRocy5cbiAgICogQHBhcmFtIHN0eWxlIFRoZSBuYW1pbmcgc3R5bGUgKGUuZy4gbG9uZyA9ICdKYW51YXJ5Jywgc2hvcnQgPSAnSmFuJywgbmFycm93ID0gJ0onKS5cbiAgICogQHJldHVybnMgQW4gb3JkZXJlZCBsaXN0IG9mIGFsbCBtb250aCBuYW1lcywgc3RhcnRpbmcgd2l0aCBKYW51YXJ5LlxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0TW9udGhOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIG5hbWVzIGZvciB0aGUgZGF0ZXMgb2YgdGhlIG1vbnRoLlxuICAgKiBAcmV0dXJucyBBbiBvcmRlcmVkIGxpc3Qgb2YgYWxsIGRhdGUgb2YgdGhlIG1vbnRoIG5hbWVzLCBzdGFydGluZyB3aXRoICcxJy5cbiAgICovXG4gIGFic3RyYWN0IGdldERhdGVOYW1lcygpOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgbmFtZXMgZm9yIHRoZSBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgKiBAcGFyYW0gc3R5bGUgVGhlIG5hbWluZyBzdHlsZSAoZS5nLiBsb25nID0gJ1N1bmRheScsIHNob3J0ID0gJ1N1bicsIG5hcnJvdyA9ICdTJykuXG4gICAqIEByZXR1cm5zIEFuIG9yZGVyZWQgbGlzdCBvZiBhbGwgd2Vla2RheSBuYW1lcywgc3RhcnRpbmcgd2l0aCBTdW5kYXkuXG4gICAqL1xuICBhYnN0cmFjdCBnZXREYXlPZldlZWtOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hbWUgZm9yIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBnZXQgdGhlIHllYXIgbmFtZSBmb3IuXG4gICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBnaXZlbiB5ZWFyIChlLmcuICcyMDE3JykuXG4gICAqL1xuICBhYnN0cmFjdCBnZXRZZWFyTmFtZShkYXRlOiBEKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIEByZXR1cm5zIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAtaW5kZXhlZCwgMCA9IFN1bmRheSkuXG4gICAqL1xuICBhYnN0cmFjdCBnZXRGaXJzdERheU9mV2VlaygpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgd2hvc2UgbW9udGggc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAqL1xuICBhYnN0cmFjdCBnZXROdW1EYXlzSW5Nb250aChkYXRlOiBEKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIGdpdmVuIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNsb25lXG4gICAqIEByZXR1cm5zIEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIGRhdGUuXG4gICAqL1xuICBhYnN0cmFjdCBjbG9uZShkYXRlOiBEKTogRDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRhdGUgd2l0aCB0aGUgZ2l2ZW4geWVhciwgbW9udGgsIGFuZCBkYXRlLiBEb2VzIG5vdCBhbGxvdyBvdmVyL3VuZGVyLWZsb3cgb2YgdGhlXG4gICAqIG1vbnRoIGFuZCBkYXRlLlxuICAgKiBAcGFyYW0geWVhciBUaGUgZnVsbCB5ZWFyIG9mIHRoZSBkYXRlLiAoZS5nLiA4OSBtZWFucyB0aGUgeWVhciA4OSwgbm90IHRoZSB5ZWFyIDE5ODkpLlxuICAgKiBAcGFyYW0gbW9udGggVGhlIG1vbnRoIG9mIHRoZSBkYXRlICgwLWluZGV4ZWQsIDAgPSBKYW51YXJ5KS4gTXVzdCBiZSBhbiBpbnRlZ2VyIDAgLSAxMS5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgb2YgbW9udGggb2YgdGhlIGRhdGUuIE11c3QgYmUgYW4gaW50ZWdlciAxIC0gbGVuZ3RoIG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICogQHJldHVybnMgVGhlIG5ldyBkYXRlLCBvciBudWxsIGlmIGludmFsaWQuXG4gICAqL1xuICBhYnN0cmFjdCBjcmVhdGVEYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyKTogRDtcblxuICAvKipcbiAgICogR2V0cyB0b2RheSdzIGRhdGUuXG4gICAqIEByZXR1cm5zIFRvZGF5J3MgZGF0ZS5cbiAgICovXG4gIGFic3RyYWN0IHRvZGF5KCk6IEQ7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGRhdGUgZnJvbSBhIHZhbHVlLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgKiBAcGFyYW0gcGFyc2VGb3JtYXQgVGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgdmFsdWUgYmVpbmcgcGFyc2VkXG4gICAqICAgICAodHlwZSBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQpLlxuICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGUsIG9yIG51bGwgaWYgZGF0ZSBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgKi9cbiAgYWJzdHJhY3QgcGFyc2UodmFsdWU6IGFueSwgcGFyc2VGb3JtYXQ6IGFueSk6IEQgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgZGF0ZSBhcyBhIHN0cmluZy5cbiAgICogQHBhcmFtIGRhdGUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgKiBAcGFyYW0gZGlzcGxheUZvcm1hdCBUaGUgZm9ybWF0IHRvIHVzZSB0byBkaXNwbGF5IHRoZSBkYXRlIGFzIGEgc3RyaW5nLlxuICAgKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGUsIG9yIG51bGwgaWYgZGF0ZSBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgKi9cbiAgYWJzdHJhY3QgZm9ybWF0KGRhdGU6IEQsIGRpc3BsYXlGb3JtYXQ6IGFueSk6IHN0cmluZztcblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHllYXJzIHRvIHRoZSBkYXRlLiBZZWFycyBhcmUgY291bnRlZCBhcyBpZiBmbGlwcGluZyAxMiBwYWdlcyBvbiB0aGVcbiAgICogY2FsZW5kYXIgZm9yIGVhY2ggeWVhciBhbmQgdGhlbiBmaW5kaW5nIHRoZSBjbG9zZXN0IGRhdGUgaW4gdGhlIG5ldyBtb250aC4gRm9yIGV4YW1wbGUgd2hlblxuICAgKiBhZGRpbmcgMSB5ZWFyIHRvIEZlYiAyOSwgMjAxNiwgdGhlIHJlc3VsdGluZyBkYXRlIHdpbGwgYmUgRmViIDI4LCAyMDE3LlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBhZGQgeWVhcnMgdG8uXG4gICAqIEBwYXJhbSB5ZWFycyBUaGUgbnVtYmVyIG9mIHllYXJzIHRvIGFkZCAobWF5IGJlIG5lZ2F0aXZlKS5cbiAgICogQHJldHVybnMgQSBuZXcgZGF0ZSBlcXVhbCB0byB0aGUgZ2l2ZW4gb25lIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgeWVhcnMgYWRkZWQuXG4gICAqL1xuICBhYnN0cmFjdCBhZGRDYWxlbmRhclllYXJzKGRhdGU6IEQsIHllYXJzOiBudW1iZXIpOiBEO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBudW1iZXIgb2YgbW9udGhzIHRvIHRoZSBkYXRlLiBNb250aHMgYXJlIGNvdW50ZWQgYXMgaWYgZmxpcHBpbmcgYSBwYWdlIG9uIHRoZVxuICAgKiBjYWxlbmRhciBmb3IgZWFjaCBtb250aCBhbmQgdGhlbiBmaW5kaW5nIHRoZSBjbG9zZXN0IGRhdGUgaW4gdGhlIG5ldyBtb250aC4gRm9yIGV4YW1wbGUgd2hlblxuICAgKiBhZGRpbmcgMSBtb250aCB0byBKYW4gMzEsIDIwMTcsIHRoZSByZXN1bHRpbmcgZGF0ZSB3aWxsIGJlIEZlYiAyOCwgMjAxNy5cbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gYWRkIG1vbnRocyB0by5cbiAgICogQHBhcmFtIG1vbnRocyBUaGUgbnVtYmVyIG9mIG1vbnRocyB0byBhZGQgKG1heSBiZSBuZWdhdGl2ZSkuXG4gICAqIEByZXR1cm5zIEEgbmV3IGRhdGUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1vbnRocyBhZGRlZC5cbiAgICovXG4gIGFic3RyYWN0IGFkZENhbGVuZGFyTW9udGhzKGRhdGU6IEQsIG1vbnRoczogbnVtYmVyKTogRDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGRheXMgdG8gdGhlIGRhdGUuIERheXMgYXJlIGNvdW50ZWQgYXMgaWYgbW92aW5nIG9uZSBjZWxsIG9uIHRoZVxuICAgKiBjYWxlbmRhciBmb3IgZWFjaCBkYXkuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGFkZCBkYXlzIHRvLlxuICAgKiBAcGFyYW0gZGF5cyBUaGUgbnVtYmVyIG9mIGRheXMgdG8gYWRkIChtYXkgYmUgbmVnYXRpdmUpLlxuICAgKiBAcmV0dXJucyBBIG5ldyBkYXRlIGVxdWFsIHRvIHRoZSBnaXZlbiBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzIGFkZGVkLlxuICAgKi9cbiAgYWJzdHJhY3QgYWRkQ2FsZW5kYXJEYXlzKGRhdGU6IEQsIGRheXM6IG51bWJlcik6IEQ7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIFJGQyAzMzM5IGNvbXBhdGlibGUgZGF0ZSBzdHJpbmcgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5KSAgZm9yIHRoZSBnaXZlblxuICAgKiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBnZXQgdGhlIElTTyBkYXRlIHN0cmluZyBmb3IuXG4gICAqIEByZXR1cm5zIFRoZSBJU08gZGF0ZSBzdHJpbmcgZGF0ZSBzdHJpbmcuXG4gICAqL1xuICBhYnN0cmFjdCBnZXRJU09EYXRlU3RyaW5nKGRhdGU6IEQpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvY2FsZSB1c2VkIGZvciBhbGwgZGF0ZXMuXG4gICAqIEBwYXJhbSBsb2NhbGUgVGhlIG5ldyBsb2NhbGUuXG4gICAqL1xuICBzZXRMb2NhbGUobG9jYWxlOiBhbnkpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gZGF0ZXMuXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0gc2Vjb25kIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlLlxuICAgKiBAcmV0dXJucyAwIGlmIHRoZSBkYXRlcyBhcmUgZXF1YWwsIGEgbnVtYmVyIGxlc3MgdGhhbiAwIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGVhcmxpZXIsXG4gICAqICAgICBhIG51bWJlciBncmVhdGVyIHRoYW4gMCBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBsYXRlci5cbiAgICovXG4gIGNvbXBhcmVEYXRlKGZpcnN0OiBELCBzZWNvbmQ6IEQpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFllYXIoZmlyc3QpIC0gdGhpcy5nZXRZZWFyKHNlY29uZCkgfHxcbiAgICAgICAgdGhpcy5nZXRNb250aChmaXJzdCkgLSB0aGlzLmdldE1vbnRoKHNlY29uZCkgfHxcbiAgICAgICAgdGhpcy5nZXREYXRlKGZpcnN0KSAtIHRoaXMuZ2V0RGF0ZShzZWNvbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gZGF0ZXMgYXJlIGVxdWFsLlxuICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSBzZWNvbmQgVGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0d28gZGF0ZXMgYXJlIGVxdWFsLlxuICAgKiAgICAgTnVsbCBkYXRlcyBhcmUgY29uc2lkZXJlZCBlcXVhbCB0byBvdGhlciBudWxsIGRhdGVzLlxuICAgKi9cbiAgc2FtZURhdGUoZmlyc3Q6IEQgfCBudWxsLCBzZWNvbmQ6IEQgfCBudWxsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZpcnN0ICYmIHNlY29uZCA/ICF0aGlzLmNvbXBhcmVEYXRlKGZpcnN0LCBzZWNvbmQpIDogZmlyc3QgPT0gc2Vjb25kO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYW1wIHRoZSBnaXZlbiBkYXRlIGJldHdlZW4gbWluIGFuZCBtYXggZGF0ZXMuXG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNsYW1wLlxuICAgKiBAcGFyYW0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRvIGFsbG93LiBJZiBudWxsIG9yIG9taXR0ZWQgbm8gbWluIGlzIGVuZm9yY2VkLlxuICAgKiBAcGFyYW0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRvIGFsbG93LiBJZiBudWxsIG9yIG9taXR0ZWQgbm8gbWF4IGlzIGVuZm9yY2VkLlxuICAgKiBAcmV0dXJucyBgbWluYCBpZiBgZGF0ZWAgaXMgbGVzcyB0aGFuIGBtaW5gLCBgbWF4YCBpZiBkYXRlIGlzIGdyZWF0ZXIgdGhhbiBgbWF4YCxcbiAgICogICAgIG90aGVyd2lzZSBgZGF0ZWAuXG4gICAqL1xuICBjbGFtcERhdGUoZGF0ZTogRCwgbWluPzogRCB8IG51bGwsIG1heD86IEQgfCBudWxsKTogRCB7XG4gICAgaWYgKG1pbiAmJiB0aGlzLmNvbXBhcmVEYXRlKGRhdGUsIG1pbikgPCAwKSB7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAobWF4ICYmIHRoaXMuY29tcGFyZURhdGUoZGF0ZSwgbWF4KSA+IDApIHtcbiAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9XG59XG4iLCJpbXBvcnQge0RhdGVBZGFwdGVyfSBmcm9tICcuL2RhdGUtYWRhcHRlcic7XG5cblxuLy8gVE9ETyhtbWFsZXJiYSk6IFJlbW92ZSB3aGVuIHdlIG5vIGxvbmdlciBzdXBwb3J0IHNhZmFyaSA5LlxuLyoqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEludGwgQVBJLiAqL1xuY29uc3QgU1VQUE9SVFNfSU5UTF9BUEkgPSB0eXBlb2YgSW50bCAhPSAndW5kZWZpbmVkJztcblxuXG4vKiogVGhlIGRlZmF1bHQgbW9udGggbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBERUZBVUxUX01PTlRIX05BTUVTID0ge1xuICAnbG9uZyc6IFtcbiAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLFxuICAgICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xuICBdLFxuICAnc2hvcnQnOiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gICduYXJyb3cnOiBbJ0onLCAnRicsICdNJywgJ0EnLCAnTScsICdKJywgJ0onLCAnQScsICdTJywgJ08nLCAnTicsICdEJ11cbn07XG5cblxuLyoqIFRoZSBkZWZhdWx0IGRhdGUgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBERUZBVUxUX0RBVEVfTkFNRVMgPSByYW5nZSgzMSwgaSA9PiBTdHJpbmcoaSArIDEpKTtcblxuXG4vKiogVGhlIGRlZmF1bHQgZGF5IG9mIHRoZSB3ZWVrIG5hbWVzIHRvIHVzZSBpZiBJbnRsIEFQSSBpcyBub3QgYXZhaWxhYmxlLiAqL1xuY29uc3QgREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FUyA9IHtcbiAgJ2xvbmcnOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICdzaG9ydCc6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICduYXJyb3cnOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVxufTtcblxuXG4vKiogQ3JlYXRlcyBhbiBhcnJheSBhbmQgZmlsbHMgaXQgd2l0aCB2YWx1ZXMuICovXG5mdW5jdGlvbiByYW5nZTxUPihsZW5ndGg6IG51bWJlciwgdmFsdWVGdW5jdGlvbjogKGluZGV4OiBudW1iZXIpID0+IFQpOiBUW10ge1xuICBjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZXNBcnJheVtpXSA9IHZhbHVlRnVuY3Rpb24oaSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlc0FycmF5O1xufVxuXG5cbi8qKiBBZGFwdHMgdGhlIG5hdGl2ZSBKUyBEYXRlIGZvciB1c2Ugd2l0aCBjZGstYmFzZWQgY29tcG9uZW50cyB0aGF0IHdvcmsgd2l0aCBkYXRlcy4gKi9cbmV4cG9ydCBjbGFzcyBOYXRpdmVEYXRlQWRhcHRlciBleHRlbmRzIERhdGVBZGFwdGVyPERhdGU+IHtcbiAgZ2V0WWVhcihkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9XG5cbiAgZ2V0TW9udGgoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfVxuXG4gIGdldERhdGUoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuICB9XG5cbiAgZ2V0RGF5T2ZXZWVrKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiBkYXRlLmdldERheSgpO1xuICB9XG5cbiAgZ2V0TW9udGhOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW10ge1xuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7bW9udGg6IHN0eWxlfSk7XG4gICAgICByZXR1cm4gcmFuZ2UoMTIsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCBpLCAxKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIERFRkFVTFRfTU9OVEhfTkFNRVNbc3R5bGVdO1xuICB9XG5cbiAgZ2V0RGF0ZU5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGxldCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge2RheTogJ251bWVyaWMnfSk7XG4gICAgICByZXR1cm4gcmFuZ2UoMzEsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoXG4gICAgICAgICAgZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCBpICsgMSkpKSk7XG4gICAgfVxuICAgIHJldHVybiBERUZBVUxUX0RBVEVfTkFNRVM7XG4gIH1cblxuICBnZXREYXlPZldlZWtOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW10ge1xuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7d2Vla2RheTogc3R5bGV9KTtcbiAgICAgIHJldHVybiByYW5nZSg3LCBpID0+IHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKFxuICAgICAgICAgIGR0Zi5mb3JtYXQobmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9EQVlfT0ZfV0VFS19OQU1FU1tzdHlsZV07XG4gIH1cblxuICBnZXRZZWFyTmFtZShkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGxldCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwge3llYXI6ICdudW1lcmljJ30pO1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGR0Zi5mb3JtYXQoZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0WWVhcihkYXRlKSk7XG4gIH1cblxuICBnZXRGaXJzdERheU9mV2VlaygpOiBudW1iZXIge1xuICAgIC8vIFdlIGNhbid0IHRlbGwgdXNpbmcgbmF0aXZlIEpTIERhdGUgd2hhdCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGlzLCB3ZSBkZWZhdWx0IHRvIFN1bmRheS5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldE51bURheXNJbk1vbnRoKGRhdGU6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERhdGUodGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgMSwgMCkpO1xuICB9XG5cbiAgY2xvbmUoZGF0ZTogRGF0ZSk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUodGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xuICB9XG5cbiAgY3JlYXRlRGF0ZSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IERhdGUge1xuICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG1vbnRoIGFuZCBkYXRlIChleGNlcHQgdXBwZXIgYm91bmQgb24gZGF0ZSB3aGljaCB3ZSBoYXZlIHRvIGNoZWNrIGFmdGVyXG4gICAgLy8gY3JlYXRpbmcgdGhlIERhdGUpLlxuICAgIGlmIChtb250aCA8IDAgfHwgbW9udGggPiAxMSB8fCBkYXRlIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhciwgbW9udGgsIGRhdGUpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZGF0ZSB3YXNuJ3QgYWJvdmUgdGhlIHVwcGVyIGJvdW5kIGZvciB0aGUgbW9udGgsIGNhdXNpbmcgdGhlIG1vbnRoIHRvXG4gICAgLy8gb3ZlcmZsb3cuXG4gICAgaWYgKHJlc3VsdC5nZXRNb250aCgpICE9IG1vbnRoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdG9kYXkoKTogRGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cblxuICBwYXJzZSh2YWx1ZTogYW55KTogRGF0ZSB8IG51bGwge1xuICAgIC8vIFdlIGhhdmUgbm8gd2F5IHVzaW5nIHRoZSBuYXRpdmUgSlMgRGF0ZSB0byBzZXQgdGhlIHBhcnNlIGZvcm1hdCBvciBsb2NhbGUsIHNvIHdlIGlnbm9yZSB0aGVzZVxuICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgbGV0IHRpbWVzdGFtcCA9IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDogRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKHRpbWVzdGFtcCkgPyBudWxsIDogbmV3IERhdGUodGltZXN0YW1wKTtcbiAgfVxuXG4gIGZvcm1hdChkYXRlOiBEYXRlLCBkaXNwbGF5Rm9ybWF0OiBPYmplY3QpOiBzdHJpbmcge1xuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCBkaXNwbGF5Rm9ybWF0KTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwRGlyZWN0aW9uYWxpdHlDaGFyYWN0ZXJzKGRhdGUudG9EYXRlU3RyaW5nKCkpO1xuICB9XG5cbiAgYWRkQ2FsZW5kYXJZZWFycyhkYXRlOiBEYXRlLCB5ZWFyczogbnVtYmVyKTogRGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ2FsZW5kYXJNb250aHMoZGF0ZSwgeWVhcnMgKiAxMik7XG4gIH1cblxuICBhZGRDYWxlbmRhck1vbnRocyhkYXRlOiBEYXRlLCBtb250aHM6IG51bWJlcik6IERhdGUge1xuICAgIGxldCBuZXdEYXRlID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzLCB0aGlzLmdldERhdGUoZGF0ZSkpO1xuXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0byB3aW5kIHVwIGluIHRoZSB3cm9uZyBtb250aCBpZiB0aGUgb3JpZ2luYWwgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIHRoZSBuZXdcbiAgICAvLyBtb250aC4gSW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gZ28gdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBkZXNpcmVkIG1vbnRoLlxuICAgIC8vIE5vdGU6IHRoZSBhZGRpdGlvbmFsICsgMTIgJSAxMiBlbnN1cmVzIHdlIGVuZCB1cCB3aXRoIGEgcG9zaXRpdmUgbnVtYmVyLCBzaW5jZSBKUyAlIGRvZXNuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhpcy5cbiAgICBpZiAodGhpcy5nZXRNb250aChuZXdEYXRlKSAhPSAoKHRoaXMuZ2V0TW9udGgoZGF0ZSkgKyBtb250aHMpICUgMTIgKyAxMikgJSAxMikge1xuICAgICAgbmV3RGF0ZSA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKG5ld0RhdGUpLCB0aGlzLmdldE1vbnRoKG5ld0RhdGUpLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuXG4gIGFkZENhbGVuZGFyRGF5cyhkYXRlOiBEYXRlLCBkYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkgKyBkYXlzKTtcbiAgfVxuXG4gIGdldElTT0RhdGVTdHJpbmcoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ0RhdGUoKSlcbiAgICBdLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgZGF0ZSBidXQgYWxsb3dzIHRoZSBtb250aCBhbmQgZGF0ZSB0byBvdmVyZmxvdy4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcikge1xuICAgIGxldCByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmYWN0IHRoYXQgSlMgbmF0aXZlIERhdGUgdHJlYXRzIHllYXJzIGluIHJhbmdlIFswLCA5OV0gYXNcbiAgICAvLyBhYmJyZXZpYXRpb25zIGZvciAxOXh4LlxuICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCkge1xuICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHRoaXMuZ2V0WWVhcihyZXN1bHQpIC0gMTkwMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIG51bWJlciB0byBtYWtlIGl0IHR3byBkaWdpdHMuXG4gICAqIEBwYXJhbSBuIFRoZSBudW1iZXIgdG8gcGFkLlxuICAgKiBAcmV0dXJucyBUaGUgcGFkZGVkIG51bWJlci5cbiAgICovXG4gIHByaXZhdGUgXzJkaWdpdChuOiBudW1iZXIpIHtcbiAgICByZXR1cm4gKCcwMCcgKyBuKS5zbGljZSgtMik7XG4gIH1cblxuICAvKipcbiAgICogU3RyaXAgb3V0IHVuaWNvZGUgTFRSIGFuZCBSVEwgY2hhcmFjdGVycy4gRWRnZSBhbmQgSUUgaW5zZXJ0IHRoZXNlIGludG8gZm9ybWF0dGVkIGRhdGVzIHdoaWxlXG4gICAqIG90aGVyIGJyb3dzZXJzIGRvIG5vdC4gV2UgcmVtb3ZlIHRoZW0gdG8gbWFrZSBvdXRwdXQgY29uc2lzdGVudCBhbmQgYmVjYXVzZSB0aGV5IGludGVyZmVyZSB3aXRoXG4gICAqIGRhdGUgcGFyc2luZy5cbiAgICogQHBhcmFtIHMgVGhlIHN0cmluZyB0byBzdHJpcCBkaXJlY3Rpb24gY2hhcmFjdGVycyBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgc3RyaXBwZWQgc3RyaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBfc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvW1xcdTIwMGVcXHUyMDBmXS9nLCAnJyk7XG4gIH1cbn1cbiIsImltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmV4cG9ydCB0eXBlIE1kRGF0ZUZvcm1hdHMgPSB7XG4gIHBhcnNlOiB7XG4gICAgZGF0ZUlucHV0OiBhbnlcbiAgfSxcbiAgZGlzcGxheToge1xuICAgIGRhdGVJbnB1dDogYW55LFxuICAgIG1vbnRoWWVhckxhYmVsOiBhbnksXG4gICAgZGF0ZUExMXlMYWJlbDogYW55LFxuICAgIG1vbnRoWWVhckExMXlMYWJlbDogYW55LFxuICB9XG59O1xuXG5cbmV4cG9ydCBjb25zdCBNRF9EQVRFX0ZPUk1BVFMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TWREYXRlRm9ybWF0cz4oJ21kLWRhdGUtZm9ybWF0cycpO1xuIiwiaW1wb3J0IHtNZERhdGVGb3JtYXRzfSBmcm9tICcuL2RhdGUtZm9ybWF0cyc7XG5cblxuZXhwb3J0IGNvbnN0IE1EX05BVElWRV9EQVRFX0ZPUk1BVFM6IE1kRGF0ZUZvcm1hdHMgPSB7XG4gIHBhcnNlOiB7XG4gICAgZGF0ZUlucHV0OiBudWxsLFxuICB9LFxuICBkaXNwbGF5OiB7XG4gICAgZGF0ZUlucHV0OiB7eWVhcjogJ251bWVyaWMnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJ30sXG4gICAgbW9udGhZZWFyTGFiZWw6IHt5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnfSxcbiAgICBkYXRlQTExeUxhYmVsOiB7eWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJ30sXG4gICAgbW9udGhZZWFyQTExeUxhYmVsOiB7eWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnfSxcbiAgfVxufTtcbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRlQWRhcHRlcn0gZnJvbSAnLi9kYXRlLWFkYXB0ZXInO1xuaW1wb3J0IHtOYXRpdmVEYXRlQWRhcHRlcn0gZnJvbSAnLi9uYXRpdmUtZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7TURfREFURV9GT1JNQVRTfSBmcm9tICcuL2RhdGUtZm9ybWF0cyc7XG5pbXBvcnQge01EX05BVElWRV9EQVRFX0ZPUk1BVFN9IGZyb20gJy4vbmF0aXZlLWRhdGUtZm9ybWF0cyc7XG5cblxuZXhwb3J0ICogZnJvbSAnLi9kYXRlLWFkYXB0ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9kYXRlLWZvcm1hdHMnO1xuZXhwb3J0ICogZnJvbSAnLi9uYXRpdmUtZGF0ZS1hZGFwdGVyJztcbmV4cG9ydCAqIGZyb20gJy4vbmF0aXZlLWRhdGUtZm9ybWF0cyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTmF0aXZlRGF0ZUFkYXB0ZXJ9XSxcbn0pXG5leHBvcnQgY2xhc3MgTmF0aXZlRGF0ZU1vZHVsZSB7fVxuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtOYXRpdmVEYXRlTW9kdWxlXSxcbiAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IE1EX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IE1EX05BVElWRV9EQVRFX0ZPUk1BVFN9XSxcbn0pXG5leHBvcnQgY2xhc3MgTWROYXRpdmVEYXRlTW9kdWxlIHt9XG4iLCJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKiogSW5qZWN0aW9uVG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBnbG9iYWwgcGxhY2Vob2xkZXIgb3B0aW9ucy4gKi9cbmV4cG9ydCBjb25zdCBNRF9QTEFDRUhPTERFUl9HTE9CQUxfT1BUSU9OUyA9XG4gIG5ldyBJbmplY3Rpb25Ub2tlbjxQbGFjZWhvbGRlck9wdGlvbnM+KCdtZC1wbGFjZWhvbGRlci1nbG9iYWwtb3B0aW9ucycpO1xuXG4vKiogVHlwZSBmb3IgdGhlIGF2YWlsYWJsZSBmbG9hdFBsYWNlaG9sZGVyIHZhbHVlcy4gKi9cbmV4cG9ydCB0eXBlIEZsb2F0UGxhY2Vob2xkZXJUeXBlID0gJ2Fsd2F5cycgfCAnbmV2ZXInIHwgJ2F1dG8nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlaG9sZGVyT3B0aW9ucyB7XG4gIGZsb2F0PzogRmxvYXRQbGFjZWhvbGRlclR5cGU7XG59XG4iLCJpbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TWRMaW5lTW9kdWxlfSBmcm9tICcuL2xpbmUvbGluZSc7XG5pbXBvcnQge1J0bE1vZHVsZX0gZnJvbSAnLi9ydGwvZGlyJztcbmltcG9ydCB7T2JzZXJ2ZUNvbnRlbnRNb2R1bGV9IGZyb20gJy4vb2JzZXJ2ZS1jb250ZW50L29ic2VydmUtY29udGVudCc7XG5pbXBvcnQge01kT3B0aW9uTW9kdWxlfSBmcm9tICcuL29wdGlvbi9pbmRleCc7XG5pbXBvcnQge1BvcnRhbE1vZHVsZX0gZnJvbSAnLi9wb3J0YWwvcG9ydGFsLWRpcmVjdGl2ZXMnO1xuaW1wb3J0IHtPdmVybGF5TW9kdWxlfSBmcm9tICcuL292ZXJsYXkvb3ZlcmxheS1kaXJlY3RpdmVzJztcbmltcG9ydCB7QTExeU1vZHVsZX0gZnJvbSAnLi9hMTF5L2luZGV4JztcbmltcG9ydCB7TWRTZWxlY3Rpb25Nb2R1bGV9IGZyb20gJy4vc2VsZWN0aW9uL2luZGV4JztcbmltcG9ydCB7TWRSaXBwbGVNb2R1bGV9IGZyb20gJy4vcmlwcGxlL2luZGV4JztcblxuXG4vLyBSVExcbmV4cG9ydCB7RGlyLCBMYXlvdXREaXJlY3Rpb24sIFJ0bE1vZHVsZX0gZnJvbSAnLi9ydGwvZGlyJztcblxuLy8gTXV0YXRpb24gT2JzZXJ2ZXJcbmV4cG9ydCB7T2JzZXJ2ZUNvbnRlbnRNb2R1bGUsIE9ic2VydmVDb250ZW50fSBmcm9tICcuL29ic2VydmUtY29udGVudC9vYnNlcnZlLWNvbnRlbnQnO1xuXG5leHBvcnQgKiBmcm9tICcuL29wdGlvbi9pbmRleCc7XG5cbi8vIFBvcnRhbHNcbmV4cG9ydCB7XG4gIFBvcnRhbCxcbiAgUG9ydGFsSG9zdCxcbiAgQmFzZVBvcnRhbEhvc3QsXG4gIENvbXBvbmVudFBvcnRhbCxcbiAgVGVtcGxhdGVQb3J0YWxcbn0gZnJvbSAnLi9wb3J0YWwvcG9ydGFsJztcbmV4cG9ydCB7XG4gIFBvcnRhbEhvc3REaXJlY3RpdmUsXG4gIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLFxuICBQb3J0YWxNb2R1bGUsXG59IGZyb20gJy4vcG9ydGFsL3BvcnRhbC1kaXJlY3RpdmVzJztcbmV4cG9ydCB7RG9tUG9ydGFsSG9zdH0gZnJvbSAnLi9wb3J0YWwvZG9tLXBvcnRhbC1ob3N0JztcblxuLy8gUGxhdGZvcm1cbmV4cG9ydCAqIGZyb20gJy4vcGxhdGZvcm0vaW5kZXgnO1xuXG4vLyBPdmVybGF5XG5leHBvcnQgKiBmcm9tICcuL292ZXJsYXkvaW5kZXgnO1xuXG4vLyBHZXN0dXJlc1xuZXhwb3J0IHtHZXN0dXJlQ29uZmlnfSBmcm9tICcuL2dlc3R1cmVzL2dlc3R1cmUtY29uZmlnJztcbi8vIEV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgaW50ZXJmYWNlcyB3aGljaCBzaG91bGQgYmUgcmUtZXhwb3J0ZWQsIGJlY2F1c2UgaWYgZXZlcnl0aGluZ1xuLy8gaXMgcmUtZXhwb3J0ZWQsIG1vZHVsZSBidW5kbGVycyBtYXkgcnVuIGludG8gaXNzdWVzIHdpdGggdHJlZXNoYWtpbmcuXG5leHBvcnQge0hhbW1lcklucHV0LCBIYW1tZXJNYW5hZ2VyfSBmcm9tICcuL2dlc3R1cmVzL2dlc3R1cmUtYW5ub3RhdGlvbnMnO1xuXG4vLyBSaXBwbGVcbmV4cG9ydCAqIGZyb20gJy4vcmlwcGxlL2luZGV4JztcblxuLy8gYTExeVxuZXhwb3J0IHtcbiAgQXJpYUxpdmVQb2xpdGVuZXNzLFxuICBMaXZlQW5ub3VuY2VyLFxuICBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOLFxuICBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUixcbn0gZnJvbSAnLi9hMTF5L2xpdmUtYW5ub3VuY2VyJztcblxuLy8gU2VsZWN0aW9uXG5leHBvcnQgKiBmcm9tICcuL3NlbGVjdGlvbi9zZWxlY3Rpb24nO1xuXG5leHBvcnQgKiBmcm9tICcuL2ExMXkvZm9jdXMtdHJhcCc7XG5leHBvcnQge0ludGVyYWN0aXZpdHlDaGVja2VyfSBmcm9tICcuL2ExMXkvaW50ZXJhY3Rpdml0eS1jaGVja2VyJztcbmV4cG9ydCB7aXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcn0gZnJvbSAnLi9hMTF5L2Zha2UtbW91c2Vkb3duJztcblxuZXhwb3J0IHtBMTF5TW9kdWxlfSBmcm9tICcuL2ExMXkvaW5kZXgnO1xuXG5leHBvcnQge1xuICBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLFxuICBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyTGlzdGVuZXIsXG4gIFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUixcbn0gZnJvbSAnLi9jb29yZGluYXRpb24vdW5pcXVlLXNlbGVjdGlvbi1kaXNwYXRjaGVyJztcblxuZXhwb3J0IHtNZExpbmVNb2R1bGUsIE1kTGluZSwgTWRMaW5lU2V0dGVyfSBmcm9tICcuL2xpbmUvbGluZSc7XG5cbi8vIFN0eWxlXG5leHBvcnQgKiBmcm9tICcuL3N0eWxlL2luZGV4JztcblxuLy8gTWlzY1xuZXhwb3J0IHtDb21wb25lbnRUeXBlfSBmcm9tICcuL292ZXJsYXkvZ2VuZXJpYy1jb21wb25lbnQtdHlwZSc7XG5cbi8vIEtleWJpbmRpbmdzXG5leHBvcnQgKiBmcm9tICcuL2tleWJvYXJkL2tleWNvZGVzJztcblxuZXhwb3J0ICogZnJvbSAnLi9jb21wYXRpYmlsaXR5L2NvbXBhdGliaWxpdHknO1xuXG4vLyBBbmltYXRpb25cbmV4cG9ydCAqIGZyb20gJy4vYW5pbWF0aW9uL2FuaW1hdGlvbic7XG5cbi8vIFNlbGVjdGlvblxuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3Rpb24vaW5kZXgnO1xuXG4vLyBDb2VyY2lvblxuZXhwb3J0IHtjb2VyY2VCb29sZWFuUHJvcGVydHl9IGZyb20gJy4vY29lcmNpb24vYm9vbGVhbi1wcm9wZXJ0eSc7XG5leHBvcnQge2NvZXJjZU51bWJlclByb3BlcnR5fSBmcm9tICcuL2NvZXJjaW9uL251bWJlci1wcm9wZXJ0eSc7XG5cbi8vIENvbXBhdGliaWxpdHlcbmV4cG9ydCB7Q29tcGF0aWJpbGl0eU1vZHVsZSwgTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGV9IGZyb20gJy4vY29tcGF0aWJpbGl0eS9jb21wYXRpYmlsaXR5JztcblxuLy8gQ29tbW9uIG1hdGVyaWFsIG1vZHVsZVxuZXhwb3J0IHtNZENvbW1vbk1vZHVsZSwgTUFURVJJQUxfU0FOSVRZX0NIRUNLU30gZnJvbSAnLi9jb21tb24tYmVoYXZpb3JzL2NvbW1vbi1tb2R1bGUnO1xuXG4vLyBEYXRldGltZVxuZXhwb3J0ICogZnJvbSAnLi9kYXRldGltZS9pbmRleCc7XG5cbi8vIFBsYWNlaG9sZGVyXG5leHBvcnQge1xuICBGbG9hdFBsYWNlaG9sZGVyVHlwZSxcbiAgUGxhY2Vob2xkZXJPcHRpb25zLFxuICBNRF9QTEFDRUhPTERFUl9HTE9CQUxfT1BUSU9OU1xufSBmcm9tICcuL3BsYWNlaG9sZGVyL3BsYWNlaG9sZGVyLW9wdGlvbnMnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgTWRMaW5lTW9kdWxlLFxuICAgIFJ0bE1vZHVsZSxcbiAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICBQb3J0YWxNb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBBMTF5TW9kdWxlLFxuICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgIE1kU2VsZWN0aW9uTW9kdWxlLFxuICBdLFxuICBleHBvcnRzOiBbXG4gICAgTWRMaW5lTW9kdWxlLFxuICAgIFJ0bE1vZHVsZSxcbiAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICBQb3J0YWxNb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBBMTF5TW9kdWxlLFxuICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgIE1kU2VsZWN0aW9uTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBNZENvcmVNb2R1bGUge31cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1kMkFjY29yZGlvblRhYiB9IGZyb20gJy4vYWNjb3JkaW9udGFiJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJy4uL2NvcmUvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21kMi1hY2NvcmRpb24nLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICBzdHlsZVVybHM6IFsnYWNjb3JkaW9uLnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgZXhwb3J0QXM6ICdtZDJBY2NvcmRpb24nXG59KVxuZXhwb3J0IGNsYXNzIE1kMkFjY29yZGlvbiB7XG5cbiAgcHJpdmF0ZSBfbXVsdGlwbGU6IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fbXVsdGlwbGU7IH1cbiAgc2V0IG11bHRpcGxlKHZhbHVlKSB7IHRoaXMuX211bHRpcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIEBPdXRwdXQoKSBjbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgdGFiczogTWQyQWNjb3JkaW9uVGFiW10gPSBbXTtcblxuICAvKipcbiAgICogQWRkIG9yIGFwcGVuZCB0YWIgaW4gYWNjb3JkaW9uXG4gICAqIEBwYXJhbSB0YWIgb2JqZWN0IG9mIE1kMkFjY29yZGlvblRhYlxuICAgKi9cbiAgYWRkVGFiKHRhYjogTWQyQWNjb3JkaW9uVGFiKSB7XG4gICAgdGhpcy50YWJzLnB1c2godGFiKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBEaXJlY3RpdmUsXG4gIElucHV0LFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBhbmltYXRlLFxuICBzdGF0ZSxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb24sXG4gIHRyaWdnZXIsXG59IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTWQyQWNjb3JkaW9uIH0gZnJvbSAnLi9hY2NvcmRpb24nO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnLi4vY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ21kMi1hY2NvcmRpb24taGVhZGVyJyB9KVxuZXhwb3J0IGNsYXNzIE1kMkFjY29yZGlvbkhlYWRlciB7IH1cblxuQENvbXBvbmVudCh7XG4gIFxuICBzZWxlY3RvcjogJ21kMi1hY2NvcmRpb24tdGFiJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwibWQyLWFjY29yZGlvbi1oZWFkZXJcIiAoY2xpY2spPVwiX2hhbmRsZUNsaWNrKCRldmVudClcIj5cbiAgICAgIDxzcGFuPnt7aGVhZGVyfX08L3NwYW4+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJtZDItYWNjb3JkaW9uLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWQyLWFjY29yZGlvbi1oZWFkZXItaWNvblwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWQyLWFjY29yZGlvbi10YWItYm9keVwiIFtAc2xpZGVdPVwic2xpZGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZDItYWNjb3JkaW9uLXRhYi1jb250ZW50XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICBzdHlsZVVybHM6IFsnYWNjb3JkaW9uLnNjc3MnXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ3NsaWRlJywgW1xuICAgICAgc3RhdGUoJ3VwJywgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpLFxuICAgICAgc3RhdGUoJ2Rvd24nLCBzdHlsZSh7IGhlaWdodDogJyonIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJ2Rvd24gPT4gdXAnLCBbXG4gICAgICAgIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSksXG4gICAgICAgIGFuaW1hdGUoMzAwLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgIF0pLFxuICAgICAgdHJhbnNpdGlvbigndXAgPT4gZG93bicsIFtcbiAgICAgICAgc3R5bGUoeyBoZWlnaHQ6IDAgfSksXG4gICAgICAgIGFuaW1hdGUoMzAwLCBzdHlsZSh7XG4gICAgICAgICAgaGVpZ2h0OiAnKidcbiAgICAgICAgfSkpXG4gICAgICBdKVxuICAgIF0pXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAncm9sZSc6ICdhY2NvcmRpb24tdGFiJyxcbiAgICAnW2NsYXNzLm1kMi1hY2NvcmRpb24tdGFiLWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAnW2NsYXNzLm1kMi1hY2NvcmRpb24tdGFiLWRpc2FibGVkXSc6ICdkaXNhYmxlZCdcbiAgfSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgZXhwb3J0QXM6ICdtZDJBY2NvcmRpb25UYWInXG59KVxuZXhwb3J0IGNsYXNzIE1kMkFjY29yZGlvblRhYiB7XG5cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZTsgfVxuICBzZXQgYWN0aXZlKHZhbHVlKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fYWN0aXZlICYmICF0aGlzLl9hY2NvcmRpb24ubXVsdGlwbGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWNjb3JkaW9uLnRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjY29yZGlvbi50YWJzW2ldICE9PSB0aGlzKSB7IHRoaXMuX2FjY29yZGlvbi50YWJzW2ldLmFjdGl2ZSA9IGZhbHNlOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHNsaWRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlID8gJ2Rvd24nIDogJ3VwJztcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9hY2NvcmRpb246IE1kMkFjY29yZGlvbikge1xuICAgIHRoaXMuX2FjY29yZGlvbi5hZGRUYWIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBhY2NvcmRpb25cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm4gaWYgaXQgaXMgZGlzYWJsZWRcbiAgICovXG4gIF9oYW5kbGVDbGljayhldmVudDogRXZlbnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMuZmluZFRhYkluZGV4KCk7XG5cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gIXRoaXMuYWN0aXZlO1xuICAgICAgdGhpcy5fYWNjb3JkaW9uLmNsb3NlLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgaW5kZXg6IGluZGV4IH0pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2FjY29yZGlvbi5tdWx0aXBsZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY2NvcmRpb24udGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9hY2NvcmRpb24udGFic1tpXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLl9hY2NvcmRpb24ub3Blbi5lbWl0KHsgb3JpZ2luYWxFdmVudDogZXZlbnQsIGluZGV4OiBpbmRleCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2FjY29yZGlvbi5vcGVuLmVtaXQoeyBvcmlnaW5hbEV2ZW50OiBldmVudCwgaW5kZXg6IGluZGV4IH0pO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBpbmRleCBvZiBzcGVjaWZpYyB0YWIgb2YgYWNjb3JkaW9uXG4gICAqIEByZXR1cm4gaW5kZXggbnVtYmVyIG9mIHRoaXMgdGFiXG4gICAqL1xuICBmaW5kVGFiSW5kZXgoKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY2NvcmRpb24udGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX2FjY29yZGlvbi50YWJzW2ldID09PSB0aGlzKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBNZDJBY2NvcmRpb24gfSBmcm9tICcuL2FjY29yZGlvbic7XG5pbXBvcnQgeyBNZDJBY2NvcmRpb25UYWIsIE1kMkFjY29yZGlvbkhlYWRlciB9IGZyb20gJy4vYWNjb3JkaW9udGFiJztcblxuZXhwb3J0ICogZnJvbSAnLi9hY2NvcmRpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9hY2NvcmRpb250YWInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW01kMkFjY29yZGlvbiwgTWQyQWNjb3JkaW9uVGFiLCBNZDJBY2NvcmRpb25IZWFkZXJdLFxuICBkZWNsYXJhdGlvbnM6IFtNZDJBY2NvcmRpb24sIE1kMkFjY29yZGlvblRhYiwgTWQyQWNjb3JkaW9uSGVhZGVyXSxcbn0pXG5leHBvcnQgY2xhc3MgTWQyQWNjb3JkaW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtcbiAgUGlwZSxcbiAgUGlwZVRyYW5zZm9ybVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoeyBuYW1lOiAnaGlnaGxpZ2h0JyB9KVxuZXhwb3J0IGNsYXNzIEhpZ2hsaWdodFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBmdW5jdGlvblxuICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAqIEBwYXJhbSBxdWVyeSBzdHJpbmcgZmlsdGVyIHZhbHVlXG4gICAqIEByZXR1cm4gZmlsdGVyZWQgc3RyaW5nIHdpdGggbWFya3VwXG4gICAqL1xuICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgcXVlcnk6IHN0cmluZykge1xuICAgIGlmIChxdWVyeS5sZW5ndGggPCAxKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgIHJldHVybiBxdWVyeSA/IHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLl9lc2NhcGVSZWdleHAocXVlcnkpLCAnZ2knKSxcbiAgICAgICc8c3BhbiBjbGFzcz1cImhpZ2hsaWdodFwiPiQmPC9zcGFuPicpIDogdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogZmlsdGVyIHBpcGVcbiAgICogQHBhcmFtIHF1ZXJ5VG9Fc2NhcGVcbiAgICogQHJldHVybiBxdWVyeVRvRXNjYXBlIHdpdGggcmVwbGFjZSBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgX2VzY2FwZVJlZ2V4cChxdWVyeVRvRXNjYXBlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcXVlcnlUb0VzY2FwZS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgZm9yd2FyZFJlZixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7XG4gIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSxcbiAgVVBfQVJST1csXG4gIERPV05fQVJST1csXG4gIEVOVEVSLFxuICBFU0NBUEUsXG4gIFRBQlxufSBmcm9tICcuLi9jb3JlL2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgSXRlbSB7XG4gIHRleHQ6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IGFueSwgdGV4dEtleTogc3RyaW5nLCB2YWx1ZUtleTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnZhbHVlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMudGV4dCA9IHNvdXJjZVt0ZXh0S2V5XTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZUtleSA/IHNvdXJjZVt2YWx1ZUtleV0gOiBzb3VyY2U7XG4gICAgfVxuICB9XG59XG5cbmxldCBuZXh0SWQgPSAwO1xuXG5leHBvcnQgY29uc3QgTUQyX0FVVE9DT01QTEVURV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNZDJBdXRvY29tcGxldGUpLFxuICBtdWx0aTogdHJ1ZVxufTtcblxuLyoqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBNZDJBdXRvY29tcGxldGUuICovXG5leHBvcnQgY2xhc3MgTWQyQXV0b2NvbXBsZXRlQ2hhbmdlIHtcbiAgc291cmNlOiBNZDJBdXRvY29tcGxldGU7XG4gIHZhbHVlOiBhbnk7XG59XG5cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItYXV0b2NvbXBsZXRlJyxcbiAgdGVtcGxhdGVVcmw6ICdhdXRvY29tcGxldGUuaHRtbCcsXG4gIHN0eWxlVXJsczogWydhdXRvY29tcGxldGUuc2NzcyddLFxuICBwcm92aWRlcnM6IFtNRDJfQVVUT0NPTVBMRVRFX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnYXV0b2NvbXBsZXRlJyxcbiAgICAnW2lkXSc6ICdpZCcsXG4gICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ3BsYWNlaG9sZGVyJyxcbiAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAncmVxdWlyZWQudG9TdHJpbmcoKScsXG4gICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICdbY2xhc3MubWQyLWF1dG9jb21wbGV0ZS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICB9LFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBleHBvcnRBczogJ21kMkF1dG9jb21wbGV0ZSdcbn0pXG5cbmV4cG9ydCBjbGFzcyBNZDJBdXRvY29tcGxldGUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZikgeyB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkgeyB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTsgfVxuXG4gIEBPdXRwdXQoKSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBPdXRwdXQoKSB0ZXh0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSAnJztcbiAgcHJpdmF0ZSBfcmVhZG9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfcmVxdWlyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaXNJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIF9vbkNoYW5nZTogKHZhbHVlOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gIF9vblRvdWNoZWQgPSAoKSA9PiB7IH07XG5cbiAgcHJpdmF0ZSBfaXRlbXM6IEFycmF5PGFueT4gPSBbXTtcbiAgX2xpc3Q6IEFycmF5PEl0ZW0+ID0gW107XG5cbiAgcHJpdmF0ZSBzZWxlY3RlZEl0ZW06IEl0ZW0gPSBudWxsO1xuICBwcml2YXRlIG5vQmx1cjogYm9vbGVhbiA9IGZhbHNlO1xuICBfZm9jdXNlZE9wdGlvbjogbnVtYmVyID0gMDtcbiAgX2lucHV0VmFsdWU6IHN0cmluZyA9ICcnO1xuICBfaW5wdXRGb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCkgaWQ6IHN0cmluZyA9ICdtZDItYXV0b2NvbXBsZXRlLScgKyAoKytuZXh0SWQpO1xuICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xuICBASW5wdXQoJ2l0ZW0tdGV4dCcpIHRleHRLZXk6IHN0cmluZyA9ICd0ZXh0JztcbiAgQElucHV0KCdpdGVtLXZhbHVlJykgdmFsdWVLZXk6IHN0cmluZyA9IG51bGw7XG4gIEBJbnB1dCgnbWluLWxlbmd0aCcpIG1pbkxlbmd0aDogbnVtYmVyID0gMTtcblxuICBASW5wdXQoKVxuICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9yZWFkb25seTsgfVxuICBzZXQgcmVhZG9ubHkodmFsdWUpIHsgdGhpcy5fcmVhZG9ubHkgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgQElucHV0KClcbiAgZ2V0IHJlcXVpcmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH1cbiAgc2V0IHJlcXVpcmVkKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICBASW5wdXQoKVxuICBzZXQgaXRlbXModmFsdWU6IEFycmF5PGFueT4pIHsgdGhpcy5faXRlbXMgPSB2YWx1ZTsgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCB2YWx1ZSgpOiBhbnkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5faW5wdXRWYWx1ZSA9ICcnO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGxldCBzZWxJdG0gPSB0aGlzLl9pdGVtcy5maW5kKChpOiBhbnkpID0+IHRoaXMuZXF1YWxzKHRoaXMudmFsdWVLZXkgP1xuICAgICAgICAgIGlbdGhpcy52YWx1ZUtleV0gOiBpLCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG5ldyBJdGVtKHNlbEl0bSwgdGhpcy50ZXh0S2V5LCB0aGlzLnZhbHVlS2V5KTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtKSB7IHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLnNlbGVjdGVkSXRlbS50ZXh0OyB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2lucHV0VmFsdWUpIHsgdGhpcy5faW5wdXRWYWx1ZSA9ICcnOyB9XG4gICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gdmFycyBvciBvYmplY3RzXG4gICAqIEBwYXJhbSBvMSBjb21wYXJlIGZpcnN0IG9iamVjdFxuICAgKiBAcGFyYW0gbzIgY29tcGFyZSBzZWNvbmQgb2JqZWN0XG4gICAqIEByZXR1cm4gYm9vbGVhbiBjb21wYXJhdGlvbiByZXN1bHRcbiAgICovXG4gIHByaXZhdGUgZXF1YWxzKG8xOiBhbnksIG8yOiBhbnkpIHtcbiAgICBpZiAobzEgPT09IG8yKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChvMSAhPT0gbzEgJiYgbzIgIT09IG8yKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbGV0IHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMiwga2V5OiBhbnksIGtleVNldDogYW55O1xuICAgIGlmICh0MSA9PT0gdDIgJiYgdDEgPT09ICdvYmplY3QnKSB7XG4gICAgICBrZXlTZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgZm9yIChrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVxdWFscyhvMVtrZXldLCBvMltrZXldKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAga2V5U2V0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yIChrZXkgaW4gbzIpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGtleVNldCkgJiYga2V5LmNoYXJBdCgwKSAhPT0gJyQnICYmIG8yW2tleV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGlzTWVudVZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICgodGhpcy5faW5wdXRGb2N1c2VkIHx8IHRoaXMubm9CbHVyKSAmJiB0aGlzLl9saXN0ICYmIHRoaXMuX2xpc3QubGVuZ3RoICYmXG4gICAgICAhdGhpcy5zZWxlY3RlZEl0ZW0pICYmICF0aGlzLnJlYWRvbmx5ID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSBzY3JvbGwgb2Ygc3VnZ2VzdGlvbiBtZW51XG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBpZiAodGhpcy5fZm9jdXNlZE9wdGlvbiA8IDApIHsgcmV0dXJuOyB9XG4gICAgbGV0IG1lbnVDb250YWluZXIgPSB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1kMi1hdXRvY29tcGxldGUtbWVudScpO1xuICAgIGlmICghbWVudUNvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICAgIGxldCBjaG9pY2VzID0gbWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcubWQyLW9wdGlvbicpO1xuICAgIGlmIChjaG9pY2VzLmxlbmd0aCA8IDEpIHsgcmV0dXJuOyB9XG5cbiAgICBsZXQgaGlnaGxpZ2h0ZWQ6IGFueSA9IGNob2ljZXNbdGhpcy5fZm9jdXNlZE9wdGlvbl07XG4gICAgaWYgKCFoaWdobGlnaHRlZCkgeyByZXR1cm47IH1cblxuICAgIGxldCB0b3A6IG51bWJlciA9IGhpZ2hsaWdodGVkLm9mZnNldFRvcCArIGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIG1lbnVDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IG1lbnVDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgaWYgKHRvcCA+IGhlaWdodCkge1xuICAgICAgbWVudUNvbnRhaW5lci5zY3JvbGxUb3AgKz0gdG9wIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodG9wIDwgaGlnaGxpZ2h0ZWQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBtZW51Q29udGFpbmVyLnNjcm9sbFRvcCAtPSBoaWdobGlnaHRlZC5jbGllbnRIZWlnaHQgLSB0b3A7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGlucHV0IGV2ZW50IGxpc3RuZXJcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICBfaGFuZGxlS2V5dXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICB0aGlzLnRleHRDaGFuZ2UuZW1pdCh0aGlzLl9pbnB1dFZhbHVlKTtcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIFRBQjogdGhpcy5faGFuZGxlTW91c2VMZWF2ZSgpOyBicmVhaztcbiAgICAgIGNhc2UgRVNDQVBFOlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9vbkNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5pc01lbnVWaXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0T3B0aW9uKGV2ZW50LCB0aGlzLl9mb2N1c2VkT3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNNZW51VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuX2ZvY3VzZWRPcHRpb24gPSAodGhpcy5fZm9jdXNlZE9wdGlvbiA9PT0gdGhpcy5fbGlzdC5sZW5ndGggLSAxKSA/IDAgOlxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy5fZm9jdXNlZE9wdGlvbiArIDEsIHRoaXMuX2xpc3QubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5pc01lbnVWaXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXNlZE9wdGlvbiA9ICh0aGlzLl9mb2N1c2VkT3B0aW9uID09PSAwKSA/IHRoaXMuX2xpc3QubGVuZ3RoIC0gMSA6XG4gICAgICAgICAgICBNYXRoLm1heCgwLCB0aGlzLl9mb2N1c2VkT3B0aW9uIC0gMSk7XG4gICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXBkYXRlSXRlbXMoKTtcbiAgICAgICAgfSwgMTApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3Qgb3B0aW9uXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gaW5kZXggb2Ygc2VsZWN0ZWQgaXRlbVxuICAgKi9cbiAgX3NlbGVjdE9wdGlvbihldmVudDogRXZlbnQsIGluZGV4OiBudW1iZXIpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gdGhpcy5fbGlzdFtpbmRleF07XG4gICAgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMuX2xpc3RbaW5kZXhdLnRleHQ7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICAgIHRoaXMuX2hhbmRsZU1vdXNlTGVhdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjbGVhciBzZWxlY3RlZCBzdWdnZXN0aW9uXG4gICAqL1xuICBfb25DbGVhcigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cbiAgICB0aGlzLl9pbnB1dFZhbHVlID0gJyc7XG4gICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMudXBkYXRlSXRlbXMoKTtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuc2VsZWN0ZWRJdGVtID8gdGhpcy5zZWxlY3RlZEl0ZW0udmFsdWUgOiB0aGlzLnNlbGVjdGVkSXRlbTtcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gIH1cblxuICAvKipcbiAgICogdXBkYXRlIHZhbHVlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVZhbHVlKCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5zZWxlY3RlZEl0ZW0gPyB0aGlzLnNlbGVjdGVkSXRlbS52YWx1ZSA6IHRoaXMuc2VsZWN0ZWRJdGVtO1xuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIHRoaXMub25Gb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNvbXBvbmVudCBmb2N1cyBsaXN0ZW5lclxuICAgKi9cbiAgcHJpdmF0ZSBvbkZvY3VzKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogaW5wdXQgZm9jdXMgbGlzdGVuZXJcbiAgICovXG4gIF9oYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLl9pbnB1dEZvY3VzZWQgPSB0cnVlO1xuICAgIHRoaXMudXBkYXRlSXRlbXMoKTtcbiAgICB0aGlzLl9mb2N1c2VkT3B0aW9uID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbnB1dCBibHVyIGxpc3RlbmVyXG4gICAqL1xuICBfaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLl9pbnB1dEZvY3VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdWdnZXN0aW9uIG1lbnUgbW91c2UgZW50ZXIgbGlzdGVuZXJcbiAgICovXG4gIF9oYW5kbGVNb3VzZUVudGVyKCkgeyB0aGlzLm5vQmx1ciA9IHRydWU7IH1cblxuICAvKipcbiAgICogc3VnZ2VzdGlvbiBtZW51IG1vdXNlIGxlYXZlIGxpc3RlbmVyXG4gICAqL1xuICBfaGFuZGxlTW91c2VMZWF2ZSgpIHsgdGhpcy5ub0JsdXIgPSBmYWxzZTsgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3VnZ2VzdGlvbiB0byBmaWx0ZXIgdGhlIHF1ZXJ5XG4gICAqIEBwYXJhbSBxdWVyeVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVJdGVtcygpIHtcbiAgICBpZiAodGhpcy5faW5wdXRWYWx1ZS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgdGhpcy5fbGlzdCA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ID0gdGhpcy5faXRlbXMubWFwKChpOiBhbnkpID0+IG5ldyBJdGVtKGksIHRoaXMudGV4dEtleSxcbiAgICAgICAgdGhpcy52YWx1ZUtleSkpLmZpbHRlcihpID0+IG5ldyBSZWdFeHAodGhpcy5faW5wdXRWYWx1ZS50cmltKCksICdpZycpLnRlc3QoaS50ZXh0KSk7XG4gICAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggJiYgdGhpcy5fbGlzdFswXS50ZXh0ICE9PSB0aGlzLl9pbnB1dFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW1pdENoYW5nZUV2ZW50KCk6IHZvaWQge1xuICAgIGxldCBldmVudCA9IG5ldyBNZDJBdXRvY29tcGxldGVDaGFuZ2UoKTtcbiAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgIGV2ZW50LnZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgdGhpcy5fb25DaGFuZ2UoZXZlbnQudmFsdWUpO1xuICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSAnJztcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBsZXQgc2VsSXRtID0gdGhpcy5faXRlbXMuZmluZCgoaTogYW55KSA9PiB0aGlzLmVxdWFscyh0aGlzLnZhbHVlS2V5ID9cbiAgICAgICAgICBpW3RoaXMudmFsdWVLZXldIDogaSwgdmFsdWUpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBuZXcgSXRlbShzZWxJdG0sIHRoaXMudGV4dEtleSwgdGhpcy52YWx1ZUtleSk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSkgeyB0aGlzLl9pbnB1dFZhbHVlID0gdGhpcy5zZWxlY3RlZEl0ZW0udGV4dDsgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9pbnB1dFZhbHVlKSB7IHRoaXMuX2lucHV0VmFsdWUgPSAnJzsgfVxuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4ge30pOiB2b2lkIHsgdGhpcy5fb25Ub3VjaGVkID0gZm47IH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSGlnaGxpZ2h0UGlwZSB9IGZyb20gJy4vYXV0b2NvbXBsZXRlLXBpcGUnO1xuaW1wb3J0IHsgTWQyQXV0b2NvbXBsZXRlIH0gZnJvbSAnLi9hdXRvY29tcGxldGUnO1xuXG5leHBvcnQgKiBmcm9tICcuL2F1dG9jb21wbGV0ZSc7XG5leHBvcnQgKiBmcm9tICcuL2F1dG9jb21wbGV0ZS1waXBlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGVdLFxuICBleHBvcnRzOiBbTWQyQXV0b2NvbXBsZXRlLCBIaWdobGlnaHRQaXBlXSxcbiAgZGVjbGFyYXRpb25zOiBbTWQyQXV0b2NvbXBsZXRlLCBIaWdobGlnaHRQaXBlXSxcbn0pXG5leHBvcnQgY2xhc3MgTWQyQXV0b2NvbXBsZXRlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgZm9yd2FyZFJlZixcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGQsXG4gIE5nTW9kdWxlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEhvc3RMaXN0ZW5lcixcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIE5nRm9ybSxcbiAgRm9ybXNNb2R1bGVcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTWQyQXV0b2NvbXBsZXRlTW9kdWxlIH0gZnJvbSAnLi4vYXV0b2NvbXBsZXRlL2luZGV4JztcbmltcG9ydCB7XG4gIEVOVEVSLFxuICBTUEFDRSxcbiAgQkFDS1NQQUNFLFxuICBERUxFVEUsXG4gIENPTU1BLFxuICBMRUZUX0FSUk9XLFxuICBSSUdIVF9BUlJPV1xufSBmcm9tICcuLi9jb3JlL2tleWJvYXJkL2tleWNvZGVzJztcblxuZXhwb3J0IGNsYXNzIENoaXAge1xuICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuICBwdWJsaWMgdmFsdWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IGFueSwgdGV4dEtleTogc3RyaW5nLCB2YWx1ZUtleTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnZhbHVlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMudGV4dCA9IHNvdXJjZVt0ZXh0S2V5XTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZUtleSA/IHNvdXJjZVt2YWx1ZUtleV0gOiBzb3VyY2U7XG4gICAgfVxuICB9XG59XG5cbmxldCBuZXh0SWQgPSAwO1xuZXhwb3J0IGNvbnN0IE1EMl9DSElQU19DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNZDJDaGlwcyksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kMkNoaXBzLiAqL1xuZXhwb3J0IGNsYXNzIE1kMkNoaXBzQ2hhbmdlIHtcbiAgc291cmNlOiBNZDJDaGlwcztcbiAgdmFsdWU6IGFueTtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWQyLWNoaXBzJyxcbiAgdGVtcGxhdGVVcmw6ICdjaGlwcy5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2NoaXBzLnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbTUQyX0NISVBTX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuXG4gIGhvc3Q6IHtcbiAgICAncm9sZSc6ICdjaGlwcycsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbdGFiaW5kZXhdJzogJ2Rpc2FibGVkID8gLTEgOiB0YWJpbmRleCcsXG4gICAgJ1tjbGFzcy5jaGlwLWlucHV0LWZvY3VzXSc6ICdpbnB1dEZvY3VzZWQgfHwgc2VsZWN0ZWRDaGlwID49IDAnLFxuICB9LFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuXG5leHBvcnQgY2xhc3MgTWQyQ2hpcHMgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICBASW5wdXQoKSBhZGRPbkNvbW1hOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgYWRkT25FbnRlcjogYm9vbGVhbiA9IHRydWU7XG4gIEBJbnB1dCgpIGFkZE9uUGFzdGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBhZGRPblNwYWNlOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGFsbG93ZWRQYXR0ZXJuOiBSZWdFeHAgPSAvLisvO1xuICBASW5wdXQoKSBuZ01vZGVsOiBzdHJpbmdbXTtcbiAgQElucHV0KCkgcGFzdGVTcGxpdFBhdHRlcm46IHN0cmluZyA9ICcsJztcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xuICBASW5wdXQoKSBhdXRvY29tcGxldGVEYXRhTGlzdDogc3RyaW5nW107XG4gIEBJbnB1dCgpIGlzQXV0b0NvbXBsZXRlOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGlzUmVtb3ZhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCkgbWluQ2hpcHM6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIG1heENoaXBzOiBudW1iZXIgPSAxMDAwMDtcbiAgQElucHV0KCkgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuICBASW5wdXQoKSBpZDogc3RyaW5nID0gJ21kMi1jaGlwcy0nICsgKCsrbmV4dElkKTtcbiAgQElucHV0KCdhdXRvY29tcGxldGUtaXRlbS10ZXh0JykgYXV0b2NvbXBsZXRlSXRlbVRleHQ6IHN0cmluZyA9ICd0ZXh0JztcbiAgQElucHV0KCdhdXRvY29tcGxldGUtaXRlbS12YWx1ZScpIGF1dG9jb21wbGV0ZUl0ZW1WYWx1ZTogc3RyaW5nID0gJ3ZhbHVlJztcbiAgQElucHV0KCdpdGVtLXRleHQnKSB0ZXh0S2V5OiBzdHJpbmcgPSAndGV4dCc7XG4gIEBJbnB1dCgnaXRlbS12YWx1ZScpIHZhbHVlS2V5OiBzdHJpbmcgPSBudWxsO1xuXG4gIEBPdXRwdXQoKSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIEBWaWV3Q2hpbGQoJ2NoaXBJbnB1dEZvcm0nKSBjaGlwSW5wdXRGb3JtOiBOZ0Zvcm07XG5cbiAgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgX29uVG91Y2hlZCA9ICgpID0+IHsgfTtcblxuICBjaGlwSXRlbUxpc3Q6IEFycmF5PENoaXA+ID0gW107XG4gIGlucHV0VmFsdWU6IHN0cmluZyA9ICcnO1xuICBzZWxlY3RlZENoaXA6IG51bWJlciA9IC0xO1xuICBpbnB1dEZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgYXV0b0NvbXBsZXRlRm9jdWVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfdmFsdWU6IGFueSA9ICcnO1xuICBwcml2YXRlIHNwbGl0UmVnRXhwOiBSZWdFeHA7XG4gIHRlbXBsYXRlSHRtbFN0cmluZzogYW55O1xuICBpdGVtOiBhbnk7XG4gIHByaXZhdGUgaXNFbXB0eUF1dG9Db21wbGV0ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICBnZXQgZWxlbWVudCgpIHtcbiAgICBjb25zdCBlbGVtZW50czogYW55ID0geyByb290OiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgbWFpbkRpdjogbnVsbCwgdGVtcGxhdGU6IG51bGwgfTtcbiAgICBlbGVtZW50cy5tYWluRGl2ID0gZWxlbWVudHMucm9vdC5xdWVyeVNlbGVjdG9yKCcubWQyLWNoaXBzLWNvbnRhaW5lcicpO1xuICAgIGVsZW1lbnRzLnRlbXBsYXRlID0gZWxlbWVudHMubWFpbkRpdi5xdWVyeVNlbGVjdG9yKCcubWQyLXRlbXBsYXRlJyk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG4gIEBJbnB1dCgpXG4gIGdldCB2YWx1ZSgpOiBhbnkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHsgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7IH1cblxuICAvKipcbiAgICogc2V0IHZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgc2V0IHNldFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5jaGlwSXRlbUxpc3QgPSBbXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGlwSXRlbUxpc3QucHVzaChuZXcgQ2hpcCh2YWx1ZVtpXSwgdGhpcy50ZXh0S2V5LCB0aGlzLnZhbHVlS2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgZ2V0Rm9jdXNBdXRvY29tcGxldGUoKSB7XG4gICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gIH1cblxuICBjaGFuZ2VBdXRvY29tcGxldGUodmFsdWU6IGFueSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5hZGROZXdDaGlwKHZhbHVlLnZhbHVlKTtcbiAgICAgIHRoaXMuaXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGxldCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLnNwbGl0UmVnRXhwID0gbmV3IFJlZ0V4cCh0aGlzLnBhc3RlU3BsaXRQYXR0ZXJuKTtcbiAgICBpZiAoZWxlbWVudHMudGVtcGxhdGUpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVIdG1sU3RyaW5nID0gZWxlbWVudHMudGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGF1dG9jb21wbGV0ZSBpbnB1dCBpcyBlbXB0eSBvciBub3RcbiAgdmFsdWV1cGRhdGUoZXZ0OiBFdmVudCkge1xuICAgIHRoaXMuaXNFbXB0eUF1dG9Db21wbGV0ZSA9IGV2dCA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbnB1dCBrZXkgbGlzdGVuZXJcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICBpbnB1dENoYW5nZWQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBsZXQga2V5ID0gZXZlbnQua2V5Q29kZTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgLy8gYmFjayBzcGFjZVxuICAgICAgY2FzZSBCQUNLU1BBQ0U6XG4gICAgICAgIHRoaXMuYmFja3NwYWNlRXZlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBkZWxldGVcbiAgICAgIGNhc2UgREVMRVRFOlxuICAgICAgICB0aGlzLmJhY2tzcGFjZUV2ZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gbGVmdCBhcnJvd1xuICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICBpZiAodGhpcy5pc0F1dG9Db21wbGV0ZSAmJiB0aGlzLmlzRW1wdHlBdXRvQ29tcGxldGUpIHtcbiAgICAgICAgICB0aGlzLmxlZnRBcnJvd0tleUV2ZW50cygpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQXV0b0NvbXBsZXRlICYmICF0aGlzLmlucHV0VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmxlZnRBcnJvd0tleUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gcmlnaHQgYXJyb3dcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIGlmICh0aGlzLmlzQXV0b0NvbXBsZXRlICYmIHRoaXMuaXNFbXB0eUF1dG9Db21wbGV0ZSkge1xuICAgICAgICAgIHRoaXMucmlnaHRBcnJvd0tleUV2ZW50cygpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQXV0b0NvbXBsZXRlICYmICF0aGlzLmlucHV0VmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnJpZ2h0QXJyb3dLZXlFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGVudGVyXG4gICAgICBjYXNlIEVOVEVSOlxuICAgICAgICBpZiAodGhpcy5hZGRPbkVudGVyKSB7XG4gICAgICAgICAgdGhpcy5hZGROZXdDaGlwKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGNvbW1hXG4gICAgICBjYXNlIENPTU1BOlxuICAgICAgICBpZiAodGhpcy5hZGRPbkNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5hZGROZXdDaGlwKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNwYWNlXG4gICAgICBjYXNlIFNQQUNFOlxuICAgICAgICBpZiAodGhpcy5hZGRPblNwYWNlKSB7XG4gICAgICAgICAgdGhpcy5hZGROZXdDaGlwKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICBfaGFuZGxlRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgaWYgKCF0aGlzLmlzQXV0b0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dC5jaGlwLWlucHV0JykuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdXRvQ29tcGxldGVGb2N1ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0U2VsZWN0ZWQoKTtcbiAgfVxuXG4gIGlucHV0Qmx1cnJlZCgpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0Rm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmlucHV0VmFsdWUpIHtcbiAgICAgIHRoaXMuYWRkTmV3Q2hpcCh0aGlzLmlucHV0VmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgfVxuXG4gIGlucHV0Rm9jdXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5pbnB1dEZvY3VzZWQgPSB0cnVlO1xuICB9XG5cbiAgaW5wdXRQYXN0ZShldmVudDogYW55KTogdm9pZCB7XG4gICAgbGV0IGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhIHx8XG4gICAgICAoZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgIGxldCBwYXN0ZWRTdHJpbmcgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKS50cmltKCk7XG4gICAgdGhpcy5hZGROZXdDaGlwKHBhc3RlZFN0cmluZyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9yZXNldElucHV0KCkpO1xuICB9XG5cbiAgbGVmdEFycm93S2V5RXZlbnRzKCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRDaGlwKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENoaXAgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwID0gdGhpcy5jaGlwSXRlbUxpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwID0gdGhpcy5zZWxlY3RlZENoaXAgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByaWdodEFycm93S2V5RXZlbnRzKCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRDaGlwICE9IC0xKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZENoaXAgPj0gdGhpcy5jaGlwSXRlbUxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwID0gdGhpcy5zZWxlY3RlZENoaXAgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzVmFsaWQoY2hpcFN0cmluZzogYW55KTogYm9vbGVhbiB7XG4gICAgbGV0IHR5cGVTdHJpbmcgPSB0eXBlb2YgY2hpcFN0cmluZztcbiAgICBsZXQgaXNFeGlzdDogYW55O1xuICAgIGlmICh0eXBlU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgY2hpcFN0cmluZyA9IGNoaXBTdHJpbmcudHJpbSgpO1xuICAgICAgaXNFeGlzdCA9IHRoaXMuY2hpcEl0ZW1MaXN0LmZpbHRlcigoY2hpcCkgPT4gY2hpcC50ZXh0ID09PSBjaGlwU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNFeGlzdCA9IHRoaXMuY2hpcEl0ZW1MaXN0LmZpbHRlcigoY2hpcCkgPT4gY2hpcC50ZXh0ID09PSBjaGlwU3RyaW5nLnRleHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGlwSXRlbUxpc3QuaW5kZXhPZihjaGlwU3RyaW5nKSA9PT0gLTEgJiYgKGlzRXhpc3QubGVuZ3RoID8gZmFsc2UgOiB0cnVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsb3dlZFBhdHRlcm4udGVzdChjaGlwU3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogYWRkIG5ldyBjaGlwXG4gICogQHBhcmFtIGNoaXBzXG4gICovXG4gIHByaXZhdGUgYWRkTmV3Q2hpcChjaGlwczogYW55KTogdm9pZCB7XG4gICAgbGV0IHZhbGlkSW5wdXQgPSB0aGlzLl9pc1ZhbGlkKGNoaXBzKTtcbiAgICBpZiAodmFsaWRJbnB1dCkge1xuICAgICAgaWYgKHRoaXMubWF4Q2hpcHMgJiYgdGhpcy5tYXhDaGlwcyA8IHRoaXMuY2hpcEl0ZW1MaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGlwSXRlbUxpc3QucHVzaChuZXcgQ2hpcChjaGlwcywgdGhpcy5hdXRvY29tcGxldGVJdGVtVGV4dCwgdGhpcy5hdXRvY29tcGxldGVJdGVtVmFsdWUpKTtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVzZXRTZWxlY3RlZCgpO1xuICAgIHRoaXMuX3Jlc2V0SW5wdXQoKTtcbiAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gIH1cblxuICAvKipcbiAqIHJlbW92ZSBzZWxlY3RlZCBjaGlwXG4gKiBAcGFyYW0gY2hpcEluZGV4VG9SZW1vdmUgaW5kZXggb2Ygc2VsZWN0ZWQgY2hpcFxuICovXG4gIHJlbW92ZVNlbGVjdGVkQ2hpcChjaGlwSW5kZXhUb1JlbW92ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jaGlwSXRlbUxpc3Quc3BsaWNlKGNoaXBJbmRleFRvUmVtb3ZlLCAxKTtcbiAgICB0aGlzLl9yZXNldFNlbGVjdGVkKCk7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBiYWNrc3BhY2VFdmVudCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaW5wdXRWYWx1ZS5sZW5ndGggJiYgdGhpcy5jaGlwSXRlbUxpc3QubGVuZ3RoICYmXG4gICAgICB0aGlzLmlzUmVtb3ZhYmxlICYmIHRoaXMuaXNFbXB0eUF1dG9Db21wbGV0ZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDaGlwICE9IC0xKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0ZWRDaGlwKHRoaXMuc2VsZWN0ZWRDaGlwKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoaXAgPSB0aGlzLmNoaXBJdGVtTGlzdC5sZW5ndGggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoaXAgPSB0aGlzLmNoaXBJdGVtTGlzdC5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0U2VsZWN0ZWQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZENoaXAgPSAtMTtcbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0SW5wdXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNBdXRvQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuY2hpcElucHV0Rm9ybS5jb250cm9sc1snYXV0b2NvbXBsZXRlJ10uc2V0VmFsdWUoJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoaXBJbnB1dEZvcm0uY29udHJvbHNbJ2NoaXBJbnB1dCddLnNldFZhbHVlKCcnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHVwZGF0ZSB2YWx1ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZSgpIHtcbiAgICB0aGlzLl92YWx1ZSA9IG5ldyBBcnJheTxhbnk+KCk7XG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLmNoaXBJdGVtTGlzdC5tYXAoKGNoaXA6IGFueSkgPT4ge1xuICAgICAgaWYgKHRoaXMudmFsdWVLZXkpIHtcbiAgICAgICAgbGV0IGM6IGFueSA9IHt9O1xuICAgICAgICBjW3RoaXMudGV4dEtleV0gPSBjaGlwLnRleHQ7XG4gICAgICAgIGNbdGhpcy52YWx1ZUtleV0gPSBjaGlwLnZhbHVlO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlwLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICB9XG5cbiAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvbG9yLiAqL1xuICBfZW1pdENoYW5nZUV2ZW50KCk6IHZvaWQge1xuICAgIGxldCBldmVudCA9IG5ldyBNZDJDaGlwc0NoYW5nZSgpO1xuICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICB0aGlzLl9vbkNoYW5nZShldmVudC52YWx1ZSk7XG4gICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5jaGlwSXRlbUxpc3QgPSBbXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGlwSXRlbUxpc3QucHVzaChuZXcgQ2hpcCh2YWx1ZVtpXSwgdGhpcy50ZXh0S2V5LCB0aGlzLnZhbHVlS2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH1cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHt9KTogdm9pZCB7IHRoaXMuX29uVG91Y2hlZCA9IGZuOyB9XG59XG5cbmV4cG9ydCBjb25zdCBNRDJfQ0hJUFNfRElSRUNUSVZFUzogYW55W10gPSBbTWQyQ2hpcHNdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgTWQyQXV0b2NvbXBsZXRlTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBNRDJfQ0hJUFNfRElSRUNUSVZFUyxcbiAgZXhwb3J0czogTUQyX0NISVBTX0RJUkVDVElWRVNcbn0pXG5leHBvcnQgY2xhc3MgTWQyQ2hpcHNNb2R1bGUgeyB9XG4iLCJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjb2xsYXBzZV0nLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnY29sbGFwc2UnLFxuICAgICdbY2xhc3MuaW5dJzogJ19jb2xsYXBzZScsXG4gICAgJ1tjbGFzcy5jb2xsYXBzZV0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jb2xsYXBzaW5nXSc6ICdfY29sbGFwc2luZycsXG4gICAgJ1thdHRyLmFyaWEtZXhwYW5kZWRdJzogJ19jb2xsYXBzZScsXG4gICAgJ1thdHRyLmFyaWEtaGlkZGVuXSc6ICchX2NvbGxhcHNlJ1xuICB9LFxuICBleHBvcnRBczogJ21kMkNvbGxhcHNlJ1xufSlcbmV4cG9ydCBjbGFzcyBNZDJDb2xsYXBzZSB7XG4gIF9jb2xsYXBzZTogYm9vbGVhbiA9IHRydWU7XG4gIF9jb2xsYXBzaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQE91dHB1dCgpIGNvbGxhcHNlZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICBAT3V0cHV0KCkgZXhwYW5kZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICBASW5wdXQoKVxuICBnZXQgY29sbGFwc2UoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jb2xsYXBzZTsgfVxuICBzZXQgY29sbGFwc2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb2xsYXBzZSA9IHZhbHVlO1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gIH1cblxuICAvKipcbiAgICogdG9nZ2xlIGNvbGxhcHNlXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbGxhcHNlKSB7IHRoaXMuaGlkZSgpOyB9IGVsc2UgeyB0aGlzLnNob3coKTsgfVxuICB9XG5cbiAgLyoqXG4gICogc2hvdyBjb2xsYXBzZVxuICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMuX2NvbGxhcHNpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NvbGxhcHNlID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2NvbGxhcHNpbmcgPSBmYWxzZTtcbiAgICB9LCA0KTtcbiAgICB0aGlzLmV4cGFuZGVkLmVtaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBoaWRlIGNvbGxhcHNlXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuX2NvbGxhcHNpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NvbGxhcHNlID0gZmFsc2U7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jb2xsYXBzaW5nID0gZmFsc2U7XG4gICAgfSwgNCk7XG4gICAgdGhpcy5jb2xsYXBzZWQuZW1pdCgpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTWQyQ29sbGFwc2UgfSBmcm9tICcuL2NvbGxhcHNlJztcblxuZXhwb3J0ICogZnJvbSAnLi9jb2xsYXBzZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBleHBvcnRzOiBbTWQyQ29sbGFwc2VdLFxuICBkZWNsYXJhdGlvbnM6IFtNZDJDb2xsYXBzZV0sXG59KVxuZXhwb3J0IGNsYXNzIE1kMkNvbGxhcHNlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgQ09MT1JfUkdCID0gLyhyZ2IpYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqJT8sXFxzKihcXGR7MSwzfSlcXHMqJT8oPzosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKS87XG5leHBvcnQgY29uc3QgQ09MT1JfSFNMID0gLyhoc2wpYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSklXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqKD86LFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkvO1xuXG5leHBvcnQgY2xhc3MgSHN2YSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBoOiBudW1iZXIsIHB1YmxpYyBzOiBudW1iZXIsIHB1YmxpYyB2OiBudW1iZXIsIHB1YmxpYyBhOiBudW1iZXIpIHsgfVxufVxuZXhwb3J0IGNsYXNzIEhzbGEge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaDogbnVtYmVyLCBwdWJsaWMgczogbnVtYmVyLCBwdWJsaWMgbDogbnVtYmVyLCBwdWJsaWMgYTogbnVtYmVyKSB7IH1cbn1cbmV4cG9ydCBjbGFzcyBSZ2JhIHtcbiAgY29uc3RydWN0b3IocHVibGljIHI6IG51bWJlciwgcHVibGljIGc6IG51bWJlciwgcHVibGljIGI6IG51bWJlciwgcHVibGljIGE6IG51bWJlcikgeyB9XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2xvclV0aWwge1xuICAvKipcbiogaHNsYSB0byBoc3ZhXG4qIEBwYXJhbSBoc2xhXG4qL1xuICBoc2xhMmhzdmEoaHNsYTogSHNsYSkge1xuICAgIGxldCBoOiBudW1iZXIgPSBNYXRoLm1pbihoc2xhLmgsIDEpLCBzID0gTWF0aC5taW4oaHNsYS5zLCAxKSwgbCA9IE1hdGgubWluKGhzbGEubCwgMSk7XG4gICAgbGV0IGEgPSBNYXRoLm1pbihoc2xhLmEsIDEpO1xuICAgIGlmIChsID09PSAwKSB7XG4gICAgICByZXR1cm4geyBoOiBoLCBzOiAwLCB2OiAwLCBhOiBhIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2OiBudW1iZXIgPSBsICsgcyAqICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgLyAyO1xuICAgICAgcmV0dXJuIHsgaDogaCwgczogMiAqICh2IC0gbCkgLyB2LCB2OiB2LCBhOiBhIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogaHN2YSB0byBoc2xhXG4gICogQHBhcmFtIGhzdmFcbiAgKi9cbiAgaHN2YTJoc2xhKGhzdmE6IEhzdmEpIHtcbiAgICBsZXQgaCA9IGhzdmEuaCwgcyA9IGhzdmEucywgdiA9IGhzdmEudiwgYSA9IGhzdmEuYTtcbiAgICBpZiAodiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBIc2xhKGgsIDAsIDAsIGEpO1xuICAgIH0gZWxzZSBpZiAocyA9PT0gMCAmJiB2ID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEhzbGEoaCwgMSwgMSwgYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsOiBudW1iZXIgPSB2ICogKDIgLSBzKSAvIDI7XG4gICAgICByZXR1cm4gbmV3IEhzbGEoaCwgdiAqIHMgLyAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpLCBsLCBhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmdiYSB0byBoc3ZhXG4gICAqIEBwYXJhbSByZ2JhXG4gICAqL1xuICByZ2JhVG9Ic3ZhKHJnYmE6IFJnYmEpIHtcbiAgICBsZXQgcjogbnVtYmVyID0gTWF0aC5taW4ocmdiYS5yLCAxKSwgZyA9IE1hdGgubWluKHJnYmEuZywgMSksIGIgPSBNYXRoLm1pbihyZ2JhLmIsIDEpO1xuICAgIGxldCBhID0gTWF0aC5taW4ocmdiYS5hLCAxKTtcbiAgICBsZXQgbWF4OiBudW1iZXIgPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgbGV0IGg6IG51bWJlciwgczogbnVtYmVyLCB2OiBudW1iZXIgPSBtYXg7XG4gICAgbGV0IGQ6IG51bWJlciA9IG1heCAtIG1pbjtcbiAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIc3ZhKGgsIHMsIHYsIGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhzdmEgdG8gcmdiYVxuICAgKiBAcGFyYW0gaHN2YVxuICAgKi9cbiAgaHN2YVRvUmdiYShoc3ZhOiBIc3ZhKSB7XG4gICAgbGV0IGg6IG51bWJlciA9IGhzdmEuaCwgczogbnVtYmVyID0gaHN2YS5zLCB2OiBudW1iZXIgPSBoc3ZhLnYsIGE6IG51bWJlciA9IGhzdmEuYTtcbiAgICBsZXQgcjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcjtcblxuICAgIGxldCBpOiBudW1iZXIgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICBsZXQgZjogbnVtYmVyID0gaCAqIDYgLSBpO1xuICAgIGxldCBwOiBudW1iZXIgPSB2ICogKDEgLSBzKTtcbiAgICBsZXQgcTogbnVtYmVyID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIGxldCB0OiBudW1iZXIgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2OyBnID0gdDsgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByID0gcTsgZyA9IHY7IGIgPSBwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHA7IGcgPSB2OyBiID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwOyBnID0gcTsgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByID0gdDsgZyA9IHA7IGIgPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHY7IGcgPSBwOyBiID0gcTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZ2JhKHIsIGcsIGIsIGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIHN0cmluZyB0byBoc3ZhXG4gICAqIEBwYXJhbSBjb2xvclN0cmluZ1xuICAgKi9cbiAgc3RyaW5nVG9Ic3ZhKGNvbG9yU3RyaW5nOiBzdHJpbmcpIHtcbiAgICBsZXQgc3RyaW5nUGFyc2VycyA9IFtcbiAgICAgIHtcbiAgICAgICAgcmU6IENPTE9SX1JHQixcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChleGVjUmVzdWx0OiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZ2JhKHBhcnNlSW50KGV4ZWNSZXN1bHRbMl0pIC8gMjU1LFxuICAgICAgICAgICAgcGFyc2VJbnQoZXhlY1Jlc3VsdFszXSkgLyAyNTUsXG4gICAgICAgICAgICBwYXJzZUludChleGVjUmVzdWx0WzRdKSAvIDI1NSxcbiAgICAgICAgICAgIGlzTmFOKHBhcnNlRmxvYXQoZXhlY1Jlc3VsdFs1XSkpID8gMSA6IHBhcnNlRmxvYXQoZXhlY1Jlc3VsdFs1XSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZTogQ09MT1JfSFNMLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGV4ZWNSZXN1bHQ6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEhzbGEocGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSkgLyAzNjAsXG4gICAgICAgICAgICBwYXJzZUludChleGVjUmVzdWx0WzNdKSAvIDEwMCxcbiAgICAgICAgICAgIHBhcnNlSW50KGV4ZWNSZXN1bHRbNF0pIC8gMTAwLFxuICAgICAgICAgICAgaXNOYU4ocGFyc2VGbG9hdChleGVjUmVzdWx0WzVdKSkgPyAxIDogcGFyc2VGbG9hdChleGVjUmVzdWx0WzVdKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlOiAvIyhbYS1mQS1GMC05XXsyfSkoW2EtZkEtRjAtOV17Mn0pKFthLWZBLUYwLTldezJ9KSQvLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGV4ZWNSZXN1bHQ6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJnYmEocGFyc2VJbnQoZXhlY1Jlc3VsdFsxXSwgMTYpIC8gMjU1LFxuICAgICAgICAgICAgcGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSwgMTYpIC8gMjU1LFxuICAgICAgICAgICAgcGFyc2VJbnQoZXhlY1Jlc3VsdFszXSwgMTYpIC8gMjU1LFxuICAgICAgICAgICAgMSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlOiAvIyhbYS1mQS1GMC05XSkoW2EtZkEtRjAtOV0pKFthLWZBLUYwLTldKSQvLFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGV4ZWNSZXN1bHQ6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJnYmEocGFyc2VJbnQoZXhlY1Jlc3VsdFsxXSArIGV4ZWNSZXN1bHRbMV0sIDE2KSAvIDI1NSxcbiAgICAgICAgICAgIHBhcnNlSW50KGV4ZWNSZXN1bHRbMl0gKyBleGVjUmVzdWx0WzJdLCAxNikgLyAyNTUsXG4gICAgICAgICAgICBwYXJzZUludChleGVjUmVzdWx0WzNdICsgZXhlY1Jlc3VsdFszXSwgMTYpIC8gMjU1LFxuICAgICAgICAgICAgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICAgIGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgaHN2YTogYW55ID0gbnVsbDtcbiAgICBmb3IgKGxldCBrZXkgaW4gc3RyaW5nUGFyc2Vycykge1xuICAgICAgaWYgKHN0cmluZ1BhcnNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gc3RyaW5nUGFyc2Vyc1trZXldO1xuICAgICAgICBsZXQgbWF0Y2g6IEFycmF5PHN0cmluZz4gPSBwYXJzZXIucmUuZXhlYyhjb2xvclN0cmluZyk7XG4gICAgICAgIGxldCBjb2xvciA9IG1hdGNoICYmIHBhcnNlci5wYXJzZShtYXRjaCk7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIFJnYmEpIHtcbiAgICAgICAgICAgIGhzdmEgPSB0aGlzLnJnYmFUb0hzdmEoY29sb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3IgaW5zdGFuY2VvZiBIc2xhKSB7XG4gICAgICAgICAgICBoc3ZhID0gdGhpcy5oc2xhMmhzdmEoY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaHN2YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHN2YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBvdXRwdXQgZm9ybWF0ZSBvZiBjb2xvclxuICAgKiBAcGFyYW0gaHN2YVxuICAgKiBAcGFyYW0gb3V0cHV0Rm9ybWF0XG4gICAqL1xuICBvdXRwdXRGb3JtYXQoaHN2YTogSHN2YSwgb3V0cHV0Rm9ybWF0OiBzdHJpbmcpIHtcbiAgICBpZiAoaHN2YS5hIDwgMSkge1xuICAgICAgc3dpdGNoIChvdXRwdXRGb3JtYXQpIHtcbiAgICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgICBsZXQgaHNsYSA9IHRoaXMuaHN2YTJoc2xhKGhzdmEpO1xuICAgICAgICAgIGxldCBoc2xhVGV4dCA9IG5ldyBIc2xhKE1hdGgucm91bmQoKGhzbGEuaCkgKiAzNjApLCBNYXRoLnJvdW5kKGhzbGEucyAqIDEwMCksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGhzbGEubCAqIDEwMCksIE1hdGgucm91bmQoaHNsYS5hICogMTAwKSAvIDEwMFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuICdoc2xhKCcgKyBoc2xhVGV4dC5oICsgJywnICsgaHNsYVRleHQucyArICclLCcgK1xuICAgICAgICAgICAgaHNsYVRleHQubCArICclLCcgKyBoc2xhVGV4dC5hICsgJyknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCByZ2JhID0gdGhpcy5kZW5vcm1hbGl6ZVJHQkEodGhpcy5oc3ZhVG9SZ2JhKGhzdmEpKTtcbiAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYmEuciArICcsJyArIHJnYmEuZyArICcsJyArIHJnYmEuYiArXG4gICAgICAgICAgICAnLCcgKyBNYXRoLnJvdW5kKHJnYmEuYSAqIDEwMCkgLyAxMDAgKyAnKSc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3V0cHV0Rm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgbGV0IGhzbGEgPSB0aGlzLmhzdmEyaHNsYShoc3ZhKTtcbiAgICAgICAgICBsZXQgaHNsYVRleHQgPSBuZXcgSHNsYShNYXRoLnJvdW5kKChoc2xhLmgpICogMzYwKSwgTWF0aC5yb3VuZChoc2xhLnMgKiAxMDApLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChoc2xhLmwgKiAxMDApLCBNYXRoLnJvdW5kKGhzbGEuYSAqIDEwMCkgLyAxMDApO1xuICAgICAgICAgIHJldHVybiAnaHNsKCcgKyBoc2xhVGV4dC5oICsgJywnICsgaHNsYVRleHQucyArICclLCcgKyBoc2xhVGV4dC5sICsgJyUpJztcbiAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICBsZXQgcmdiYSA9IHRoaXMuZGVub3JtYWxpemVSR0JBKHRoaXMuaHN2YVRvUmdiYShoc3ZhKSk7XG4gICAgICAgICAgcmV0dXJuICdyZ2IoJyArIHJnYmEuciArICcsJyArIHJnYmEuZyArICcsJyArIHJnYmEuYiArICcpJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5oZXhUZXh0KHRoaXMuZGVub3JtYWxpemVSR0JBKHRoaXMuaHN2YVRvUmdiYShoc3ZhKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoZXhUZXh0KHJnYmE6IFJnYmEpIHtcbiAgICBsZXQgbWFpblRleHQgPSAoKDEgPDwgMjQpIHwgKHJnYmEuciA8PCAxNikgfCAocmdiYS5nIDw8IDgpIHwgcmdiYS5iKS50b1N0cmluZygxNik7XG4gICAgbGV0IGhleFRleHQgPSAnIycgKyBtYWluVGV4dC5zdWJzdHIoMSk7XG4gICAgcmV0dXJuIGhleFRleHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGRlbm9ybWFsaXplUkdCQShyZ2JhOiBSZ2JhKSB7XG4gICAgcmV0dXJuIG5ldyBSZ2JhKE1hdGgucm91bmQocmdiYS5yICogMjU1KSwgTWF0aC5yb3VuZChyZ2JhLmcgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChyZ2JhLmIgKiAyNTUpLCByZ2JhLmEpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgRWxlbWVudFJlZixcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIERpcmVjdGl2ZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgUmVuZGVyZXIsXG4gIFNlbGYsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTmdDb250cm9sXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJy4uL2NvcmUvY29lcmNpb24vYm9vbGVhbi1wcm9wZXJ0eSc7XG5pbXBvcnQgeyBPdmVybGF5IH0gZnJvbSAnLi4vY29yZS9vdmVybGF5L292ZXJsYXknO1xuaW1wb3J0IHsgT3ZlcmxheVJlZiB9IGZyb20gJy4uL2NvcmUvb3ZlcmxheS9vdmVybGF5LXJlZic7XG5pbXBvcnQgeyBPdmVybGF5U3RhdGUgfSBmcm9tICcuLi9jb3JlL292ZXJsYXkvb3ZlcmxheS1zdGF0ZSc7XG5pbXBvcnQgeyBQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vY29yZS9vdmVybGF5L3Bvc2l0aW9uL3Bvc2l0aW9uLXN0cmF0ZWd5JztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnLi4vY29yZS9wb3J0YWwvcG9ydGFsJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ29sb3JVdGlsLCBSZ2JhLCBIc2xhLCBIc3ZhIH0gZnJvbSAnLi9jb2xvci11dGlsJztcblxuZXhwb3J0IGNsYXNzIFNsaWRlclBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIGg6IG51bWJlciwgcHVibGljIHM6IG51bWJlciwgcHVibGljIHY6IG51bWJlciwgcHVibGljIGE6IG51bWJlcikgeyB9XG59XG5leHBvcnQgY2xhc3MgU2xpZGVyRGltZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIGg6IG51bWJlciwgcHVibGljIHM6IG51bWJlciwgcHVibGljIHY6IG51bWJlciwgcHVibGljIGE6IG51bWJlcikgeyB9XG59XG5cbmV4cG9ydCB0eXBlIENvbnRhaW5lciA9ICdpbmxpbmUnIHwgJ2RpYWxvZyc7XG5cbmxldCBuZXh0SWQgPSAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdGV4dF0nLFxuICBob3N0OiB7XG4gICAgJyhpbnB1dCknOiAnY2hhbmdlSW5wdXQoJGV2ZW50KSdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBUZXh0RGlyZWN0aXZlIHtcbiAgQE91dHB1dCgnbmV3VmFsdWUnKSBuZXdWYWx1ZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBASW5wdXQoJ3RleHQnKSB0ZXh0OiBhbnk7XG4gIEBJbnB1dCgncmcnKSByZzogbnVtYmVyO1xuICBjaGFuZ2VJbnB1dChldmVudDogYW55KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgaWYgKHRoaXMucmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5uZXdWYWx1ZS5lbWl0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG51bWVyaWMgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmICghaXNOYU4obnVtZXJpYykgJiYgbnVtZXJpYyA+PSAwICYmIG51bWVyaWMgPD0gdGhpcy5yZykge1xuICAgICAgICB0aGlzLm5ld1ZhbHVlLmVtaXQoeyB2OiBudW1lcmljLCByZzogdGhpcy5yZyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NvbG9ycGlja2VyLXNsaWRlcl0nLFxuICBob3N0OiB7XG4gICAgJyhtb3VzZWRvd24pJzogJ3N0YXJ0KCRldmVudCknLFxuICAgICcodG91Y2hzdGFydCknOiAnc3RhcnQoJGV2ZW50KSdcbiAgfVxufSlcbmV4cG9ydCBjbGFzcyBDb2xvcnBpY2tlclNsaWRlckRpcmVjdGl2ZSB7XG4gIEBJbnB1dCgnY29sb3JwaWNrZXItc2xpZGVyJykgc2xpZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgncG9pbnQteCcpIHBvaW50WDogbnVtYmVyO1xuICBASW5wdXQoJ3BvaW50LXknKSBwb2ludFk6IG51bWJlcjtcbiAgQE91dHB1dCgnY2hhbmdlJykgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gIHByaXZhdGUgbGlzdGVuZXJNb3ZlOiBhbnk7XG4gIHByaXZhdGUgbGlzdGVuZXJTdG9wOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgIHRoaXMubGlzdGVuZXJNb3ZlID0gKGV2ZW50OiBhbnkpID0+IHsgdGhpcy5tb3ZlKGV2ZW50KTsgfTtcbiAgICB0aGlzLmxpc3RlbmVyU3RvcCA9ICgpID0+IHsgdGhpcy5zdG9wKCk7IH07XG4gIH1cblxuICAvKipcbiAgICogc2V0IGN1cnNvciBwb3NpdGlvblxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIHNldEN1cnNvcihldmVudDogYW55KSB7XG4gICAgbGV0IGhlaWdodCA9IHRoaXMuX2dldE5hdGl2ZUVsZW1lbnQoKS5vZmZzZXRIZWlnaHQ7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5fZ2V0TmF0aXZlRWxlbWVudCgpLm9mZnNldFdpZHRoO1xuICAgIGxldCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5nZXRYKGV2ZW50KSwgd2lkdGgpKTtcbiAgICBsZXQgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuZ2V0WShldmVudCksIGhlaWdodCkpO1xuXG4gICAgaWYgKHRoaXMucG9pbnRYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wb2ludFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jaGFuZ2UuZW1pdCh7XG4gICAgICAgIHM6IHggLyB3aWR0aCwgdjogKDEgLSB5IC8gaGVpZ2h0KSxcbiAgICAgICAgcG9pbnRYOiB0aGlzLnBvaW50WCwgcG9pbnRZOiB0aGlzLnBvaW50WVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvaW50WCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucG9pbnRZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2hhbmdlLmVtaXQoeyB2OiB5IC8gaGVpZ2h0LCByZzogdGhpcy5wb2ludFkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbmdlLmVtaXQoeyB2OiB4IC8gd2lkdGgsIHJnOiB0aGlzLnBvaW50WCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogaW5wdXQgZXZlbnQgbGlzdG5lclxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIG1vdmUoZXZlbnQ6IGFueSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5zZXRDdXJzb3IoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIGlucHV0IGV2ZW50IGxpc3RuZXJcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICBzdGFydChldmVudDogYW55KSB7XG4gICAgdGhpcy5zZXRDdXJzb3IoZXZlbnQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubGlzdGVuZXJNb3ZlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmxpc3RlbmVyTW92ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubGlzdGVuZXJTdG9wKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMubGlzdGVuZXJTdG9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdG9wIG1vdXNlIGV2ZW50XG4gICAqL1xuICBzdG9wKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubGlzdGVuZXJNb3ZlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmxpc3RlbmVyTW92ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMubGlzdGVuZXJTdG9wKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMubGlzdGVuZXJTdG9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgeFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIGdldFgoZXZlbnQ6IGFueSkge1xuICAgIGxldCBib3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLl9nZXROYXRpdmVFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIChldmVudC5wYWdlWCAhPT0gdW5kZWZpbmVkID8gZXZlbnQucGFnZVggOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYKSAtXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3QubGVmdCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgeVxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIGdldFkoZXZlbnQ6IGFueSkge1xuICAgIGxldCBib3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLl9nZXROYXRpdmVFbGVtZW50KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIChldmVudC5wYWdlWSAhPT0gdW5kZWZpbmVkID8gZXZlbnQucGFnZVkgOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZKSAtXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3QudG9wIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICB9XG5cbiAgX2dldE5hdGl2ZUVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWQyQ29sb3JwaWNrZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZDJDb2xvckNoYW5nZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzb3VyY2U6IE1kMkNvbG9ycGlja2VyLCBwdWJsaWMgY29sb3I6IHN0cmluZykgeyB9XG59XG5cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItY29sb3JwaWNrZXInLFxuICB0ZW1wbGF0ZVVybDogJ2NvbG9ycGlja2VyLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnY29sb3JwaWNrZXIuc2NzcyddLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnY29sb3JwaWNrZXInLFxuICAgICdbaWRdJzogJ2lkJyxcbiAgICAnW2NsYXNzLm1kMi1jb2xvcnBpY2tlci1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdwbGFjZWhvbGRlcicsXG4gICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkLnRvU3RyaW5nKCknLFxuICB9LFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIE1kMkNvbG9ycGlja2VyIGltcGxlbWVudHMgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDtcbiAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcbiAgcHJpdmF0ZSBfYmFja2Ryb3BTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBfaW5uZXJWYWx1ZTogc3RyaW5nID0gJyc7XG4gIF9pc0NvbG9ycGlja2VyVmlzaWJsZTogYm9vbGVhbjtcbiAgX2h1ZVNsaWRlckNvbG9yOiBzdHJpbmc7XG4gIHNsaWRlcjogU2xpZGVyUG9zaXRpb247XG4gIHNsaWRlckRpbTogU2xpZGVyRGltZW5zaW9uO1xuICBoc3ZhOiBIc3ZhO1xuICByZ2JhVGV4dDogUmdiYTtcbiAgaHNsYVRleHQ6IEhzbGE7XG4gIG91dHB1dENvbG9yOiBzdHJpbmc7XG4gIGFscGhhQ29sb3I6IHN0cmluZztcbiAgaGV4VGV4dDogc3RyaW5nO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgYmFja0NvbG9yOiBib29sZWFuID0gdHJ1ZTtcblxuICBwcml2YXRlIF9jcmVhdGVkOiBib29sZWFuO1xuICBwcml2YXRlIF9kZWZhbHV0Q29sb3I6IHN0cmluZyA9ICcjMDAwMDAwJztcbiAgcHJpdmF0ZSBfaW5pdGlhbENvbG9yOiBzdHJpbmc7XG5cbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gIHByaXZhdGUgX3BhbmVsT3BlbiA9IGZhbHNlO1xuICBwcml2YXRlIF9jb2xvcjogc3RyaW5nID0gbnVsbDtcblxuICAvKiogV2hldGhlciBmaWxsaW5nIG91dCB0aGUgc2VsZWN0IGlzIHJlcXVpcmVkIGluIHRoZSBmb3JtLiAgKi9cbiAgX3JlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZC4gICovXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIGlzSW5wdXRGb2N1czogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgcGxhY2Vob2xkZXIgZGlzcGxheWVkIGluIHRoZSB0cmlnZ2VyIG9mIHRoZSBzZWxlY3QuICovXG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyOiBzdHJpbmc7XG4gIHByaXZhdGUgX2NvbnRhaW5lcjogQ29udGFpbmVyID0gJ2lubGluZSc7XG5cbiAgZm9udENvbG9yOiBzdHJpbmc7XG4gIF9pc0Rhcms6IGJvb2xlYW47XG4gIGlzSW5wdXRWYWxpZENvbG9yOiBib29sZWFuID0gZmFsc2U7XG5cbiAgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgX29uVG91Y2hlZCA9ICgpID0+IHsgfTtcblxuICBASW5wdXQoKVxuICBnZXQgY29sb3IoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfVxuICBzZXQgY29sb3IodmFsdWU6IHN0cmluZykgeyB0aGlzLl9jb2xvciA9IHZhbHVlOyB9XG5cbiAgLyoqIFBsYWNlaG9sZGVyIHRvIGJlIHNob3duIGlmIG5vIHZhbHVlIGhhcyBiZWVuIHNlbGVjdGVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgcGxhY2Vob2xkZXIoKSB7IHJldHVybiB0aGlzLl9wbGFjZWhvbGRlcjsgfVxuICBzZXQgcGxhY2Vob2xkZXIodmFsdWU6IHN0cmluZykgeyB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlOyB9XG5cbiAgQElucHV0KClcbiAgZ2V0IHJlcXVpcmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH1cbiAgc2V0IHJlcXVpcmVkKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIEBJbnB1dCgnZm9ybWF0JykgY0Zvcm1hdDogc3RyaW5nID0gJ2hleCc7XG4gIEBPdXRwdXQoJ2NvbG9ycGlja2VyQ2hhbmdlJykgY29sb3JwaWNrZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgZGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIGJ5IHRoZSB1c2VyLiAqL1xuICBAT3V0cHV0KCkgY2hhbmdlOiBFdmVudEVtaXR0ZXI8TWQyQ29sb3JDaGFuZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxNZDJDb2xvckNoYW5nZT4oKTtcbiAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSAnbWQyLWNvbG9ycGlja2VyLScgKyAoKytuZXh0SWQpO1xuXG4gIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9pbm5lclZhbHVlO1xuXG4gIH1cbiAgLyoqXG4gICogc2V0IGFjY2Vzc29yIGluY2x1ZGluZyBjYWxsIHRoZSBvbmNoYW5nZSBjYWxsYmFja1xuICAqL1xuICBzZXQgdmFsdWUodjogYW55KSB7XG4gICAgaWYgKHYgIT09IHRoaXMuX2lubmVyVmFsdWUpIHtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIHRoaXMuaHN2YSA9IHRoaXMuX3V0aWwuc3RyaW5nVG9Ic3ZhKHYpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5uZXJWYWx1ZSA9IHY7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KClcbiAgZ2V0IGNvbnRhaW5lcigpIHsgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjsgfVxuICBzZXQgY29udGFpbmVyKHZhbHVlOiBDb250YWluZXIpIHtcbiAgICBpZiAodGhpcy5fY29udGFpbmVyICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gdmFsdWUgfHwgJ2lubGluZSc7XG4gICAgICB0aGlzLmRlc3Ryb3lQYW5lbCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzZXRHcmFkaWVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCB0cmFuc3BhcmVudCwgdHJhbnNwYXJlbnQpLCcgK1xuICAgICAgJ2xpbmVhci1ncmFkaWVudCh0byBsZWZ0LCAnICsgdGhpcy5oZXhUZXh0ICsgJywgcmdiYSgyNTUsIDI1NSwgMjU1LCAwKSknXG4gICAgfTtcblxuICB9XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIG9wZW5lZC4gKi9cbiAgQE91dHB1dCgpIG9uT3BlbjogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBjbG9zZWQuICovXG4gIEBPdXRwdXQoKSBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgQFZpZXdDaGlsZCgncG9ydGFsJykgX3RlbXBsYXRlUG9ydGFsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgIHByaXZhdGUgX3V0aWw6IENvbG9yVXRpbCwgQFNlbGYoKSBAT3B0aW9uYWwoKSBwdWJsaWMgX2NvbnRyb2w6IE5nQ29udHJvbCkge1xuICAgIHRoaXMuX2NyZWF0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fY29udHJvbCkge1xuICAgICAgdGhpcy5fY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHsgdGhpcy5kZXN0cm95UGFuZWwoKTsgfVxuXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBwYW5lbCBpcyBvcGVuLiAqL1xuICBnZXQgcGFuZWxPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wYW5lbE9wZW47XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgb3ZlcmxheSBwYW5lbCBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cblxuICAvKiogT3BlbnMgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgbGV0IGhzdmEgPSB0aGlzLl91dGlsLnN0cmluZ1RvSHN2YSh0aGlzLmNvbG9yICsgJycpO1xuICAgIHRoaXMuaXNJbnB1dEZvY3VzID0gdHJ1ZTtcbiAgICBpZiAoaHN2YSkge1xuICAgICAgdGhpcy5oc3ZhID0gaHN2YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oc3ZhID0gdGhpcy5fdXRpbC5zdHJpbmdUb0hzdmEodGhpcy5fZGVmYWx1dENvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnNsaWRlckRpbSA9IG5ldyBTbGlkZXJEaW1lbnNpb24oMjQ1LCAyNTAsIDEzMCwgMjQ1KTtcbiAgICB0aGlzLnNsaWRlciA9IG5ldyBTbGlkZXJQb3NpdGlvbigwLCAwLCAwLCAwKTtcbiAgICBpZiAodGhpcy5jRm9ybWF0ID09PSAncmdiJykge1xuICAgICAgdGhpcy5mb3JtYXQgPSAxO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jRm9ybWF0ID09PSAnaHNsJykge1xuICAgICAgdGhpcy5mb3JtYXQgPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcm1hdCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoIXRoaXMuX2lzQ29sb3JwaWNrZXJWaXNpYmxlKSB7XG4gICAgICB0aGlzLl9pbml0aWFsQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMuX2lzQ29sb3JwaWNrZXJWaXNpYmxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNDb2xvcnBpY2tlclZpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG5cbiAgICBpZiAoIXRoaXMuX3BvcnRhbCkge1xuICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3RlbXBsYXRlUG9ydGFsLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpO1xuICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcbiAgICB0aGlzLl9wYW5lbE9wZW4gPSB0cnVlO1xuICAgIHRoaXMub25PcGVuLmVtaXQoKTtcbiAgfVxuXG4gIC8qKiBDbG9zZXMgdGhlIG92ZXJsYXkgcGFuZWwgYW5kIGZvY3VzZXMgdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5pc0lucHV0Rm9jdXMgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuX2lzQ29sb3JwaWNrZXJWaXNpYmxlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2lubmVyVmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0Q29sb3JGcm9tU3RyaW5nKHRoaXMuX2lubmVyVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwYW5lbCBmcm9tIHRoZSBET00uICovXG4gIGRlc3Ryb3lQYW5lbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICBfb25CbHVyKCkge1xuICAgIGlmICghdGhpcy5wYW5lbE9wZW4pIHtcbiAgICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICAqIGlucHV0IGV2ZW50IGxpc3RuZXJcbiAgICAqIEBwYXJhbSBldmVudFxuICAgICovXG4gIGNoYW5nZUlucHV0KGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgdGhpcy5jb2xvcnBpY2tlckNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAqIHNldCBzYXR1cmF0aW9uLGxpZ2h0bmVzcyxodWUsYWxwaGEsUkdCIHZhbHVlXG4gICogQHBhcmFtIHZhbFxuICAqIEBwYXJhbSByZ1xuICAqL1xuICBzZXRTYXR1cmF0aW9uKHZhbDogeyB2OiBudW1iZXIsIHJnOiBudW1iZXIgfSkge1xuICAgIGxldCBoc2xhID0gdGhpcy5fdXRpbC5oc3ZhMmhzbGEodGhpcy5oc3ZhKTtcbiAgICBoc2xhLnMgPSB2YWwudiAvIHZhbC5yZztcbiAgICB0aGlzLmhzdmEgPSB0aGlzLl91dGlsLmhzbGEyaHN2YShoc2xhKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgc2V0TGlnaHRuZXNzKHZhbDogeyB2OiBudW1iZXIsIHJnOiBudW1iZXIgfSkge1xuICAgIGxldCBoc2xhID0gdGhpcy5fdXRpbC5oc3ZhMmhzbGEodGhpcy5oc3ZhKTtcbiAgICBoc2xhLmwgPSB2YWwudiAvIHZhbC5yZztcbiAgICB0aGlzLmhzdmEgPSB0aGlzLl91dGlsLmhzbGEyaHN2YShoc2xhKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgc2V0SHVlKHZhbDogeyB2OiBudW1iZXIsIHJnOiBudW1iZXIgfSkge1xuICAgIHRoaXMuaHN2YS5oID0gdmFsLnYgLyB2YWwucmc7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHNldEFscGhhKHZhbDogeyB2OiBudW1iZXIsIHJnOiBudW1iZXIgfSkge1xuICAgIHRoaXMuaHN2YS5hID0gdmFsLnYgLyB2YWwucmc7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHNldFIodmFsOiB7IHY6IG51bWJlciwgcmc6IG51bWJlciB9KSB7XG4gICAgbGV0IHJnYmEgPSB0aGlzLl91dGlsLmhzdmFUb1JnYmEodGhpcy5oc3ZhKTtcbiAgICByZ2JhLnIgPSB2YWwudiAvIHZhbC5yZztcbiAgICB0aGlzLmhzdmEgPSB0aGlzLl91dGlsLnJnYmFUb0hzdmEocmdiYSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICBzZXRHKHZhbDogeyB2OiBudW1iZXIsIHJnOiBudW1iZXIgfSkge1xuICAgIGxldCByZ2JhID0gdGhpcy5fdXRpbC5oc3ZhVG9SZ2JhKHRoaXMuaHN2YSk7XG4gICAgcmdiYS5nID0gdmFsLnYgLyB2YWwucmc7XG4gICAgdGhpcy5oc3ZhID0gdGhpcy5fdXRpbC5yZ2JhVG9Ic3ZhKHJnYmEpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgc2V0Qih2YWw6IHsgdjogbnVtYmVyLCByZzogbnVtYmVyIH0pIHtcbiAgICBsZXQgcmdiYSA9IHRoaXMuX3V0aWwuaHN2YVRvUmdiYSh0aGlzLmhzdmEpO1xuICAgIHJnYmEuYiA9IHZhbC52IC8gdmFsLnJnO1xuICAgIHRoaXMuaHN2YSA9IHRoaXMuX3V0aWwucmdiYVRvSHN2YShyZ2JhKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIHNldFNhdHVyYXRpb25BbmRCcmlnaHRuZXNzKHZhbDogeyBzOiBudW1iZXIsIHY6IG51bWJlciwgcG9pbnRYOiBudW1iZXIsIHBvaW50WTogbnVtYmVyIH0pIHtcbiAgICB0aGlzLmhzdmEucyA9IHZhbC5zIC8gdmFsLnBvaW50WDtcbiAgICB0aGlzLmhzdmEudiA9IHZhbC52IC8gdmFsLnBvaW50WTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIGNsaWNrT2soKSB7XG4gICAgdGhpcy5faXNDb2xvcnBpY2tlclZpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLmlzSW5wdXRWYWxpZENvbG9yID0gZmFsc2U7XG4gICAgdGhpcy5jb2xvciA9IHRoaXMuX2lubmVyVmFsdWU7XG5cbiAgICBpZiAodGhpcy5faW5uZXJWYWx1ZSAhPSB0aGlzLl9pbml0aWFsQ29sb3IpIHtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH1cbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgKiBkZXNlbGVjdCByZWNlbnQgY29sb3IgYW5kIGNsb3NlIHBvcHVwXG4gICovXG4gIGNhbmNlbENvbG9yKCkge1xuICAgIHRoaXMuX2lubmVyVmFsdWUgPSB0aGlzLl9pbml0aWFsQ29sb3I7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG4gIGlzVmFsaWRDb2xvcihzdHI6IHN0cmluZykge1xuICAgIHJldHVybiBzdHIubWF0Y2goL14jW2EtZjAtOV17Nn0kL2kpICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgICAqIHNldCBjb2xvclxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICBzZXRDb2xvckZyb21TdHJpbmcodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQ29sb3IodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9ICcjMDAwMDAwJztcbiAgICAgIHRoaXMuYmFja0NvbG9yID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBoc3ZhID0gdGhpcy5fdXRpbC5zdHJpbmdUb0hzdmEodmFsdWUpO1xuICAgIGlmIChoc3ZhICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmhzdmEgPSBoc3ZhO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZm9ybWF0UG9saWN5KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmZvcm1hdCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmZvcm1hdCA9PT0gMCAmJiB0aGlzLmhzdmEuYSA8IDEpIHtcbiAgICAgIHRoaXMuZm9ybWF0Kys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiB1cGRhdGUgY29sb3JcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgaHNsYSA9IHRoaXMuX3V0aWwuaHN2YTJoc2xhKHRoaXMuaHN2YSk7XG4gICAgbGV0IHJnYmEgPSB0aGlzLl91dGlsLmRlbm9ybWFsaXplUkdCQSh0aGlzLl91dGlsLmhzdmFUb1JnYmEodGhpcy5oc3ZhKSk7XG4gICAgbGV0IGh1ZVJnYmEgPSB0aGlzLl91dGlsLmRlbm9ybWFsaXplUkdCQSh0aGlzLl91dGlsLmhzdmFUb1JnYmEoXG4gICAgICBuZXcgSHN2YSh0aGlzLmhzdmEuaCwgMSwgMSwgMSkpKTtcblxuICAgIHRoaXMuYWxwaGFDb2xvciA9ICdyZ2IoJyArIHJnYmEuciArICcsJyArIHJnYmEuZyArICcsJyArIHJnYmEuYiArICcpJztcbiAgICB0aGlzLl9odWVTbGlkZXJDb2xvciA9ICdyZ2IoJyArIGh1ZVJnYmEuciArICcsJyArIGh1ZVJnYmEuZyArICcsJyArIGh1ZVJnYmEuYiArICcpJztcbiAgICB0aGlzLmhzbGFUZXh0ID0gbmV3IEhzbGEoTWF0aC5yb3VuZCgoaHNsYS5oKSAqIDM2MCksIE1hdGgucm91bmQoaHNsYS5zICogMTAwKSxcbiAgICAgIE1hdGgucm91bmQoaHNsYS5sICogMTAwKSwgTWF0aC5yb3VuZChoc2xhLmEgKiAxMDApIC8gMTAwKTtcbiAgICB0aGlzLnJnYmFUZXh0ID0gbmV3IFJnYmEocmdiYS5yLCByZ2JhLmcsIHJnYmEuYiwgTWF0aC5yb3VuZChyZ2JhLmEgKiAxMDApIC8gMTAwKTtcbiAgICBpZiAodGhpcy5iYWNrQ29sb3IpIHtcbiAgICAgIHRoaXMuaGV4VGV4dCA9IHRoaXMuX3V0aWwuaGV4VGV4dChyZ2JhKTtcbiAgICB9XG4gICAgdGhpcy5iYWNrQ29sb3IgPSB0cnVlO1xuICAgIGxldCBjb2xvckNvZGUgPSBNYXRoLnJvdW5kKCh0aGlzLnJnYmFUZXh0LnIgKiAyOTkgKyB0aGlzLnJnYmFUZXh0LmcgKiA1ODcgK1xuICAgICAgdGhpcy5yZ2JhVGV4dC5iICogMTE0KSAvIDEwMDApO1xuICAgIGlmIChjb2xvckNvZGUgPj0gMTI4IHx8IHRoaXMuaHN2YS5hIDwgMC4zNSkge1xuICAgICAgdGhpcy5mb250Q29sb3IgPSAnYmxhY2snO1xuICAgICAgdGhpcy5faXNEYXJrID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb250Q29sb3IgPSAnd2hpdGUnO1xuICAgICAgdGhpcy5faXNEYXJrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9ybWF0ID09PSAwICYmIHRoaXMuaHN2YS5hIDwgMSkge1xuICAgICAgdGhpcy5mb3JtYXQrKztcbiAgICB9XG4gICAgdGhpcy5vdXRwdXRDb2xvciA9IHRoaXMuX3V0aWwub3V0cHV0Rm9ybWF0KHRoaXMuaHN2YSwgdGhpcy5jRm9ybWF0KTtcbiAgICB0aGlzLnNsaWRlciA9IG5ldyBTbGlkZXJQb3NpdGlvbigodGhpcy5oc3ZhLmgpICogdGhpcy5zbGlkZXJEaW0uaCxcbiAgICAgIHRoaXMuaHN2YS5zICogdGhpcy5zbGlkZXJEaW0ucyAtIDcsICgxIC0gdGhpcy5oc3ZhLnYpICogdGhpcy5zbGlkZXJEaW0udiAtIDcsXG4gICAgICB0aGlzLmhzdmEuYSAqIHRoaXMuc2xpZGVyRGltLmEpO1xuICAgIHRoaXMuX2lubmVyVmFsdWUgPSB0aGlzLm91dHB1dENvbG9yO1xuICB9XG5cbiAgY2xlYXJDb2xvcihldmVudDogRXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLmNvbG9yID0gJyc7XG4gICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gIH1cblxuICBpc0Rlc2NlbmRhbnQocGFyZW50OiBhbnksIGNoaWxkOiBhbnkpIHtcbiAgICBsZXQgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjaGVja0lucHV0VmFsKCk6IHZvaWQge1xuICAgIHRoaXMuaHN2YSA9IHRoaXMuX3V0aWwuc3RyaW5nVG9Ic3ZhKHRoaXMuY29sb3IgKyAnJyk7XG4gICAgdGhpcy5pc0lucHV0Rm9jdXMgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5oc3ZhKSB7XG4gICAgICBpZiAodGhpcy5faW5uZXJWYWx1ZSAhPT0gdGhpcy5jb2xvcikge1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNJbnB1dFZhbGlkQ29sb3IgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0lucHV0VmFsaWRDb2xvciA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICB9XG5cbiAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGNvbG9yLiAqL1xuICBfZW1pdENoYW5nZUV2ZW50KCk6IHZvaWQge1xuICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuY29sb3IpO1xuICAgIHRoaXMuY2hhbmdlLmVtaXQobmV3IE1kMkNvbG9yQ2hhbmdlKHRoaXMsIHRoaXMuY29sb3IpKTtcbiAgICB0aGlzLl9pbm5lclZhbHVlID0gdGhpcy5jb2xvcjtcbiAgfVxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9pbm5lclZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5jb2xvciA9IHZhbHVlO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB7fSk6IHZvaWQgeyB0aGlzLl9vblRvdWNoZWQgPSBmbjsgfVxuXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcbiAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLl9pbm5lclZhbHVlID0gdGhpcy5faW5pdGlhbENvbG9yO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIHBhbmVsJ3MgdGVtcGxhdGUgYW5kIHNhdmVzIGl0c1xuICAgKiAgT3ZlcmxheVJlZiBzbyB0aGF0IGl0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZW4gb3BlbiBpcyBjYWxsZWQuXG4gICAqL1xuICBwcml2YXRlIF9jcmVhdGVPdmVybGF5KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgbGV0IGNvbmZpZyA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9jcmVhdGVQaWNrZXJQb3NpdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgIGNvbmZpZy5oYXNCYWNrZHJvcCA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJztcbiAgICAgICAgY29uZmlnLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXG4gICAgICAgICAgLmdsb2JhbCgpXG4gICAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpXG4gICAgICAgICAgLmNlbnRlclZlcnRpY2FsbHkoKTtcbiAgICAgICAgY29uZmlnLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgdGhlIHBvcHVwIFBvc2l0aW9uU3RyYXRlZ3kuICovXG4gIHByaXZhdGUgX2NyZWF0ZVBpY2tlclBvc2l0aW9uU3RyYXRlZ3koKTogUG9zaXRpb25TdHJhdGVneSB7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQsXG4gICAgICB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ3RvcCcgfSlcbiAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICd0b3AnIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXG4gICAgICB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSlcbiAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdib3R0b20nIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdib3R0b20nIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSwgT3ZlcmxheU1vZHVsZSwgUG9ydGFsTW9kdWxlLCBBMTF5TW9kdWxlIH0gZnJvbSAnLi4vY29yZS9pbmRleCc7XG5pbXBvcnQgeyBNZDJDb2xvcnBpY2tlciwgQ29sb3JwaWNrZXJTbGlkZXJEaXJlY3RpdmUsIFRleHREaXJlY3RpdmUgfSBmcm9tICcuL2NvbG9ycGlja2VyJztcbmltcG9ydCB7IENvbG9yVXRpbCB9IGZyb20gJy4vY29sb3ItdXRpbCc7XG5cblxuZXhwb3J0ICogZnJvbSAnLi9jb2xvcnBpY2tlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbG9yLXV0aWwnO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgRm9ybXNNb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBQb3J0YWxNb2R1bGUsXG4gICAgU3R5bGVNb2R1bGUsXG4gICAgQTExeU1vZHVsZSxcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIE1kMkNvbG9ycGlja2VyLFxuICAgIENvbG9ycGlja2VyU2xpZGVyRGlyZWN0aXZlLFxuICAgIFRleHREaXJlY3RpdmVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgTWQyQ29sb3JwaWNrZXIsXG4gICAgQ29sb3JwaWNrZXJTbGlkZXJEaXJlY3RpdmUsXG4gICAgVGV4dERpcmVjdGl2ZVxuICBdLFxuICBwcm92aWRlcnM6IFtDb2xvclV0aWxdXG59KVxuZXhwb3J0IGNsYXNzIE1kMkNvbG9ycGlja2VyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBDb250ZW50Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHttaXhpbkRpc2FibGVkLCBDYW5EaXNhYmxlfSBmcm9tICcuLi9jb3JlL2NvbW1vbi1iZWhhdmlvcnMvZGlzYWJsZWQnO1xuXG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1kMk9wdGdyb3VwLlxuZXhwb3J0IGNsYXNzIE1kMk9wdGdyb3VwQmFzZSB7IH1cbmV4cG9ydCBjb25zdCBfTWQyT3B0Z3JvdXBNaXhpbkJhc2UgPSBtaXhpbkRpc2FibGVkKE1kMk9wdGdyb3VwQmFzZSk7XG5cbi8vIENvdW50ZXIgZm9yIHVuaXF1ZSBncm91cCBpZHMuXG5sZXQgbmV4dElkID0gMDtcblxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBpcyB1c2VkIHRvIGdyb3VwIGluc3RhbmNlcyBvZiBgbWQyLW9wdGlvbmAuXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItb3B0Z3JvdXAnLFxuICB0ZW1wbGF0ZVVybDogJ29wdGdyb3VwLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnb3B0Z3JvdXAuc2NzcyddLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBpbnB1dHM6IFsnZGlzYWJsZWQnXSxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdtZDItb3B0Z3JvdXAnLFxuICAgICdyb2xlJzogJ2dyb3VwJyxcbiAgICAnW2NsYXNzLm1kMi1vcHRncm91cC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdfbGFiZWxJZCcsXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTWQyT3B0Z3JvdXAgZXh0ZW5kcyBfTWQyT3B0Z3JvdXBNaXhpbkJhc2UgaW1wbGVtZW50cyBDYW5EaXNhYmxlIHtcbiAgLyoqIExhYmVsIGZvciB0aGUgb3B0aW9uIGdyb3VwLiAqL1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBVbmlxdWUgaWQgZm9yIHRoZSB1bmRlcmx5aW5nIGxhYmVsLiAqL1xuICBfbGFiZWxJZDogc3RyaW5nID0gYG1kMi1vcHRncm91cC1sYWJlbC0ke25leHRJZCsrfWA7XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgT3B0aW9uYWwsXG4gIE5nTW9kdWxlLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRU5URVIsIFNQQUNFIH0gZnJvbSAnLi4vY29yZS9rZXlib2FyZC9rZXljb2Rlcyc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL2NvZXJjaW9uL2Jvb2xlYW4tcHJvcGVydHknO1xuaW1wb3J0IHsgTWRTZWxlY3Rpb25Nb2R1bGUgfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi9pbmRleCc7XG5pbXBvcnQgeyBNZDJPcHRncm91cCB9IGZyb20gJy4vb3B0Z3JvdXAnO1xuXG4vKipcbiAqIE9wdGlvbiBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5sZXQgX3VuaXF1ZUlkQ291bnRlciA9IDA7XG5cbi8qKiBFdmVudCBvYmplY3QgZW1pdHRlZCBieSBNZE9wdGlvbiB3aGVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuICovXG5leHBvcnQgY2xhc3MgTWQyT3B0aW9uU2VsZWN0aW9uQ2hhbmdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogTWQyT3B0aW9uLCBwdWJsaWMgaXNVc2VySW5wdXQgPSBmYWxzZSkgeyB9XG59XG5cblxuLyoqXG4gKiBTaW5nbGUgb3B0aW9uIGluc2lkZSBvZiBhIGA8bWQyLXNlbGVjdD5gIGVsZW1lbnQuXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItb3B0aW9uJyxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgJ1tjbGFzcy5tZDItc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAnW2NsYXNzLm1kMi1vcHRpb24tbXVsdGlwbGVdJzogJ211bHRpcGxlJyxcbiAgICAnW2NsYXNzLm1kMi1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZC50b1N0cmluZygpJyxcbiAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgJ1tjbGFzcy5tZDItb3B0aW9uLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJyhjbGljayknOiAnX3NlbGVjdFZpYUludGVyYWN0aW9uKCknLFxuICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgJ1tjbGFzcy5tZDItb3B0aW9uXSc6ICd0cnVlJyxcbiAgfSxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgc3R5bGVVcmxzOiBbJ29wdGlvbi5zY3NzJ10sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTWQyT3B0aW9uIHtcbiAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBkaXNhYmxlZC4gICovXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfaWQ6IHN0cmluZyA9IGBtZDItb3B0aW9uLSR7X3VuaXF1ZUlkQ291bnRlcisrfWA7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHdyYXBwaW5nIGNvbXBvbmVudCBpcyBpbiBtdWx0aXBsZSBzZWxlY3Rpb24gbW9kZS4gKi9cbiAgbXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgb3B0aW9uLiAqL1xuICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLl9pZDsgfVxuXG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3B0aW9uIGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKi9cbiAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH1cblxuICAvKiogVGhlIGZvcm0gdmFsdWUgb2YgdGhlIG9wdGlvbi4gKi9cbiAgQElucHV0KCkgdmFsdWU6IGFueTtcblxuICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgZGlzYWJsZWQoKSB7IHJldHVybiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmRpc2FibGVkKSB8fCB0aGlzLl9kaXNhYmxlZDsgfVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGFueSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC4gKi9cbiAgQE91dHB1dCgpIG9uU2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxNZDJPcHRpb25TZWxlY3Rpb25DaGFuZ2U+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHVibGljIHJlYWRvbmx5IGdyb3VwOiBNZDJPcHRncm91cCxcbiAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmKSB7IH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCByZWFkeSB0byBiZSBzZWxlY3RlZC5cbiAgICogQW4gYWN0aXZlIG9wdGlvbiBkaXNwbGF5cyBzdHlsZXMgYXMgaWYgaXQgaXMgZm9jdXNlZCwgYnV0IHRoZVxuICAgKiBmb2N1cyBpcyBhY3R1YWxseSByZXRhaW5lZCBzb21ld2hlcmUgZWxzZS4gVGhpcyBjb21lcyBpbiBoYW5keVxuICAgKiBmb3IgY29tcG9uZW50cyBsaWtlIGF1dG9jb21wbGV0ZSB3aGVyZSBmb2N1cyBtdXN0IHJlbWFpbiBvbiB0aGUgaW5wdXQuXG4gICAqL1xuICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgb3B0aW9uLiBJdCBpcyBuZWNlc3NhcnkgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZVxuICAgKiBzZWxlY3QncyB0cmlnZ2VyLlxuICAgKi9cbiAgZ2V0IHZpZXdWYWx1ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLnRleHRDb250ZW50LnRyaW0oKTtcbiAgfVxuXG4gIC8qKiBTZWxlY3RzIHRoZSBvcHRpb24uICovXG4gIHNlbGVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gIH1cblxuICAvKiogRGVzZWxlY3RzIHRoZSBvcHRpb24uICovXG4gIGRlc2VsZWN0KCk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gIH1cblxuICAvKiogU2V0cyBmb2N1cyBvbnRvIHRoaXMgb3B0aW9uLiAqL1xuICBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2V0cyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRvIG1ha2UgaXQgYXBwZWFyXG4gICAqIGFjdGl2ZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBzbyBrZXlcbiAgICogZXZlbnRzIHdpbGwgZGlzcGxheSB0aGUgcHJvcGVyIG9wdGlvbnMgYXMgYWN0aXZlIG9uIGFycm93IGtleSBldmVudHMuXG4gICAqL1xuICBzZXRBY3RpdmVTdHlsZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIGRpc3BsYXkgc3R5bGVzIG9uIHRoZSBvcHRpb24gdGhhdCBtYWRlIGl0IGFwcGVhclxuICAgKiBhY3RpdmUuIFRoaXMgaXMgdXNlZCBieSB0aGUgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgc28ga2V5XG4gICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgKi9cbiAgc2V0SW5hY3RpdmVTdHlsZXMoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIH1cblxuICAvKiogRW5zdXJlcyB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIHdoZW4gYWN0aXZhdGVkIGZyb20gdGhlIGtleWJvYXJkLiAqL1xuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgdGhpcy5fc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgb3B0aW9uIHdoaWxlIGluZGljYXRpbmcgdGhlIHNlbGVjdGlvbiBjYW1lIGZyb20gdGhlIHVzZXIuIFVzZWQgdG9cbiAgICogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QncyB2aWV3IC0+IG1vZGVsIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLlxuICAgKi9cbiAgX3NlbGVjdFZpYUludGVyYWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gIXRoaXMuX3NlbGVjdGVkIDogdHJ1ZTtcbiAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuICovXG4gIF9nZXRUYWJJbmRleCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJztcbiAgfVxuXG4gIC8qKiBGZXRjaGVzIHRoZSBob3N0IERPTSBlbGVtZW50LiAqL1xuICBfZ2V0SG9zdEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICAvKiogRW1pdHMgdGhlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQuICovXG4gIHByaXZhdGUgX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudChpc1VzZXJJbnB1dCA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5lbWl0KG5ldyBNZDJPcHRpb25TZWxlY3Rpb25DaGFuZ2UodGhpcywgaXNVc2VySW5wdXQpKTtcbiAgfVxuXG59XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1kU2VsZWN0aW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW01kMk9wdGlvbiwgTWQyT3B0Z3JvdXBdLFxuICBkZWNsYXJhdGlvbnM6IFtNZDJPcHRpb24sIE1kMk9wdGdyb3VwXVxufSlcbmV4cG9ydCBjbGFzcyBNZDJPcHRpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQge1F1ZXJ5TGlzdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1VQX0FSUk9XLCBET1dOX0FSUk9XLCBUQUJ9IGZyb20gJy4uL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBmb3IgaXRlbXMgdGhhdCBjYW4gYmUgZGlzYWJsZWQuIFRoZSB0eXBlIHBhc3NlZCBpbnRvXG4gKiBMaXN0S2V5TWFuYWdlciBtdXN0IGV4dGVuZCB0aGlzIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYW5EaXNhYmxlIHtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBrZXlib2FyZCBldmVudHMgZm9yIHNlbGVjdGFibGUgbGlzdHMuIElmIHlvdSBwYXNzIGl0IGEgcXVlcnkgbGlzdFxuICogb2YgaXRlbXMsIGl0IHdpbGwgc2V0IHRoZSBhY3RpdmUgaXRlbSBjb3JyZWN0bHkgd2hlbiBhcnJvdyBldmVudHMgb2NjdXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaXN0S2V5TWFuYWdlcjxUIGV4dGVuZHMgQ2FuRGlzYWJsZT4ge1xuICBwcml2YXRlIF9hY3RpdmVJdGVtSW5kZXg6IG51bWJlciA9IG51bGw7XG4gIHByaXZhdGUgX2FjdGl2ZUl0ZW06IFQ7XG4gIHByaXZhdGUgX3RhYk91dCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgX3dyYXA6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pdGVtczogUXVlcnlMaXN0PFQ+KSB7XG4gIH1cblxuICAvKipcbiAgICogVHVybnMgb24gd3JhcHBpbmcgbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBhY3RpdmUgaXRlbSB3aWxsIHdyYXAgdG9cbiAgICogdGhlIG90aGVyIGVuZCBvZiBsaXN0IHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIExpc3RLZXlNYW5hZ2VyIHRoYXQgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIG9uLlxuICAgKi9cbiAgd2l0aFdyYXAoKTogdGhpcyB7XG4gICAgdGhpcy5fd3JhcCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIGluZGV4IHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byBiZSBzZXQgYXMgYWN0aXZlLlxuICAgKi9cbiAgc2V0QWN0aXZlSXRlbShpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fYWN0aXZlSXRlbSA9IHRoaXMuX2l0ZW1zLnRvQXJyYXkoKVtpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gZGVwZW5kaW5nIG9uIHRoZSBrZXkgZXZlbnQgcGFzc2VkIGluLlxuICAgKiBAcGFyYW0gZXZlbnQgS2V5Ym9hcmQgZXZlbnQgdG8gYmUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggZWxlbWVudCBzaG91bGQgYmUgYWN0aXZlLlxuICAgKi9cbiAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIHRoaXMuc2V0TmV4dEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICB0aGlzLnNldFByZXZpb3VzSXRlbUFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCOlxuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2hvdWxkbid0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIG9uIHRhYi5cbiAgICAgICAgdGhpcy5fdGFiT3V0Lm5leHQobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0uICovXG4gIGdldCBhY3RpdmVJdGVtSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlSXRlbUluZGV4O1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbS4gKi9cbiAgZ2V0IGFjdGl2ZUl0ZW0oKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW07XG4gIH1cblxuICAvKiogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgc2V0Rmlyc3RJdGVtQWN0aXZlKCk6IHZvaWQge1xuICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KDAsIDEpO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBsYXN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgc2V0TGFzdEl0ZW1BY3RpdmUoKTogdm9pZCB7XG4gICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5faXRlbXMubGVuZ3RoIC0gMSwgLTEpO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBuZXh0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgc2V0TmV4dEl0ZW1BY3RpdmUoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID09PSBudWxsID8gdGhpcy5zZXRGaXJzdEl0ZW1BY3RpdmUoKSA6IHRoaXMuX3NldEFjdGl2ZUl0ZW1CeURlbHRhKDEpO1xuICB9XG5cbiAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIGEgcHJldmlvdXMgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LiAqL1xuICBzZXRQcmV2aW91c0l0ZW1BY3RpdmUoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID09PSBudWxsICYmIHRoaXMuX3dyYXAgPyB0aGlzLnNldExhc3RJdGVtQWN0aXZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3NldEFjdGl2ZUl0ZW1CeURlbHRhKC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3Mgc2V0dGluZyBvZiB0aGUgYWN0aXZlSXRlbUluZGV4IHdpdGhvdXQgYW55IG90aGVyIGVmZmVjdHMuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgbmV3IGFjdGl2ZUl0ZW1JbmRleC5cbiAgICovXG4gIHVwZGF0ZUFjdGl2ZUl0ZW1JbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFueSB0aW1lIHRoZSBUQUIga2V5IGlzIHByZXNzZWQsIHNvIGNvbXBvbmVudHMgY2FuIHJlYWN0XG4gICAqIHdoZW4gZm9jdXMgaXMgc2hpZnRlZCBvZmYgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBnZXQgdGFiT3V0KCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl90YWJPdXQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgYWN0aXZlIGl0ZW0sIGdpdmVuIGEgbGlzdCBvZiBpdGVtcyBhbmQgdGhlIGRlbHRhIGJldHdlZW4gdGhlXG4gICAqIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBhbmQgdGhlIG5ldyBhY3RpdmUgaXRlbS4gSXQgd2lsbCBjYWxjdWxhdGUgZGlmZmVyZW50bHlcbiAgICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgd3JhcCBtb2RlIGlzIHR1cm5lZCBvbi5cbiAgICovXG4gIHByaXZhdGUgX3NldEFjdGl2ZUl0ZW1CeURlbHRhKGRlbHRhOiBudW1iZXIsIGl0ZW1zID0gdGhpcy5faXRlbXMudG9BcnJheSgpKTogdm9pZCB7XG4gICAgdGhpcy5fd3JhcCA/IHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKVxuICAgICAgICAgICAgICAgOiB0aGlzLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlKGRlbHRhLCBpdGVtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gcHJvcGVybHkgZ2l2ZW4gXCJ3cmFwXCIgbW9kZS4gSW4gb3RoZXIgd29yZHMsIGl0IHdpbGwgY29udGludWUgdG8gbW92ZVxuICAgKiBkb3duIHRoZSBsaXN0IHVudGlsIGl0IGZpbmRzIGFuIGl0ZW0gdGhhdCBpcyBub3QgZGlzYWJsZWQsIGFuZCBpdCB3aWxsIHdyYXAgaWYgaXRcbiAgICogZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0QWN0aXZlSW5XcmFwTW9kZShkZWx0YTogbnVtYmVyLCBpdGVtczogVFtdKTogdm9pZCB7XG4gICAgLy8gd2hlbiBhY3RpdmUgaXRlbSB3b3VsZCBsZWF2ZSBtZW51LCB3cmFwIHRvIGJlZ2lubmluZyBvciBlbmRcbiAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPVxuICAgICAgKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCArIGRlbHRhICsgaXRlbXMubGVuZ3RoKSAlIGl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIHNraXAgYWxsIGRpc2FibGVkIG1lbnUgaXRlbXMgcmVjdXJzaXZlbHkgdW50aWwgYW4gZW5hYmxlZCBvbmUgaXMgcmVhY2hlZFxuICAgIGlmIChpdGVtc1t0aGlzLl9hY3RpdmVJdGVtSW5kZXhdLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbldyYXBNb2RlKGRlbHRhLCBpdGVtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbSh0aGlzLl9hY3RpdmVJdGVtSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiB0aGUgZGVmYXVsdCBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbFxuICAgKiBjb250aW51ZSB0byBtb3ZlIGRvd24gdGhlIGxpc3QgdW50aWwgaXQgZmluZHMgYW4gaXRlbSB0aGF0IGlzIG5vdCBkaXNhYmxlZC4gSWZcbiAgICogaXQgZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LCBpdCB3aWxsIHN0b3AgYW5kIG5vdCB3cmFwLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0QWN0aXZlSW5EZWZhdWx0TW9kZShkZWx0YTogbnVtYmVyLCBpdGVtczogVFtdKTogdm9pZCB7XG4gICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEsIGRlbHRhLCBpdGVtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBzdGFydGluZyBhdCB0aGUgaW5kZXggc3BlY2lmaWVkLiBJZiB0aGVcbiAgICogaXRlbSBpcyBkaXNhYmxlZCwgaXQgd2lsbCBtb3ZlIGluIHRoZSBmYWxsYmFja0RlbHRhIGRpcmVjdGlvbiB1bnRpbCBpdCBlaXRoZXJcbiAgICogZmluZHMgYW4gZW5hYmxlZCBpdGVtIG9yIGVuY291bnRlcnMgdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHByaXZhdGUgX3NldEFjdGl2ZUl0ZW1CeUluZGV4KGluZGV4OiBudW1iZXIsIGZhbGxiYWNrRGVsdGE6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IHRoaXMuX2l0ZW1zLnRvQXJyYXkoKSk6IHZvaWQge1xuICAgIGlmICghaXRlbXNbaW5kZXhdKSB7IHJldHVybjsgfVxuICAgIHdoaWxlIChpdGVtc1tpbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgIGluZGV4ICs9IGZhbGxiYWNrRGVsdGE7XG4gICAgICBpZiAoIWl0ZW1zW2luZGV4XSkgeyByZXR1cm47IH1cbiAgICB9XG4gICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgfVxuXG59XG4iLCJcbmltcG9ydCB7UXVlcnlMaXN0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TGlzdEtleU1hbmFnZXIsIENhbkRpc2FibGV9IGZyb20gJy4vbGlzdC1rZXktbWFuYWdlcic7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgaW50ZXJmYWNlIGZvciBmb2N1c2FibGUgaXRlbXMgKHVzZWQgYnkgdGhlIEZvY3VzS2V5TWFuYWdlcikuXG4gKiBFYWNoIGl0ZW0gbXVzdCBrbm93IGhvdyB0byBmb2N1cyBpdHNlbGYgYW5kIHdoZXRoZXIgb3Igbm90IGl0IGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb2N1c2FibGUgZXh0ZW5kcyBDYW5EaXNhYmxlIHtcbiAgZm9jdXMoKTogdm9pZDtcbn1cblxuXG5leHBvcnQgY2xhc3MgRm9jdXNLZXlNYW5hZ2VyIGV4dGVuZHMgTGlzdEtleU1hbmFnZXI8Rm9jdXNhYmxlPiB7XG5cbiAgY29uc3RydWN0b3IoaXRlbXM6IFF1ZXJ5TGlzdDxGb2N1c2FibGU+KSB7XG4gICAgc3VwZXIoaXRlbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEl0IGFsc28gYWRkcyBmb2N1c2VzIHRoZSBuZXdseSBhY3RpdmUgaXRlbS5cbiAgICovXG4gIHNldEFjdGl2ZUl0ZW0oaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHN1cGVyLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuXG4gICAgaWYgKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgdGhpcy5hY3RpdmVJdGVtLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIGFuaW1hdGUsXG4gIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSxcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uLFxuICB0cmlnZ2VyLFxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGFyZSBhbGwgdGhlIGFuaW1hdGlvbnMgZm9yIHRoZSBtZDItc2VsZWN0IGNvbXBvbmVudCwgd2l0aCBlYWNoXG4gKiBjb25zdCBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBmb3Igb25lIGFuaW1hdGlvbi5cbiAqXG4gKiBUaGUgdmFsdWVzIGJlbG93IG1hdGNoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQW5ndWxhckpTIE1hdGVyaWFsIG1kMi1zZWxlY3QgYW5pbWF0aW9uLlxuICovXG5cbi8qKlxuICogVGhpcyBhbmltYXRpb24gc2hyaW5rcyB0aGUgcGxhY2Vob2xkZXIgdGV4dCB0byA3NSUgb2YgaXRzIG5vcm1hbCBzaXplIGFuZCB0cmFuc2xhdGVzXG4gKiBpdCB0byBlaXRoZXIgdGhlIHRvcCBsZWZ0IGNvcm5lciAobHRyKSBvciB0b3AgcmlnaHQgY29ybmVyIChydGwpIG9mIHRoZSB0cmlnZ2VyLFxuICogZGVwZW5kaW5nIG9uIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1QbGFjZWhvbGRlcjogQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhID0gdHJpZ2dlcigndHJhbnNmb3JtUGxhY2Vob2xkZXInLCBbXG4gIHN0YXRlKCdmbG9hdGluZy1sdHInLCBzdHlsZSh7XG4gICAgdG9wOiAnLTIycHgnLFxuICAgIGxlZnQ6ICctMnB4JyxcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgwLjc1KWBcbiAgfSkpLFxuICBzdGF0ZSgnZmxvYXRpbmctcnRsJywgc3R5bGUoe1xuICAgIHRvcDogJy0yMnB4JyxcbiAgICBsZWZ0OiAnMnB4JyxcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgwLjc1KWBcbiAgfSkpLFxuICB0cmFuc2l0aW9uKCcqID0+IConLCBhbmltYXRlKGA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKWApKVxuXSk7XG5cbi8qKlxuICogVGhpcyBhbmltYXRpb24gdHJhbnNmb3JtcyB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbCBvbiBhbmQgb2ZmIHRoZSBwYWdlLlxuICpcbiAqIFdoZW4gdGhlIHBhbmVsIGlzIGF0dGFjaGVkIHRvIHRoZSBET00sIGl0IGV4cGFuZHMgaXRzIHdpZHRoIDMycHgsIHNjYWxlcyBpdCB1cCB0b1xuICogMTAwJSBvbiB0aGUgWSBheGlzLCBmYWRlcyBpbiBpdHMgYm9yZGVyLCBhbmQgdHJhbnNsYXRlcyBzbGlnaHRseSB1cCBhbmQgdG8gdGhlXG4gKiBzaWRlIHRvIGVuc3VyZSB0aGUgb3B0aW9uIHRleHQgY29ycmVjdGx5IG92ZXJsYXBzIHRoZSB0cmlnZ2VyIHRleHQuXG4gKlxuICogV2hlbiB0aGUgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgbGluZWFybHkuXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1QYW5lbDogQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhID0gdHJpZ2dlcigndHJhbnNmb3JtUGFuZWwnLCBbXG4gIHN0YXRlKCdzaG93aW5nJywgc3R5bGUoe1xuICAgIG9wYWNpdHk6IDEsXG4gICAgbWluV2lkdGg6ICdjYWxjKDEwMCUgKyAzMnB4KScsXG4gICAgdHJhbnNmb3JtOiBgc2NhbGVZKDEpYFxuICB9KSksXG4gIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICBzdHlsZSh7XG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlWSgwKWBcbiAgICB9KSxcbiAgICBhbmltYXRlKGAxNTBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKWApXG4gIF0pLFxuICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbXG4gICAgYW5pbWF0ZSgnMjUwbXMgMTAwbXMgbGluZWFyJywgc3R5bGUoe29wYWNpdHk6IDB9KSlcbiAgXSlcbl0pO1xuXG4vKipcbiAqIFRoaXMgYW5pbWF0aW9uIGZhZGVzIGluIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCB0ZXh0IGNvbnRlbnQgb2YgdGhlXG4gKiBzZWxlY3QncyBvcHRpb25zLiBJdCBpcyB0aW1lIGRlbGF5ZWQgdG8gb2NjdXIgMTAwbXMgYWZ0ZXIgdGhlIG92ZXJsYXlcbiAqIHBhbmVsIGhhcyB0cmFuc2Zvcm1lZCBpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGZhZGVJbkNvbnRlbnQ6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSAgPSAgdHJpZ2dlcignZmFkZUluQ29udGVudCcsIFtcbiAgc3RhdGUoJ3Nob3dpbmcnLCBzdHlsZSh7b3BhY2l0eTogMX0pKSxcbiAgdHJhbnNpdGlvbigndm9pZCA9PiBzaG93aW5nJywgW1xuICAgIHN0eWxlKHtvcGFjaXR5OiAwfSksXG4gICAgYW5pbWF0ZShgMTUwbXMgMTAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMilgKVxuICBdKVxuXSk7XG4iLCIvKipcbiAqIFJldHVybnMgYW4gZXhjZXB0aW9uIHRvIGJlIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gY2hhbmdlIGEgc1xuICogZWxlY3QncyBgbXVsdGlwbGVgIG9wdGlvbiBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1kU2VsZWN0RHluYW1pY011bHRpcGxlRXJyb3IoKTogRXJyb3Ige1xuICByZXR1cm4gbmV3IEVycm9yKCdDYW5ub3QgY2hhbmdlIGBtdWx0aXBsZWAgbW9kZSBvZiBzZWxlY3QgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGNlcHRpb24gdG8gYmUgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhc3NpZ24gYSBub24tYXJyYXkgdmFsdWUgdG8gYSBzZWxlY3RcbiAqIGluIGBtdWx0aXBsZWAgbW9kZS4gTm90ZSB0aGF0IGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgYXJlIHN0aWxsIHZhbGlkIHZhbHVlcyB0byBhbGxvdyBmb3JcbiAqIHJlc2V0dGluZyB0aGUgdmFsdWUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZFNlbGVjdE5vbkFycmF5VmFsdWVFcnJvcigpOiBFcnJvciB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdHJ1dGh5IG5vbi1hcnJheSB2YWx1ZSB0byBzZWxlY3QgaW4gYG11bHRpcGxlYCBtb2RlLicpO1xufVxuIiwiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFNlbGYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBWaWV3Q2hpbGQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBBdHRyaWJ1dGUsXG4gIE9uSW5pdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZDJPcHRpb24sIE1kMk9wdGlvblNlbGVjdGlvbkNoYW5nZSB9IGZyb20gJy4vb3B0aW9uJztcbmltcG9ydCB7IE1kMk9wdGdyb3VwIH0gZnJvbSAnLi9vcHRncm91cCc7XG5pbXBvcnQgeyBFTlRFUiwgU1BBQ0UsIFVQX0FSUk9XLCBET1dOX0FSUk9XLCBIT01FLCBFTkQgfSBmcm9tICcuLi9jb3JlL2tleWJvYXJkL2tleWNvZGVzJztcbmltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciB9IGZyb20gJy4uL2NvcmUvYTExeS9mb2N1cy1rZXktbWFuYWdlcic7XG5pbXBvcnQgeyBEaXIgfSBmcm9tICcuLi9jb3JlL3J0bC9kaXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgbWVyZ2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUGxhY2Vob2xkZXIsIHRyYW5zZm9ybVBhbmVsLCBmYWRlSW5Db250ZW50IH0gZnJvbSAnLi9zZWxlY3QtYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9jb2VyY2lvbi9ib29sZWFuLXByb3BlcnR5JztcbmltcG9ydCB7IENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUgfSBmcm9tICcuLi9jb3JlL292ZXJsYXkvb3ZlcmxheS1kaXJlY3RpdmVzJztcbmltcG9ydCB7IFZpZXdwb3J0UnVsZXIgfSBmcm9tICcuLi9jb3JlL292ZXJsYXkvcG9zaXRpb24vdmlld3BvcnQtcnVsZXInO1xuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZWwgfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0TWRTZWxlY3REeW5hbWljTXVsdGlwbGVFcnJvciwgZ2V0TWRTZWxlY3ROb25BcnJheVZhbHVlRXJyb3IgfSBmcm9tICcuL3NlbGVjdC1lcnJvcnMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoLCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBzdHlsZSBjb25zdGFudHMgYXJlIG5lY2Vzc2FyeSB0byBzYXZlIGhlcmUgaW4gb3JkZXJcbiAqIHRvIHByb3Blcmx5IGNhbGN1bGF0ZSB0aGUgYWxpZ25tZW50IG9mIHRoZSBzZWxlY3RlZCBvcHRpb24gb3ZlclxuICogdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAqL1xuXG4vKiogVGhlIGZpeGVkIGhlaWdodCBvZiBldmVyeSBvcHRpb24gZWxlbWVudCAob3B0aW9uLCBncm91cCBoZWFkZXIgZXRjLikuICovXG5leHBvcnQgY29uc3QgU0VMRUNUX0lURU1fSEVJR0hUID0gNDg7XG5cbi8qKiBUaGUgbWF4IGhlaWdodCBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbCAqL1xuZXhwb3J0IGNvbnN0IFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gMjU2O1xuXG4vKiogVGhlIG1heCBudW1iZXIgb2Ygb3B0aW9ucyB2aXNpYmxlIGF0IG9uY2UgaW4gdGhlIHNlbGVjdCBwYW5lbC4gKi9cbmV4cG9ydCBjb25zdCBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVEID1cbiAgTWF0aC5mbG9vcihTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCAvIFNFTEVDVF9JVEVNX0hFSUdIVCk7XG5cbi8qKiBUaGUgZml4ZWQgaGVpZ2h0IG9mIHRoZSBzZWxlY3QncyB0cmlnZ2VyIGVsZW1lbnQuICovXG5leHBvcnQgY29uc3QgU0VMRUNUX1RSSUdHRVJfSEVJR0hUID0gMzA7XG5cbi8qKlxuICogTXVzdCBhZGp1c3QgZm9yIHRoZSBkaWZmZXJlbmNlIGluIGhlaWdodCBiZXR3ZWVuIHRoZSBvcHRpb24gYW5kIHRoZSB0cmlnZ2VyLFxuICogc28gdGhlIHRleHQgd2lsbCBhbGlnbiBvbiB0aGUgeSBheGlzLlxuICovXG5leHBvcnQgY29uc3QgU0VMRUNUX0lURU1fSEVJR0hUX0FESlVTVE1FTlQgPSAoU0VMRUNUX0lURU1fSEVJR0hUIC0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUKSAvIDI7XG5cbi8qKiBUaGUgcGFuZWwncyBwYWRkaW5nIG9uIHRoZSB4LWF4aXMgKi9cbmV4cG9ydCBjb25zdCBTRUxFQ1RfUEFORUxfUEFERElOR19YID0gMTY7XG5cbi8qKiBUaGUgcGFuZWwncyB4IGF4aXMgcGFkZGluZyBpZiBpdCBpcyBpbmRlbnRlZCAoZS5nLiB0aGVyZSBpcyBhbiBvcHRpb24gZ3JvdXApLiAqL1xuZXhwb3J0IGNvbnN0IFNFTEVDVF9QQU5FTF9JTkRFTlRfUEFERElOR19YID0gU0VMRUNUX1BBTkVMX1BBRERJTkdfWCAqIDI7XG5cbi8qKlxuICogRGlzdGFuY2UgYmV0d2VlbiB0aGUgcGFuZWwgZWRnZSBhbmQgdGhlIG9wdGlvbiB0ZXh0IGluXG4gKiBtdWx0aS1zZWxlY3Rpb24gbW9kZS5cbiAqXG4gKiAoU0VMRUNUX1BBRERJTkcgKiAxLjc1KSArIDIwID0gNDhcbiAqIFRoZSBwYWRkaW5nIGlzIG11bHRpcGxpZWQgYnkgMS43NSBiZWNhdXNlIHRoZSBjaGVja2JveCdzIG1hcmdpbiBpcyBoYWxmIHRoZSBwYWRkaW5nLCBhbmRcbiAqIHRoZSBicm93c2VyIGFkZHMgfjRweCwgYmVjYXVzZSB3ZSdyZSB1c2luZyBpbmxpbmUgZWxlbWVudHMuXG4gKiBUaGUgY2hlY2tib3ggd2lkdGggaXMgMjBweC5cbiAqL1xuZXhwb3J0IGNvbnN0IFNFTEVDVF9NVUxUSVBMRV9QQU5FTF9QQURESU5HX1ggPSBTRUxFQ1RfUEFORUxfUEFERElOR19YICogMS4yNSArIDIwO1xuXG4vKipcbiAqIFRoZSBwYW5lbCdzIHBhZGRpbmcgb24gdGhlIHktYXhpcy4gVGhpcyBwYWRkaW5nIGluZGljYXRlcyB0aGVyZSBhcmUgbW9yZVxuICogb3B0aW9ucyBhdmFpbGFibGUgaWYgeW91IHNjcm9sbC5cbiAqL1xuZXhwb3J0IGNvbnN0IFNFTEVDVF9QQU5FTF9QQURESU5HX1kgPSAxNjtcblxuLyoqXG4gKiBUaGUgc2VsZWN0IHBhbmVsIHdpbGwgb25seSBcImZpdFwiIGluc2lkZSB0aGUgdmlld3BvcnQgaWYgaXQgaXMgcG9zaXRpb25lZCBhdFxuICogdGhpcyB2YWx1ZSBvciBtb3JlIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQgYm91bmRhcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORyA9IDg7XG5cbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgdmFsdWUgaGFzIGNoYW5nZWQuICovXG5leHBvcnQgY2xhc3MgTWQyU2VsZWN0Q2hhbmdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogTWQyU2VsZWN0LCBwdWJsaWMgdmFsdWU6IGFueSkgeyB9XG59XG5cbi8qKiBBbGxvd2VkIHZhbHVlcyBmb3IgdGhlIGZsb2F0UGxhY2Vob2xkZXIgb3B0aW9uLiAqL1xuZXhwb3J0IHR5cGUgTWQyU2VsZWN0RmxvYXRQbGFjZWhvbGRlclR5cGUgPSAnYWx3YXlzJyB8ICduZXZlcicgfCAnYXV0byc7XG5cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItc2VsZWN0JyxcbiAgdGVtcGxhdGVVcmw6ICdzZWxlY3QuaHRtbCcsXG4gIHN0eWxlVXJsczogWydzZWxlY3Quc2NzcyddLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBob3N0OiB7XG4gICAgJ3JvbGUnOiAnbGlzdGJveCcsXG4gICAgJ1thdHRyLnRhYmluZGV4XSc6ICd0YWJJbmRleCcsXG4gICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ19hcmlhTGFiZWwnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ2FyaWFMYWJlbGxlZGJ5JyxcbiAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAncmVxdWlyZWQudG9TdHJpbmcoKScsXG4gICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICdbYXR0ci5hcmlhLWludmFsaWRdJzogJ19jb250cm9sPy5pbnZhbGlkIHx8IFwiZmFsc2VcIicsXG4gICAgJ1thdHRyLmFyaWEtb3duc10nOiAnX29wdGlvbklkcycsXG4gICAgJ1tjbGFzcy5tZDItc2VsZWN0LWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5tZDItc2VsZWN0XSc6ICd0cnVlJyxcbiAgICAnKGtleWRvd24pJzogJ19oYW5kbGVDbG9zZWRLZXlkb3duKCRldmVudCknLFxuICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgfSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyYW5zZm9ybVBsYWNlaG9sZGVyLFxuICAgIHRyYW5zZm9ybVBhbmVsLFxuICAgIGZhZGVJbkNvbnRlbnRcbiAgXSxcbiAgZXhwb3J0QXM6ICdtZDJTZWxlY3QnLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJTZWxlY3QgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAvKiogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgcGFuZWwgaXMgb3Blbi4gKi9cbiAgcHJpdmF0ZSBfcGFuZWxPcGVuID0gZmFsc2U7XG5cbiAgLyoqIFN1YnNjcmlwdGlvbnMgdG8gb3B0aW9uIGV2ZW50cy4gKi9cbiAgcHJpdmF0ZSBfb3B0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFN1YnNjcmlwdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBvcHRpb24gbGlzdC4gKi9cbiAgcHJpdmF0ZSBfY2hhbmdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFN1YnNjcmlwdGlvbiB0byB0YWIgZXZlbnRzIHdoaWxlIG92ZXJsYXkgaXMgZm9jdXNlZC4gKi9cbiAgcHJpdmF0ZSBfdGFiU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFdoZXRoZXIgZmlsbGluZyBvdXQgdGhlIHNlbGVjdCBpcyByZXF1aXJlZCBpbiB0aGUgZm9ybS4gICovXG4gIHByaXZhdGUgX3JlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZC4gICovXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgcGFuZWwsIGNhbGN1bGF0ZWQgdG8gY2VudGVyIHRoZSBzZWxlY3RlZCBvcHRpb24uICovXG4gIHByaXZhdGUgX3Njcm9sbFRvcCA9IDA7XG5cbiAgLyoqIFRoZSBwbGFjZWhvbGRlciBkaXNwbGF5ZWQgaW4gdGhlIHRyaWdnZXIgb2YgdGhlIHNlbGVjdC4gKi9cbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXI6IHN0cmluZztcblxuICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIGluIG11bHRpcGxlIHNlbGVjdGlvbiBtb2RlLiAqL1xuICBwcml2YXRlIF9tdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBEZWFscyB3aXRoIHRoZSBzZWxlY3Rpb24gbG9naWMuICovXG4gIF9zZWxlY3Rpb25Nb2RlbDogU2VsZWN0aW9uTW9kZWw8TWQyT3B0aW9uPjtcblxuICAvKiogVGhlIGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGUgcGxhY2Vob2xkZXIuICovXG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcblxuICAvKiogVGFiIGluZGV4IGZvciB0aGUgZWxlbWVudC4gKi9cbiAgcHJpdmF0ZSBfdGFiSW5kZXg6IG51bWJlcjtcblxuICAvKiogVGhlbWUgY29sb3IgZm9yIHRoZSBjb21wb25lbnQuICovXG4gIHByaXZhdGUgX2NvbG9yOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgdHJpZ2dlci4gTXVzdCBiZSBzYXZlZCB0byBzZXQgdGhlIG1pbiB3aWR0aCBvZiB0aGUgb3ZlcmxheSBwYW5lbFxuICAgKiBhbmQgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICovXG4gIF90cmlnZ2VyV2lkdGg6IG51bWJlcjtcblxuICAvKiogTWFuYWdlcyBrZXlib2FyZCBldmVudHMgZm9yIG9wdGlvbnMgaW4gdGhlIHBhbmVsLiAqL1xuICBfa2V5TWFuYWdlcjogRm9jdXNLZXlNYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIHNlbGVjdGVkIG9wdGlvbidzIHZhbHVlLiBNdXN0IGJlIHNldCBwcm9ncmFtbWF0aWNhbGx5XG4gICAqIHRvIGVuc3VyZSBpdHMgb3ZlcmZsb3cgaXMgY2xpcHBlZCwgYXMgaXQncyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQuXG4gICAqL1xuICBfc2VsZWN0ZWRWYWx1ZVdpZHRoOiBudW1iZXI7XG5cbiAgLyoqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xuICBfb25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gIC8qKiBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHNlbGVjdCBoYXMgYmVlbiB0b3VjaGVkICovXG4gIF9vblRvdWNoZWQgPSAoKSA9PiB7IH07XG5cbiAgLyoqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuICovXG4gIF9vcHRpb25JZHM6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBUaGUgdmFsdWUgb2YgdGhlIHNlbGVjdCBwYW5lbCdzIHRyYW5zZm9ybS1vcmlnaW4gcHJvcGVydHkuICovXG4gIF90cmFuc2Zvcm1PcmlnaW46IHN0cmluZyA9ICd0b3AnO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBwYW5lbCdzIGFuaW1hdGlvbiBpcyBkb25lLiAqL1xuICBfcGFuZWxEb25lQW5pbWF0aW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSB5LW9mZnNldCBvZiB0aGUgb3ZlcmxheSBwYW5lbCBpbiByZWxhdGlvbiB0byB0aGUgdHJpZ2dlcidzIHRvcCBzdGFydCBjb3JuZXIuXG4gICAqIFRoaXMgbXVzdCBiZSBhZGp1c3RlZCB0byBhbGlnbiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRleHQgb3ZlciB0aGUgdHJpZ2dlciB0ZXh0LlxuICAgKiB3aGVuIHRoZSBwYW5lbCBvcGVucy4gV2lsbCBjaGFuZ2UgYmFzZWQgb24gdGhlIHktcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIG9wdGlvbi5cbiAgICovXG4gIF9vZmZzZXRZID0gMDtcblxuICAvKipcbiAgICogVGhpcyBwb3NpdGlvbiBjb25maWcgZW5zdXJlcyB0aGF0IHRoZSB0b3AgXCJzdGFydFwiIGNvcm5lciBvZiB0aGUgb3ZlcmxheVxuICAgKiBpcyBhbGlnbmVkIHdpdGggd2l0aCB0aGUgdG9wIFwic3RhcnRcIiBvZiB0aGUgb3JpZ2luIGJ5IGRlZmF1bHQgKG92ZXJsYXBwaW5nXG4gICAqIHRoZSB0cmlnZ2VyIGNvbXBsZXRlbHkpLiBJZiB0aGUgcGFuZWwgY2Fubm90IGZpdCBiZWxvdyB0aGUgdHJpZ2dlciwgaXRcbiAgICogd2lsbCBmYWxsIGJhY2sgdG8gYSBwb3NpdGlvbiBhYm92ZSB0aGUgdHJpZ2dlci5cbiAgICovXG4gIF9wb3NpdGlvbnMgPSBbXG4gICAge1xuICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICB9LFxuICBdO1xuXG4gIC8qKiBUcmlnZ2VyIHRoYXQgb3BlbnMgdGhlIHNlbGVjdC4gKi9cbiAgQFZpZXdDaGlsZCgndHJpZ2dlcicpIHRyaWdnZXI6IEVsZW1lbnRSZWY7XG5cbiAgLyoqIE92ZXJsYXkgcGFuZSBjb250YWluaW5nIHRoZSBvcHRpb25zLiAqL1xuICBAVmlld0NoaWxkKENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUpIG92ZXJsYXlEaXI6IENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG5cbiAgLyoqIEFsbCBvZiB0aGUgZGVmaW5lZCBzZWxlY3Qgb3B0aW9ucy4gKi9cbiAgQENvbnRlbnRDaGlsZHJlbihNZDJPcHRpb24sIHsgZGVzY2VuZGFudHM6IHRydWUgfSkgb3B0aW9uczogUXVlcnlMaXN0PE1kMk9wdGlvbj47XG5cbiAgLyoqIEFsbCBvZiB0aGUgZGVmaW5lZCBncm91cHMgb2Ygb3B0aW9ucy4gKi9cbiAgQENvbnRlbnRDaGlsZHJlbihNZDJPcHRncm91cCkgb3B0aW9uR3JvdXBzOiBRdWVyeUxpc3Q8TWQyT3B0Z3JvdXA+O1xuXG4gIC8qKiBQbGFjZWhvbGRlciB0byBiZSBzaG93biBpZiBubyB2YWx1ZSBoYXMgYmVlbiBzZWxlY3RlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IHBsYWNlaG9sZGVyKCkgeyByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7IH1cbiAgc2V0IHBsYWNlaG9sZGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlO1xuXG4gICAgLy8gTXVzdCB3YWl0IHRvIHJlY29yZCB0aGUgdHJpZ2dlciB3aWR0aCB0byBlbnN1cmUgcGxhY2Vob2xkZXIgd2lkdGggaXMgaW5jbHVkZWQuXG4gICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oKCkgPT4gdGhpcy5fc2V0VHJpZ2dlcldpZHRoKCkpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC4gKi9cbiAgQElucHV0KClcbiAgZ2V0IGRpc2FibGVkKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlcXVpcmVkLiAqL1xuICBASW5wdXQoKVxuICBnZXQgcmVxdWlyZWQoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfVxuICBzZXQgcmVxdWlyZWQodmFsdWU6IGFueSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cblxuICAvKiogV2hldGhlciB0aGUgdXNlciBzaG91bGQgYmUgYWxsb3dlZCB0byBzZWxlY3QgbXVsdGlwbGUgb3B0aW9ucy4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG11bHRpcGxlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fbXVsdGlwbGU7IH1cbiAgc2V0IG11bHRpcGxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsKSB7XG4gICAgICB0aHJvdyBnZXRNZFNlbGVjdER5bmFtaWNNdWx0aXBsZUVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbXVsdGlwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdG8gZmxvYXQgdGhlIHBsYWNlaG9sZGVyIHRleHQuICovXG4gIEBJbnB1dCgpXG4gIGdldCBmbG9hdFBsYWNlaG9sZGVyKCk6IE1kMlNlbGVjdEZsb2F0UGxhY2Vob2xkZXJUeXBlIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXI7IH1cbiAgc2V0IGZsb2F0UGxhY2Vob2xkZXIodmFsdWU6IE1kMlNlbGVjdEZsb2F0UGxhY2Vob2xkZXJUeXBlKSB7XG4gICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9IHZhbHVlIHx8ICdhdXRvJztcbiAgfVxuICBwcml2YXRlIF9mbG9hdFBsYWNlaG9sZGVyOiBNZDJTZWxlY3RGbG9hdFBsYWNlaG9sZGVyVHlwZSA9ICdhdXRvJztcblxuICAvKiogVGFiIGluZGV4IGZvciB0aGUgc2VsZWN0IGVsZW1lbnQuICovXG4gIEBJbnB1dCgpXG4gIGdldCB0YWJJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQgPyAtMSA6IHRoaXMuX3RhYkluZGV4OyB9XG4gIHNldCB0YWJJbmRleCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX3RhYkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFyaWEgbGFiZWwgb2YgdGhlIHNlbGVjdC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgdXNlZCBhcyBsYWJlbC4gKi9cbiAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgPSAnJztcblxuICAvKiogSW5wdXQgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUuICovXG4gIEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JykgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBDb21iaW5lZCBzdHJlYW0gb2YgYWxsIG9mIHRoZSBjaGlsZCBvcHRpb25zJyBjaGFuZ2UgZXZlbnRzLiAqL1xuICBnZXQgb3B0aW9uU2VsZWN0aW9uQ2hhbmdlcygpOiBPYnNlcnZhYmxlPE1kMk9wdGlvblNlbGVjdGlvbkNoYW5nZT4ge1xuICAgIHJldHVybiBtZXJnZSguLi50aGlzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24ub25TZWxlY3Rpb25DaGFuZ2UpKTtcbiAgfVxuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCBoYXMgYmVlbiBvcGVuZWQuICovXG4gIEBPdXRwdXQoKSBvbk9wZW46IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gY2xvc2VkLiAqL1xuICBAT3V0cHV0KCkgb25DbG9zZTogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQgYnkgdGhlIHVzZXIuICovXG4gIEBPdXRwdXQoKSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxNZDJTZWxlY3RDaGFuZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxNZDJTZWxlY3RDaGFuZ2U+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF92aWV3cG9ydFJ1bGVyOiBWaWV3cG9ydFJ1bGVyLCBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXIsIEBTZWxmKCkgQE9wdGlvbmFsKCkgcHVibGljIF9jb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB0YWJJbmRleDogc3RyaW5nKSB7XG5cbiAgICBpZiAodGhpcy5fY29udHJvbCkge1xuICAgICAgdGhpcy5fY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl90YWJJbmRleCA9IHBhcnNlSW50KHRhYkluZGV4KSB8fCAwO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWw8TWQyT3B0aW9uPih0aGlzLm11bHRpcGxlLCBudWxsLCBmYWxzZSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5faW5pdEtleU1hbmFnZXIoKTtcblxuICAgIHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKG51bGwpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVzZXRPcHRpb25zKCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb250cm9sKSB7XG4gICAgICAgIC8vIERlZmVyIHNldHRpbmcgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIHRoZSBcIkV4cHJlc3Npb25cbiAgICAgICAgLy8gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWRcIiBlcnJvcnMgZnJvbSBBbmd1bGFyLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB0aGlzLl9zZXRTZWxlY3Rpb25CeVZhbHVlKHRoaXMuX2NvbnRyb2wudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX2Ryb3BTdWJzY3JpcHRpb25zKCk7XG5cbiAgICBpZiAodGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFiU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogVG9nZ2xlcyB0aGUgb3ZlcmxheSBwYW5lbCBvcGVuIG9yIGNsb3NlZC4gKi9cbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cblxuICAvKiogT3BlbnMgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RyaWdnZXJXaWR0aCkge1xuICAgICAgdGhpcy5fc2V0VHJpZ2dlcldpZHRoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9IHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXJTdGF0ZSgpO1xuICAgIHRoaXMuX3BhbmVsT3BlbiA9IHRydWU7XG4gIH1cblxuICAvKiogQ2xvc2VzIHRoZSBvdmVybGF5IHBhbmVsIGFuZCBmb2N1c2VzIHRoZSBob3N0IGVsZW1lbnQuICovXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZm9jdXNIb3N0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCdzIHZhbHVlLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgKi9cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QncyB2YWx1ZVxuICAgKiBjaGFuZ2VzIGZyb20gdXNlciBpbnB1dC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgKi9cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QgaXMgYmx1cnJlZFxuICAgKiBieSB0aGUgdXNlci4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIHJlcXVpcmVkXG4gICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICovXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB7fSk6IHZvaWQge1xuICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICAvKiogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgcGFuZWwgaXMgb3Blbi4gKi9cbiAgZ2V0IHBhbmVsT3BlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICB9XG5cbiAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICBnZXQgc2VsZWN0ZWQoKTogTWQyT3B0aW9uIHwgTWQyT3B0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWQgOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXTtcbiAgfVxuXG4gIC8qKiBUaGUgdmFsdWUgZGlzcGxheWVkIGluIHRoZSB0cmlnZ2VyLiAqL1xuICBnZXQgdHJpZ2dlclZhbHVlKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuX211bHRpcGxlKSB7XG4gICAgICBsZXQgc2VsZWN0ZWRPcHRpb25zID0gdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWQubWFwKG9wdGlvbiA9PiBvcHRpb24udmlld1ZhbHVlKTtcblxuICAgICAgaWYgKHRoaXMuX2lzUnRsKCkpIHtcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhjcmlzYmV0byk6IGRlbGltaXRlciBzaG91bGQgYmUgY29uZmlndXJhYmxlIGZvciBwcm9wZXIgbG9jYWxpemF0aW9uLlxuICAgICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXS52aWV3VmFsdWU7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbiBSVEwgbW9kZS4gKi9cbiAgX2lzUnRsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2lkdGggb2YgdGhlIHRyaWdnZXIgZWxlbWVudC4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWF0Y2hcbiAgICogdGhlIG92ZXJsYXkgd2lkdGggdG8gdGhlIHRyaWdnZXIgd2lkdGguXG4gICAqL1xuICBwcml2YXRlIF9zZXRUcmlnZ2VyV2lkdGgoKTogdm9pZCB7XG4gICAgdGhpcy5fdHJpZ2dlcldpZHRoID0gdGhpcy5fZ2V0VHJpZ2dlclJlY3QoKS53aWR0aDtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHRoZSBrZXlib2FyZCBpbnRlcmFjdGlvbnMgb2YgYSBjbG9zZWQgc2VsZWN0LiAqL1xuICBfaGFuZGxlQ2xvc2VkS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IFNQQUNFKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgfHwgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICB0aGlzLl9oYW5kbGVBcnJvd0tleShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEhhbmRsZXMga2V5cHJlc3NlcyBpbnNpZGUgdGhlIHBhbmVsLiAqL1xuICBfaGFuZGxlUGFuZWxLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEhPTUUgfHwgZXZlbnQua2V5Q29kZSA9PT0gRU5EKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQua2V5Q29kZSA9PT0gSE9NRSA/IHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCkgOlxuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldExhc3RJdGVtQWN0aXZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcGFuZWwgZWxlbWVudCBpcyBmaW5pc2hlZCB0cmFuc2Zvcm1pbmcgaW4gKHRob3VnaCBub3QgZmFkaW5nIGluKSwgaXRcbiAgICogZW1pdHMgYW4gZXZlbnQgYW5kIGZvY3VzZXMgYW4gb3B0aW9uIGlmIHRoZSBwYW5lbCBpcyBvcGVuLlxuICAgKi9cbiAgX29uUGFuZWxEb25lKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnBhbmVsT3Blbikge1xuICAgICAgdGhpcy5fZm9jdXNDb3JyZWN0T3B0aW9uKCk7XG4gICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG4gICAgICB0aGlzLl9wYW5lbERvbmVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMub3ZlcmxheURpci5vZmZzZXRYID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcGFuZWwgY29udGVudCBpcyBkb25lIGZhZGluZyBpbiwgdGhlIF9wYW5lbERvbmVBbmltYXRpbmcgcHJvcGVydHkgaXNcbiAgICogc2V0IHNvIHRoZSBwcm9wZXIgY2xhc3MgY2FuIGJlIGFkZGVkIHRvIHRoZSBwYW5lbC5cbiAgICovXG4gIF9vbkZhZGVJbkRvbmUoKTogdm9pZCB7XG4gICAgdGhpcy5fcGFuZWxEb25lQW5pbWF0aW5nID0gdGhpcy5wYW5lbE9wZW47XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIHRvdWNoZWQgY2FsbGJhY2sgb25seSBpZiB0aGUgcGFuZWwgaXMgY2xvc2VkLiBPdGhlcndpc2UsIHRoZSB0cmlnZ2VyIHdpbGxcbiAgICogXCJibHVyXCIgdG8gdGhlIHBhbmVsIHdoZW4gaXQgb3BlbnMsIGNhdXNpbmcgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICovXG4gIF9vbkJsdXIoKSB7XG4gICAgaWYgKCF0aGlzLnBhbmVsT3Blbikge1xuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBvdmVybGF5IHBhbmVsIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgKi9cbiAgX29uQXR0YWNoZWQoKTogdm9pZCB7XG4gICAgdGhpcy5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldFgoKTtcbiAgICB0aGlzLl9zZXRTY3JvbGxUb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHNjcm9sbCBjb250YWluZXIuIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXJcbiAgICogdGhlIG92ZXJsYXkgcGFuZSBpcyBhdHRhY2hlZCBvciB0aGUgc2Nyb2xsIGNvbnRhaW5lciBlbGVtZW50IHdpbGwgbm90IHlldCBiZVxuICAgKiBwcmVzZW50IGluIHRoZSBET00uXG4gICAqL1xuICBwcml2YXRlIF9zZXRTY3JvbGxUb3AoKTogdm9pZCB7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID1cbiAgICAgIHRoaXMub3ZlcmxheURpci5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZDItc2VsZWN0LXBhbmVsJyk7XG4gICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuX3Njcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBvcHRpb24gYmFzZWQgb24gYSB2YWx1ZS4gSWYgbm8gb3B0aW9uIGNhbiBiZVxuICAgKiBmb3VuZCB3aXRoIHRoZSBkZXNpZ25hdGVkIHZhbHVlLCB0aGUgc2VsZWN0IHRyaWdnZXIgaXMgY2xlYXJlZC5cbiAgICovXG4gIHByaXZhdGUgX3NldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWU6IGFueSB8IGFueVtdKTogdm9pZCB7XG4gICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgdmFsdWUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHRocm93IGdldE1kU2VsZWN0Tm9uQXJyYXlWYWx1ZUVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChjdXJyZW50VmFsdWU6IGFueSkgPT4gdGhpcy5fc2VsZWN0VmFsdWUoY3VycmVudFZhbHVlKSk7XG4gICAgICB0aGlzLl9zb3J0VmFsdWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlbGVjdFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRWYWx1ZVdpZHRoKCk7XG5cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLl9wbGFjZWhvbGRlclN0YXRlID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYW5kIHNlbGVjdHMgYW5kIG9wdGlvbiBiYXNlZCBvbiBpdHMgdmFsdWUuXG4gICAqIEByZXR1cm5zIE9wdGlvbiB0aGF0IGhhcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICovXG4gIHByaXZhdGUgX3NlbGVjdFZhbHVlKHZhbHVlOiBhbnkpOiBNZDJPcHRpb24ge1xuICAgIGxldCBvcHRpb25zQXJyYXkgPSB0aGlzLm9wdGlvbnMudG9BcnJheSgpO1xuICAgIGxldCBjb3JyZXNwb25kaW5nT3B0aW9uID0gb3B0aW9uc0FycmF5LmZpbmQob3B0aW9uID0+IG9wdGlvbi52YWx1ZSAhPSBudWxsXG4gICAgICAmJiBvcHRpb24udmFsdWUgIT0gdW5kZWZpbmVkICYmIHRoaXMuZXF1YWxzKG9wdGlvbi52YWx1ZSwgdmFsdWUpKTtcblxuICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICBjb3JyZXNwb25kaW5nT3B0aW9uLnNlbGVjdCgpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG9wdGlvbnNBcnJheS5pbmRleE9mKGNvcnJlc3BvbmRpbmdPcHRpb24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ycmVzcG9uZGluZ09wdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHR3byB2YXJzIG9yIG9iamVjdHNcbiAgICogQHBhcmFtIG8xIGNvbXBhcmUgZmlyc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSBvMiBjb21wYXJlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiBib29sZWFuIGNvbXBhcmF0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHJpdmF0ZSBlcXVhbHMobzE6IGFueSwgbzI6IGFueSkge1xuICAgIGlmIChvMSA9PT0gbzIpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKG8xICE9PSBvMSAmJiBvMiAhPT0gbzIpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBsZXQgdDEgPSB0eXBlb2YgbzEsIHQyID0gdHlwZW9mIG8yLCBrZXk6IGFueSwga2V5U2V0OiBhbnk7XG4gICAgaWYgKHQxID09PSB0MiAmJiB0MSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGtleVNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGtleSBpbiBvMSkge1xuICAgICAgICBpZiAoIXRoaXMuZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBrZXlTZXRba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBvMikge1xuICAgICAgICBpZiAoIShrZXkgaW4ga2V5U2V0KSAmJiBrZXkuY2hhckF0KDApICE9PSAnJCcgJiYgbzJba2V5XSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBzZWxlY3QgdHJpZ2dlciBhbmQgZGVzZWxlY3RzIGV2ZXJ5IG9wdGlvbiBpbiB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHNraXAgT3B0aW9uIHRoYXQgc2hvdWxkIG5vdCBiZSBkZXNlbGVjdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2xlYXJTZWxlY3Rpb24oc2tpcD86IE1kMk9wdGlvbik6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgdGhpcy5vcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIGlmIChvcHRpb24gIT09IHNraXApIHtcbiAgICAgICAgb3B0aW9uLmRlc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9nZXRUcmlnZ2VyUmVjdCgpOiBDbGllbnRSZWN0IHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICAvKiogU2V0cyB1cCBhIGtleSBtYW5hZ2VyIHRvIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24gdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIHByaXZhdGUgX2luaXRLZXlNYW5hZ2VyKCkge1xuICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uID0gdGhpcy5fa2V5TWFuYWdlci50YWJPdXQuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICAvKiogRHJvcHMgY3VycmVudCBvcHRpb24gc3Vic2NyaXB0aW9ucyBhbmQgSURzIGFuZCByZXNldHMgZnJvbSBzY3JhdGNoLiAqL1xuICBwcml2YXRlIF9yZXNldE9wdGlvbnMoKTogdm9pZCB7XG4gICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICB0aGlzLl9saXN0ZW5Ub09wdGlvbnMoKTtcbiAgICB0aGlzLl9zZXRPcHRpb25JZHMoKTtcbiAgICB0aGlzLl9zZXRPcHRpb25NdWx0aXBsZSgpO1xuICB9XG5cbiAgLyoqIExpc3RlbnMgdG8gdXNlci1nZW5lcmF0ZWQgc2VsZWN0aW9uIGV2ZW50cyBvbiBlYWNoIG9wdGlvbi4gKi9cbiAgcHJpdmF0ZSBfbGlzdGVuVG9PcHRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbiA9IHRoaXMub3B0aW9uU2VsZWN0aW9uQ2hhbmdlc1xuICAgICAgLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmlzVXNlcklucHV0KSlcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9vblNlbGVjdChldmVudC5zb3VyY2UpO1xuICAgICAgICB0aGlzLl9zZXRWYWx1ZVdpZHRoKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKiBJbnZva2VkIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWQuICovXG4gIHByaXZhdGUgX29uU2VsZWN0KG9wdGlvbjogTWQyT3B0aW9uKTogdm9pZCB7XG4gICAgY29uc3Qgd2FzU2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbik7XG5cbiAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwudG9nZ2xlKG9wdGlvbik7XG4gICAgICB3YXNTZWxlY3RlZCA/IG9wdGlvbi5kZXNlbGVjdCgpIDogb3B0aW9uLnNlbGVjdCgpO1xuICAgICAgdGhpcy5fc29ydFZhbHVlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbihvcHRpb24udmFsdWUgPT0gbnVsbCA/IG51bGwgOiBvcHRpb24pO1xuXG4gICAgICBpZiAob3B0aW9uLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcyhvcHRpb24udmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG9wdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdhc1NlbGVjdGVkICE9PSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKG9wdGlvbikpIHtcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29ydHMgdGhlIG1vZGVsIHZhbHVlcywgZW5zdXJpbmcgdGhhdCB0aGV5IGtlZXAgdGhlIHNhbWVcbiAgICogb3JkZXIgdGhhdCB0aGV5IGhhdmUgaW4gdGhlIHBhbmVsLlxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydFZhbHVlcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG5cbiAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBvcHRpb24gc3Vic2NyaXB0aW9ucy4gKi9cbiAgcHJpdmF0ZSBfZHJvcFN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29wdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fb3B0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9vcHRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBFbWl0cyBjaGFuZ2UgZXZlbnQgdG8gc2V0IHRoZSBtb2RlbCB2YWx1ZS4gKi9cbiAgcHJpdmF0ZSBfcHJvcGFnYXRlQ2hhbmdlcyhmYWxsYmFja1ZhbHVlPzogYW55KTogdm9pZCB7XG4gICAgbGV0IHZhbHVlVG9FbWl0ID0gbnVsbDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc2VsZWN0ZWQpKSB7XG4gICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQubWFwKG9wdGlvbiA9PiBvcHRpb24udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVRvRW1pdCA9IHRoaXMuc2VsZWN0ZWQgPyB0aGlzLnNlbGVjdGVkLnZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZVRvRW1pdCk7XG4gICAgdGhpcy5jaGFuZ2UuZW1pdChuZXcgTWQyU2VsZWN0Q2hhbmdlKHRoaXMsIHZhbHVlVG9FbWl0KSk7XG4gIH1cblxuICAvKiogUmVjb3JkcyBvcHRpb24gSURzIHRvIHBhc3MgdG8gdGhlIGFyaWEtb3ducyBwcm9wZXJ0eS4gKi9cbiAgcHJpdmF0ZSBfc2V0T3B0aW9uSWRzKCkge1xuICAgIHRoaXMuX29wdGlvbklkcyA9IHRoaXMub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5pZCkuam9pbignICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGBtdWx0aXBsZWAgcHJvcGVydHkgb24gZWFjaCBvcHRpb24uIFRoZSBwcm9taXNlIGlzIG5lY2Vzc2FyeVxuICAgKiBpbiBvcmRlciB0byBhdm9pZCBBbmd1bGFyIGVycm9ycyB3aGVuIG1vZGlmeWluZyB0aGUgcHJvcGVydHkgYWZ0ZXIgaW5pdC5cbiAgICovXG4gIHByaXZhdGUgX3NldE9wdGlvbk11bHRpcGxlKCkge1xuICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiBvcHRpb24ubXVsdGlwbGUgPSB0aGlzLm11bHRpcGxlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNdXN0IHNldCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdGVkIG9wdGlvbidzIHZhbHVlIHByb2dyYW1tYXRpY2FsbHlcbiAgICogYmVjYXVzZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgYW5kIG90aGVyd2lzZSB3aWxsIG5vdCBjbGlwXG4gICAqIG92ZXJmbG93LiBUaGUgc2VsZWN0aW9uIGFycm93IGlzIDlweCB3aWRlLCBhZGQgNHB4IG9mIHBhZGRpbmcgPSAxM1xuICAgKi9cbiAgcHJpdmF0ZSBfc2V0VmFsdWVXaWR0aCgpIHtcbiAgICB0aGlzLl9zZWxlY3RlZFZhbHVlV2lkdGggPSB0aGlzLl90cmlnZ2VyV2lkdGggLSAxMztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBzZWxlY3RlZCBpdGVtLiBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIGl0IHdpbGwgZm9jdXNcbiAgICogdGhlIGZpcnN0IGl0ZW0gaW5zdGVhZC5cbiAgICovXG4gIHByaXZhdGUgX2ZvY3VzQ29ycmVjdE9wdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0odGhpcy5fZ2V0T3B0aW9uSW5kZXgodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0ZWRbMF0pKTtcbiAgICB9XG4gIH1cblxuICAvKiogRm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50IHdoZW4gdGhlIHBhbmVsIGNsb3Nlcy4gKi9cbiAgcHJpdmF0ZSBfZm9jdXNIb3N0KCk6IHZvaWQge1xuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwcm92aWRlZCBvcHRpb24gaW4gdGhlIG9wdGlvbiBsaXN0LiAqL1xuICBwcml2YXRlIF9nZXRPcHRpb25JbmRleChvcHRpb246IE1kMk9wdGlvbik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWR1Y2UoKHJlc3VsdDogbnVtYmVyLCBjdXJyZW50OiBNZDJPcHRpb24sIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IChvcHRpb24gPT09IGN1cnJlbnQgPyBpbmRleCA6IHVuZGVmaW5lZCkgOiByZXN1bHQ7XG4gICAgfSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgcG9zaXRpb24gYW5kIHgtIGFuZCB5LW9mZnNldHMgb2YgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gIHByaXZhdGUgX2NhbGN1bGF0ZU92ZXJsYXlQb3NpdGlvbigpOiB2b2lkIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1Db3VudCgpO1xuICAgIGNvbnN0IHBhbmVsSGVpZ2h0ID0gTWF0aC5taW4oaXRlbXMgKiBTRUxFQ1RfSVRFTV9IRUlHSFQsIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUKTtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJIZWlnaHQgPSBpdGVtcyAqIFNFTEVDVF9JVEVNX0hFSUdIVDtcblxuICAgIC8vIFRoZSBmYXJ0aGVzdCB0aGUgcGFuZWwgY2FuIGJlIHNjcm9sbGVkIGJlZm9yZSBpdCBoaXRzIHRoZSBib3R0b21cbiAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxDb250YWluZXJIZWlnaHQgLSBwYW5lbEhlaWdodDtcblxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IHRoaXMuX2dldE9wdGlvbkluZGV4KHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdKTtcblxuICAgICAgc2VsZWN0ZWRJbmRleCArPSB0aGlzLl9nZXRMYWJlbENvdW50QmVmb3JlT3B0aW9uKHNlbGVjdGVkSW5kZXgpO1xuXG4gICAgICAvLyBXZSBtdXN0IG1haW50YWluIGEgc2Nyb2xsIGJ1ZmZlciBzbyB0aGUgc2VsZWN0ZWQgb3B0aW9uIHdpbGwgYmUgc2Nyb2xsZWQgdG8gdGhlXG4gICAgICAvLyBjZW50ZXIgb2YgdGhlIG92ZXJsYXkgcGFuZWwgcmF0aGVyIHRoYW4gdGhlIHRvcC5cbiAgICAgIGNvbnN0IHNjcm9sbEJ1ZmZlciA9IHBhbmVsSGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJsYXlTY3JvbGwoc2VsZWN0ZWRJbmRleCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpO1xuICAgICAgdGhpcy5fb2Zmc2V0WSA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJsYXlPZmZzZXRZKHNlbGVjdGVkSW5kZXgsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLCB0aGUgcGFuZWwgY2VudGVycyBvbiB0aGUgZmlyc3Qgb3B0aW9uLiBJbiB0aGlzIGNhc2UsXG4gICAgICAvLyB3ZSBtdXN0IG9ubHkgYWRqdXN0IGZvciB0aGUgaGVpZ2h0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgIC8vIGFuZCB0aGUgdHJpZ2dlciBlbGVtZW50LCB0aGVuIG11bHRpcGx5IGl0IGJ5IC0xIHRvIGVuc3VyZSB0aGUgcGFuZWwgbW92ZXNcbiAgICAgIC8vIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbiB1cCB0aGUgcGFnZS5cbiAgICAgIHRoaXMuX29mZnNldFkgPSAoU0VMRUNUX0lURU1fSEVJR0hUIC0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUKSAvIDIgKiAtMTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja092ZXJsYXlXaXRoaW5WaWV3cG9ydChtYXhTY3JvbGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbC5cbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gY2VudGVyIHRoZSBzZWxlY3RlZCBvcHRpb24gaW4gdGhlIHBhbmVsLiBJZiB0aGUgb3B0aW9uIGlzXG4gICAqIHRvbyBoaWdoIG9yIHRvbyBsb3cgaW4gdGhlIHBhbmVsIHRvIGJlIHNjcm9sbGVkIHRvIHRoZSBjZW50ZXIsIGl0IGNsYW1wcyB0aGVcbiAgICogc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBtaW4gb3IgbWF4IHNjcm9sbCBwb3NpdGlvbnMgcmVzcGVjdGl2ZWx5LlxuICAgKi9cbiAgX2NhbGN1bGF0ZU92ZXJsYXlTY3JvbGwoc2VsZWN0ZWRJbmRleDogbnVtYmVyLCBzY3JvbGxCdWZmZXI6IG51bWJlcixcbiAgICBtYXhTY3JvbGw6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3Qgb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCA9IFNFTEVDVF9JVEVNX0hFSUdIVCAqIHNlbGVjdGVkSW5kZXg7XG4gICAgY29uc3QgaGFsZk9wdGlvbkhlaWdodCA9IFNFTEVDVF9JVEVNX0hFSUdIVCAvIDI7XG5cbiAgICAvLyBTdGFydHMgYXQgdGhlIG9wdGlvbk9mZnNldEZyb21TY3JvbGxUb3AsIHdoaWNoIHNjcm9sbHMgdGhlIG9wdGlvbiB0byB0aGUgdG9wIG9mIHRoZVxuICAgIC8vIHNjcm9sbCBjb250YWluZXIsIHRoZW4gc3VidHJhY3RzIHRoZSBzY3JvbGwgYnVmZmVyIHRvIHNjcm9sbCB0aGUgb3B0aW9uIGRvd24gdG9cbiAgICAvLyB0aGUgY2VudGVyIG9mIHRoZSBvdmVybGF5IHBhbmVsLiBIYWxmIHRoZSBvcHRpb24gaGVpZ2h0IG11c3QgYmUgcmUtYWRkZWQgdG8gdGhlXG4gICAgLy8gc2Nyb2xsVG9wIHNvIHRoZSBvcHRpb24gaXMgY2VudGVyZWQgYmFzZWQgb24gaXRzIG1pZGRsZSwgbm90IGl0cyB0b3AgZWRnZS5cbiAgICBjb25zdCBvcHRpbWFsU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wIC0gc2Nyb2xsQnVmZmVyICsgaGFsZk9wdGlvbkhlaWdodDtcbiAgICByZXR1cm4gY2xhbXBWYWx1ZSgwLCBvcHRpbWFsU2Nyb2xsUG9zaXRpb24sIG1heFNjcm9sbCk7XG4gIH1cblxuICAvKipcbiAgICogRmlndXJlcyBvdXQgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBzdGF0ZSBmb3IgdGhlIHBsYWNlaG9sZGVyLlxuICAgKi9cbiAgX2dldFBsYWNlaG9sZGVyQW5pbWF0aW9uU3RhdGUoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5mbG9hdFBsYWNlaG9sZGVyID09PSAnbmV2ZXInKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cycpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBDU1MgYG9wYWNpdHlgIG9mIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LlxuICAgKi9cbiAgX2dldFBsYWNlaG9sZGVyT3BhY2l0eSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAodGhpcy5mbG9hdFBsYWNlaG9sZGVyICE9PSAnbmV2ZXInIHx8IHRoaXMuX3NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSkgP1xuICAgICAgJzEnIDogJzAnO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIGFyaWEtbGFiZWwgb2YgdGhlIHNlbGVjdCBjb21wb25lbnQuICovXG4gIGdldCBfYXJpYUxhYmVsKCk6IHN0cmluZyB7XG4gICAgLy8gSWYgYW4gYXJpYUxhYmVsbGVkYnkgdmFsdWUgaGFzIGJlZW4gc2V0LCB0aGUgc2VsZWN0IHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoZVxuICAgIC8vIGBhcmlhLWxhYmVsbGVkYnlgIHZhbHVlIGJ5IHNldHRpbmcgdGhlIGFyaWFMYWJlbCB0byB0aGUgcGxhY2Vob2xkZXIuXG4gICAgcmV0dXJuIHRoaXMuYXJpYUxhYmVsbGVkYnkgPyBudWxsIDogdGhpcy5hcmlhTGFiZWwgfHwgdGhpcy5wbGFjZWhvbGRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB4LW9mZnNldCBvZiB0aGUgb3ZlcmxheSBwYW5lbCBpbiByZWxhdGlvbiB0byB0aGUgdHJpZ2dlcidzIHRvcCBzdGFydCBjb3JuZXIuXG4gICAqIFRoaXMgbXVzdCBiZSBhZGp1c3RlZCB0byBhbGlnbiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRleHQgb3ZlciB0aGUgdHJpZ2dlciB0ZXh0IHdoZW5cbiAgICogdGhlIHBhbmVsIG9wZW5zLiBXaWxsIGNoYW5nZSBiYXNlZCBvbiBMVFIgb3IgUlRMIHRleHQgZGlyZWN0aW9uLiBOb3RlIHRoYXQgdGhlIG9mZnNldFxuICAgKiBjYW4ndCBiZSBjYWxjdWxhdGVkIHVudGlsIHRoZSBwYW5lbCBoYXMgYmVlbiBhdHRhY2hlZCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgdGhlXG4gICAqIGNvbnRlbnQgd2lkdGggaW4gb3JkZXIgdG8gY29uc3RyYWluIHRoZSBwYW5lbCB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJpdmF0ZSBfY2FsY3VsYXRlT3ZlcmxheU9mZnNldFgoKTogdm9pZCB7XG4gICAgY29uc3Qgb3ZlcmxheVJlY3QgPSB0aGlzLm92ZXJsYXlEaXIub3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgIGNvbnN0IGlzUnRsID0gdGhpcy5faXNSdGwoKTtcbiAgICBsZXQgb2Zmc2V0WDogbnVtYmVyO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBvZmZzZXQsIGRlcGVuZGluZyBvbiB0aGUgb3B0aW9uIHBhZGRpbmcuXG4gICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgIG9mZnNldFggPSBTRUxFQ1RfTVVMVElQTEVfUEFORUxfUEFERElOR19YO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXTtcbiAgICAgIG9mZnNldFggPSBzZWxlY3RlZCAmJiBzZWxlY3RlZC5ncm91cCA/IFNFTEVDVF9QQU5FTF9JTkRFTlRfUEFERElOR19YIDogU0VMRUNUX1BBTkVMX1BBRERJTkdfWDtcbiAgICB9XG5cbiAgICAvLyBJbnZlcnQgdGhlIG9mZnNldCBpbiBMVFIuXG4gICAgaWYgKCFpc1J0bCkge1xuICAgICAgb2Zmc2V0WCAqPSAtMTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgaG93IG11Y2ggdGhlIHNlbGVjdCBvdmVyZmxvd3Mgb24gZWFjaCBzaWRlLlxuICAgIGNvbnN0IGxlZnRPdmVyZmxvdyA9IDAgLSAob3ZlcmxheVJlY3QubGVmdCArIG9mZnNldFhcbiAgICAgIC0gKGlzUnRsID8gU0VMRUNUX1BBTkVMX1BBRERJTkdfWCAqIDIgOiAwKSk7XG4gICAgY29uc3QgcmlnaHRPdmVyZmxvdyA9IG92ZXJsYXlSZWN0LnJpZ2h0ICsgb2Zmc2V0WCAtIHZpZXdwb3J0UmVjdC53aWR0aFxuICAgICAgKyAoaXNSdGwgPyAwIDogU0VMRUNUX1BBTkVMX1BBRERJTkdfWCAqIDIpO1xuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgb3ZlcmZsb3dzIG9uIGVpdGhlciBzaWRlLCByZWR1Y2UgdGhlIG9mZnNldCB0byBhbGxvdyBpdCB0byBmaXQuXG4gICAgaWYgKGxlZnRPdmVyZmxvdyA+IDApIHtcbiAgICAgIG9mZnNldFggKz0gbGVmdE92ZXJmbG93ICsgU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgfSBlbHNlIGlmIChyaWdodE92ZXJmbG93ID4gMCkge1xuICAgICAgb2Zmc2V0WCAtPSByaWdodE92ZXJmbG93ICsgU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBvZmZzZXQgZGlyZWN0bHkgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIGdvIHRocm91Z2ggY2hhbmdlIGRldGVjdGlvbiBhbmRcbiAgICAvLyBwb3RlbnRpYWxseSB0cmlnZ2VyaW5nIFwiY2hhbmdlZCBhZnRlciBpdCB3YXMgY2hlY2tlZFwiIGVycm9ycy5cbiAgICB0aGlzLm92ZXJsYXlEaXIub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSB5LW9mZnNldCBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbCBpbiByZWxhdGlvbiB0byB0aGVcbiAgICogdG9wIHN0YXJ0IGNvcm5lciBvZiB0aGUgdHJpZ2dlci4gSXQgaGFzIHRvIGJlIGFkanVzdGVkIGluIG9yZGVyIGZvciB0aGVcbiAgICogc2VsZWN0ZWQgb3B0aW9uIHRvIGJlIGFsaWduZWQgb3ZlciB0aGUgdHJpZ2dlciB3aGVuIHRoZSBwYW5lbCBvcGVucy5cbiAgICovXG4gIHByaXZhdGUgX2NhbGN1bGF0ZU92ZXJsYXlPZmZzZXRZKHNlbGVjdGVkSW5kZXg6IG51bWJlciwgc2Nyb2xsQnVmZmVyOiBudW1iZXIsXG4gICAgbWF4U2Nyb2xsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3A6IG51bWJlcjtcblxuICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcCA9IHNlbGVjdGVkSW5kZXggKiBTRUxFQ1RfSVRFTV9IRUlHSFQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zY3JvbGxUb3AgPT09IG1heFNjcm9sbCkge1xuICAgICAgY29uc3QgZmlyc3REaXNwbGF5ZWRJbmRleCA9IHRoaXMuX2dldEl0ZW1Db3VudCgpIC0gU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRGlzcGxheUluZGV4ID0gc2VsZWN0ZWRJbmRleCAtIGZpcnN0RGlzcGxheWVkSW5kZXg7XG5cbiAgICAgIC8vIEJlY2F1c2UgdGhlIHBhbmVsIGhlaWdodCBpcyBsb25nZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSBvcHRpb25zIGFsb25lLFxuICAgICAgLy8gdGhlcmUgaXMgYWx3YXlzIGV4dHJhIHBhZGRpbmcgYXQgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHBhbmVsLiBXaGVuXG4gICAgICAvLyBzY3JvbGxlZCB0byB0aGUgdmVyeSBib3R0b20sIHRoaXMgcGFkZGluZyBpcyBhdCB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmRcbiAgICAgIC8vIG11c3QgYmUgYWRkZWQgdG8gdGhlIG9mZnNldC5cbiAgICAgIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcCA9XG4gICAgICAgIHNlbGVjdGVkRGlzcGxheUluZGV4ICogU0VMRUNUX0lURU1fSEVJR0hUICsgU0VMRUNUX1BBTkVMX1BBRERJTkdfWTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIG9wdGlvbiB3YXMgc2Nyb2xsZWQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgdXNpbmcgYSBzY3JvbGwgYnVmZmVyLFxuICAgICAgLy8gaXRzIG9mZnNldCB3aWxsIGJlIHRoZSBzY3JvbGwgYnVmZmVyIG1pbnVzIHRoZSBoYWxmIGhlaWdodCB0aGF0IHdhcyBhZGRlZCB0b1xuICAgICAgLy8gY2VudGVyIGl0LlxuICAgICAgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wID0gc2Nyb2xsQnVmZmVyIC0gU0VMRUNUX0lURU1fSEVJR0hUIC8gMjtcbiAgICB9XG5cbiAgICAvLyBUaGUgZmluYWwgb2Zmc2V0IGlzIHRoZSBvcHRpb24ncyBvZmZzZXQgZnJvbSB0aGUgdG9wLCBhZGp1c3RlZCBmb3IgdGhlIGhlaWdodFxuICAgIC8vIGRpZmZlcmVuY2UsIG11bHRpcGxpZWQgYnkgLTEgdG8gZW5zdXJlIHRoYXQgdGhlIG92ZXJsYXkgbW92ZXMgaW4gdGhlIGNvcnJlY3RcbiAgICAvLyBkaXJlY3Rpb24gdXAgdGhlIHBhZ2UuXG4gICAgcmV0dXJuIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcCAqIC0xIC0gU0VMRUNUX0lURU1fSEVJR0hUX0FESlVTVE1FTlQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoYXQgdGhlIGF0dGVtcHRlZCBvdmVybGF5IHBvc2l0aW9uIHdpbGwgZml0IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICAqIElmIGl0IHdpbGwgbm90IGZpdCwgdHJpZXMgdG8gYWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gYW5kIHRoZSBhc3NvY2lhdGVkXG4gICAqIHktb2Zmc2V0IHNvIHRoZSBwYW5lbCBjYW4gb3BlbiBmdWxseSBvbi1zY3JlZW4uIElmIGl0IHN0aWxsIHdvbid0IGZpdCxcbiAgICogc2V0cyB0aGUgb2Zmc2V0IGJhY2sgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb24gdG8gdGFrZSBvdmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2hlY2tPdmVybGF5V2l0aGluVmlld3BvcnQobWF4U2Nyb2xsOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgIGNvbnN0IHRyaWdnZXJSZWN0ID0gdGhpcy5fZ2V0VHJpZ2dlclJlY3QoKTtcblxuICAgIGNvbnN0IHRvcFNwYWNlQXZhaWxhYmxlID0gdHJpZ2dlclJlY3QudG9wIC0gU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgY29uc3QgYm90dG9tU3BhY2VBdmFpbGFibGUgPVxuICAgICAgdmlld3BvcnRSZWN0LmhlaWdodCAtIHRyaWdnZXJSZWN0LmJvdHRvbSAtIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuXG4gICAgY29uc3QgcGFuZWxIZWlnaHRUb3AgPSBNYXRoLmFicyh0aGlzLl9vZmZzZXRZKTtcbiAgICBjb25zdCB0b3RhbFBhbmVsSGVpZ2h0ID1cbiAgICAgIE1hdGgubWluKHRoaXMuX2dldEl0ZW1Db3VudCgpICogU0VMRUNUX0lURU1fSEVJR0hULCBTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCk7XG4gICAgY29uc3QgcGFuZWxIZWlnaHRCb3R0b20gPSB0b3RhbFBhbmVsSGVpZ2h0IC0gcGFuZWxIZWlnaHRUb3AgLSB0cmlnZ2VyUmVjdC5oZWlnaHQ7XG5cbiAgICBpZiAocGFuZWxIZWlnaHRCb3R0b20gPiBib3R0b21TcGFjZUF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5fYWRqdXN0UGFuZWxVcChwYW5lbEhlaWdodEJvdHRvbSwgYm90dG9tU3BhY2VBdmFpbGFibGUpO1xuICAgIH0gZWxzZSBpZiAocGFuZWxIZWlnaHRUb3AgPiB0b3BTcGFjZUF2YWlsYWJsZSkge1xuICAgICAgdGhpcy5fYWRqdXN0UGFuZWxEb3duKHBhbmVsSGVpZ2h0VG9wLCB0b3BTcGFjZUF2YWlsYWJsZSwgbWF4U2Nyb2xsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBBZGp1c3RzIHRoZSBvdmVybGF5IHBhbmVsIHVwIHRvIGZpdCBpbiB0aGUgdmlld3BvcnQuICovXG4gIHByaXZhdGUgX2FkanVzdFBhbmVsVXAocGFuZWxIZWlnaHRCb3R0b206IG51bWJlciwgYm90dG9tU3BhY2VBdmFpbGFibGU6IG51bWJlcikge1xuICAgIGNvbnN0IGRpc3RhbmNlQmVsb3dWaWV3cG9ydCA9IHBhbmVsSGVpZ2h0Qm90dG9tIC0gYm90dG9tU3BhY2VBdmFpbGFibGU7XG5cbiAgICAvLyBTY3JvbGxzIHRoZSBwYW5lbCB1cCBieSB0aGUgZGlzdGFuY2UgaXQgd2FzIGV4dGVuZGluZyBwYXN0IHRoZSBib3VuZGFyeSwgdGhlblxuICAgIC8vIGFkanVzdHMgdGhlIG9mZnNldCBieSB0aGF0IGFtb3VudCB0byBtb3ZlIHRoZSBwYW5lbCB1cCBpbnRvIHRoZSB2aWV3cG9ydC5cbiAgICB0aGlzLl9zY3JvbGxUb3AgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgIHRoaXMuX29mZnNldFkgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkJhc2VkT25PcHRpb24oKTtcblxuICAgIC8vIElmIHRoZSBwYW5lbCBpcyBzY3JvbGxlZCB0byB0aGUgdmVyeSB0b3AsIGl0IHdvbid0IGJlIGFibGUgdG8gZml0IHRoZSBwYW5lbFxuICAgIC8vIGJ5IHNjcm9sbGluZywgc28gc2V0IHRoZSBvZmZzZXQgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb24gdG8gdGFrZVxuICAgIC8vIGVmZmVjdC5cbiAgICBpZiAodGhpcy5fc2Nyb2xsVG9wIDw9IDApIHtcbiAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XG4gICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IGA1MCUgYm90dG9tIDBweGA7XG4gICAgfVxuICB9XG5cbiAgLyoqIEFkanVzdHMgdGhlIG92ZXJsYXkgcGFuZWwgZG93biB0byBmaXQgaW4gdGhlIHZpZXdwb3J0LiAqL1xuICBwcml2YXRlIF9hZGp1c3RQYW5lbERvd24ocGFuZWxIZWlnaHRUb3A6IG51bWJlciwgdG9wU3BhY2VBdmFpbGFibGU6IG51bWJlcixcbiAgICBtYXhTY3JvbGw6IG51bWJlcikge1xuICAgIGNvbnN0IGRpc3RhbmNlQWJvdmVWaWV3cG9ydCA9IHBhbmVsSGVpZ2h0VG9wIC0gdG9wU3BhY2VBdmFpbGFibGU7XG5cbiAgICAvLyBTY3JvbGxzIHRoZSBwYW5lbCBkb3duIGJ5IHRoZSBkaXN0YW5jZSBpdCB3YXMgZXh0ZW5kaW5nIHBhc3QgdGhlIGJvdW5kYXJ5LCB0aGVuXG4gICAgLy8gYWRqdXN0cyB0aGUgb2Zmc2V0IGJ5IHRoYXQgYW1vdW50IHRvIG1vdmUgdGhlIHBhbmVsIGRvd24gaW50byB0aGUgdmlld3BvcnQuXG4gICAgdGhpcy5fc2Nyb2xsVG9wICs9IGRpc3RhbmNlQWJvdmVWaWV3cG9ydDtcbiAgICB0aGlzLl9vZmZzZXRZICs9IGRpc3RhbmNlQWJvdmVWaWV3cG9ydDtcbiAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG5cbiAgICAvLyBJZiB0aGUgcGFuZWwgaXMgc2Nyb2xsZWQgdG8gdGhlIHZlcnkgYm90dG9tLCBpdCB3b24ndCBiZSBhYmxlIHRvIGZpdCB0aGVcbiAgICAvLyBwYW5lbCBieSBzY3JvbGxpbmcsIHNvIHNldCB0aGUgb2Zmc2V0IHRvIDAgdG8gYWxsb3cgdGhlIGZhbGxiYWNrIHBvc2l0aW9uXG4gICAgLy8gdG8gdGFrZSBlZmZlY3QuXG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IG1heFNjcm9sbDtcbiAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gYDUwJSB0b3AgMHB4YDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiogU2V0cyB0aGUgdHJhbnNmb3JtIG9yaWdpbiBwb2ludCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICBwcml2YXRlIF9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk6IHN0cmluZyB7XG4gICAgY29uc3Qgb3JpZ2luWSA9XG4gICAgICBNYXRoLmFicyh0aGlzLl9vZmZzZXRZKSAtIFNFTEVDVF9JVEVNX0hFSUdIVF9BREpVU1RNRU5UICsgU0VMRUNUX0lURU1fSEVJR0hUIC8gMjtcbiAgICByZXR1cm4gYDUwJSAke29yaWdpbll9cHggMHB4YDtcbiAgfVxuXG4gIC8qKiBGaWd1cmVzIG91dCB0aGUgZmxvYXRpbmcgcGxhY2Vob2xkZXIgc3RhdGUgdmFsdWUuICovXG4gIHByaXZhdGUgX2Zsb2F0UGxhY2Vob2xkZXJTdGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pc1J0bCgpID8gJ2Zsb2F0aW5nLXJ0bCcgOiAnZmxvYXRpbmctbHRyJztcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHRoZSB1c2VyIHByZXNzaW5nIHRoZSBhcnJvdyBrZXlzIG9uIGEgY2xvc2VkIHNlbGVjdC4gICovXG4gIHByaXZhdGUgX2hhbmRsZUFycm93S2V5KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX211bHRpcGxlKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZBY3RpdmVJdGVtID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtO1xuXG4gICAgICAvLyBDeWNsZSB0aG91Z2ggdGhlIHNlbGVjdCBvcHRpb25zIGV2ZW4gd2hlbiB0aGUgc2VsZWN0IGlzIGNsb3NlZCxcbiAgICAgIC8vIG1hdGNoaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbmF0aXZlIHNlbGVjdCBlbGVtZW50LlxuICAgICAgLy8gVE9ETyhjcmlzYmV0byk6IG5hdGl2ZSBzZWxlY3RzIGFsc28gY3ljbGUgdGhyb3VnaCB0aGUgb3B0aW9ucyB3aXRoIGxlZnQvcmlnaHQgYXJyb3dzLFxuICAgICAgLy8gaG93ZXZlciB0aGUga2V5IG1hbmFnZXIgb25seSBzdXBwb3J0cyB1cC9kb3duIGF0IHRoZSBtb21lbnQuXG4gICAgICB0aGlzLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRBY3RpdmVJdGVtID0gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtIGFzIE1kMk9wdGlvbjtcblxuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVJdGVtICE9PSBwcmV2QWN0aXZlSXRlbSkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25CeVZhbHVlKGN1cnJlbnRBY3RpdmVJdGVtLnZhbHVlKTtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgb2YgaXRlbXMgaW4gdGhlIHNlbGVjdC4gVGhpcyBpbmNsdWRlcyBvcHRpb25zIGFuZCBncm91cCBsYWJlbHMuICovXG4gIHByaXZhdGUgX2dldEl0ZW1Db3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGVuZ3RoICsgdGhpcy5vcHRpb25Hcm91cHMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCBvZiBvcHRpb24gZ3JvdXAgbGFiZWxzIHRoYXQgcHJlY2VkZSB0aGUgc3BlY2lmaWVkIG9wdGlvbi5cbiAgICogVXNlZnVsIHdoZW4gcG9zaXRpb25pbmcgdGhlIHBhbmVsLCBiZWNhdXNlIHRoZSBsYWJlbHMgd2lsbCBvZmZzZXQgdGhlIGluZGV4IG9mIHRoZVxuICAgKiBjdXJyZW50bHktc2VsZWN0ZWQgb3B0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0TGFiZWxDb3VudEJlZm9yZU9wdGlvbihvcHRpb25JbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5vcHRpb25Hcm91cHMubGVuZ3RoKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICBsZXQgZ3JvdXBzID0gdGhpcy5vcHRpb25Hcm91cHMudG9BcnJheSgpO1xuICAgICAgbGV0IGdyb3VwQ291bnRlciA9IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uSW5kZXggKyAxOyBpKyspIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbaV0uZ3JvdXAgJiYgb3B0aW9uc1tpXS5ncm91cCA9PT0gZ3JvdXBzW2dyb3VwQ291bnRlcl0pIHtcbiAgICAgICAgICBncm91cENvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JvdXBDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbn1cblxuLyoqIENsYW1wcyBhIHZhbHVlIG4gYmV0d2VlbiBtaW4gYW5kIG1heCB2YWx1ZXMuICovXG5mdW5jdGlvbiBjbGFtcFZhbHVlKG1pbjogbnVtYmVyLCBuOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbiksIG1heCk7XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vKipcbiAqIEZpeGVkIGhlYWRlciB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYWJvdmUgYSBzZWxlY3QncyBvcHRpb25zLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdtZDItc2VsZWN0LWhlYWRlcicsXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbWQyLXNlbGVjdC1oZWFkZXInLFxuICB9XG59KVxuZXhwb3J0IGNsYXNzIE1kMlNlbGVjdEhlYWRlciB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTWQyU2VsZWN0IH0gZnJvbSAnLi9zZWxlY3QnO1xuaW1wb3J0IHsgTWQyU2VsZWN0SGVhZGVyIH0gZnJvbSAnLi9zZWxlY3QtaGVhZGVyJztcbmltcG9ydCB7IE1kMk9wdGlvbk1vZHVsZSB9IGZyb20gJy4vb3B0aW9uJztcbmltcG9ydCB7IE1kQ29tbW9uTW9kdWxlLCBPdmVybGF5TW9kdWxlIH0gZnJvbSAnLi4vY29yZS9pbmRleCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIE1kMk9wdGlvbk1vZHVsZSxcbiAgICBNZENvbW1vbk1vZHVsZSxcbiAgXSxcbiAgZXhwb3J0czogW01kMlNlbGVjdCwgTWQyU2VsZWN0SGVhZGVyLCBNZDJPcHRpb25Nb2R1bGUsIE1kQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbTWQyU2VsZWN0LCBNZDJTZWxlY3RIZWFkZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJTZWxlY3RNb2R1bGUgeyB9XG5cblxuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3QnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3QtaGVhZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vb3B0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vb3B0Z3JvdXAnO1xuZXhwb3J0IHsgZmFkZUluQ29udGVudCwgdHJhbnNmb3JtUGFuZWwsIHRyYW5zZm9ybVBsYWNlaG9sZGVyIH0gZnJvbSAnLi9zZWxlY3QtYW5pbWF0aW9ucyc7XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIERpcmVjdGl2ZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBEb0NoZWNrLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIEl0ZXJhYmxlRGlmZmVyLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgTmdNb2R1bGUsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTWQyU2VsZWN0TW9kdWxlIH0gZnJvbSAnLi4vc2VsZWN0L2luZGV4JztcblxuZXhwb3J0IGNsYXNzIE1kMlBhZ2luYXRpb25DaGFuZ2Uge1xuICBzb3VyY2U6IE1kMlBhZ2luYXRpb247XG4gIGFjdGl2ZVBhZ2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0RXZlbnQge1xuICBzb3J0Qnk6IHN0cmluZyB8IHN0cmluZ1tdO1xuICBzb3J0T3JkZXI6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlRXZlbnQge1xuICBhY3RpdmVQYWdlOiBudW1iZXI7XG4gIHJvd3NQZXJQYWdlOiBudW1iZXI7XG4gIGRhdGFMZW5ndGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRXZlbnQge1xuICBsZW5ndGg6IG51bWJlcjtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAndGFibGVbbWQyRGF0YV0nLFxuICBleHBvcnRBczogJ21kMkRhdGFUYWJsZSdcbn0pXG5leHBvcnQgY2xhc3MgTWQyRGF0YVRhYmxlIGltcGxlbWVudHMgRG9DaGVjayB7XG5cbiAgcHJpdmF0ZSBkaWZmOiBJdGVyYWJsZURpZmZlcjxhbnk+O1xuICBwcml2YXRlIGlzRGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfZGF0YTogQXJyYXk8YW55PiA9IFtdO1xuICBwcml2YXRlIF9hY3RpdmVQYWdlOiBudW1iZXIgPSAxO1xuICBwcml2YXRlIF9yb3dzUGVyUGFnZTogbnVtYmVyID0gMTAwMDtcbiAgcHJpdmF0ZSBfc29ydEJ5OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+ID0gJyc7XG4gIHByaXZhdGUgX3NvcnRPcmRlcjogc3RyaW5nID0gJ2FzYyc7XG5cbiAgZGF0YTogQXJyYXk8YW55PjtcblxuICBASW5wdXQoKVxuICBnZXQgbWQyRGF0YSgpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH1cbiAgc2V0IG1kMkRhdGEodmFsdWU6IEFycmF5PGFueT4pIHtcbiAgICBpZiAodGhpcy5fZGF0YSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVQYWdlKCk7XG4gICAgICB0aGlzLmlzRGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCBhY3RpdmVQYWdlKCkgeyByZXR1cm4gdGhpcy5fYWN0aXZlUGFnZTsgfVxuICBzZXQgYWN0aXZlUGFnZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVBhZ2UgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9hY3RpdmVQYWdlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KClcbiAgZ2V0IHJvd3NQZXJQYWdlKCkgeyByZXR1cm4gdGhpcy5fcm93c1BlclBhZ2U7IH1cbiAgc2V0IHJvd3NQZXJQYWdlKHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fcm93c1BlclBhZ2UgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9yb3dzUGVyUGFnZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zZXRQYWdlKHRoaXMuYWN0aXZlUGFnZSwgdmFsdWUpO1xuICAgICAgdGhpcy5pc0RhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBnZXQgc29ydEJ5KCkgeyByZXR1cm4gdGhpcy5fc29ydEJ5OyB9XG4gIHNldCBzb3J0QnkodmFsdWU6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAodGhpcy5fc29ydEJ5ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fc29ydEJ5ID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vblNvcnRDaGFuZ2UubmV4dCh7IHNvcnRCeTogdGhpcy5zb3J0QnksIHNvcnRPcmRlcjogdGhpcy5zb3J0T3JkZXIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzRGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCBzb3J0T3JkZXIoKSB7IHJldHVybiB0aGlzLl9zb3J0T3JkZXI7IH1cbiAgc2V0IHNvcnRPcmRlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCEodmFsdWUgPT09ICdhc2MnIHx8IHZhbHVlID09PSAnZGVzYycpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3NvcnRPcmRlciB2YWx1ZSBtdXN0IGJlIG9uZSBvZiBbXCJhc2NcIiwgXCJkZXNjXCJdLCBidXQgaXM6JywgdmFsdWUpO1xuICAgICAgdmFsdWUgPSAnYXNjJztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnRPcmRlciAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX3NvcnRPcmRlciA9IHZhbHVlO1xuICAgICAgdGhpcy5pc0RhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCkgYWN0aXZlUGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICBAT3V0cHV0KCkgcm93c1BlclBhZ2VDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgQE91dHB1dCgpIHNvcnRCeUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nIHwgc3RyaW5nW10+KCk7XG4gIEBPdXRwdXQoKSBzb3J0T3JkZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICBvblNvcnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPFNvcnRFdmVudD4oKTtcbiAgb25QYWdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxQYWdlRXZlbnQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMpIHtcbiAgICB0aGlzLmRpZmYgPSBkaWZmZXJzLmZpbmQoW10pLmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpOiBhbnkge1xuICAgIGxldCBjaGFuZ2VzID0gdGhpcy5kaWZmLmRpZmYodGhpcy5tZDJEYXRhKTtcbiAgICBpZiAoY2hhbmdlcykge1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZVBhZ2UoKTtcbiAgICAgIHRoaXMuaXNEYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZmlsbERhdGEoKTtcbiAgICAgIHRoaXMuZGlmZi5kaWZmKHRoaXMubWQyRGF0YSk7XG4gICAgICB0aGlzLmlzRGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBnZXRTb3J0KCk6IFNvcnRFdmVudCB7XG4gICAgcmV0dXJuIHsgc29ydEJ5OiB0aGlzLnNvcnRCeSwgc29ydE9yZGVyOiB0aGlzLnNvcnRPcmRlciB9O1xuICB9XG5cbiAgc2V0U29ydChzb3J0Qnk6IHN0cmluZyB8IHN0cmluZ1tdLCBzb3J0T3JkZXI6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnNvcnRCeSAhPT0gc29ydEJ5IHx8IHRoaXMuc29ydE9yZGVyICE9PSBzb3J0T3JkZXIpIHtcbiAgICAgIHRoaXMuc29ydEJ5ID0gc29ydEJ5O1xuICAgICAgdGhpcy5zb3J0T3JkZXIgPSBzb3J0T3JkZXI7XG4gICAgICB0aGlzLmlzRGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vblNvcnRDaGFuZ2UubmV4dCh7IHNvcnRCeTogc29ydEJ5LCBzb3J0T3JkZXI6IHNvcnRPcmRlciB9KTtcbiAgICAgIHRoaXMuc29ydEJ5Q2hhbmdlLmVtaXQodGhpcy5zb3J0QnkpO1xuICAgICAgdGhpcy5zb3J0T3JkZXJDaGFuZ2UuZW1pdCh0aGlzLnNvcnRPcmRlcik7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGFnZSgpOiBQYWdlRXZlbnQge1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmVQYWdlOiB0aGlzLmFjdGl2ZVBhZ2UsXG4gICAgICByb3dzUGVyUGFnZTogdGhpcy5yb3dzUGVyUGFnZSxcbiAgICAgIGRhdGFMZW5ndGg6IHRoaXMubWQyRGF0YS5sZW5ndGhcbiAgICB9O1xuICB9XG5cbiAgc2V0UGFnZShhY3RpdmVQYWdlOiBudW1iZXIsIHJvd3NQZXJQYWdlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yb3dzUGVyUGFnZSAhPT0gcm93c1BlclBhZ2UgfHwgdGhpcy5hY3RpdmVQYWdlICE9PSBhY3RpdmVQYWdlKSB7XG4gICAgICB0aGlzLmFjdGl2ZVBhZ2UgPSB0aGlzLmFjdGl2ZVBhZ2UgIT09IGFjdGl2ZVBhZ2UgP1xuICAgICAgICBhY3RpdmVQYWdlIDogdGhpcy5jYWxjdWxhdGVOZXdBY3RpdmVQYWdlKHRoaXMucm93c1BlclBhZ2UsIHJvd3NQZXJQYWdlKTtcbiAgICAgIGlmICh0aGlzLnJvd3NQZXJQYWdlICE9PSByb3dzUGVyUGFnZSkge1xuICAgICAgICB0aGlzLl9yb3dzUGVyUGFnZSA9IHJvd3NQZXJQYWdlO1xuICAgICAgICB0aGlzLnJvd3NQZXJQYWdlQ2hhbmdlLmVtaXQodGhpcy5yb3dzUGVyUGFnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzRGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vblBhZ2VDaGFuZ2UuZW1pdCh7XG4gICAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuYWN0aXZlUGFnZSxcbiAgICAgICAgcm93c1BlclBhZ2U6IHRoaXMucm93c1BlclBhZ2UsXG4gICAgICAgIGRhdGFMZW5ndGg6IHRoaXMubWQyRGF0YSA/IHRoaXMubWQyRGF0YS5sZW5ndGggOiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlUGFnZUNoYW5nZS5lbWl0KHRoaXMuYWN0aXZlUGFnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVOZXdBY3RpdmVQYWdlKHByZXZpb3VzUm93c1BlclBhZ2U6IG51bWJlciwgY3VycmVudFJvd3NQZXJQYWdlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBmaXJzdFJvd09uUGFnZSA9ICh0aGlzLmFjdGl2ZVBhZ2UgLSAxKSAqIHByZXZpb3VzUm93c1BlclBhZ2UgKyAxO1xuICAgIGxldCBuZXdBY3RpdmVQYWdlID0gTWF0aC5jZWlsKGZpcnN0Um93T25QYWdlIC8gY3VycmVudFJvd3NQZXJQYWdlKTtcbiAgICByZXR1cm4gbmV3QWN0aXZlUGFnZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVjYWxjdWxhdGVQYWdlKCkge1xuICAgIGxldCBsYXN0UGFnZSA9IE1hdGguY2VpbCh0aGlzLm1kMkRhdGEubGVuZ3RoIC8gdGhpcy5yb3dzUGVyUGFnZSk7XG4gICAgaWYgKGxhc3RQYWdlIDwgdGhpcy5hY3RpdmVQYWdlKSB7XG4gICAgICB0aGlzLl9hY3RpdmVQYWdlID0gbGFzdFBhZ2UgfHwgMTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdGl2ZVBhZ2VDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZVBhZ2UpO1xuICAgICAgfSwgMTApO1xuICAgIH0gZWxzZSB7IH1cblxuICAgIHRoaXMub25QYWdlQ2hhbmdlLmVtaXQoe1xuICAgICAgYWN0aXZlUGFnZTogdGhpcy5hY3RpdmVQYWdlLFxuICAgICAgcm93c1BlclBhZ2U6IHRoaXMucm93c1BlclBhZ2UsXG4gICAgICBkYXRhTGVuZ3RoOiB0aGlzLm1kMkRhdGEubGVuZ3RoXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZpbGxEYXRhKCkge1xuICAgIGxldCBvZmZzZXQgPSAodGhpcy5hY3RpdmVQYWdlIC0gMSkgKiB0aGlzLnJvd3NQZXJQYWdlO1xuICAgIGxldCBkYXRhID0gdGhpcy5tZDJEYXRhO1xuICAgIGxldCBzb3J0SW50ID0gdGhpcy5zb3J0T3JkZXIgPT09ICdkZXNjJyA/IC0xIDogMTtcbiAgICBpZiAodGhpcy5zb3J0QnkpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiB7XG4gICAgICAgIGxldCB4ID0gdGhpcy5jYXNlSW5zZW5zaXRpdmVJdGVyYXRlZShhKTtcbiAgICAgICAgbGV0IHkgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZUl0ZXJhdGVlKGIpO1xuICAgICAgICByZXR1cm4gKCh4ID4geSkgPyAxIDogKHkgPiB4KSA/IC0xIDogMCkgKiBzb3J0SW50O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLnJvd3NQZXJQYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FzZUluc2Vuc2l0aXZlSXRlcmF0ZWUodmFsdWU6IGFueSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3J0QnkgPT09ICdzdHJpbmcnIHx8IHRoaXMuc29ydEJ5IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBmb3IgKGxldCBzb3J0QnlQcm9wZXJ0eSBvZiB0aGlzLnNvcnRCeS5zcGxpdCgnLicpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVbc29ydEJ5UHJvcGVydHldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW3RoaXMuc29ydEJ5ICsgJyddO1xuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1ttZDJTb3J0QnldJyxcbiAgdGVtcGxhdGVVcmw6ICdzb3J0Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnZGF0YS10YWJsZS5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm1kMi1zb3J0LWFjdGl2ZV0nOiAnX2lzQXNjIHx8IF9pc0Rlc2MnLFxuICAgICcoY2xpY2spJzogJ19zb3J0KCknXG4gIH0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTWQyRGF0YVRhYmxlU29ydEJ5IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBASW5wdXQoKSBtZDJTb3J0Qnk6IHN0cmluZztcblxuICBfaXNBc2M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX2lzRGVzYzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX21kMlRhYmxlOiBNZDJEYXRhVGFibGUpIHtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX21kMlRhYmxlLm9uU29ydENoYW5nZS5zdWJzY3JpYmUoKGV2ZW50OiBTb3J0RXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX2lzQXNjID0gKGV2ZW50LnNvcnRCeSA9PT0gdGhpcy5tZDJTb3J0QnkgJiYgZXZlbnQuc29ydE9yZGVyID09PSAnYXNjJyk7XG4gICAgICB0aGlzLl9pc0Rlc2MgPSAoZXZlbnQuc29ydEJ5ID09PSB0aGlzLm1kMlNvcnRCeSAmJiBldmVudC5zb3J0T3JkZXIgPT09ICdkZXNjJyk7XG4gICAgfSk7XG4gIH1cblxuICBfc29ydCgpIHtcbiAgICBpZiAodGhpcy5faXNBc2MpIHtcbiAgICAgIHRoaXMuX21kMlRhYmxlLnNldFNvcnQodGhpcy5tZDJTb3J0QnksICdkZXNjJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21kMlRhYmxlLnNldFNvcnQodGhpcy5tZDJTb3J0QnksICdhc2MnKTtcbiAgICB9XG4gIH1cblxufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtZDItcGFnaW5hdGlvbicsXG4gIHRlbXBsYXRlVXJsOiAncGFnaW5hdGlvbi5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2RhdGEtdGFibGUuc2NzcyddLFxuICBleHBvcnRBczogJ21kMlBhZ2luYXRpb24nLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIE1kMlBhZ2luYXRpb24ge1xuXG4gIF9hY3RpdmVQYWdlOiBudW1iZXIgPSAxO1xuXG4gIEBJbnB1dCgpIHJvd3NQZXJQYWdlU2V0OiBhbnkgPSBbXTtcbiAgQElucHV0KCkgbWQyVGFibGU6IE1kMkRhdGFUYWJsZTtcbiAgQElucHV0KCkgcGFnaW5hdGlvbkxhYmVsOiBzdHJpbmcgPSAnUm93cyBwZXIgcGFnZTonO1xuXG4gIF9yb3dzUGVyUGFnZTogbnVtYmVyO1xuICBfZGF0YUxlbmd0aDogbnVtYmVyID0gMDtcbiAgX2xhc3RQYWdlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoIEBPcHRpb25hbCgpIHByaXZhdGUgX2RhdGFUYWJsZTogTWQyRGF0YVRhYmxlKSB7IH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgdGhpcy5tZDJUYWJsZSA9IHRoaXMubWQyVGFibGUgfHwgdGhpcy5fZGF0YVRhYmxlO1xuICAgIHRoaXMub25QYWdlQ2hhbmdlU3Vic2NyaWJlcih0aGlzLm1kMlRhYmxlLmdldFBhZ2UoKSk7XG4gICAgdGhpcy5tZDJUYWJsZS5vblBhZ2VDaGFuZ2Uuc3Vic2NyaWJlKHRoaXMub25QYWdlQ2hhbmdlU3Vic2NyaWJlcik7XG4gIH1cblxuICBfc2V0UGFnZShwYWdlTnVtYmVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLm1kMlRhYmxlLnNldFBhZ2UocGFnZU51bWJlciwgdGhpcy5fcm93c1BlclBhZ2UpO1xuICB9XG5cbiAgX3NldFJvd3MoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIHRoaXMubWQyVGFibGUuc2V0UGFnZSh0aGlzLl9hY3RpdmVQYWdlLCBwYXJzZUludChldmVudC52YWx1ZSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBvblBhZ2VDaGFuZ2VTdWJzY3JpYmVyID0gKGV2ZW50OiBQYWdlRXZlbnQpID0+IHtcbiAgICB0aGlzLl9hY3RpdmVQYWdlID0gZXZlbnQuYWN0aXZlUGFnZTtcbiAgICB0aGlzLl9yb3dzUGVyUGFnZSA9IGV2ZW50LnJvd3NQZXJQYWdlO1xuICAgIHRoaXMuX2RhdGFMZW5ndGggPSBldmVudC5kYXRhTGVuZ3RoO1xuICAgIHRoaXMuX2xhc3RQYWdlID0gTWF0aC5jZWlsKHRoaXMuX2RhdGFMZW5ndGggLyB0aGlzLl9yb3dzUGVyUGFnZSk7XG4gIH1cblxufVxuXG5leHBvcnQgY29uc3QgTUQyX0RBVEFfVEFCTEVfRElSRUNUSVZFUzogYW55W10gPSBbXG4gIE1kMkRhdGFUYWJsZSxcbiAgTWQyRGF0YVRhYmxlU29ydEJ5LFxuICBNZDJQYWdpbmF0aW9uXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgTWQyU2VsZWN0TW9kdWxlXSxcbiAgZXhwb3J0czogTUQyX0RBVEFfVEFCTEVfRElSRUNUSVZFUyxcbiAgZGVjbGFyYXRpb25zOiBNRDJfREFUQV9UQUJMRV9ESVJFQ1RJVkVTLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJEYXRhVGFibGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmNvbnN0IFNVUFBPUlRTX0lOVExfQVBJID0gZmFsc2U7IC8vIHR5cGVvZiBJbnRsICE9ICd1bmRlZmluZWQnO1xuXG5cbi8qKiBUaGUgZGVmYXVsdCBtb250aCBuYW1lcyB0byB1c2UgaWYgSW50bCBBUEkgaXMgbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IERFRkFVTFRfTU9OVEhfTkFNRVMgPSB7XG4gICdsb25nJzogW1xuICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsXG4gICAgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXG4gIF0sXG4gICdzaG9ydCc6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgJ25hcnJvdyc6IFsnSicsICdGJywgJ00nLCAnQScsICdNJywgJ0onLCAnSicsICdBJywgJ1MnLCAnTycsICdOJywgJ0QnXVxufTtcblxuXG4vKiogVGhlIGRlZmF1bHQgZGF0ZSBuYW1lcyB0byB1c2UgaWYgSW50bCBBUEkgaXMgbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IERFRkFVTFRfREFURV9OQU1FUyA9IHJhbmdlKDMxLCBpID0+IFN0cmluZyhpICsgMSkpO1xuXG4vKiogVGhlIGRlZmF1bHQgaG91ciBuYW1lcyB0byB1c2UgaWYgSW50bCBBUEkgaXMgbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IERFRkFVTFRfSE9VUl9OQU1FUyA9IHJhbmdlKDI0LCBpID0+IFN0cmluZyhpKSk7XG5cbi8qKiBUaGUgZGVmYXVsdCBtaW51dGUgbmFtZXMgdG8gdXNlIGlmIEludGwgQVBJIGlzIG5vdCBhdmFpbGFibGUuICovXG5jb25zdCBERUZBVUxUX01JTlVURV9OQU1FUyA9IHJhbmdlKDYwLCBpID0+IFN0cmluZyhpKSk7XG5cblxuLyoqIFRoZSBkZWZhdWx0IGRheSBvZiB0aGUgd2VlayBuYW1lcyB0byB1c2UgaWYgSW50bCBBUEkgaXMgbm90IGF2YWlsYWJsZS4gKi9cbmNvbnN0IERFRkFVTFRfREFZX09GX1dFRUtfTkFNRVMgPSB7XG4gICdsb25nJzogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAnc2hvcnQnOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAnbmFycm93JzogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ11cbn07XG5cblxuLyoqIENyZWF0ZXMgYW4gYXJyYXkgYW5kIGZpbGxzIGl0IHdpdGggdmFsdWVzLiAqL1xuZnVuY3Rpb24gcmFuZ2U8VD4obGVuZ3RoOiBudW1iZXIsIHZhbHVlRnVuY3Rpb246IChpbmRleDogbnVtYmVyKSA9PiBUKTogVFtdIHtcbiAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWVzQXJyYXlbaV0gPSB2YWx1ZUZ1bmN0aW9uKGkpO1xuICB9XG4gIHJldHVybiB2YWx1ZXNBcnJheTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb250aHMge1xuICBsb25nOiBBcnJheTxzdHJpbmc+O1xuICBzaG9ydDogQXJyYXk8c3RyaW5nPjtcbiAgbmFycm93OiBBcnJheTxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheXNPZldlZWsge1xuICBsb25nOiBBcnJheTxzdHJpbmc+O1xuICBzaG9ydDogQXJyYXk8c3RyaW5nPjtcbiAgbmFycm93OiBBcnJheTxzdHJpbmc+O1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZUxvY2FsZSB7XG5cbiAgbG9jYWxlOiBhbnk7XG4gIG1vbnRoczogTW9udGhzO1xuICBkYXlzT2ZXZWVrOiBEYXlzT2ZXZWVrO1xuICBkYXRlczogQXJyYXk8c3RyaW5nPjtcbiAgaG91cnM6IEFycmF5PHN0cmluZz47XG4gIG1pbnV0ZXM6IEFycmF5PHN0cmluZz47XG4gIGZpcnN0RGF5T2ZXZWVrOiBudW1iZXIgPSAwO1xuXG4gIGdldERheU9mV2VlayhkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXkoKTtcbiAgfVxuXG4gIGdldE1vbnRoTmFtZXMoc3R5bGU6ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93Jyk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5tb250aHMpIHsgcmV0dXJuIHRoaXMubW9udGhzW3N0eWxlXTsgfVxuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IG1vbnRoOiBzdHlsZSB9KTtcbiAgICAgIHJldHVybiByYW5nZSgxMiwgaSA9PiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KG5ldyBEYXRlKDIwMTcsIGksIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9NT05USF9OQU1FU1tzdHlsZV07XG4gIH1cblxuICBnZXREYXRlTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmRhdGVzKSB7IHJldHVybiB0aGlzLmRhdGVzOyB9XG4gICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XG4gICAgICBsZXQgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgZGF5OiAnbnVtZXJpYycgfSk7XG4gICAgICByZXR1cm4gcmFuZ2UoMzEsIGkgPT4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoXG4gICAgICAgIGR0Zi5mb3JtYXQobmV3IERhdGUoMjAxNywgMCwgaSArIDEpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gREVGQVVMVF9EQVRFX05BTUVTO1xuICB9XG5cbiAgZ2V0SG91ck5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5ob3VycykgeyByZXR1cm4gdGhpcy5ob3VyczsgfVxuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IGhvdXI6ICdudW1lcmljJyB9KTtcbiAgICAgIHJldHVybiByYW5nZSgyNCwgaSA9PiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhcbiAgICAgICAgZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCAwLCBpKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIERFRkFVTFRfSE9VUl9OQU1FUztcbiAgfVxuXG4gIGdldE1pbnV0ZU5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5taW51dGVzKSB7IHJldHVybiB0aGlzLm1pbnV0ZXM7IH1cbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGxldCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyBtaW51dGU6ICdudW1lcmljJyB9KTtcbiAgICAgIHJldHVybiByYW5nZSg2MCwgaSA9PiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhcbiAgICAgICAgZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCAwLCAwLCBpKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIERFRkFVTFRfTUlOVVRFX05BTUVTO1xuICB9XG5cbiAgZ2V0RGF5T2ZXZWVrTmFtZXMoc3R5bGU6ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93Jyk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5kYXlzT2ZXZWVrKSB7IHJldHVybiB0aGlzLmRheXNPZldlZWtbc3R5bGVdOyB9XG4gICAgaWYgKFNVUFBPUlRTX0lOVExfQVBJKSB7XG4gICAgICBsZXQgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgd2Vla2RheTogc3R5bGUgfSk7XG4gICAgICByZXR1cm4gcmFuZ2UoNywgaSA9PiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhcbiAgICAgICAgZHRmLmZvcm1hdChuZXcgRGF0ZSgyMDE3LCAwLCBpICsgMSkpKSk7XG4gICAgfVxuICAgIHJldHVybiBERUZBVUxUX0RBWV9PRl9XRUVLX05BTUVTW3N0eWxlXTtcbiAgfVxuXG4gIGdldFllYXJOYW1lKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICAgIGlmIChTVVBQT1JUU19JTlRMX0FQSSkge1xuICAgICAgbGV0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IHllYXI6ICdudW1lcmljJyB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkdGYuZm9ybWF0KGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgZ2V0Rmlyc3REYXlPZldlZWsoKTogbnVtYmVyIHtcbiAgICAvLyBXZSBjYW4ndCB0ZWxsIHVzaW5nIG5hdGl2ZSBKUyBEYXRlIHdoYXQgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpcywgd2UgZGVmYXVsdCB0byBTdW5kYXkuXG4gICAgcmV0dXJuIHRoaXMuZmlyc3REYXlPZldlZWs7XG4gIH1cblxuICBmb3JtYXQoZGF0ZTogRGF0ZSwgZGlzcGxheUZvcm1hdDogT2JqZWN0KTogc3RyaW5nIHtcbiAgICBpZiAoU1VQUE9SVFNfSU5UTF9BUEkpIHtcbiAgICAgIGxldCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgZGlzcGxheUZvcm1hdCk7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaXBEaXJlY3Rpb25hbGl0eUNoYXJhY3RlcnMoZHRmLmZvcm1hdChkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhkYXRlLnRvRGF0ZVN0cmluZygpKTtcbiAgfVxuXG4gIGdldERhdGVMYWJlbChkOiBEYXRlKTogc3RyaW5nIHtcbiAgICBsZXQgZGF5OiBzdHJpbmcgPSB0aGlzLmdldERheU9mV2Vla05hbWVzKCdzaG9ydCcpW2QuZ2V0RGF5KCldO1xuICAgIGxldCBkYXRlOiBzdHJpbmcgPSB0aGlzLmdldERhdGVOYW1lcygpW2QuZ2V0RGF0ZSgpIC0gMV07XG4gICAgbGV0IG1vbnRoOiBzdHJpbmcgPSB0aGlzLmdldE1vbnRoTmFtZXMoJ3Nob3J0JylbZC5nZXRNb250aCgpXTtcbiAgICByZXR1cm4gYCR7ZGF5fSwgJHttb250aH0gJHtkYXRlfWA7XG4gIH1cblxuICBnZXRIb3Vyc0xhYmVsKGQ6IERhdGUpOiBzdHJpbmcgeyByZXR1cm4gYCR7dGhpcy5nZXRIb3VyTmFtZXMoKVtkLmdldEhvdXJzKCldfWA7IH1cblxuICBnZXRNaW51dGVzTGFiZWwoZDogRGF0ZSk6IHN0cmluZyB7IHJldHVybiBgJHt0aGlzLmdldE1pbnV0ZU5hbWVzKClbZC5nZXRNaW51dGVzKCldfWA7IH1cblxuICBnZXRNb250aExhYmVsKGQ6IERhdGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmdldE1vbnRoTmFtZXMoJ2xvbmcnKVtkLmdldE1vbnRoKCldfSAke3RoaXMuZ2V0WWVhck5hbWUoZCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcCBvdXQgdW5pY29kZSBMVFIgYW5kIFJUTCBjaGFyYWN0ZXJzLiBFZGdlIGFuZCBJRSBpbnNlcnQgdGhlc2UgaW50byBmb3JtYXR0ZWQgZGF0ZXMgd2hpbGVcbiAgICogb3RoZXIgYnJvd3NlcnMgZG8gbm90LiBXZSByZW1vdmUgdGhlbSB0byBtYWtlIG91dHB1dCBjb25zaXN0ZW50IGFuZCBiZWNhdXNlIHRoZXkgaW50ZXJmZXJlIHdpdGhcbiAgICogZGF0ZSBwYXJzaW5nLlxuICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIHN0cmlwIGRpcmVjdGlvbiBjaGFyYWN0ZXJzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBzdHJpcHBlZCBzdHJpbmcuXG4gICAqL1xuICBwcml2YXRlIF9zdHJpcERpcmVjdGlvbmFsaXR5Q2hhcmFjdGVycyhzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bXFx1MjAwZVxcdTIwMGZdL2csICcnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZUxvY2FsZSB9IGZyb20gJy4vZGF0ZS1sb2NhbGUnO1xuXG5leHBvcnQgY2xhc3MgRGF0ZVV0aWwge1xuXG4gIF9sb2NhbGU6IERhdGVMb2NhbGUgPSBuZXcgRGF0ZUxvY2FsZSgpO1xuXG4gIHBhcnNlRGF0ZU1hcDogYW55ID0ge1xuICAgICd5JzogMCwgICAgICAvLyBwbGFjZWhvbGRlciAtPiBjdG9ySW5kZXhcbiAgICAnWSc6IFswLCAtMjAwMF0sXG4gICAgJ00nOiBbMSwgMV0sIC8vIHBsYWNlaG9sZGVyIC0+IFtjdG9ySW5kZXgsIG9mZnNldHx2YWx1ZSBhcnJheV1cbiAgICAnbic6IFsxLCB0aGlzLl9sb2NhbGUuZ2V0TW9udGhOYW1lcygnc2hvcnQnKV0sXG4gICAgJ04nOiBbMSwgdGhpcy5fbG9jYWxlLmdldE1vbnRoTmFtZXMoJ2xvbmcnKV0sXG4gICAgJ2QnOiAyLFxuICAgICdtJzogNCxcbiAgICAnSCc6IDMsXG4gICAgJ2gnOiAzLFxuICAgICdLJzogWzMsIDFdLFxuICAgICdrJzogWzMsIDFdLFxuICAgICdzJzogNSxcbiAgICAnUyc6IDYsXG4gICAgJ2EnOiBbMywgWydhbScsICdwbSddXSxcbiAgICAnQSc6IFszLCBbJ0FNJywgJ1BNJ11dXG4gIH07XG5cbiAgcmVwbGFjZShzOiBzdHJpbmcsIHJlZ2V4cDogYW55LCBzdWI/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gKHMgIT0gbnVsbCA/ICcnICsgcyA6ICcnKS5yZXBsYWNlKHJlZ2V4cCwgc3ViICE9IG51bGwgPyBzdWIgOiAnJyk7XG4gIH1cblxuICBzdGFydHNXaXRoKGJhc2U6IGFueSwgc3RhcnQ6IGFueSkge1xuICAgIHJldHVybiBzdGFydCAhPSBudWxsICYmIGJhc2Uuc3Vic3RyKDAsIHN0YXJ0Lmxlbmd0aCkgPT0gc3RhcnQ7XG4gIH1cblxuICBpc1R5cGUoczogYW55LCBvOiBhbnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHMgPT0gbztcbiAgfVxuXG4gIGlzRnVuY3Rpb24oZjogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUeXBlKGYsICdmdW5jdGlvbicpO1xuICB9XG5cbiAgaXNMaXN0KHY6IGFueSkge1xuICAgIHJldHVybiAhIXYgJiYgdi5sZW5ndGggIT0gbnVsbCAmJiAhdGhpcy5pc1N0cmluZyh2KSAmJiAhdGhpcy5pc05vZGUodikgJiYgIXRoaXMuaXNGdW5jdGlvbih2KTtcbiAgfVxuXG4gIGlzU3RyaW5nKHM6IGFueSkge1xuICAgIHJldHVybiB0aGlzLmlzVHlwZShzLCAnc3RyaW5nJyk7XG4gIH1cblxuICBpc09iamVjdChmOiBhbnkpIHtcbiAgICByZXR1cm4gISFmICYmIHRoaXMuaXNUeXBlKGYsICdvYmplY3QnKTtcbiAgfVxuXG4gIGlzTm9kZShuOiBhbnkpIHtcbiAgICByZXR1cm4gbiAmJiBuWydub2RlVHlwZSddO1xuICB9XG5cbiAgaXNOdW1iZXIobjogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUeXBlKG4sICdudW1iZXInKTtcbiAgfVxuXG4gIGdldEZpbmRGdW5jKGZpbmRGdW5jOiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Z1bmN0aW9uKGZpbmRGdW5jKSA/IGZpbmRGdW5jIDogKG9iajogYW55LCBpbmRleDogYW55KSA9PiB7XG4gICAgICBpZiAoZmluZEZ1bmMgPT09IG9iaikge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGdldEZpbmRJbmRleChsaXN0OiBhbnksIGluZGV4OiBhbnksIGRlZmF1bHRJbmRleDogYW55KSB7XG4gICAgcmV0dXJuIGluZGV4ID09IG51bGwgPyBkZWZhdWx0SW5kZXggOlxuICAgICAgaW5kZXggPCAwID8gTWF0aC5tYXgobGlzdC5sZW5ndGggKyBpbmRleCwgMCkgOiBNYXRoLm1pbihsaXN0Lmxlbmd0aCwgaW5kZXgpO1xuICB9XG5cbiAgZmluZChsaXN0OiBhbnksIGZpbmRGdW5jOiBhbnksIHN0YXJ0SW5kZXg/OiBhbnksIGVuZEluZGV4PzogYW55KSB7XG4gICAgbGV0IGYgPSB0aGlzLmdldEZpbmRGdW5jKGZpbmRGdW5jKTtcbiAgICBsZXQgZSA9IHRoaXMuZ2V0RmluZEluZGV4KGxpc3QsIGVuZEluZGV4LCBsaXN0Lmxlbmd0aCk7XG4gICAgbGV0IHI6IGFueTtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5nZXRGaW5kSW5kZXgobGlzdCwgc3RhcnRJbmRleCwgMCk7IGkgPCBlOyBpKyspIHtcbiAgICAgIGlmICgociA9IGYuY2FsbChsaXN0LCBsaXN0W2ldLCBpKSkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXJzZURhdGUoZGF0ZTogc3RyaW5nLCBmbXQ6IHN0cmluZykge1xuICAgIGxldCBpbmRleE1hcDogYW55ID0ge307IC8vIGNvbnRhaW5zIHJlR3JvdXBQb3NpdGlvbiAtPiB0eXBlTGV0dGVyIG9yIFt0eXBlTGV0dGVyLCB2YWx1ZSBhcnJheV1cbiAgICBsZXQgcmVJbmRleCA9IDE7XG4gICAgbGV0IHRpbWV6b25lT2Zmc2V0TWF0Y2g6IGFueTtcbiAgICBsZXQgdGltZXpvbmVJbmRleDogYW55O1xuICAgIGxldCBtYXRjaDogYW55O1xuXG4gICAgbGV0IGZvcm1hdCA9IHRoaXMucmVwbGFjZShmbXQsIC9eXFw/Lyk7XG4gICAgaWYgKGZvcm1hdCAhPSBmbXQgJiYgIXRoaXMucmVwbGFjZShkYXRlLCAvXlxccyt8XFxzKyQvZykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9IC9eXFxbKFsrLV0pKFxcZFxcZCkoXFxkXFxkKVxcXVxccyooLiopLy5leGVjKGZvcm1hdCkpIHtcbiAgICAgIHRpbWV6b25lT2Zmc2V0TWF0Y2ggPSBtYXRjaDtcbiAgICAgIGZvcm1hdCA9IG1hdGNoWzRdO1xuICAgIH1cblxuICAgIGxldCBwYXJzZXIgPSBuZXcgUmVnRXhwKGZvcm1hdC5yZXBsYWNlKC8oLikoXFwxKikoPzpcXFsoW15cXF1dKilcXF0pPy9nLFxuICAgICAgKHdob2xlTWF0Y2gsIHBsYWNlaG9sZGVyQ2hhciwgcGxhY2Vob2xkZXJEaWdpdHMsIHBhcmFtKSA9PiB7XG4gICAgICAgIGlmICgvW2RtaGt5aHNdL2kudGVzdChwbGFjZWhvbGRlckNoYXIpKSB7XG4gICAgICAgICAgaW5kZXhNYXBbcmVJbmRleCsrXSA9IHBsYWNlaG9sZGVyQ2hhcjtcbiAgICAgICAgICBsZXQgcGxlbiA9IHBsYWNlaG9sZGVyRGlnaXRzLmxlbmd0aCArIDE7XG4gICAgICAgICAgcmV0dXJuICcoXFxcXGQnICsgKHBsZW4gPCAyID8gJysnIDogKCd7MSwnICsgcGxlbiArICd9JykpICsgJyknO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYWNlaG9sZGVyQ2hhciA9PSAneicpIHtcbiAgICAgICAgICB0aW1lem9uZUluZGV4ID0gcmVJbmRleDtcbiAgICAgICAgICByZUluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuICcoWystXSkoXFxcXGRcXFxcZCkoXFxcXGRcXFxcZCknO1xuICAgICAgICB9IGVsc2UgaWYgKC9bTm5hQV0vLnRlc3QocGxhY2Vob2xkZXJDaGFyKSkge1xuICAgICAgICAgIGluZGV4TWFwW3JlSW5kZXgrK10gPSBbcGxhY2Vob2xkZXJDaGFyLCBwYXJhbSAmJiBwYXJhbS5zcGxpdCgnLCcpXTtcbiAgICAgICAgICByZXR1cm4gJyhbYS16QS1aXFxcXHUwMDgwLVxcXFx1MWZmZl0rKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL3cvaS50ZXN0KHBsYWNlaG9sZGVyQ2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gJ1thLXpBLVpcXFxcdTAwODAtXFxcXHUxZmZmXSsnO1xuICAgICAgICB9IGVsc2UgaWYgKC9cXHMvLnRlc3QocGxhY2Vob2xkZXJDaGFyKSkge1xuICAgICAgICAgIHJldHVybiAnXFxcXHMrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHdob2xlTWF0Y2gsIC9bXFxcXFxcW1xcXVxcL3t9KCkqKz8uJHxeLV0vZywgJ1xcXFwkJicpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICBpZiAoIShtYXRjaCA9IHBhcnNlci5leGVjKGRhdGUpKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgY3RvckFyZ3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZUluZGV4OyBpKyspIHtcbiAgICAgIGxldCBtYXRjaFZhbCA9IG1hdGNoW2ldO1xuICAgICAgbGV0IGluZGV4RW50cnk6IGFueSA9IGluZGV4TWFwW2ldO1xuICAgICAgaWYgKHRoaXMuaXNMaXN0KGluZGV4RW50cnkpKSB7IC8vIGZvciBhLCBuIG9yIE5cbiAgICAgICAgbGV0IHBsYWNlaG9sZGVyQ2hhciA9IGluZGV4RW50cnlbMF07XG4gICAgICAgIGxldCBtYXBFbnRyeSA9IHRoaXMucGFyc2VEYXRlTWFwW3BsYWNlaG9sZGVyQ2hhcl07XG4gICAgICAgIGxldCBjdG9ySW5kZXggPSBtYXBFbnRyeVswXTtcbiAgICAgICAgbGV0IHZhbExpc3QgPSBpbmRleEVudHJ5WzFdIHx8IG1hcEVudHJ5WzFdO1xuICAgICAgICBsZXQgbGlzdFZhbHVlID0gdGhpcy5maW5kKHZhbExpc3QsXG4gICAgICAgICAgKHY6IGFueSwgaW5kZXg6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRzV2l0aChtYXRjaFZhbC50b0xvd2VyQ2FzZSgpLCB2LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxpc3RWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXJDaGFyID09ICdhJyB8fCBwbGFjZWhvbGRlckNoYXIgPT0gJ0EnKSB7XG4gICAgICAgICAgY3RvckFyZ3NbY3RvckluZGV4XSArPSBsaXN0VmFsdWUgKiAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdG9yQXJnc1tjdG9ySW5kZXhdID0gbGlzdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluZGV4RW50cnkpIHsgLy8gZm9yIG51bWVyaWMgdmFsdWVzICh5SG1NcylcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChtYXRjaFZhbCk7XG4gICAgICAgIGxldCBtYXBFbnRyeSA9IHRoaXMucGFyc2VEYXRlTWFwW2luZGV4RW50cnldO1xuICAgICAgICBpZiAodGhpcy5pc0xpc3QobWFwRW50cnkpKSB7XG4gICAgICAgICAgY3RvckFyZ3NbbWFwRW50cnlbMF1dICs9IHZhbHVlIC0gbWFwRW50cnlbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3RvckFyZ3NbbWFwRW50cnldICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkID0gbmV3IERhdGUoY3RvckFyZ3NbMF0sIGN0b3JBcmdzWzFdLCBjdG9yQXJnc1syXSwgY3RvckFyZ3NbM10sIGN0b3JBcmdzWzRdLFxuICAgICAgY3RvckFyZ3NbNV0sIGN0b3JBcmdzWzZdKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIHRvZGF5KCk6IERhdGUge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICB9XG5cbiAgcGFyc2UodmFsdWU6IGFueSk6IERhdGUgfCBudWxsIHtcbiAgICBsZXQgdGltZXN0YW1wID0gdHlwZW9mIHZhbHVlID09ICdudW1iZXInID8gdmFsdWUgOiBEYXRlLnBhcnNlKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4odGltZXN0YW1wKSA/IG51bGwgOiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICB9XG5cbiAgZ2V0WWVhcihkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9XG5cbiAgZ2V0TW9udGgoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfVxuXG4gIGdldERhdGUoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuICB9XG5cbiAgZ2V0SG91cnMoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbiAgfVxuXG4gIGdldE1pbnV0ZXMoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xuICB9XG5cbiAgZ2V0U2Vjb25kcyhkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gIH1cblxuICBjcmVhdGVEYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyLFxuICAgIGhvdXJzOiBudW1iZXIsIG1pbnV0ZXM6IG51bWJlciwgc2Vjb25kczogbnVtYmVyKTogRGF0ZSB7XG4gICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgbW9udGggYW5kIGRhdGUgKGV4Y2VwdCB1cHBlciBib3VuZCBvbiBkYXRlIHdoaWNoIHdlIGhhdmUgdG8gY2hlY2sgYWZ0ZXJcbiAgICAvLyBjcmVhdGluZyB0aGUgRGF0ZSkuXG4gICAgaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExIHx8IGRhdGUgPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZGF0ZSB3YXNuJ3QgYWJvdmUgdGhlIHVwcGVyIGJvdW5kIGZvciB0aGUgbW9udGgsIGNhdXNpbmcgdGhlIG1vbnRoIHRvXG4gICAgLy8gb3ZlcmZsb3cuXG4gICAgaWYgKHJlc3VsdC5nZXRNb250aCgpICE9IG1vbnRoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY2xvbmUoZGF0ZTogRGF0ZSk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUodGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSksXG4gICAgICB0aGlzLmdldEhvdXJzKGRhdGUpLCB0aGlzLmdldE1pbnV0ZXMoZGF0ZSksIHRoaXMuZ2V0U2Vjb25kcyhkYXRlKSk7XG4gIH1cblxuICBnZXROdW1EYXlzSW5Nb250aChkYXRlOiBEYXRlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXRlKHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coXG4gICAgICB0aGlzLmdldFllYXIoZGF0ZSksIHRoaXMuZ2V0TW9udGgoZGF0ZSkgKyAxLCAwLCAwLCAwLCAwKSk7XG4gIH1cblxuICBhZGRDYWxlbmRhclllYXJzKGRhdGU6IERhdGUsIHllYXJzOiBudW1iZXIpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDYWxlbmRhck1vbnRocyhkYXRlLCB5ZWFycyAqIDEyKTtcbiAgfVxuXG4gIGFkZENhbGVuZGFyTW9udGhzKGRhdGU6IERhdGUsIG1vbnRoczogbnVtYmVyKTogRGF0ZSB7XG4gICAgbGV0IG5ld0RhdGUgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KFxuICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgbW9udGhzLCB0aGlzLmdldERhdGUoZGF0ZSksIHRoaXMuZ2V0SG91cnMoZGF0ZSksXG4gICAgICB0aGlzLmdldE1pbnV0ZXMoZGF0ZSksIHRoaXMuZ2V0U2Vjb25kcyhkYXRlKSk7XG5cbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIHdpbmQgdXAgaW4gdGhlIHdyb25nIG1vbnRoIGlmIHRoZSBvcmlnaW5hbCBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gdGhlIG5ld1xuICAgIC8vIG1vbnRoLiBJbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBnbyB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIGRlc2lyZWQgbW9udGguXG4gICAgLy8gTm90ZTogdGhlIGFkZGl0aW9uYWwgKyAxMiAlIDEyIGVuc3VyZXMgd2UgZW5kIHVwIHdpdGggYSBwb3NpdGl2ZSBudW1iZXIsIHNpbmNlIEpTICUgZG9lc24ndFxuICAgIC8vIGd1YXJhbnRlZSB0aGlzLlxuICAgIGlmICh0aGlzLmdldE1vbnRoKG5ld0RhdGUpICE9ICgodGhpcy5nZXRNb250aChkYXRlKSArIG1vbnRocykgJSAxMiArIDEyKSAlIDEyKSB7XG4gICAgICBuZXdEYXRlID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh0aGlzLmdldFllYXIobmV3RGF0ZSksIHRoaXMuZ2V0TW9udGgobmV3RGF0ZSksIDAsXG4gICAgICAgIHRoaXMuZ2V0SG91cnMobmV3RGF0ZSksIHRoaXMuZ2V0TWludXRlcyhuZXdEYXRlKSwgdGhpcy5nZXRTZWNvbmRzKG5ld0RhdGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuXG4gIGFkZENhbGVuZGFyRGF5cyhkYXRlOiBEYXRlLCBkYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgIHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSwgdGhpcy5nZXREYXRlKGRhdGUpICsgZGF5cyxcbiAgICAgIHRoaXMuZ2V0SG91cnMoZGF0ZSksIHRoaXMuZ2V0TWludXRlcyhkYXRlKSwgdGhpcy5nZXRTZWNvbmRzKGRhdGUpKTtcbiAgfVxuXG4gIGFkZENhbGVuZGFySG91cnMoZGF0ZTogRGF0ZSwgaG91cnM6IG51bWJlcik6IERhdGUge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KFxuICAgICAgdGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSksXG4gICAgICB0aGlzLmdldEhvdXJzKGRhdGUpICsgaG91cnMsIHRoaXMuZ2V0TWludXRlcyhkYXRlKSwgdGhpcy5nZXRTZWNvbmRzKGRhdGUpKTtcbiAgfVxuXG4gIGFkZENhbGVuZGFyTWludXRlcyhkYXRlOiBEYXRlLCBtaW51dGVzOiBudW1iZXIpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyhcbiAgICAgIHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSwgdGhpcy5nZXREYXRlKGRhdGUpLFxuICAgICAgdGhpcy5nZXRIb3VycyhkYXRlKSwgdGhpcy5nZXRNaW51dGVzKGRhdGUpICsgbWludXRlcywgdGhpcy5nZXRTZWNvbmRzKGRhdGUpKTtcbiAgfVxuICBnZXRJU09EYXRlU3RyaW5nKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBbXG4gICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICB0aGlzLl8yZGlnaXQoZGF0ZS5nZXRVVENNb250aCgpICsgMSksXG4gICAgICB0aGlzLl8yZGlnaXQoZGF0ZS5nZXRVVENEYXRlKCkpXG4gICAgXS5qb2luKCctJyk7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhIGRhdGUgYnV0IGFsbG93cyB0aGUgbW9udGggYW5kIGRhdGUgdG8gb3ZlcmZsb3cuICovXG4gIHByaXZhdGUgX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIsXG4gICAgaG91cnM6IG51bWJlciwgbWludXRlczogbnVtYmVyLCBzZWNvbmRzOiBudW1iZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCBmb3IgdGhlIGZhY3QgdGhhdCBKUyBuYXRpdmUgRGF0ZSB0cmVhdHMgeWVhcnMgaW4gcmFuZ2UgWzAsIDk5XSBhc1xuICAgIC8vIGFiYnJldmlhdGlvbnMgZm9yIDE5eHguXG4gICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICByZXN1bHQuc2V0RnVsbFllYXIodGhpcy5nZXRZZWFyKHJlc3VsdCkgLSAxOTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYWRzIGEgbnVtYmVyIHRvIG1ha2UgaXQgdHdvIGRpZ2l0cy5cbiAgICogQHBhcmFtIG4gVGhlIG51bWJlciB0byBwYWQuXG4gICAqIEByZXR1cm5zIFRoZSBwYWRkZWQgbnVtYmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBfMmRpZ2l0KG46IG51bWJlcikge1xuICAgIHJldHVybiAoJzAwJyArIG4pLnNsaWNlKC0yKTtcbiAgfVxuXG4gIGNvbXBhcmVEYXRlKGZpcnN0OiBEYXRlLCBzZWNvbmQ6IERhdGUpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFllYXIoZmlyc3QpIC0gdGhpcy5nZXRZZWFyKHNlY29uZCkgfHxcbiAgICAgIHRoaXMuZ2V0TW9udGgoZmlyc3QpIC0gdGhpcy5nZXRNb250aChzZWNvbmQpIHx8XG4gICAgICB0aGlzLmdldERhdGUoZmlyc3QpIC0gdGhpcy5nZXREYXRlKHNlY29uZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aCBmb3IgdGhlIGdpdmVuIGRhdGUncyBtb250aC5cbiAgICovXG4gIGdldEZpcnN0RGF0ZU9mV2VlayhkYXRlOiBEYXRlLCBmaXJzdERheU9mV2VlazogbnVtYmVyKSB7XG4gICAgbGV0IGRheTogbnVtYmVyID0gZGF0ZS5nZXREYXRlKCkgLSAoKDcgKyBkYXRlLmdldERheSgpIC0gZmlyc3REYXlPZldlZWspICUgNyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXksIGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggZm9yIHRoZSBnaXZlbiBkYXRlJ3MgbW9udGguXG4gICAqL1xuICBnZXRGaXJzdERhdGVPZk1vbnRoKGRhdGU6IERhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoZSBtb250aCBmb3IgdGhlIGdpdmVuIGRhdGUncyBtb250aC5cbiAgICovXG4gIGdldE51bWJlck9mRGF5c0luTW9udGgoZGF0ZTogRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDApLmdldERhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJiaXRyYXJ5IGRhdGUgaW4gdGhlIG1vbnRoIGFmdGVyIHRoZSBnaXZlbiBkYXRlJ3MgbW9udGguXG4gICAqL1xuICBnZXREYXRlSW5OZXh0TW9udGgoZGF0ZTogRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDEsXG4gICAgICBkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYXJiaXRyYXJ5IGRhdGUgaW4gdGhlIG1vbnRoIGJlZm9yZSB0aGUgZ2l2ZW4gZGF0ZSdzIG1vbnRoLlxuICAgKi9cbiAgZ2V0RGF0ZUluUHJldmlvdXNNb250aChkYXRlOiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpIC0gMSwgMSxcbiAgICAgIGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciB0d28gZGF0ZXMgaGF2ZSB0aGUgc2FtZSB5ZWFyLlxuICAgKi9cbiAgaXNTYW1lWWVhcihkMTogRGF0ZSwgZDI6IERhdGUpIHtcbiAgICByZXR1cm4gZDEgJiYgZDIgJiYgZDEuZ2V0RnVsbFllYXIoKSA9PT0gZDIuZ2V0RnVsbFllYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdHdvIGRhdGVzIGhhdmUgdGhlIHNhbWUgbW9udGggYW5kIHllYXIuXG4gICAqL1xuICBpc1NhbWVNb250aEFuZFllYXIoZDE6IERhdGUsIGQyOiBEYXRlKSB7XG4gICAgcmV0dXJuIGQxICYmIGQyICYmIGQxLmdldEZ1bGxZZWFyKCkgPT09IGQyLmdldEZ1bGxZZWFyKCkgJiYgZDEuZ2V0TW9udGgoKSA9PT0gZDIuZ2V0TW9udGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdHdvIGRhdGVzIGFyZSB0aGUgc2FtZSBkYXkgKG5vdCBub3QgbmVjZXNhcmlseSB0aGUgc2FtZSB0aW1lKS5cbiAgICovXG4gIGlzU2FtZURheShkMTogRGF0ZSwgZDI6IERhdGUpIHtcbiAgICByZXR1cm4gZDEgJiYgZDIgJiYgZDEuZ2V0RGF0ZSgpID09IGQyLmdldERhdGUoKSAmJiB0aGlzLmlzU2FtZU1vbnRoQW5kWWVhcihkMSwgZDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciB0d28gZGF0ZXMgYXJlIHRoZSBzYW1lIGhvdXJzLlxuICAgKi9cbiAgaXNTYW1lSG91cihkMTogRGF0ZSwgZDI6IERhdGUpIHtcbiAgICByZXR1cm4gZDEgJiYgZDIgJiYgZDEuZ2V0SG91cnMoKSA9PSBkMi5nZXRIb3VycygpICYmIHRoaXMuaXNTYW1lRGF5KGQxLCBkMik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIHR3byBkYXRlcyBhcmUgdGhlIHNhbWUgbWludXRlcy5cbiAgICovXG4gIGlzU2FtZU1pbnV0ZShkMTogRGF0ZSwgZDI6IERhdGUpIHtcbiAgICByZXR1cm4gZDEgJiYgZDIgJiYgZDEuZ2V0TWludXRlcygpID09IGQyLmdldE1pbnV0ZXMoKSAmJiB0aGlzLmlzU2FtZUhvdXIoZDEsIGQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgYSBkYXRlIGlzIGluIHRoZSBtb250aCBpbW1lZGlhdGVseSBhZnRlciBzb21lIGRhdGUuXG4gICAqIEBwYXJhbSBzdGFydERhdGUgVGhlIGRhdGUgZnJvbSB3aGljaCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0gZW5kRGF0ZSBUaGUgZGF0ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgXG4gICAqL1xuICBpc0luTmV4dE1vbnRoKHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSkge1xuICAgIGxldCBuZXh0TW9udGggPSB0aGlzLmdldERhdGVJbk5leHRNb250aChzdGFydERhdGUpO1xuICAgIHJldHVybiB0aGlzLmlzU2FtZU1vbnRoQW5kWWVhcihuZXh0TW9udGgsIGVuZERhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciBhIGRhdGUgaXMgaW4gdGhlIG1vbnRoIGltbWVkaWF0ZWx5IGJlZm9yZSBzb21lIGRhdGUuXG4gICAqIEBwYXJhbSBzdGFydERhdGUgVGhlIGRhdGUgZnJvbSB3aGljaCB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0gZW5kRGF0ZSBUaGUgZGF0ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgXG4gICAqL1xuICBpc0luUHJldmlvdXNNb250aChzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpIHtcbiAgICBsZXQgcHJldmlvdXNNb250aCA9IHRoaXMuZ2V0RGF0ZUluUHJldmlvdXNNb250aChzdGFydERhdGUpO1xuICAgIHJldHVybiB0aGlzLmlzU2FtZU1vbnRoQW5kWWVhcihlbmREYXRlLCBwcmV2aW91c01vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtaWRwb2ludCBiZXR3ZWVuIHR3byBkYXRlcy5cbiAgICogQHBhcmFtIGQxXG4gICAqIEBwYXJhbSBkMlxuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGdldERhdGVNaWRwb2ludChkMTogRGF0ZSwgZDI6IERhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlQXRNaWRuaWdodCgoZDEuZ2V0VGltZSgpICsgZDIuZ2V0VGltZSgpKSAvIDIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHdlZWsgb2YgdGhlIG1vbnRoIHRoYXQgYSBnaXZlbiBkYXRlIG9jY3VycyBpbi5cbiAgICogQHBhcmFtIGRhdGVcbiAgICogQHJldHVybnMgSW5kZXggb2YgdGhlIHdlZWsgb2YgdGhlIG1vbnRoICh6ZXJvLWJhc2VkKS5cbiAgICovXG4gIGdldFdlZWtPZk1vbnRoKGRhdGU6IERhdGUpIHtcbiAgICBsZXQgZmlyc3REYXlPZk1vbnRoID0gdGhpcy5nZXRGaXJzdERhdGVPZk1vbnRoKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChmaXJzdERheU9mTW9udGguZ2V0RGF5KCkgKyBkYXRlLmdldERhdGUoKSAtIDEpIC8gNyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgd2VlayBvZiB0aGUgeWVhciB0aGF0IGEgZ2l2ZW4gZGF0ZSBvY2N1cnMgaW4uXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSB3ZWVrIGFjY29yZGluZyB0byBJU08tODYwMS5cbiAgICovXG4gIGdldFdlZWtPZlllYXIoZGF0ZTogRGF0ZSkge1xuICAgIC8vIENvcHkgZGF0ZSBzbyBkb24ndCBtb2RpZnkgb3JpZ2luYWxcbiAgICBjb25zdCBkID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKSk7XG4gICAgLy8gU2V0IHRvIG5lYXJlc3QgVGh1cnNkYXk6IGN1cnJlbnQgZGF0ZSArIDQgLSBjdXJyZW50IGRheSBudW1iZXJcbiAgICAvLyBNYWtlIFN1bmRheSdzIGRheSBudW1iZXIgN1xuICAgIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIDQgLSAoZC5nZXRVVENEYXkoKSB8fCA3KSk7XG4gICAgLy8gR2V0IGZpcnN0IGRheSBvZiB5ZWFyXG4gICAgY29uc3QgeWVhclN0YXJ0ID0gbmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSk7XG4gICAgLy8gQ2FsY3VsYXRlIGZ1bGwgd2Vla3MgdG8gbmVhcmVzdCBUaHVyc2RheSBhbmQgcmV0dXJuIHdlZWtOb1xuICAgIHJldHVybiBNYXRoLmNlaWwoKCAoICgrZCAtICt5ZWFyU3RhcnQpIC8gODY0MDAwMDApICsgMSkgLyA3KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbmV3IGRhdGUgaW5jcmVtZW50ZWQgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBtaW51dGVzLiBOdW1iZXIgb2YgbWludXRlcyBjYW4gYmUgbmVnYXRpdmUuXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqIEBwYXJhbSBudW1iZXJPZk1pbnV0ZXNcbiAgICogQHJldHVybnMgXG4gICAqL1xuICBpbmNyZW1lbnRNaW51dGVzKGRhdGU6IERhdGUsIG51bWJlck9mTWludXRlczogbnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSxcbiAgICAgIGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCkgKyBudW1iZXJPZk1pbnV0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBuZXcgZGF0ZSBpbmNyZW1lbnRlZCBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGhvdXJzLiBOdW1iZXIgb2YgaG91cnMgY2FuIGJlIG5lZ2F0aXZlLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcGFyYW0gbnVtYmVyT2ZIb3Vyc1xuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGluY3JlbWVudEhvdXJzKGRhdGU6IERhdGUsIG51bWJlck9mSG91cnM6IG51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksXG4gICAgICBkYXRlLmdldEhvdXJzKCkgKyBudW1iZXJPZkhvdXJzLCBkYXRlLmdldE1pbnV0ZXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIG5ldyBkYXRlIGluY3JlbWVudGVkIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2YgZGF5cy4gTnVtYmVyIG9mIGRheXMgY2FuIGJlIG5lZ2F0aXZlLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcGFyYW0gbnVtYmVyT2ZEYXlzXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgaW5jcmVtZW50RGF5cyhkYXRlOiBEYXRlLCBudW1iZXJPZkRheXM6IG51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkgKyBudW1iZXJPZkRheXMsXG4gICAgICBkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbmV3IGRhdGUgaW5jcmVtZW50ZWQgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBtb250aHMuIE51bWJlciBvZiBtb250aHMgY2FuIGJlIG5lZ2F0aXZlLlxuICAgKiBJZiB0aGUgZGF0ZSBvZiB0aGUgZ2l2ZW4gbW9udGggZG9lcyBub3QgbWF0Y2ggdGhlIHRhcmdldCBtb250aCwgdGhlIGRhdGUgd2lsbCBiZSBzZXQgdG8gdGhlXG4gICAqIGxhc3QgZGF5IG9mIHRoZSBtb250aC5cbiAgICogQHBhcmFtIGRhdGVcbiAgICogQHBhcmFtIG51bWJlck9mTW9udGhzXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgaW5jcmVtZW50TW9udGhzKGRhdGU6IERhdGUsIG51bWJlck9mTW9udGhzOiBudW1iZXIpIHtcbiAgICAvLyBJZiB0aGUgc2FtZSBkYXRlIGluIHRoZSB0YXJnZXQgbW9udGggZG9lcyBub3QgYWN0dWFsbHkgZXhpc3QsIHRoZSBEYXRlIG9iamVjdCB3aWxsXG4gICAgLy8gYXV0b21hdGljYWxseSBhZHZhbmNlICphbm90aGVyKiBtb250aCBieSB0aGUgbnVtYmVyIG9mIG1pc3NpbmcgZGF5cy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IHRyeSB0byBnbyBmcm9tIEphbi4gMzAgdG8gRmViLiAzMCwgeW91J2xsIGVuZCB1cCBvbiBNYXJjaCAyLlxuICAgIC8vIFNvLCB3ZSBjaGVjayBpZiB0aGUgbW9udGggb3ZlcmZsb3dlZCBhbmQgZ28gdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSB0YXJnZXQgbW9udGggaW5zdGVhZC5cbiAgICBsZXQgZGF0ZUluVGFyZ2V0TW9udGggPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIG51bWJlck9mTW9udGhzLCAxLFxuICAgICAgZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSk7XG4gICAgbGV0IG51bWJlck9mRGF5c0luTW9udGggPSB0aGlzLmdldE51bWJlck9mRGF5c0luTW9udGgoZGF0ZUluVGFyZ2V0TW9udGgpO1xuICAgIGlmIChudW1iZXJPZkRheXNJbk1vbnRoIDwgZGF0ZS5nZXREYXRlKCkpIHtcbiAgICAgIGRhdGVJblRhcmdldE1vbnRoLnNldERhdGUobnVtYmVyT2ZEYXlzSW5Nb250aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVJblRhcmdldE1vbnRoLnNldERhdGUoZGF0ZS5nZXREYXRlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlSW5UYXJnZXRNb250aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGludGVnZXIgZGlzdGFuY2UgYmV0d2VlbiB0d28gbW9udGhzLiBUaGlzICpvbmx5KiBjb25zaWRlcnMgdGhlIG1vbnRoIGFuZCB5ZWFyXG4gICAqIHBvcnRpb24gb2YgdGhlIERhdGUgaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRcbiAgICogQHBhcmFtIGVuZFxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgbW9udGhzIGJldHdlZW4gYHN0YXJ0YCBhbmQgYGVuZGAuIElmIGBlbmRgIGlzIGJlZm9yZSBgc3RhcnRgXG4gICAqICAgICBjaHJvbm9sb2dpY2FsbHksIHRoaXMgbnVtYmVyIHdpbGwgYmUgbmVnYXRpdmUuXG4gICAqL1xuICBnZXRNb250aERpc3RhbmNlKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUpIHtcbiAgICByZXR1cm4gKDEyICogKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkpICsgKGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICogQHJldHVybnMgXG4gICAqL1xuICBnZXRMYXN0RGF0ZU9mTW9udGgoZGF0ZTogRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgdGhpcy5nZXROdW1iZXJPZkRheXNJbk1vbnRoKGRhdGUpLFxuICAgICAgZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBkYXRlIGlzIHZhbGlkLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcmV0dXJuICBXaGV0aGVyIHRoZSBkYXRlIGlzIGEgdmFsaWQgRGF0ZS5cbiAgICovXG4gIGlzVmFsaWREYXRlKGRhdGU6IERhdGUpIHtcbiAgICByZXR1cm4gZGF0ZSAhPSBudWxsICYmIGRhdGUuZ2V0VGltZSAmJiAhaXNOYU4oZGF0ZS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBkYXRlJ3MgdGltZSB0byBtaWRuaWdodC5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIHNldERhdGVUaW1lVG9NaWRuaWdodChkYXRlOiBEYXRlKSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZERhdGUoZGF0ZSkpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkYXRlIHdpdGggdGhlIHRpbWUgc2V0IHRvIG1pZG5pZ2h0LlxuICAgKiBEcm9wLWluIHJlcGxhY2VtZW50IGZvciB0d28gZm9ybXMgb2YgdGhlIERhdGUgY29uc3RydWN0b3I6XG4gICAqIDEuIE5vIGFyZ3VtZW50IGZvciBEYXRlIHJlcHJlc2VudGluZyBub3cuXG4gICAqIDIuIFNpbmdsZS1hcmd1bWVudCB2YWx1ZSByZXByZXNlbnRpbmcgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgVW5peCBFcG9jaFxuICAgKiBvciBhIERhdGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiBOZXcgZGF0ZSB3aXRoIHRpbWUgc2V0IHRvIG1pZG5pZ2h0LlxuICAgKi9cbiAgY3JlYXRlRGF0ZUF0TWlkbmlnaHQodmFsdWU6IGFueSkge1xuICAgIGxldCBkYXRlOiBEYXRlO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLnNldERhdGVUaW1lVG9NaWRuaWdodChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBkYXRlIGlzIHdpdGhpbiBhIG1pbiBhbmQgbWF4IHJhbmdlLCBpZ25vcmluZyB0aGUgdGltZSBjb21wb25lbnQuXG4gICAqIElmIG1pbkRhdGUgb3IgbWF4RGF0ZSBhcmUgbm90IGRhdGVzLCB0aGV5IGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcGFyYW0gbWluRGF0ZVxuICAgKiBAcGFyYW0gbWF4RGF0ZVxuICAgKi9cbiAgaXNEYXRlV2l0aGluUmFuZ2UoZGF0ZTogRGF0ZSwgbWluRGF0ZTogRGF0ZSwgbWF4RGF0ZTogRGF0ZSkge1xuICAgIGxldCBkYXRlQXRNaWRuaWdodCA9IHRoaXMuY3JlYXRlRGF0ZUF0TWlkbmlnaHQoZGF0ZSk7XG4gICAgbGV0IG1pbkRhdGVBdE1pZG5pZ2h0ID0gdGhpcy5pc1ZhbGlkRGF0ZShtaW5EYXRlKSA/IHRoaXMuY3JlYXRlRGF0ZUF0TWlkbmlnaHQobWluRGF0ZSkgOiBudWxsO1xuICAgIGxldCBtYXhEYXRlQXRNaWRuaWdodCA9IHRoaXMuaXNWYWxpZERhdGUobWF4RGF0ZSkgPyB0aGlzLmNyZWF0ZURhdGVBdE1pZG5pZ2h0KG1heERhdGUpIDogbnVsbDtcbiAgICByZXR1cm4gKCFtaW5EYXRlQXRNaWRuaWdodCB8fCBtaW5EYXRlQXRNaWRuaWdodCA8PSBkYXRlQXRNaWRuaWdodCkgJiZcbiAgICAgICghbWF4RGF0ZUF0TWlkbmlnaHQgfHwgbWF4RGF0ZUF0TWlkbmlnaHQgPj0gZGF0ZUF0TWlkbmlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGRhdGUgaXMgd2l0aGluIGEgbWluIGFuZCBtYXggcmFuZ2UuXG4gICAqIElmIG1pbkRhdGUgb3IgbWF4RGF0ZSBhcmUgbm90IGRhdGVzLCB0aGV5IGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKiBAcGFyYW0gbWluRGF0ZVxuICAgKiBAcGFyYW0gbWF4RGF0ZVxuICAgKi9cbiAgaXNGdWxsRGF0ZVdpdGhpblJhbmdlKGRhdGU6IERhdGUsIG1pbkRhdGU6IERhdGUsIG1heERhdGU6IERhdGUpIHtcbiAgICBtaW5EYXRlID0gdGhpcy5pc1ZhbGlkRGF0ZShtaW5EYXRlKSA/IG1pbkRhdGUgOiBudWxsO1xuICAgIG1heERhdGUgPSB0aGlzLmlzVmFsaWREYXRlKG1heERhdGUpID8gbWF4RGF0ZSA6IG51bGw7XG4gICAgcmV0dXJuICghbWluRGF0ZSB8fCBtaW5EYXRlIDw9IGRhdGUpICYmXG4gICAgICAoIW1heERhdGUgfHwgbWF4RGF0ZSA+PSBkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbmV3IGRhdGUgaW5jcmVtZW50ZWQgYnkgdGhlIGdpdmVuIG51bWJlciBvZiB5ZWFycy4gTnVtYmVyIG9mIHllYXJzIGNhbiBiZSBuZWdhdGl2ZS5cbiAgICogU2VlIGBpbmNyZW1lbnRNb250aHNgIGZvciBub3RlcyBvbiBvdmVyZmxvdyBmb3Igc3BlY2lmaWMgZGF0ZXMuXG4gICAqIEBwYXJhbSBkYXRlXG4gICAqIEBwYXJhbSBudW1iZXJPZlllYXJzXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgaW5jcmVtZW50WWVhcnMoZGF0ZTogRGF0ZSwgbnVtYmVyT2ZZZWFyczogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50TW9udGhzKGRhdGUsIG51bWJlck9mWWVhcnMgKiAxMik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlZ2VyIGRpc3RhbmNlIGJldHdlZW4gdHdvIHllYXJzLiBUaGlzICpvbmx5KiBjb25zaWRlcnMgdGhlIHllYXIgcG9ydGlvbiBvZiB0aGVcbiAgICogRGF0ZSBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFxuICAgKiBAcGFyYW0gZW5kXG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBtb250aHMgYmV0d2VlbiBgc3RhcnRgIGFuZCBgZW5kYC4gSWYgYGVuZGAgaXMgYmVmb3JlIGBzdGFydGBcbiAgICogICAgIGNocm9ub2xvZ2ljYWxseSwgdGhpcyBudW1iZXIgd2lsbCBiZSBuZWdhdGl2ZS5cbiAgICovXG4gIGdldFllYXJEaXN0YW5jZShzdGFydDogRGF0ZSwgZW5kOiBEYXRlKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFtcHMgYSBkYXRlIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBhIG1heGltdW0gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGUgRGF0ZSB0byBiZSBjbGFtcGVkXG4gICAqIEBwYXJhbSBtaW5EYXRlIE1pbmltdW0gZGF0ZVxuICAgKiBAcGFyYW0gbWF4RGF0ZSBNYXhpbXVtIGRhdGVcbiAgICogQHJldHVyblxuICAgKi9cbiAgY2xhbXBEYXRlKGRhdGU6IERhdGUsIG1pbkRhdGU6IERhdGUsIG1heERhdGU6IERhdGUpIHtcbiAgICBsZXQgYm91bmREYXRlID0gZGF0ZTtcbiAgICBpZiAobWluRGF0ZSAmJiBkYXRlIDwgbWluRGF0ZSkge1xuICAgICAgYm91bmREYXRlID0gbmV3IERhdGUobWluRGF0ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAobWF4RGF0ZSAmJiBkYXRlID4gbWF4RGF0ZSkge1xuICAgICAgYm91bmREYXRlID0gbmV3IERhdGUobWF4RGF0ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmREYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFuZCBwYXJzZXMgdGhlIHRpbWVzdGFtcCBmcm9tIGEgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSBub2RlIE5vZGUgZnJvbSB3aGljaCB0aGUgdGltZXN0YW1wIHdpbGwgYmUgZXh0cmFjdGVkLlxuICAgKiBAcmV0dXJuIFRpbWUgc2luY2UgZXBvY2guXG4gICAqL1xuICBnZXRUaW1lc3RhbXBGcm9tTm9kZShub2RlOiBhbnkpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10aW1lc3RhbXAnKSkge1xuICAgICAgcmV0dXJuIE51bWJlcihub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS10aW1lc3RhbXAnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIG1vbnRoIGlzIHdpdGhpbiBhIG1pbiBhbmQgbWF4IHJhbmdlLCBpZ25vcmluZyB0aGUgZGF0ZSBhbmQgdGltZSBjb21wb25lbnRzLlxuICAgKiBJZiBtaW5EYXRlIG9yIG1heERhdGUgYXJlIG5vdCBkYXRlcywgdGhleSBhcmUgaWdub3JlZC5cbiAgICogQHBhcmFtIGRhdGVcbiAgICogQHBhcmFtIG1pbkRhdGVcbiAgICogQHBhcmFtIG1heERhdGVcbiAgICovXG4gIGlzTW9udGhXaXRoaW5SYW5nZShkYXRlOiBEYXRlLCBtaW5EYXRlOiBEYXRlLCBtYXhEYXRlOiBEYXRlKSB7XG4gICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgcmV0dXJuICghbWluRGF0ZSB8fCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPCB5ZWFyIHx8IG1pbkRhdGUuZ2V0TW9udGgoKSA8PSBtb250aCkgJiZcbiAgICAgICghbWF4RGF0ZSB8fCBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgPiB5ZWFyIHx8IG1heERhdGUuZ2V0TW9udGgoKSA+PSBtb250aCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdHdvIGRhdGVzLlxuICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMgMCBpZiB0aGUgZGF0ZXMgYXJlIGVxdWFsLCBhIG51bWJlciBsZXNzIHRoYW4gMCBpZiB0aGUgZmlyc3QgZGF0ZSBpcyBlYXJsaWVyLFxuICAgKiAgICAgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAgaWYgdGhlIGZpcnN0IGRhdGUgaXMgbGF0ZXIuXG4gICAqL1xuICBjb21wYXJlRGF0ZUFuZFRpbWUoZmlyc3Q6IERhdGUsIHNlY29uZDogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0WWVhcihmaXJzdCkgLSB0aGlzLmdldFllYXIoc2Vjb25kKSB8fFxuICAgICAgdGhpcy5nZXRNb250aChmaXJzdCkgLSB0aGlzLmdldE1vbnRoKHNlY29uZCkgfHxcbiAgICAgIHRoaXMuZ2V0RGF0ZShmaXJzdCkgLSB0aGlzLmdldERhdGUoc2Vjb25kKSB8fFxuICAgICAgdGhpcy5nZXRIb3VycyhmaXJzdCkgLSB0aGlzLmdldERhdGUoc2Vjb25kKSB8fFxuICAgICAgdGhpcy5nZXRNaW51dGVzKGZpcnN0KSAtIHRoaXMuZ2V0RGF0ZShzZWNvbmQpIHx8XG4gICAgICB0aGlzLmdldFNlY29uZHMoZmlyc3QpIC0gdGhpcy5nZXREYXRlKHNlY29uZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gICAqICAgICBOdWxsIGRhdGVzIGFyZSBjb25zaWRlcmVkIGVxdWFsIHRvIG90aGVyIG51bGwgZGF0ZXMuXG4gICAqL1xuICBzYW1lRGF0ZShmaXJzdDogRGF0ZSB8IG51bGwsIHNlY29uZDogRGF0ZSB8IG51bGwpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmlyc3QgJiYgc2Vjb25kID8gIXRoaXMuY29tcGFyZURhdGUoZmlyc3QsIHNlY29uZCkgOiBmaXJzdCA9PSBzZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgZGF0ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gICAqICAgICBOdWxsIGRhdGVzIGFyZSBjb25zaWRlcmVkIGVxdWFsIHRvIG90aGVyIG51bGwgZGF0ZXMuXG4gICAqL1xuICBzYW1lRGF0ZUFuZFRpbWUoZmlyc3Q6IERhdGUgfCBudWxsLCBzZWNvbmQ6IERhdGUgfCBudWxsKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZpcnN0ICYmIHNlY29uZCA/ICF0aGlzLmNvbXBhcmVEYXRlQW5kVGltZShmaXJzdCwgc2Vjb25kKSA6IGZpcnN0ID09IHNlY29uZDtcbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBhbmltYXRlLFxuICBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEsXG4gIGtleWZyYW1lcyxcbiAgc3RhdGUsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uLFxuICB0cmlnZ2VyLFxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBmYWRlcyBpbiB0aGUgYmFja2dyb3VuZCBjb2xvciBhbmQgdGV4dCBjb250ZW50IG9mIHRoZVxuICogc2VsZWN0J3Mgb3B0aW9ucy4gSXQgaXMgdGltZSBkZWxheWVkIHRvIG9jY3VyIDEwMG1zIGFmdGVyIHRoZSBvdmVybGF5XG4gKiBwYW5lbCBoYXMgdHJhbnNmb3JtZWQgaW4uXG4gKi9cbmV4cG9ydCBjb25zdCBmYWRlSW5Db250ZW50OiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEgPSB0cmlnZ2VyKCdmYWRlSW5Db250ZW50JywgW1xuICBzdGF0ZSgnc2hvd2luZycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gIHRyYW5zaXRpb24oJ3ZvaWQgPT4gc2hvd2luZycsIFtcbiAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgYW5pbWF0ZShgMTUwbXMgMTAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMilgKVxuICBdKVxuXSk7XG5cbmV4cG9ydCBjb25zdCBzbGlkZUNhbGVuZGFyOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEgPSB0cmlnZ2VyKCdzbGlkZUNhbGVuZGFyJywgW1xuICB0cmFuc2l0aW9uKCcqID0+IGxlZnQnLCBbXG4gICAgYW5pbWF0ZSgxODAsIGtleWZyYW1lcyhbXG4gICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknLCBvZmZzZXQ6IDAuNSB9KSxcbiAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknLCBvZmZzZXQ6IDAuNTEgfSksXG4gICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvZmZzZXQ6IDEgfSlcbiAgICBdKSlcbiAgXSksXG4gIHRyYW5zaXRpb24oJyogPT4gcmlnaHQnLCBbXG4gICAgYW5pbWF0ZSgxODAsIGtleWZyYW1lcyhbXG4gICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwMCUpJywgb2Zmc2V0OiAwLjUgfSksXG4gICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMTAwJSknLCBvZmZzZXQ6IDAuNTEgfSksXG4gICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLCBvZmZzZXQ6IDEgfSlcbiAgICBdKSlcbiAgXSlcbl0pO1xuIiwiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgRE9XTl9BUlJPVyxcbiAgRU5ELFxuICBFTlRFUixcbiAgSE9NRSxcbiAgTEVGVF9BUlJPVyxcbiAgUEFHRV9ET1dOLFxuICBQQUdFX1VQLFxuICBSSUdIVF9BUlJPVyxcbiAgVVBfQVJST1dcbn0gZnJvbSAnLi4vY29yZS9rZXlib2FyZC9rZXljb2Rlcyc7XG5pbXBvcnQgeyBEYXRlTG9jYWxlIH0gZnJvbSAnLi9kYXRlLWxvY2FsZSc7XG5pbXBvcnQgeyBEYXRlVXRpbCB9IGZyb20gJy4vZGF0ZS11dGlsJztcbmltcG9ydCB7IHNsaWRlQ2FsZW5kYXIgfSBmcm9tICcuL2RhdGVwaWNrZXItYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUgfSBmcm9tICcuLi9jb3JlJztcblxuXG4vKipcbiAqIEEgY2FsZW5kYXIgdGhhdCBpcyB1c2VkIGFzIHBhcnQgb2YgdGhlIGRhdGVwaWNrZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItY2FsZW5kYXInLFxuICB0ZW1wbGF0ZVVybDogJ2NhbGVuZGFyLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnY2FsZW5kYXIuc2NzcyddLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5tZDItY2FsZW5kYXJdJzogJ3RydWUnLFxuICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAnKGtleWRvd24pJzogJ19oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duKCRldmVudCknLFxuICB9LFxuICBhbmltYXRpb25zOiBbc2xpZGVDYWxlbmRhcl0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJDYWxlbmRhciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBXZWVrLW51bWJlciBzaG91bGQgYmUgZGlzcGxheWVkICovXG4gIEBJbnB1dCgpIGRpc3BsYXlXZWVrOiBib29sZWFuO1xuXG4gIEBJbnB1dCgpIHR5cGU6ICdkYXRlJyB8ICd0aW1lJyB8ICdtb250aCcgfCAnZGF0ZXRpbWUnID0gJ2RhdGUnO1xuXG4gIC8qKiBBIGRhdGUgcmVwcmVzZW50aW5nIHRoZSBwZXJpb2QgKG1vbnRoIG9yIHllYXIpIHRvIHN0YXJ0IHRoZSBjYWxlbmRhciBpbi4gKi9cbiAgQElucHV0KCkgc3RhcnRBdDogRGF0ZTtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHN0YXJ0ZWQgaW4gbW9udGggb3IgeWVhciB2aWV3LiAqL1xuICBASW5wdXQoKSBzdGFydFZpZXc6ICdjbG9jaycgfCAnbW9udGgnIHwgJ3llYXInID0gJ21vbnRoJztcblxuICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xuICBASW5wdXQoKSBzZWxlY3RlZDogRGF0ZTtcblxuICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICBASW5wdXQoKSBtaW5EYXRlOiBEYXRlO1xuXG4gIC8qKiBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuICovXG4gIEBJbnB1dCgpIG1heERhdGU6IERhdGU7XG5cbiAgQElucHV0KCkgdGltZUludGVydmFsOiBudW1iZXIgPSAxO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRGF0ZSkgPT4gYm9vbGVhbjtcblxuICAvKiogRW1pdHMgd2hlbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUgY2hhbmdlcy4gKi9cbiAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gIC8qKiBEYXRlIGZpbHRlciBmb3IgdGhlIG1vbnRoIGFuZCB5ZWFyIHZpZXdzLiAqL1xuICBfZGF0ZUZpbHRlckZvclZpZXdzID0gKGRhdGU6IERhdGUpID0+IHtcbiAgICByZXR1cm4gISFkYXRlICYmXG4gICAgICAoIXRoaXMuZGF0ZUZpbHRlciB8fCB0aGlzLmRhdGVGaWx0ZXIoZGF0ZSkpICYmXG4gICAgICAoIXRoaXMubWluRGF0ZSB8fCB0aGlzLl91dGlsLmNvbXBhcmVEYXRlKGRhdGUsIHRoaXMubWluRGF0ZSkgPj0gMCkgJiZcbiAgICAgICghdGhpcy5tYXhEYXRlIHx8IHRoaXMuX3V0aWwuY29tcGFyZURhdGUoZGF0ZSwgdGhpcy5tYXhEYXRlKSA8PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhY3RpdmUgZGF0ZS4gVGhpcyBkZXRlcm1pbmVzIHdoaWNoIHRpbWUgcGVyaW9kIGlzIHNob3duIGFuZCB3aGljaCBkYXRlIGlzXG4gICAqIGhpZ2hsaWdodGVkIHdoZW4gdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICovXG4gIGdldCBfYWN0aXZlRGF0ZSgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX2NsYW1wZWRBY3RpdmVEYXRlOyB9XG4gIHNldCBfYWN0aXZlRGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGxldCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGU7XG4gICAgdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUgPSB0aGlzLl91dGlsLmNsYW1wRGF0ZSh2YWx1ZSwgdGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGUpO1xuICAgIGlmIChvbGRBY3RpdmVEYXRlICYmIHRoaXMuX2NsYW1wZWRBY3RpdmVEYXRlICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSAnbW9udGgnICYmXG4gICAgICAhdGhpcy5fdXRpbC5pc1NhbWVNb250aEFuZFllYXIob2xkQWN0aXZlRGF0ZSwgdGhpcy5fY2xhbXBlZEFjdGl2ZURhdGUpKSB7XG4gICAgICBpZiAodGhpcy5fdXRpbC5pc0luTmV4dE1vbnRoKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2NsYW1wZWRBY3RpdmVEYXRlKSkge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RhdGUoJ3JpZ2h0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3RhdGUoJ2xlZnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfY2xhbXBlZEFjdGl2ZURhdGU6IERhdGU7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIGluIG1vbnRoIHZpZXcuICovXG4gIF9jdXJyZW50VmlldzogJ2Nsb2NrJyB8ICdtb250aCcgfCAneWVhcicgPSAnbW9udGgnO1xuICBfY2xvY2tWaWV3OiAnaG91cicgfCAnbWludXRlJyA9ICdob3VyJztcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGUgY3VycmVudCBjYWxlbmRhciB2aWV3LiAqL1xuICBnZXQgX3llYXJMYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGUuZ2V0WWVhck5hbWUodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cblxuICBnZXQgX21vbnRoWWVhckxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSAnbW9udGgnID8gdGhpcy5fbG9jYWxlLmdldE1vbnRoTGFiZWwodGhpcy5fYWN0aXZlRGF0ZSkgOlxuICAgICAgdGhpcy5fbG9jYWxlLmdldFllYXJOYW1lKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG5cbiAgZ2V0IF9kYXRlTGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlLmdldERhdGVMYWJlbCh0aGlzLl9hY3RpdmVEYXRlKTtcbiAgfVxuXG4gIGdldCBfaG91cnNMYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAoJzAnICsgdGhpcy5fbG9jYWxlLmdldEhvdXJzTGFiZWwodGhpcy5fYWN0aXZlRGF0ZSkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIGdldCBfbWludXRlc0xhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICgnMCcgKyB0aGlzLl9sb2NhbGUuZ2V0TWludXRlc0xhYmVsKHRoaXMuX2FjdGl2ZURhdGUpKS5zbGljZSgtMik7XG4gIH1cblxuICBfY2FsZW5kYXJTdGF0ZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgIHByaXZhdGUgX2xvY2FsZTogRGF0ZUxvY2FsZSwgcHJpdmF0ZSBfdXRpbDogRGF0ZVV0aWwpIHtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5zdGFydEF0IHx8IHRoaXMuX3V0aWwudG9kYXkoKTtcbiAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSAnbW9udGgnKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9ICd5ZWFyJztcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9ICdjbG9jayc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gdGhpcy5zdGFydFZpZXcgfHwgJ21vbnRoJztcbiAgICB9XG4gIH1cblxuICAvKiogSGFuZGxlcyBkYXRlIHNlbGVjdGlvbiBpbiB0aGUgbW9udGggdmlldy4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHlwZSA9PSAnZGF0ZScpIHtcbiAgICAgIGlmICghdGhpcy5fdXRpbC5zYW1lRGF0ZShkYXRlLCB0aGlzLnNlbGVjdGVkKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoZGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgdGhpcy5fY3VycmVudFZpZXcgPSAnY2xvY2snO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBIYW5kbGVzIG1vbnRoIHNlbGVjdGlvbiBpbiB0aGUgeWVhciB2aWV3LiAqL1xuICBfbW9udGhTZWxlY3RlZChtb250aDogRGF0ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnR5cGUgPT0gJ21vbnRoJykge1xuICAgICAgaWYgKCF0aGlzLl91dGlsLmlzU2FtZU1vbnRoQW5kWWVhcihtb250aCwgdGhpcy5zZWxlY3RlZCkpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuX3V0aWwuZ2V0Rmlyc3REYXRlT2ZNb250aChtb250aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbW9udGg7XG4gICAgICB0aGlzLl9jdXJyZW50VmlldyA9ICdtb250aCc7XG4gICAgICB0aGlzLl9jbG9ja1ZpZXcgPSAnaG91cic7XG4gICAgfVxuICB9XG5cbiAgX3RpbWVTZWxlY3RlZChkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2Nsb2NrVmlldyAhPT0gJ21pbnV0ZScpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBkYXRlO1xuICAgICAgdGhpcy5fY2xvY2tWaWV3ID0gJ21pbnV0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fdXRpbC5zYW1lRGF0ZUFuZFRpbWUoZGF0ZSwgdGhpcy5zZWxlY3RlZCkpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9vbkFjdGl2ZURhdGVDaGFuZ2UoZGF0ZTogRGF0ZSkge1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBkYXRlO1xuICB9XG5cbiAgX3llYXJDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gJ3llYXInO1xuICB9XG4gIF9kYXRlQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9ICdtb250aCc7XG4gIH1cblxuICBfaG91cnNDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gJ2Nsb2NrJztcbiAgICB0aGlzLl9jbG9ja1ZpZXcgPSAnaG91cic7XG4gIH1cbiAgX21pbnV0ZXNDbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gJ2Nsb2NrJztcbiAgICB0aGlzLl9jbG9ja1ZpZXcgPSAnbWludXRlJztcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHVzZXIgY2xpY2tzIG9uIHRoZSBwcmV2aW91cyBidXR0b24uICovXG4gIF9wcmV2aW91c0NsaWNrZWQoKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX2N1cnJlbnRWaWV3ID09PSAnbW9udGgnID9cbiAgICAgIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgLTEpIDpcbiAgICAgIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gIH1cblxuICAvKiogSGFuZGxlcyB1c2VyIGNsaWNrcyBvbiB0aGUgbmV4dCBidXR0b24uICovXG4gIF9uZXh0Q2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fY3VycmVudFZpZXcgPT09ICdtb250aCcgP1xuICAgICAgdGhpcy5fdXRpbC5hZGRDYWxlbmRhck1vbnRocyh0aGlzLl9hY3RpdmVEYXRlLCAxKSA6XG4gICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gIH1cblxuICAvKiogV2hldGhlciB0aGUgcHJldmlvdXMgcGVyaW9kIGJ1dHRvbiBpcyBlbmFibGVkLiAqL1xuICBfcHJldmlvdXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5taW5EYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLm1pbkRhdGUgfHwgIXRoaXMuX2lzU2FtZVZpZXcodGhpcy5fYWN0aXZlRGF0ZSwgdGhpcy5taW5EYXRlKTtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHRoZSBuZXh0IHBlcmlvZCBidXR0b24gaXMgZW5hYmxlZC4gKi9cbiAgX25leHRFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5tYXhEYXRlIHx8ICF0aGlzLl9pc1NhbWVWaWV3KHRoaXMuX2FjdGl2ZURhdGUsIHRoaXMubWF4RGF0ZSk7XG4gIH1cblxuICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keS4gKi9cbiAgX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBUT0RPKG1tYWxlcmJhKTogV2UgY3VycmVudGx5IGFsbG93IGtleWJvYXJkIG5hdmlnYXRpb24gdG8gZGlzYWJsZWQgZGF0ZXMsIGJ1dCBqdXN0IHByZXZlbnRcbiAgICAvLyBkaXNhYmxlZCBvbmVzIGZyb20gYmVpbmcgc2VsZWN0ZWQuIFRoaXMgbWF5IG5vdCBiZSBpZGVhbCwgd2Ugc2hvdWxkIGxvb2sgaW50byB3aGV0aGVyXG4gICAgLy8gbmF2aWdhdGlvbiBzaG91bGQgc2tpcCBvdmVyIGRpc2FibGVkIGRhdGVzLCBhbmQgaWYgc28sIGhvdyB0byBpbXBsZW1lbnQgdGhhdCBlZmZpY2llbnRseS5cbiAgICBpZiAodGhpcy5fY3VycmVudFZpZXcgPT09ICdtb250aCcpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25Jbk1vbnRoVmlldyhldmVudCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50VmlldyA9PT0gJ3llYXInKSB7XG4gICAgICB0aGlzLl9oYW5kbGVDYWxlbmRhckJvZHlLZXlkb3duSW5ZZWFyVmlldyhldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd25JbkNsb2NrVmlldyhldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIHR3byBkYXRlcyByZXByZXNlbnQgdGhlIHNhbWUgdmlldyBpbiB0aGUgY3VycmVudCB2aWV3IG1vZGUgKG1vbnRoIG9yIHllYXIpLiAqL1xuICBwcml2YXRlIF9pc1NhbWVWaWV3KGRhdGUxOiBEYXRlLCBkYXRlMjogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlldyA9PT0gJ21vbnRoJyA/XG4gICAgICB0aGlzLl91dGlsLmdldFllYXIoZGF0ZTEpID09IHRoaXMuX3V0aWwuZ2V0WWVhcihkYXRlMikgJiZcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZTEpID09IHRoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZTIpIDpcbiAgICAgIHRoaXMuX3V0aWwuZ2V0WWVhcihkYXRlMSkgPT0gdGhpcy5fdXRpbC5nZXRZZWFyKGRhdGUyKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cbiAgcHJpdmF0ZSBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluTW9udGhWaWV3KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl91dGlsLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl91dGlsLmFkZENhbGVuZGFyRGF5cyh0aGlzLl9hY3RpdmVEYXRlLCAtNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fdXRpbC5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSwgNyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIT01FOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fdXRpbC5hZGRDYWxlbmRhckRheXModGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gdGhpcy5fdXRpbC5nZXREYXRlKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVORDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJEYXlzKHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgKHRoaXMuX3V0aWwuZ2V0TnVtRGF5c0luTW9udGgodGhpcy5fYWN0aXZlRGF0ZSkgLVxuICAgICAgICAgICAgdGhpcy5fdXRpbC5nZXREYXRlKHRoaXMuX2FjdGl2ZURhdGUpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQUdFX1VQOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gZXZlbnQuYWx0S2V5ID9cbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyWWVhcnModGhpcy5fYWN0aXZlRGF0ZSwgLTEpIDpcbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBR0VfRE9XTjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGV2ZW50LmFsdEtleSA/XG4gICAgICAgICAgdGhpcy5fdXRpbC5hZGRDYWxlbmRhclllYXJzKHRoaXMuX2FjdGl2ZURhdGUsIDEpIDpcbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIGlmICh0aGlzLl9kYXRlRmlsdGVyRm9yVmlld3ModGhpcy5fYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLl9kYXRlU2VsZWN0ZWQodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvbid0IHByZXZlbnQgZGVmYXVsdCBvciBmb2N1cyBhY3RpdmUgY2VsbCBvbiBrZXlzIHRoYXQgd2UgZG9uJ3QgZXhwbGljaXRseSBoYW5kbGUuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHVuZXhwZWN0ZWQgZGVmYXVsdCBhY3Rpb25zIHN1Y2ggYXMgZm9ybSBzdWJtaXNzaW9uLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIHllYXIgdmlldy4gKi9cbiAgcHJpdmF0ZSBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluWWVhclZpZXcoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl91dGlsLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9wcmV2TW9udGhJblNhbWVDb2wodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fbmV4dE1vbnRoSW5TYW1lQ29sKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJNb250aHModGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAtdGhpcy5fdXRpbC5nZXRNb250aCh0aGlzLl9hY3RpdmVEYXRlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFTkQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl91dGlsLmFkZENhbGVuZGFyTW9udGhzKHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgMTEgLSB0aGlzLl91dGlsLmdldE1vbnRoKHRoaXMuX2FjdGl2ZURhdGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBR0VfVVA6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPVxuICAgICAgICAgIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCBldmVudC5hbHRLZXkgPyAtMTAgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQUdFX0RPV046XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPVxuICAgICAgICAgIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJZZWFycyh0aGlzLl9hY3RpdmVEYXRlLCBldmVudC5hbHRLZXkgPyAxMCA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgIHRoaXMuX21vbnRoU2VsZWN0ZWQodGhpcy5fYWN0aXZlRGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG9uJ3QgcHJldmVudCBkZWZhdWx0IG9yIGZvY3VzIGFjdGl2ZSBjZWxsIG9uIGtleXMgdGhhdCB3ZSBkb24ndCBleHBsaWNpdGx5IGhhbmRsZS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgdW5leHBlY3RlZCBkZWZhdWx0IGFjdGlvbnMgc3VjaCBhcyBmb3JtIHN1Ym1pc3Npb24uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIG9uIHRoZSBjYWxlbmRhciBib2R5IHdoZW4gY2FsZW5kYXIgaXMgaW4gbW9udGggdmlldy4gKi9cbiAgcHJpdmF0ZSBfaGFuZGxlQ2FsZW5kYXJCb2R5S2V5ZG93bkluQ2xvY2tWaWV3KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fY2xvY2tWaWV3ID09ICdob3VyJyA/XG4gICAgICAgICAgdGhpcy5fdXRpbC5hZGRDYWxlbmRhckhvdXJzKHRoaXMuX2FjdGl2ZURhdGUsIDEpIDpcbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyTWludXRlcyh0aGlzLl9hY3RpdmVEYXRlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl9jbG9ja1ZpZXcgPT0gJ2hvdXInID9cbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFySG91cnModGhpcy5fYWN0aXZlRGF0ZSwgLTEpIDpcbiAgICAgICAgICB0aGlzLl91dGlsLmFkZENhbGVuZGFyTWludXRlcyh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgdGhpcy5fdGltZVNlbGVjdGVkKHRoaXMuX2FjdGl2ZURhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEb24ndCBwcmV2ZW50IGRlZmF1bHQgb3IgZm9jdXMgYWN0aXZlIGNlbGwgb24ga2V5cyB0aGF0IHdlIGRvbid0IGV4cGxpY2l0bHkgaGFuZGxlLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCB1bmV4cGVjdGVkIGRlZmF1bHQgYWN0aW9ucyBzdWNoIGFzIGZvcm0gc3VibWlzc2lvbi5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGF0ZSBmb3IgdGhlIG1vbnRoIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBnaXZlbiBtb250aCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlXG4gICAqIGNhbGVuZGFyIHRhYmxlLlxuICAgKi9cbiAgcHJpdmF0ZSBfcHJldk1vbnRoSW5TYW1lQ29sKGRhdGU6IERhdGUpOiBEYXRlIHtcbiAgICAvLyBEZXRlcm1pbmUgaG93IG1hbnkgbW9udGhzIHRvIGp1bXAgZm9yd2FyZCBnaXZlbiB0aGF0IHRoZXJlIGFyZSAyIGVtcHR5IHNsb3RzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAvLyBvZiBlYWNoIHllYXIuXG4gICAgbGV0IGluY3JlbWVudCA9IHRoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZSkgPD0gNCA/IC01IDpcbiAgICAgICh0aGlzLl91dGlsLmdldE1vbnRoKGRhdGUpID49IDcgPyAtNyA6IC0xMik7XG4gICAgcmV0dXJuIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJNb250aHMoZGF0ZSwgaW5jcmVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRhdGUgZm9yIHRoZSBtb250aCB0aGF0IGNvbWVzIGFmdGVyIHRoZSBnaXZlbiBtb250aCBpbiB0aGUgc2FtZSBjb2x1bW4gaW4gdGhlXG4gICAqIGNhbGVuZGFyIHRhYmxlLlxuICAgKi9cbiAgcHJpdmF0ZSBfbmV4dE1vbnRoSW5TYW1lQ29sKGRhdGU6IERhdGUpOiBEYXRlIHtcbiAgICAvLyBEZXRlcm1pbmUgaG93IG1hbnkgbW9udGhzIHRvIGp1bXAgZm9yd2FyZCBnaXZlbiB0aGF0IHRoZXJlIGFyZSAyIGVtcHR5IHNsb3RzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAvLyBvZiBlYWNoIHllYXIuXG4gICAgbGV0IGluY3JlbWVudCA9IHRoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZSkgPD0gNCA/IDcgOlxuICAgICAgKHRoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZSkgPj0gNyA/IDUgOiAxMik7XG4gICAgcmV0dXJuIHRoaXMuX3V0aWwuYWRkQ2FsZW5kYXJNb250aHMoZGF0ZSwgaW5jcmVtZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsZW5kYXJTdGF0ZShkaXJlY3Rpb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2NhbGVuZGFyU3RhdGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICBfY2FsZW5kYXJTdGF0ZURvbmUoKSB7XG4gICAgdGhpcy5fY2FsZW5kYXJTdGF0ZSA9ICcnO1xuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbXBvbmVudFJlZixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBOZ1pvbmUsXG4gIFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTkdfVkFMSURBVE9SUyxcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvckZuLFxuICBWYWxpZGF0b3JzLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL2NvZXJjaW9uL2Jvb2xlYW4tcHJvcGVydHknO1xuaW1wb3J0IHsgT3ZlcmxheSB9IGZyb20gJy4uL2NvcmUvb3ZlcmxheS9vdmVybGF5JztcbmltcG9ydCB7IE92ZXJsYXlSZWYgfSBmcm9tICcuLi9jb3JlL292ZXJsYXkvb3ZlcmxheS1yZWYnO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsIH0gZnJvbSAnLi4vY29yZS9wb3J0YWwvcG9ydGFsJztcbmltcG9ydCB7IE92ZXJsYXlTdGF0ZSB9IGZyb20gJy4uL2NvcmUvb3ZlcmxheS9vdmVybGF5LXN0YXRlJztcbmltcG9ydCB7IERpciB9IGZyb20gJy4uL2NvcmUvcnRsL2Rpcic7XG5pbXBvcnQgeyBQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vY29yZS9vdmVybGF5L3Bvc2l0aW9uL3Bvc2l0aW9uLXN0cmF0ZWd5JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnLi4vY29yZS9rZXlib2FyZC9rZXljb2Rlcyc7XG5pbXBvcnQgeyBNZDJDYWxlbmRhciB9IGZyb20gJy4vY2FsZW5kYXInO1xuaW1wb3J0IHsgRGF0ZUxvY2FsZSB9IGZyb20gJy4vZGF0ZS1sb2NhbGUnO1xuaW1wb3J0IHsgRGF0ZVV0aWwgfSBmcm9tICcuL2RhdGUtdXRpbCc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBNZDJTZWxlY3QuICovXG5leHBvcnQgY2xhc3MgTWQyRGF0ZUNoYW5nZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzb3VyY2U6IE1kMkRhdGVwaWNrZXIsIHB1YmxpYyB2YWx1ZTogRGF0ZSkgeyB9XG59XG5cbi8qKiBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBlYWNoIGRhdGVwaWNrZXIgaW5zdGFuY2UuICovXG5sZXQgZGF0ZXBpY2tlclVpZCA9IDA7XG5cblxuLyoqXG4gKiBDb21wb25lbnQgdXNlZCBhcyB0aGUgY29udGVudCBmb3IgdGhlIGRhdGVwaWNrZXIgZGlhbG9nIGFuZCBwb3B1cC4gV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiB1c2luZ1xuICogTWQyQ2FsZW5kYXIgZGlyZWN0bHkgYXMgdGhlIGNvbnRlbnQgc28gd2UgY2FuIGNvbnRyb2wgdGhlIGluaXRpYWwgZm9jdXMuIFRoaXMgYWxzbyBnaXZlcyB1cyBhXG4gKiBwbGFjZSB0byBwdXQgYWRkaXRpb25hbCBmZWF0dXJlcyBvZiB0aGUgcG9wdXAgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNhbGVuZGFyIGl0c2VsZiBpbiB0aGVcbiAqIGZ1dHVyZS4gKGUuZy4gY29uZmlybWF0aW9uIGJ1dHRvbnMpLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQyLWRhdGVwaWNrZXItY29udGVudCcsXG4gIHRlbXBsYXRlVXJsOiAnZGF0ZXBpY2tlci1jb250ZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnZGF0ZXBpY2tlci1jb250ZW50LnNjc3MnXSxcbiAgaG9zdDoge1xuICAgICdjbGFzcyc6ICdtZDItZGF0ZXBpY2tlci1jb250ZW50JyxcbiAgICAnW2NsYXNzLm1kMi1kYXRlcGlja2VyLWNvbnRlbnQtdG91Y2hdJzogJ2RhdGVwaWNrZXI/LnRvdWNoVWknLFxuICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gIH0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJEYXRlcGlja2VyQ29udGVudCB7XG4gIGRhdGVwaWNrZXI6IE1kMkRhdGVwaWNrZXI7XG5cbiAgQFZpZXdDaGlsZChNZDJDYWxlbmRhcikgX2NhbGVuZGFyOiBNZDJDYWxlbmRhcjtcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50IG9uIGRhdGVwaWNrZXIgY29udGVudC5cbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogUmV0dXJuIHNvIHRoYXQgd2UgZG9uJ3QgcHJldmVudERlZmF1bHQgb24ga2V5cyB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBoYW5kbGVkLiAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjb25zdCBNRDJfREFURVBJQ0tFUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWQyRGF0ZXBpY2tlciksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5leHBvcnQgY29uc3QgTUQyX0RBVEVQSUNLRVJfVkFMSURBVE9SUzogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNZDJEYXRlcGlja2VyKSxcbiAgbXVsdGk6IHRydWVcbn07XG5cbi8qIENvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgdGhlIGRhdGVwaWNrZXIgcG9wdXAvZGlhbG9nLiAqL1xuQENvbXBvbmVudCh7XG4gIFxuICBzZWxlY3RvcjogJ21kMi1kYXRlcGlja2VyJyxcbiAgdGVtcGxhdGVVcmw6ICdkYXRlcGlja2VyLmh0bWwnLFxuICBzdHlsZVVybHM6IFsnZGF0ZXBpY2tlci5zY3NzJ10sXG4gIHByb3ZpZGVyczogW01EMl9EQVRFUElDS0VSX1ZBTFVFX0FDQ0VTU09SLCBNRDJfREFURVBJQ0tFUl9WQUxJREFUT1JTXSxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ2RhdGVwaWNrZXInLFxuICAgICdbY2xhc3MubWQyLWRhdGVwaWNrZXItZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAnW2NsYXNzLm1kMi1kYXRlcGlja2VyLW9wZW5lZF0nOiAnb3BlbmVkJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAncGxhY2Vob2xkZXInLFxuICAgICdbYXR0ci5hcmlhLXJlcXVpcmVkXSc6ICdyZXF1aXJlZC50b1N0cmluZygpJyxcbiAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gIH0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIE1kMkRhdGVwaWNrZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICBfb25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICBfb25Ub3VjaGVkID0gKCkgPT4geyB9O1xuICBfdmFsaWRhdG9yT25DaGFuZ2UgPSAoKSA9PiB7IH07XG5cbiAgX2lucHV0Rm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgZGF0ZSB0byBvcGVuIHRoZSBjYWxlbmRhciB0byBpbml0aWFsbHkuICovXG4gIEBJbnB1dCgpIHN0YXJ0QXQ6IERhdGU7XG5cbiAgLyoqIFRoZSB2aWV3IHRoYXQgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBpbi4gKi9cbiAgQElucHV0KCkgc3RhcnRWaWV3OiAnY2xvY2snIHwgJ21vbnRoJyB8ICd5ZWFyJyA9ICdtb250aCc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIFVJIGlzIGluIHRvdWNoIG1vZGUuIEluIHRvdWNoIG1vZGUgdGhlIGNhbGVuZGFyIG9wZW5zIGluIGEgZGlhbG9nIHJhdGhlclxuICAgKiB0aGFuIGEgcG9wdXAgYW5kIGVsZW1lbnRzIGhhdmUgbW9yZSBwYWRkaW5nIHRvIGFsbG93IGZvciBiaWdnZXIgdG91Y2ggdGFyZ2V0cy5cbiAgICovXG4gIEBJbnB1dCgpIHRvdWNoVWkgPSBmYWxzZTtcblxuICAvKiogV2hldGhlciB0aGUgV2Vlay1udW1iZXIgc2hvdWxkIGJlIGRpc3BsYXllZCAqL1xuICBASW5wdXQoKSBkaXNwbGF5V2VlazogYm9vbGVhbjtcblxuICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgQElucHV0KCkgbW9kZTogJ2F1dG8nIHwgJ3BvcnRyYWl0JyB8ICdsYW5kc2NhcGUnID0gJ2F1dG8nO1xuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICBASW5wdXQoKSB0aW1lSW50ZXJ2YWw6IG51bWJlciA9IDE7XG4gIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90eXBlOyB9XG4gIHNldCB0eXBlKHZhbHVlOiAnZGF0ZScgfCAndGltZScgfCAnbW9udGgnIHwgJ2RhdGV0aW1lJykge1xuICAgIHRoaXMuX3R5cGUgPSB2YWx1ZSB8fCAnZGF0ZSc7XG4gICAgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMuX2Zvcm1hdERhdGUodGhpcy5fdmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX3R5cGU6ICdkYXRlJyB8ICd0aW1lJyB8ICdtb250aCcgfCAnZGF0ZXRpbWUnID0gJ2RhdGUnO1xuXG4gIEBJbnB1dCgpXG4gIGdldCBmb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvcm1hdCB8fCAodGhpcy50eXBlID09PSAnbW9udGgnID8gJ01NTU0geScgOiB0aGlzLnR5cGUgPT09ICdkYXRlJyA/XG4gICAgICAnZGQvTU0veScgOiB0aGlzLnR5cGUgPT09ICd0aW1lJyA/ICdISDptbScgOiB0aGlzLnR5cGUgPT09ICdkYXRldGltZScgP1xuICAgICAgICAnZGQvTU0veSBISDptbScgOiAnZGQvTU0veScpO1xuICB9XG4gIHNldCBmb3JtYXQodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9mb3JtYXQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9mb3JtYXQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLl9mb3JtYXREYXRlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBfZm9ybWF0OiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHZhbGlkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBtaW4oKTogRGF0ZSB7IHJldHVybiB0aGlzLl9taW5EYXRlOyB9XG4gIHNldCBtaW4odmFsdWU6IERhdGUpIHtcbiAgICB0aGlzLl9taW5EYXRlID0gdmFsdWU7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuICBfbWluRGF0ZTogRGF0ZTtcblxuICAvKiogVGhlIG1heGltdW0gdmFsaWQgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1heCgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX21heERhdGU7IH1cbiAgc2V0IG1heCh2YWx1ZTogRGF0ZSkge1xuICAgIHRoaXMuX21heERhdGUgPSB2YWx1ZTtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG4gIF9tYXhEYXRlOiBEYXRlO1xuXG4gIEBJbnB1dCgpIHNldCBkYXRlRmlsdGVyKGZpbHRlcjogKGRhdGU6IERhdGUgfCBudWxsKSA9PiBib29sZWFuKSB7XG4gICAgdGhpcy5fZGF0ZUZpbHRlciA9IGZpbHRlcjtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG4gIF9kYXRlRmlsdGVyOiAoZGF0ZTogRGF0ZSB8IG51bGwpID0+IGJvb2xlYW47XG5cbiAgQElucHV0KClcbiAgZ2V0IHJlcXVpcmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH1cbiAgc2V0IHJlcXVpcmVkKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfVxuICBwcml2YXRlIF9yZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9XG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoKVxuICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICBzZXQgdmFsdWUodmFsdWU6IERhdGUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY29lcmNlRGF0ZVByb3BlcnR5KHZhbHVlKTtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHRoaXMuX3ZhbHVlO1xuICAgIHRoaXMuc3RhcnRBdCA9IHRoaXMuX3ZhbHVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMuX2Zvcm1hdERhdGUodGhpcy5fdmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHByaXZhdGUgX3ZhbHVlOiBEYXRlO1xuXG4gIF9pbnB1dFZhbHVlOiBzdHJpbmcgPSAnJztcblxuICBASW5wdXQoKVxuICBnZXQgb3Blbk9uRm9jdXMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9vcGVuT25Gb2N1czsgfVxuICBzZXQgb3Blbk9uRm9jdXModmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fb3Blbk9uRm9jdXMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG4gIHByaXZhdGUgX29wZW5PbkZvY3VzOiBib29sZWFuO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBpc09wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgJiYgIXRoaXMub3BlbmVkKSB7IHRoaXMub3BlbigpOyB9XG4gIH1cblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gb3BlbmVkLiAqL1xuICBAT3V0cHV0KCkgb25PcGVuOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIGNsb3NlZC4gKi9cbiAgQE91dHB1dCgpIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCBkYXRlIGhhcyBiZWVuIGNoYW5nZWQgYnkgdGhlIHVzZXIuICovXG4gIEBPdXRwdXQoKSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxNZDJEYXRlQ2hhbmdlPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWQyRGF0ZUNoYW5nZT4oKTtcblxuICAvKiogRW1pdHMgbmV3IHNlbGVjdGVkIGRhdGUgd2hlbiBzZWxlY3RlZCBkYXRlIGNoYW5nZXMuICovXG4gIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNhbGVuZGFyIGlzIG9wZW4uICovXG4gIG9wZW5lZCA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIF9zZWxlY3RlZDogRGF0ZSA9IG51bGw7XG5cbiAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZCBhcyBhIHBvcHVwLiAqL1xuICBwcml2YXRlIF9wb3B1cFJlZjogT3ZlcmxheVJlZjtcblxuICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgd2hlbiB0aGUgY2FsZW5kYXIgaXMgb3BlbmVkIGFzIGEgZGlhbG9nLiAqL1xuICBwcml2YXRlIF9kaWFsb2dSZWY6IE92ZXJsYXlSZWY7XG5cbiAgLyoqIEEgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIGNhbGVuZGFyIGZvciB0aGlzIGRhdGVwaWNrZXIuICovXG4gIHByaXZhdGUgX2NhbGVuZGFyUG9ydGFsOiBDb21wb25lbnRQb3J0YWw8TWQyRGF0ZXBpY2tlckNvbnRlbnQ+O1xuXG4gIHByaXZhdGUgX2lucHV0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWluIGRhdGUuICovXG4gIHByaXZhdGUgX21pblZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIHJldHVybiAoIXRoaXMubWluIHx8ICFjb250cm9sLnZhbHVlIHx8XG4gICAgICB0aGlzLl91dGlsLmNvbXBhcmVEYXRlKHRoaXMubWluLCBjb250cm9sLnZhbHVlKSA8PSAwKSA/XG4gICAgICBudWxsIDogeyAnbWQyRGF0ZXBpY2tlck1pbic6IHsgJ21pbic6IHRoaXMubWluLCAnYWN0dWFsJzogY29udHJvbC52YWx1ZSB9IH07XG4gIH1cblxuICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtYXggZGF0ZS4gKi9cbiAgcHJpdmF0ZSBfbWF4VmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgcmV0dXJuICghdGhpcy5tYXggfHwgIWNvbnRyb2wudmFsdWUgfHxcbiAgICAgIHRoaXMuX3V0aWwuY29tcGFyZURhdGUodGhpcy5tYXgsIGNvbnRyb2wudmFsdWUpID49IDApID9cbiAgICAgIG51bGwgOiB7ICdtZDJEYXRlcGlja2VyTWF4JzogeyAnbWF4JzogdGhpcy5tYXgsICdhY3R1YWwnOiBjb250cm9sLnZhbHVlIH0gfTtcbiAgfVxuXG4gIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhlIGRhdGUgZmlsdGVyLiAqL1xuICBwcml2YXRlIF9maWx0ZXJWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gIXRoaXMuX2RhdGVGaWx0ZXIgfHwgIWNvbnRyb2wudmFsdWUgfHwgdGhpcy5fZGF0ZUZpbHRlcihjb250cm9sLnZhbHVlKSA/XG4gICAgICBudWxsIDogeyAnbWQyRGF0ZXBpY2tlckZpbHRlcic6IHRydWUgfTtcbiAgfVxuXG4gIC8qKiBUaGUgY29tYmluZWQgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhpcyBpbnB1dC4gKi9cbiAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9XG4gIFZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5fbWluVmFsaWRhdG9yLCB0aGlzLl9tYXhWYWxpZGF0b3IsIHRoaXMuX2ZpbHRlclZhbGlkYXRvcl0pO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgX2xvY2FsZTogRGF0ZUxvY2FsZSxcbiAgICBwcml2YXRlIF91dGlsOiBEYXRlVXRpbCxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcikge1xuICAgIHRoaXMuaWQgPSAodGhpcy5pZCkgPyB0aGlzLmlkIDogYG1kMi1kYXRlcGlja2VyLSR7ZGF0ZXBpY2tlclVpZCsrfWA7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgaWYgKHRoaXMuX3BvcHVwUmVmKSB7XG4gICAgICB0aGlzLl9wb3B1cFJlZi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsb2dSZWYpIHtcbiAgICAgIHRoaXMuX2RpYWxvZ1JlZi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbnB1dFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5faW5wdXRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHZhbGlkYXRlKGM6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yID8gdGhpcy5fdmFsaWRhdG9yKGMpIDogbnVsbDtcbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4ge30pOiB2b2lkIHsgdGhpcy5fb25Ub3VjaGVkID0gZm47IH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIF9oYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLl9pbnB1dEZvY3VzZWQgPSB0cnVlO1xuICAgIGlmICghdGhpcy5vcGVuZWQgJiYgdGhpcy5vcGVuT25Gb2N1cykge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJsdXIoZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5faW5wdXRGb2N1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLm9wZW5lZCkge1xuICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgfVxuICAgIGxldCBlbDogYW55ID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCBkYXRlOiBEYXRlID0gdGhpcy5fdXRpbC5wYXJzZURhdGUoZWwudmFsdWUsIHRoaXMuZm9ybWF0KTtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIGRhdGUgPSB0aGlzLl91dGlsLnBhcnNlKGVsLnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGRhdGUgIT0gbnVsbCAmJiBkYXRlLmdldFRpbWUgJiYgIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuXG4gICAgICBsZXQgZDogRGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUpO1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIGQuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdkYXRlJykge1xuICAgICAgICBkLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl91dGlsLmlzU2FtZU1pbnV0ZSh0aGlzLnZhbHVlLCBkKSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fdXRpbC5jcmVhdGVEYXRlKGQuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICBkLmdldE1vbnRoKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksXG4gICAgICAgICAgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0TWludXRlcygpLFxuICAgICAgICAgIGQuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIGVsLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvZXJjZURhdGVQcm9wZXJ0eSh2YWx1ZTogYW55KTogRGF0ZSB7XG4gICAgbGV0IHY6IERhdGUgPSBudWxsO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmdldFRpbWUgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkpIHtcbiAgICAgIHYgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlICYmIHRoaXMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIGxldCB0ID0gdmFsdWUgKyAnJztcbiAgICAgICAgdiA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHYuc2V0SG91cnMocGFyc2VJbnQodC5zdWJzdHJpbmcoMCwgMikpKTtcbiAgICAgICAgdi5zZXRNaW51dGVzKHBhcnNlSW50KHQuc3Vic3RyaW5nKDMsIDUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHYgPSBpc05hTih0aW1lc3RhbXApID8gbnVsbCA6IG5ldyBEYXRlKHRpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkOiBEYXRlID0gdiA/IHRoaXMuX3V0aWwuY3JlYXRlRGF0ZSh2LmdldEZ1bGxZZWFyKCksXG4gICAgICB2LmdldE1vbnRoKCksXG4gICAgICB2LmdldERhdGUoKSxcbiAgICAgIHYuZ2V0SG91cnMoKSxcbiAgICAgIHYuZ2V0TWludXRlcygpLFxuICAgICAgdi5nZXRTZWNvbmRzKCkpIDogbnVsbDtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBmb3JtYXQgZGF0ZVxuICAgKiBAcGFyYW0gZGF0ZSBEYXRlIE9iamVjdFxuICAgKiBAcmV0dXJuIHN0cmluZyB3aXRoIGZvcm1hdHRlZCBkYXRlXG4gICAqL1xuICBwcml2YXRlIF9mb3JtYXREYXRlKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5mb3JtYXQgfHwgIWRhdGUpIHsgcmV0dXJuICcnOyB9XG5cbiAgICBsZXQgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG5cbiAgICAvKiBZZWFycyAqL1xuICAgIGlmIChmb3JtYXQuaW5kZXhPZigneXknKSA+IC0xKSB7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgneXknLCAoJzAwJyArIHRoaXMuX3V0aWwuZ2V0WWVhcihkYXRlKSkuc2xpY2UoLTIpKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCd5JykgPiAtMSkge1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ3knLCAnJyArIHRoaXMuX3V0aWwuZ2V0WWVhcihkYXRlKSk7XG4gICAgfVxuXG4gICAgLyogRGF5cyAqL1xuICAgIGlmIChmb3JtYXQuaW5kZXhPZignZGQnKSA+IC0xKSB7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnZGQnLCAoJzAnICsgdGhpcy5fdXRpbC5nZXREYXRlKGRhdGUpKS5zbGljZSgtMikpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJ2QnKSA+IC0xKSB7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnZCcsICcnICsgdGhpcy5fdXRpbC5nZXREYXRlKGRhdGUpKTtcbiAgICB9XG5cbiAgICAvKiBIb3VycyAqL1xuICAgIGlmICgvW2FBXS8udGVzdChmb3JtYXQpKSB7XG4gICAgICAvKiAxMi1ob3VyICovXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0hIJykgPiAtMSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnSEgnLFxuICAgICAgICAgICgnMCcgKyB0aGlzLl9nZXRIb3VyczEyKHRoaXMuX3V0aWwuZ2V0SG91cnMoZGF0ZSkpKS5zbGljZSgtMikpO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignSCcpID4gLTEpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ0gnLFxuICAgICAgICAgICcnICsgdGhpcy5fZ2V0SG91cnMxMih0aGlzLl91dGlsLmdldEhvdXJzKGRhdGUpKSk7XG4gICAgICB9XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnQScsICgodGhpcy5fdXRpbC5nZXRIb3VycyhkYXRlKSA8IDEyKSA/ICdBTScgOiAnUE0nKSlcbiAgICAgICAgLnJlcGxhY2UoJ2EnLCAoKHRoaXMuX3V0aWwuZ2V0SG91cnMoZGF0ZSkgPCAxMikgPyAnYW0nIDogJ3BtJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiAyNC1ob3VyICovXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0hIJykgPiAtMSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnSEgnLCAoJzAnICsgdGhpcy5fdXRpbC5nZXRIb3VycyhkYXRlKSkuc2xpY2UoLTIpKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJ0gnKSA+IC0xKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdIJywgJycgKyB0aGlzLl91dGlsLmdldEhvdXJzKGRhdGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBNaW51dGVzICovXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdtbScpID4gLTEpIHtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdtbScsICgnMCcgKyB0aGlzLl91dGlsLmdldE1pbnV0ZXMoZGF0ZSkpLnNsaWNlKC0yKSk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignbScpID4gLTEpIHtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdtJywgJycgKyB0aGlzLl91dGlsLmdldE1pbnV0ZXMoZGF0ZSkpO1xuICAgIH1cblxuICAgIC8qIFNlY29uZHMgKi9cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ3NzJykgPiAtMSkge1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ3NzJywgKCcwJyArIHRoaXMuX3V0aWwuZ2V0U2Vjb25kcyhkYXRlKSkuc2xpY2UoLTIpKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCdzJykgPiAtMSkge1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ3MnLCAnJyArIHRoaXMuX3V0aWwuZ2V0U2Vjb25kcyhkYXRlKSk7XG4gICAgfVxuXG4gICAgLyogTW9udGhzICovXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdNTU1NJykgPiAtMSkge1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ01NTU0nLFxuICAgICAgICB0aGlzLl9sb2NhbGUuZ2V0TW9udGhOYW1lcygnbG9uZycpW3RoaXMuX3V0aWwuZ2V0TW9udGgoZGF0ZSldKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCdNTU0nKSA+IC0xKSB7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnTU1NJyxcbiAgICAgICAgdGhpcy5fbG9jYWxlLmdldE1vbnRoTmFtZXMoJ3Nob3J0JylbdGhpcy5fdXRpbC5nZXRNb250aChkYXRlKV0pO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJ01NJykgPiAtMSkge1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ01NJywgKCcwJyArICh0aGlzLl91dGlsLmdldE1vbnRoKGRhdGUpICsgMSkpLnNsaWNlKC0yKSk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignTScpID4gLTEpIHtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdNJywgJycgKyAodGhpcy5fdXRpbC5nZXRNb250aChkYXRlKSArIDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBob3VyIG9mIHRoZSBkYXRlIGluIHRoZSAxMi1ob3VyIGZvcm1hdFxuICAgKiBAcGFyYW0gZGF0ZSBEYXRlIE9iamVjdFxuICAgKiBAcmV0dXJuIGhvdXIgb2YgdGhlIGRhdGUgaW4gdGhlIDEyLWhvdXIgZm9ybWF0XG4gICAqL1xuICBwcml2YXRlIF9nZXRIb3VyczEyKGhvdXJzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChob3VycyA9PSAwKSB7XG4gICAgICBob3VycyA9IDEyO1xuICAgIH0gZWxzZSBpZiAoaG91cnMgPiAxMikge1xuICAgICAgaG91cnMgLT0gMTI7XG4gICAgfVxuICAgIHJldHVybiBob3VycztcbiAgfVxuXG4gIC8qKiBTZWxlY3RzIHRoZSBnaXZlbiBkYXRlIGFuZCBjbG9zZXMgdGhlIGN1cnJlbnRseSBvcGVuIHBvcHVwIG9yIGRpYWxvZy4gKi9cbiAgX3NlbGVjdEFuZENsb3NlKGRhdGU6IERhdGUpOiB2b2lkIHtcbiAgICBsZXQgb2xkVmFsdWUgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICBpZiAoIXRoaXMuX3V0aWwuc2FtZURhdGVBbmRUaW1lKG9sZFZhbHVlLCB0aGlzLl9zZWxlY3RlZCkpIHtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgIH1cbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgZGF0ZS4gKi9cbiAgX2VtaXRDaGFuZ2VFdmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICB0aGlzLmNoYW5nZS5lbWl0KG5ldyBNZDJEYXRlQ2hhbmdlKHRoaXMsIHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8qKiBPcGVuIHRoZSBjYWxlbmRhci4gKi9cbiAgb3BlbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoIXRoaXMuX2NhbGVuZGFyUG9ydGFsKSB7XG4gICAgICB0aGlzLl9jYWxlbmRhclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoTWQyRGF0ZXBpY2tlckNvbnRlbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cblxuICAgIHRoaXMudG91Y2hVaSA/IHRoaXMuX29wZW5Bc0RpYWxvZygpIDogdGhpcy5fb3BlbkFzUG9wdXAoKTtcbiAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuICB9XG5cbiAgLyoqIENsb3NlIHRoZSBjYWxlbmRhci4gKi9cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9wdXBSZWYgJiYgdGhpcy5fcG9wdXBSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgdGhpcy5fcG9wdXBSZWYuZGV0YWNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsb2dSZWYgJiYgdGhpcy5fZGlhbG9nUmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIHRoaXMuX2RpYWxvZ1JlZi5kZXRhY2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbGVuZGFyUG9ydGFsICYmIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2NhbGVuZGFyUG9ydGFsLmRldGFjaCgpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG4gIH1cblxuICAvKiogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBkaWFsb2cuICovXG4gIHByaXZhdGUgX29wZW5Bc0RpYWxvZygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2RpYWxvZ1JlZikge1xuICAgICAgdGhpcy5fY3JlYXRlRGlhbG9nKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2dSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgbGV0IGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPE1kMkRhdGVwaWNrZXJDb250ZW50PiA9XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpO1xuICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLmRhdGVwaWNrZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZ1JlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICAvKiogT3BlbiB0aGUgY2FsZW5kYXIgYXMgYSBwb3B1cC4gKi9cbiAgcHJpdmF0ZSBfb3BlbkFzUG9wdXAoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9wb3B1cFJlZikge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3BvcHVwUmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgIGxldCBjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxNZDJEYXRlcGlja2VyQ29udGVudD4gPVxuICAgICAgICB0aGlzLl9wb3B1cFJlZi5hdHRhY2godGhpcy5fY2FsZW5kYXJQb3J0YWwpO1xuICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLmRhdGVwaWNrZXIgPSB0aGlzO1xuXG4gICAgICAvKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9uY2UgdGhlIGNhbGVuZGFyIGhhcyByZW5kZXJlZC4gKi9cbiAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9wb3B1cFJlZi51cGRhdGVQb3NpdGlvbigpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3B1cFJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2UoKSk7XG4gIH1cblxuICAvKiogQ3JlYXRlIHRoZSBkaWFsb2cuICovXG4gIHByaXZhdGUgX2NyZWF0ZURpYWxvZygpOiB2b2lkIHtcbiAgICBjb25zdCBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZ2xvYmFsKClcbiAgICAgIC5jZW50ZXJIb3Jpem9udGFsbHkoKVxuICAgICAgLmNlbnRlclZlcnRpY2FsbHkoKTtcbiAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LWRhcmstYmFja2Ryb3AnO1xuICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICB0aGlzLl9kaWFsb2dSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5U3RhdGUpO1xuICB9XG5cbiAgLyoqIENyZWF0ZSB0aGUgcG9wdXAuICovXG4gIHByaXZhdGUgX2NyZWF0ZVBvcHVwKCk6IHZvaWQge1xuICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2NyZWF0ZVBvcHVwUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIG92ZXJsYXlTdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XG4gICAgb3ZlcmxheVN0YXRlLmJhY2tkcm9wQ2xhc3MgPSAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnO1xuICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuXG4gICAgdGhpcy5fcG9wdXBSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5U3RhdGUpO1xuICB9XG5cbiAgLyoqIENyZWF0ZSB0aGUgcG9wdXAgUG9zaXRpb25TdHJhdGVneS4gKi9cbiAgcHJpdmF0ZSBfY3JlYXRlUG9wdXBQb3NpdGlvblN0cmF0ZWd5KCk6IFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50LFxuICAgICAgeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnYm90dG9tJyB9LFxuICAgICAgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXG4gICAgICB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSlcbiAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcbiAgICAgIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdib3R0b20nIH0sXG4gICAgICB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXG4gICAgICB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAndG9wJyB9LFxuICAgICAgeyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZDJEYXRlcGlja2VyIH0gZnJvbSAnLi9kYXRlcGlja2VyJztcblxuXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnYnV0dG9uW21kMkRhdGVwaWNrZXJUb2dnbGVdJyxcbiAgdGVtcGxhdGU6ICcnLFxuICBzdHlsZVVybHM6IFsnZGF0ZXBpY2tlci10b2dnbGUuc2NzcyddLFxuICBob3N0OiB7XG4gICAgJ3R5cGUnOiAnYnV0dG9uJyxcbiAgICAnY2xhc3MnOiAnbWQyLWRhdGVwaWNrZXItdG9nZ2xlJyxcbiAgICAnYXJpYS1sYWJlbCc6ICdPcGVuIGNhbGVuZGFyJyxcbiAgICAnKGNsaWNrKSc6ICdfb3BlbigkZXZlbnQpJyxcbiAgfSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE1kMkRhdGVwaWNrZXJUb2dnbGU8RD4ge1xuICAvKiogRGF0ZXBpY2tlciBpbnN0YW5jZSB0aGF0IHRoZSBidXR0b24gd2lsbCB0b2dnbGUuICovXG4gIEBJbnB1dCgnbWQyRGF0ZXBpY2tlclRvZ2dsZScpIGRhdGVwaWNrZXI6IE1kMkRhdGVwaWNrZXI7XG5cbiAgX29wZW4oZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlcikge1xuICAgICAgdGhpcy5kYXRlcGlja2VyLm9wZW4oKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIGNhbGVuZGFyIGNlbGwuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBNZDJDYWxlbmRhckNlbGwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHVibGljIGRpc3BsYXlWYWx1ZTogc3RyaW5nLFxuICAgICAgICAgICAgICBwdWJsaWMgYXJpYUxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuLFxuICAgICAgICAgICAgICBwdWJsaWMgaGVhZGVyPzogc3RyaW5nKSB7fVxufVxuXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBjYWxlbmRhciBkYXRhIGluIGEgdGFibGUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdbbWQyLWNhbGVuZGFyLWJvZHldJyxcbiAgdGVtcGxhdGVVcmw6ICdjYWxlbmRhci1ib2R5Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnY2FsZW5kYXItYm9keS5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbWQyLWNhbGVuZGFyLWJvZHknLFxuICB9LFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTWQyQ2FsZW5kYXJCb2R5IHtcbiAgLyoqIFRoZSBsYWJlbCBmb3IgdGhlIHRhYmxlLiAoZS5nLiBcIkphbiAyMDE3XCIpLiAqL1xuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgY2VsbHMgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUuICovXG4gIEBJbnB1dCgpIHJvd3M6IE1kMkNhbGVuZGFyQ2VsbFtdW107XG5cbiAgLyoqIFRoZSB2YWx1ZSBpbiB0aGUgdGFibGUgdGhhdCBjb3JyZXNwb25kcyB0byB0b2RheS4gKi9cbiAgQElucHV0KCkgdG9kYXlWYWx1ZTogbnVtYmVyO1xuXG4gIC8qKiBUaGUgdmFsdWUgaW4gdGhlIHRhYmxlIHRoYXQgaXMgY3VycmVudGx5IHNlbGVjdGVkLiAqL1xuICBASW5wdXQoKSBzZWxlY3RlZFZhbHVlOiBudW1iZXI7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIG51bWJlciBvZiBmcmVlIGNlbGxzIG5lZWRlZCB0byBmaXQgdGhlIGxhYmVsIGluIHRoZSBmaXJzdCByb3cuICovXG4gIEBJbnB1dCgpIGxhYmVsTWluUmVxdWlyZWRDZWxsczogbnVtYmVyO1xuXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLiAqL1xuICBASW5wdXQoKSBudW1Db2xzID0gNztcblxuICAvKiogV2hldGhlciB0byBhbGxvdyBzZWxlY3Rpb24gb2YgZGlzYWJsZWQgY2VsbHMuICovXG4gIEBJbnB1dCgpIGFsbG93RGlzYWJsZWRTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAvKiogVGhlIGNlbGwgbnVtYmVyIG9mIHRoZSBhY3RpdmUgY2VsbCBpbiB0aGUgdGFibGUuICovXG4gIEBJbnB1dCgpIGFjdGl2ZUNlbGwgPSAwO1xuXG4gIC8qKiBXaGV0aGVyIHRoZSBXZWVrLW51bWJlciBzaG91bGQgYmUgZGlzcGxheWVkICovXG4gIEBJbnB1dCgpIGRpc3BsYXlXZWVrOiBib29sZWFuO1xuXG4gIC8qKiBFbWl0cyB3aGVuIGEgbmV3IHZhbHVlIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIF9jZWxsQ2xpY2tlZChjZWxsOiBNZDJDYWxlbmRhckNlbGwpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWxsb3dEaXNhYmxlZFNlbGVjdGlvbiAmJiAhY2VsbC5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZUNoYW5nZS5lbWl0KGNlbGwudmFsdWUpO1xuICB9XG5cbiAgLyoqIFRoZSBudW1iZXIgb2YgYmxhbmsgY2VsbHMgdG8gcHV0IGF0IHRoZSBiZWdpbm5pbmcgZm9yIHRoZSBmaXJzdCByb3cuICovXG4gIGdldCBfZmlyc3RSb3dPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzICYmIHRoaXMucm93cy5sZW5ndGggJiYgdGhpcy5yb3dzWzBdLmxlbmd0aCA/XG4gICAgICAgIHRoaXMubnVtQ29scyAtIHRoaXMucm93c1swXS5sZW5ndGggOiAwO1xuICB9XG5cbiAgX2lzQWN0aXZlQ2VsbChyb3dJbmRleDogbnVtYmVyLCBjb2xJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IGNlbGxOdW1iZXIgPSByb3dJbmRleCAqIHRoaXMubnVtQ29scyArIGNvbEluZGV4O1xuXG4gICAgLy8gQWNjb3VudCBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgZmlyc3Qgcm93IG1heSBub3QgaGF2ZSBhcyBtYW55IGNlbGxzLlxuICAgIGlmIChyb3dJbmRleCkge1xuICAgICAgY2VsbE51bWJlciAtPSB0aGlzLl9maXJzdFJvd09mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbE51bWJlciA9PSB0aGlzLmFjdGl2ZUNlbGw7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlTG9jYWxlIH0gZnJvbSAnLi9kYXRlLWxvY2FsZSc7XG5pbXBvcnQgeyBEYXRlVXRpbCB9IGZyb20gJy4vZGF0ZS11dGlsJztcbmltcG9ydCB7IE1kMkNhbGVuZGFyQ2VsbCB9IGZyb20gJy4vY2FsZW5kYXItYm9keSc7XG5pbXBvcnQgeyBNRF9EQVRFX0ZPUk1BVFMsIE1kRGF0ZUZvcm1hdHMgfSBmcm9tICcuLi9jb3JlL2RhdGV0aW1lL2RhdGUtZm9ybWF0cyc7XG5pbXBvcnQgeyBzbGlkZUNhbGVuZGFyIH0gZnJvbSAnLi9kYXRlcGlja2VyLWFuaW1hdGlvbnMnO1xuXG5cbmNvbnN0IERBWVNfUEVSX1dFRUsgPSA3O1xuXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBhIHNpbmdsZSBtb250aCBpbiB0aGUgZGF0ZXBpY2tlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQENvbXBvbmVudCh7XG4gIFxuICBzZWxlY3RvcjogJ21kMi1tb250aC12aWV3JyxcbiAgdGVtcGxhdGVVcmw6ICdtb250aC12aWV3Lmh0bWwnLFxuICBhbmltYXRpb25zOiBbc2xpZGVDYWxlbmRhcl0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJNb250aFZpZXcgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqIFdoZXRoZXIgdGhlIFdlZWstbnVtYmVyIHNob3VsZCBiZSBkaXNwbGF5ZWQgKi9cbiAgQElucHV0KCkgZGlzcGxheVdlZWs6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRlIHRvIGRpc3BsYXkgaW4gdGhpcyBtb250aCB2aWV3IChldmVyeXRoaW5nIG90aGVyIHRoYW4gdGhlIG1vbnRoIGFuZCB5ZWFyIGlzIGlnbm9yZWQpLlxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IGFjdGl2ZURhdGUoKTogRGF0ZSB7IHJldHVybiB0aGlzLl9hY3RpdmVEYXRlOyB9XG4gIHNldCBhY3RpdmVEYXRlKHZhbHVlOiBEYXRlKSB7XG4gICAgbGV0IG9sZEFjdGl2ZURhdGUgPSB0aGlzLl9hY3RpdmVEYXRlO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB2YWx1ZSB8fCB0aGlzLl91dGlsLnRvZGF5KCk7XG4gICAgaWYgKG9sZEFjdGl2ZURhdGUgJiYgdGhpcy5fYWN0aXZlRGF0ZSAmJlxuICAgICAgIXRoaXMuX3V0aWwuaXNTYW1lTW9udGhBbmRZZWFyKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgICBpZiAodGhpcy5fdXRpbC5pc0luTmV4dE1vbnRoKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdGF0ZSgncmlnaHQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTdGF0ZSgnbGVmdCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcml2YXRlIF9hY3RpdmVEYXRlOiBEYXRlO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZCgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRGF0ZSkge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gdGhpcy5fZ2V0RGF0ZUluQ3VycmVudE1vbnRoKHRoaXMuc2VsZWN0ZWQpO1xuICB9XG4gIHByaXZhdGUgX3NlbGVjdGVkOiBEYXRlO1xuXG4gIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICBASW5wdXQoKSBkYXRlRmlsdGVyOiAoZGF0ZTogRGF0ZSkgPT4gYm9vbGVhbjtcblxuICAvKiogRW1pdHMgd2hlbiBhIG5ldyBkYXRlIGlzIHNlbGVjdGVkLiAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgLyoqIEdyaWQgb2YgY2FsZW5kYXIgY2VsbHMgcmVwcmVzZW50aW5nIHRoZSBkYXRlcyBvZiB0aGUgbW9udGguICovXG4gIF93ZWVrczogTWQyQ2FsZW5kYXJDZWxsW11bXTtcblxuICAvKiogVGhlIG51bWJlciBvZiBibGFuayBjZWxscyBpbiB0aGUgZmlyc3Qgcm93IGJlZm9yZSB0aGUgMXN0IG9mIHRoZSBtb250aC4gKi9cbiAgX2ZpcnN0V2Vla09mZnNldDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0ZSBvZiB0aGUgbW9udGggdGhhdCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIERhdGUgZmFsbHMgb24uXG4gICAqIE51bGwgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBEYXRlIGlzIGluIGFub3RoZXIgbW9udGguXG4gICAqL1xuICBfc2VsZWN0ZWREYXRlOiBudW1iZXI7XG5cbiAgLyoqIFRoZSBkYXRlIG9mIHRoZSBtb250aCB0aGF0IHRvZGF5IGZhbGxzIG9uLiBOdWxsIGlmIHRvZGF5IGlzIGluIGFub3RoZXIgbW9udGguICovXG4gIF90b2RheURhdGU6IG51bWJlcjtcblxuICAvKiogVGhlIG5hbWVzIG9mIHRoZSB3ZWVrZGF5cy4gKi9cbiAgX3dlZWtkYXlzOiB7IGxvbmc6IHN0cmluZywgbmFycm93OiBzdHJpbmcgfVtdO1xuXG4gIF9jYWxlbmRhclN0YXRlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9jYWxlOiBEYXRlTG9jYWxlLCBwdWJsaWMgX3V0aWw6IERhdGVVdGlsLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoTURfREFURV9GT1JNQVRTKSBwcml2YXRlIF9kYXRlRm9ybWF0czogTWREYXRlRm9ybWF0cykge1xuICAgIGlmICghdGhpcy5fZGF0ZUZvcm1hdHMpIHtcbiAgICAgIHRocm93IEVycm9yKCdNRF9EQVRFX0ZPUk1BVFMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdERheU9mV2VlayA9IHRoaXMuX2xvY2FsZS5nZXRGaXJzdERheU9mV2VlaygpO1xuICAgIGNvbnN0IG5hcnJvd1dlZWtkYXlzID0gdGhpcy5fbG9jYWxlLmdldERheU9mV2Vla05hbWVzKCduYXJyb3cnKTtcbiAgICBjb25zdCBsb25nV2Vla2RheXMgPSB0aGlzLl9sb2NhbGUuZ2V0RGF5T2ZXZWVrTmFtZXMoJ2xvbmcnKTtcblxuICAgIC8vIFJvdGF0ZSB0aGUgbGFiZWxzIGZvciBkYXlzIG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBsZXQgd2Vla2RheXMgPSBsb25nV2Vla2RheXMubWFwKChsb25nLCBpKSA9PiB7XG4gICAgICByZXR1cm4geyBsb25nLCBuYXJyb3c6IG5hcnJvd1dlZWtkYXlzW2ldIH07XG4gICAgfSk7XG4gICAgdGhpcy5fd2Vla2RheXMgPSB3ZWVrZGF5cy5zbGljZShmaXJzdERheU9mV2VlaykuY29uY2F0KHdlZWtkYXlzLnNsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKSk7XG5cbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fdXRpbC50b2RheSgpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIC8qKiBIYW5kbGVzIHdoZW4gYSBuZXcgZGF0ZSBpcyBzZWxlY3RlZC4gKi9cbiAgX2RhdGVTZWxlY3RlZChkYXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fdXRpbC5jcmVhdGVEYXRlKFxuICAgICAgdGhpcy5fdXRpbC5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksIHRoaXMuX3V0aWwuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIGRhdGUsIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TWludXRlcyh0aGlzLmFjdGl2ZURhdGUpLFxuICAgICAgdGhpcy5fdXRpbC5nZXRTZWNvbmRzKHRoaXMuYWN0aXZlRGF0ZSkpKTtcbiAgfVxuXG4gIC8qKiBJbml0aWFsaXplcyB0aGlzIG1vbnRoIHZpZXcuICovXG4gIHByaXZhdGUgX2luaXQoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gdGhpcy5fZ2V0RGF0ZUluQ3VycmVudE1vbnRoKHRoaXMuc2VsZWN0ZWQpO1xuICAgIHRoaXMuX3RvZGF5RGF0ZSA9IHRoaXMuX2dldERhdGVJbkN1cnJlbnRNb250aCh0aGlzLl91dGlsLnRvZGF5KCkpO1xuXG4gICAgbGV0IGZpcnN0T2ZNb250aCA9IHRoaXMuX3V0aWwuY3JlYXRlRGF0ZSh0aGlzLl91dGlsLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSwgMSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TWludXRlcyh0aGlzLmFjdGl2ZURhdGUpLFxuICAgICAgdGhpcy5fdXRpbC5nZXRTZWNvbmRzKHRoaXMuYWN0aXZlRGF0ZSkpO1xuICAgIHRoaXMuX2ZpcnN0V2Vla09mZnNldCA9XG4gICAgICAoREFZU19QRVJfV0VFSyArIHRoaXMuX2xvY2FsZS5nZXREYXlPZldlZWsoZmlyc3RPZk1vbnRoKSAtXG4gICAgICAgIHRoaXMuX2xvY2FsZS5nZXRGaXJzdERheU9mV2VlaygpKSAlIERBWVNfUEVSX1dFRUs7XG5cbiAgICB0aGlzLl9jcmVhdGVXZWVrQ2VsbHMoKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIE1kQ2FsZW5kYXJDZWxscyBmb3IgdGhlIGRhdGVzIGluIHRoaXMgbW9udGguICovXG4gIHByaXZhdGUgX2NyZWF0ZVdlZWtDZWxscygpIHtcbiAgICBsZXQgZGF5c0luTW9udGggPSB0aGlzLl91dGlsLmdldE51bURheXNJbk1vbnRoKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgbGV0IGRhdGVOYW1lcyA9IHRoaXMuX2xvY2FsZS5nZXREYXRlTmFtZXMoKTtcbiAgICBsZXQgb2xkV2VlaztcbiAgICB0aGlzLl93ZWVrcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGNlbGwgPSB0aGlzLl9maXJzdFdlZWtPZmZzZXQ7IGkgPCBkYXlzSW5Nb250aDsgaSsrICwgY2VsbCsrKSB7XG4gICAgICBsZXQgZGF0ZSA9IHRoaXMuX3V0aWwuY3JlYXRlRGF0ZShcbiAgICAgICAgdGhpcy5fdXRpbC5nZXRZZWFyKHRoaXMuYWN0aXZlRGF0ZSksXG4gICAgICAgIHRoaXMuX3V0aWwuZ2V0TW9udGgodGhpcy5hY3RpdmVEYXRlKSwgaSArIDEsXG4gICAgICAgIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgICAgdGhpcy5fdXRpbC5nZXRNaW51dGVzKHRoaXMuYWN0aXZlRGF0ZSksXG4gICAgICAgIHRoaXMuX3V0aWwuZ2V0U2Vjb25kcyh0aGlzLmFjdGl2ZURhdGUpKTtcbiAgICAgIGxldCBlbmFibGVkID0gIXRoaXMuZGF0ZUZpbHRlciB8fFxuICAgICAgICB0aGlzLmRhdGVGaWx0ZXIoZGF0ZSk7XG4gICAgICBsZXQgYXJpYUxhYmVsID0gdGhpcy5fbG9jYWxlLmZvcm1hdChkYXRlLCB0aGlzLl9kYXRlRm9ybWF0cy5kaXNwbGF5LmRhdGVBMTF5TGFiZWwpO1xuICAgICAgbGV0IG5ld1dlZWsgPSB0aGlzLl91dGlsLmdldFdlZWtPZlllYXIoZGF0ZSk7XG4gICAgICBpZiAob2xkV2VlayAhPT0gbmV3V2Vlaykge1xuICAgICAgICB0aGlzLl93ZWVrcy5wdXNoKFtdKTtcbiAgICAgICAgb2xkV2VlayA9IG5ld1dlZWs7XG4gICAgICAgIGNlbGwgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5fd2Vla3NbdGhpcy5fd2Vla3MubGVuZ3RoIC0gMV1cbiAgICAgICAgLnB1c2gobmV3IE1kMkNhbGVuZGFyQ2VsbChpICsgMSwgZGF0ZU5hbWVzW2ldLCBhcmlhTGFiZWwsIGVuYWJsZWQsIG5ld1dlZWsudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRlIGluIHRoaXMgbW9udGggdGhhdCB0aGUgZ2l2ZW4gRGF0ZSBmYWxscyBvbi5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBnaXZlbiBEYXRlIGlzIGluIGFub3RoZXIgbW9udGguXG4gICAqL1xuICBwcml2YXRlIF9nZXREYXRlSW5DdXJyZW50TW9udGgoZGF0ZTogRGF0ZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3V0aWwuaXNTYW1lTW9udGhBbmRZZWFyKGRhdGUsIHRoaXMuYWN0aXZlRGF0ZSkgP1xuICAgICAgdGhpcy5fdXRpbC5nZXREYXRlKGRhdGUpIDogbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsZW5kYXJTdGF0ZShkaXJlY3Rpb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2NhbGVuZGFyU3RhdGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICBfY2FsZW5kYXJTdGF0ZURvbmUoKSB7XG4gICAgdGhpcy5fY2FsZW5kYXJTdGF0ZSA9ICcnO1xuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlTG9jYWxlIH0gZnJvbSAnLi9kYXRlLWxvY2FsZSc7XG5pbXBvcnQgeyBEYXRlVXRpbCB9IGZyb20gJy4vZGF0ZS11dGlsJztcbmltcG9ydCB7IE1kMkNhbGVuZGFyQ2VsbCB9IGZyb20gJy4vY2FsZW5kYXItYm9keSc7XG5pbXBvcnQgeyBNRF9EQVRFX0ZPUk1BVFMsIE1kRGF0ZUZvcm1hdHMgfSBmcm9tICcuLi9jb3JlL2RhdGV0aW1lL2RhdGUtZm9ybWF0cyc7XG5pbXBvcnQgeyBzbGlkZUNhbGVuZGFyIH0gZnJvbSAnLi9kYXRlcGlja2VyLWFuaW1hdGlvbnMnO1xuXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBhIHNpbmdsZSB5ZWFyIGluIHRoZSBkYXRlcGlja2VyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQyLXllYXItdmlldycsXG4gIHRlbXBsYXRlVXJsOiAneWVhci12aWV3Lmh0bWwnLFxuICBhbmltYXRpb25zOiBbc2xpZGVDYWxlbmRhcl0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJZZWFyVmlldyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAvKiogVGhlIGRhdGUgdG8gZGlzcGxheSBpbiB0aGlzIHllYXIgdmlldyAoZXZlcnl0aGluZyBvdGhlciB0aGFuIHRoZSB5ZWFyIGlzIGlnbm9yZWQpLiAqL1xuICBASW5wdXQoKVxuICBnZXQgYWN0aXZlRGF0ZSgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZURhdGU7IH1cbiAgc2V0IGFjdGl2ZURhdGUodmFsdWU6IERhdGUpIHtcbiAgICBsZXQgb2xkQWN0aXZlRGF0ZSA9IHRoaXMuX2FjdGl2ZURhdGU7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHZhbHVlIHx8IHRoaXMuX3V0aWwudG9kYXkoKTtcbiAgICBpZiAob2xkQWN0aXZlRGF0ZSAmJiB0aGlzLl9hY3RpdmVEYXRlICYmXG4gICAgICAhdGhpcy5fdXRpbC5pc1NhbWVZZWFyKG9sZEFjdGl2ZURhdGUsIHRoaXMuX2FjdGl2ZURhdGUpKSB7XG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAvLyBpZiAob2xkQWN0aXZlRGF0ZSA8IHRoaXMuX2FjdGl2ZURhdGUpIHtcbiAgICAgIC8vICB0aGlzLmNhbGVuZGFyU3RhdGUoJ3JpZ2h0Jyk7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gIHRoaXMuY2FsZW5kYXJTdGF0ZSgnbGVmdCcpO1xuICAgICAgLy8gfVxuICAgIH1cbiAgfVxuICBwcml2YXRlIF9hY3RpdmVEYXRlOiBEYXRlO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZCgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRGF0ZSkge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgdGhpcy5fc2VsZWN0ZWRNb250aCA9IHRoaXMuX2dldE1vbnRoSW5DdXJyZW50WWVhcih0aGlzLnNlbGVjdGVkKTtcbiAgfVxuICBwcml2YXRlIF9zZWxlY3RlZDogRGF0ZTtcblxuICAvKiogQSBmdW5jdGlvbiB1c2VkIHRvIGZpbHRlciB3aGljaCBkYXRlcyBhcmUgc2VsZWN0YWJsZS4gKi9cbiAgQElucHV0KCkgZGF0ZUZpbHRlcjogKGRhdGU6IERhdGUpID0+IGJvb2xlYW47XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBuZXcgbW9udGggaXMgc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcblxuICAvKiogR3JpZCBvZiBjYWxlbmRhciBjZWxscyByZXByZXNlbnRpbmcgdGhlIG1vbnRocyBvZiB0aGUgeWVhci4gKi9cbiAgX21vbnRoczogTWQyQ2FsZW5kYXJDZWxsW11bXTtcblxuICAvKiogVGhlIGxhYmVsIGZvciB0aGlzIHllYXIgKGUuZy4gXCIyMDE3XCIpLiAqL1xuICBfeWVhckxhYmVsOiBzdHJpbmc7XG5cbiAgLyoqIFRoZSBtb250aCBpbiB0aGlzIHllYXIgdGhhdCB0b2RheSBmYWxscyBvbi4gTnVsbCBpZiB0b2RheSBpcyBpbiBhIGRpZmZlcmVudCB5ZWFyLiAqL1xuICBfdG9kYXlNb250aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9udGggaW4gdGhpcyB5ZWFyIHRoYXQgdGhlIHNlbGVjdGVkIERhdGUgZmFsbHMgb24uXG4gICAqIE51bGwgaWYgdGhlIHNlbGVjdGVkIERhdGUgaXMgaW4gYSBkaWZmZXJlbnQgeWVhci5cbiAgICovXG4gIF9zZWxlY3RlZE1vbnRoOiBudW1iZXI7XG5cbiAgX2NhbGVuZGFyU3RhdGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2NhbGU6IERhdGVMb2NhbGUsIHB1YmxpYyBfdXRpbDogRGF0ZVV0aWwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNRF9EQVRFX0ZPUk1BVFMpIHByaXZhdGUgX2RhdGVGb3JtYXRzOiBNZERhdGVGb3JtYXRzKSB7XG4gICAgaWYgKCF0aGlzLl9kYXRlRm9ybWF0cykge1xuICAgICAgdGhyb3cgRXJyb3IoJ01EX0RBVEVfRk9STUFUUycpO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0aGlzLl91dGlsLnRvZGF5KCk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgLyoqIEhhbmRsZXMgd2hlbiBhIG5ldyBtb250aCBpcyBzZWxlY3RlZC4gKi9cbiAgX21vbnRoU2VsZWN0ZWQobW9udGg6IG51bWJlcikge1xuICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLl91dGlsLmNyZWF0ZURhdGUoXG4gICAgICB0aGlzLl91dGlsLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsXG4gICAgICB0aGlzLl91dGlsLmdldERhdGUodGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TWludXRlcyh0aGlzLmFjdGl2ZURhdGUpLFxuICAgICAgdGhpcy5fdXRpbC5nZXRTZWNvbmRzKHRoaXMuYWN0aXZlRGF0ZSkpKTtcbiAgfVxuXG4gIC8qKiBJbml0aWFsaXplcyB0aGlzIG1vbnRoIHZpZXcuICovXG4gIHByaXZhdGUgX2luaXQoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRNb250aCA9IHRoaXMuX2dldE1vbnRoSW5DdXJyZW50WWVhcih0aGlzLnNlbGVjdGVkKTtcbiAgICB0aGlzLl90b2RheU1vbnRoID0gdGhpcy5fZ2V0TW9udGhJbkN1cnJlbnRZZWFyKHRoaXMuX3V0aWwudG9kYXkoKSk7XG4gICAgdGhpcy5feWVhckxhYmVsID0gdGhpcy5fbG9jYWxlLmdldFllYXJOYW1lKHRoaXMuYWN0aXZlRGF0ZSk7XG5cbiAgICBsZXQgbW9udGhOYW1lcyA9IHRoaXMuX2xvY2FsZS5nZXRNb250aE5hbWVzKCdzaG9ydCcpO1xuICAgIC8vIEZpcnN0IHJvdyBvZiBtb250aHMgb25seSBjb250YWlucyA1IGVsZW1lbnRzIHNvIHdlIGNhbiBmaXQgdGhlIHllYXIgbGFiZWwgb24gdGhlIHNhbWUgcm93LlxuICAgIHRoaXMuX21vbnRocyA9IFtbMCwgMSwgMiwgMywgNF0sIFs1LCA2LCA3LCA4LCA5LCAxMCwgMTFdXS5tYXAocm93ID0+IHJvdy5tYXAoXG4gICAgICBtb250aCA9PiB0aGlzLl9jcmVhdGVDZWxsRm9yTW9udGgobW9udGgsIG1vbnRoTmFtZXNbbW9udGhdKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vbnRoIGluIHRoaXMgeWVhciB0aGF0IHRoZSBnaXZlbiBEYXRlIGZhbGxzIG9uLlxuICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGdpdmVuIERhdGUgaXMgaW4gYW5vdGhlciB5ZWFyLlxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0TW9udGhJbkN1cnJlbnRZZWFyKGRhdGU6IERhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5fdXRpbC5pc1NhbWVZZWFyKGRhdGUsIHRoaXMuYWN0aXZlRGF0ZSkgP1xuICAgICAgdGhpcy5fdXRpbC5nZXRNb250aChkYXRlKSA6IG51bGw7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhbiBNZENhbGVuZGFyQ2VsbCBmb3IgdGhlIGdpdmVuIG1vbnRoLiAqL1xuICBwcml2YXRlIF9jcmVhdGVDZWxsRm9yTW9udGgobW9udGg6IG51bWJlciwgbW9udGhOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgYXJpYUxhYmVsID0gdGhpcy5fbG9jYWxlLmZvcm1hdChcbiAgICAgIHRoaXMuX3V0aWwuY3JlYXRlRGF0ZSh0aGlzLl91dGlsLmdldFllYXIodGhpcy5hY3RpdmVEYXRlKSwgbW9udGgsIDEsXG4gICAgICAgIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgICAgdGhpcy5fdXRpbC5nZXRNaW51dGVzKHRoaXMuYWN0aXZlRGF0ZSksXG4gICAgICAgIHRoaXMuX3V0aWwuZ2V0U2Vjb25kcyh0aGlzLmFjdGl2ZURhdGUpKSxcbiAgICAgIHRoaXMuX2RhdGVGb3JtYXRzLmRpc3BsYXkubW9udGhZZWFyQTExeUxhYmVsKTtcbiAgICByZXR1cm4gbmV3IE1kMkNhbGVuZGFyQ2VsbChcbiAgICAgIG1vbnRoLCBtb250aE5hbWUudG9Mb2NhbGVVcHBlckNhc2UoKSwgYXJpYUxhYmVsLCB0aGlzLl9pc01vbnRoRW5hYmxlZChtb250aCkpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGdpdmVuIG1vbnRoIGlzIGVuYWJsZWQuICovXG4gIHByaXZhdGUgX2lzTW9udGhFbmFibGVkKG1vbnRoOiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0ZUZpbHRlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0T2ZNb250aCA9IHRoaXMuX3V0aWwuY3JlYXRlRGF0ZShcbiAgICAgIHRoaXMuX3V0aWwuZ2V0WWVhcih0aGlzLmFjdGl2ZURhdGUpLCBtb250aCwgMSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKSxcbiAgICAgIHRoaXMuX3V0aWwuZ2V0TWludXRlcyh0aGlzLmFjdGl2ZURhdGUpLFxuICAgICAgdGhpcy5fdXRpbC5nZXRTZWNvbmRzKHRoaXMuYWN0aXZlRGF0ZSkpO1xuXG4gICAgLy8gSWYgYW55IGRhdGUgaW4gdGhlIG1vbnRoIGlzIGVuYWJsZWQgY291bnQgdGhlIG1vbnRoIGFzIGVuYWJsZWQuXG4gICAgZm9yIChsZXQgZGF0ZSA9IGZpcnN0T2ZNb250aDsgdGhpcy5fdXRpbC5nZXRNb250aChkYXRlKSA9PSBtb250aDtcbiAgICAgIGRhdGUgPSB0aGlzLl91dGlsLmFkZENhbGVuZGFyRGF5cyhkYXRlLCAxKSkge1xuICAgICAgaWYgKHRoaXMuZGF0ZUZpbHRlcihkYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGNhbGVuZGFyU3RhdGUoZGlyZWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9jYWxlbmRhclN0YXRlID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgX2NhbGVuZGFyU3RhdGVEb25lKCkge1xuICAgIHRoaXMuX2NhbGVuZGFyU3RhdGUgPSAnJztcbiAgfVxuXG59XG4iLCJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICAvLyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIC8vIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVV0aWwgfSBmcm9tICcuL2RhdGUtdXRpbCc7XG5pbXBvcnQgeyBEYXRlTG9jYWxlIH0gZnJvbSAnLi9kYXRlLWxvY2FsZSc7XG5cbmV4cG9ydCBjb25zdCBDTE9DS19SQURJVVMgPSA1MDtcbmV4cG9ydCBjb25zdCBDTE9DS19JTk5FUl9SQURJVVMgPSAyNy41O1xuZXhwb3J0IGNvbnN0IENMT0NLX09VVEVSX1JBRElVUyA9IDQxLjI1O1xuZXhwb3J0IGNvbnN0IENMT0NLX1RJQ0tfUkFESVVTID0gNy4wODMzO1xuXG5leHBvcnQgdHlwZSBDbG9ja1ZpZXcgPSAnaG91cicgfCAnbWludXRlJztcblxuLyoqXG4gKiBBIGNsb2NrIHRoYXQgaXMgdXNlZCBhcyBwYXJ0IG9mIHRoZSBkYXRlcGlja2VyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQyLWNsb2NrJyxcbiAgdGVtcGxhdGVVcmw6ICdjbG9jay5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2Nsb2NrLnNjc3MnXSxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ2Nsb2NrJyxcbiAgICAnKG1vdXNlZG93biknOiAnX2hhbmRsZU1vdXNlZG93bigkZXZlbnQpJyxcbiAgfSxcbiAgLy8gZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgLy8gY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE1kMkNsb2NrIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIC8qKlxuICAgKiBUaGUgZGF0ZSB0byBkaXNwbGF5IGluIHRoaXMgY2xvY2sgdmlldy5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBhY3RpdmVEYXRlKCk6IERhdGUgeyByZXR1cm4gdGhpcy5fYWN0aXZlRGF0ZTsgfVxuICBzZXQgYWN0aXZlRGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGxldCBvbGRBY3RpdmVEYXRlID0gdGhpcy5fYWN0aXZlRGF0ZTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdGhpcy5fdXRpbC5jbGFtcERhdGUodmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgaWYgKCF0aGlzLl91dGlsLmlzU2FtZU1pbnV0ZShvbGRBY3RpdmVEYXRlLCB0aGlzLl9hY3RpdmVEYXRlKSkge1xuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9hY3RpdmVEYXRlOiBEYXRlO1xuXG4gIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZCgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9XG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogRGF0ZSkge1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdGhpcy5fdXRpbC5wYXJzZSh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7IHRoaXMuYWN0aXZlRGF0ZSA9IHRoaXMuX3NlbGVjdGVkOyB9XG4gIH1cbiAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IERhdGU7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1pbigpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX21pbjsgfVxuICBzZXQgbWluKGRhdGU6IERhdGUpIHsgdGhpcy5fbWluID0gdGhpcy5fdXRpbC5wYXJzZShkYXRlKTsgfVxuICBwcml2YXRlIF9taW46IERhdGU7XG5cbiAgLyoqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgQElucHV0KClcbiAgZ2V0IG1heCgpOiBEYXRlIHsgcmV0dXJuIHRoaXMuX21heDsgfVxuICBzZXQgbWF4KGRhdGU6IERhdGUpIHsgdGhpcy5fbWF4ID0gdGhpcy5fdXRpbC5wYXJzZShkYXRlKTsgfVxuICBwcml2YXRlIF9tYXg6IERhdGU7XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNsb2NrIHNob3VsZCBiZSBzdGFydGVkIGluIGhvdXIgb3IgbWludXRlIHZpZXcuICovXG4gIEBJbnB1dCgpXG4gIHNldCBzdGFydFZpZXcodmFsdWU6IENsb2NrVmlldykge1xuICAgIHRoaXMuX2hvdXJWaWV3ID0gdmFsdWUgIT0gJ21pbnV0ZSc7XG4gIH1cblxuICAvKiogQSBmdW5jdGlvbiB1c2VkIHRvIGZpbHRlciB3aGljaCBkYXRlcyBhcmUgc2VsZWN0YWJsZS4gKi9cbiAgQElucHV0KCkgZGF0ZUZpbHRlcjogKGRhdGU6IERhdGUpID0+IGJvb2xlYW47XG5cbiAgQElucHV0KCkgaW50ZXJ2YWw6IG51bWJlciA9IDE7XG5cbiAgQElucHV0KCkgdHdlbHZlaG91cjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZSBjaGFuZ2VzLiAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgQE91dHB1dCgpIGFjdGl2ZURhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgLyoqIEhvdXJzIGFuZCBNaW51dGVzIHJlcHJlc2VudGluZyB0aGUgY2xvY2sgdmlldy4gKi9cbiAgX2hvdXJzOiBBcnJheTxPYmplY3Q+ID0gW107XG4gIF9taW51dGVzOiBBcnJheTxPYmplY3Q+ID0gW107XG5cbiAgLyoqIFdoZXRoZXIgdGhlIGNsb2NrIGlzIGluIGhvdXIgdmlldy4gKi9cbiAgX2hvdXJWaWV3OiBib29sZWFuID0gdHJ1ZTtcblxuICBfc2VsZWN0ZWRIb3VyOiBudW1iZXI7XG4gIF9zZWxlY3RlZE1pbnV0ZTogbnVtYmVyO1xuXG4gIGdldCBfaGFuZCgpOiBhbnkge1xuICAgIHRoaXMuX3NlbGVjdGVkSG91ciA9IHRoaXMuX3V0aWwuZ2V0SG91cnModGhpcy5hY3RpdmVEYXRlKTtcbiAgICB0aGlzLl9zZWxlY3RlZE1pbnV0ZSA9IHRoaXMuX3V0aWwuZ2V0TWludXRlcyh0aGlzLmFjdGl2ZURhdGUpO1xuICAgIGxldCBkZWcgPSAwO1xuICAgIGxldCByYWRpdXMgPSBDTE9DS19PVVRFUl9SQURJVVM7XG4gICAgaWYgKHRoaXMuX2hvdXJWaWV3KSB7XG4gICAgICBsZXQgb3V0ZXIgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0SG91cnMoKSA+IDAgJiYgdGhpcy5hY3RpdmVEYXRlLmdldEhvdXJzKCkgPCAxMztcbiAgICAgIHJhZGl1cyA9IG91dGVyID8gQ0xPQ0tfT1VURVJfUkFESVVTIDogQ0xPQ0tfSU5ORVJfUkFESVVTO1xuICAgICAgaWYgKHRoaXMudHdlbHZlaG91cikge1xuICAgICAgICByYWRpdXMgPSBDTE9DS19PVVRFUl9SQURJVVM7XG4gICAgICB9XG4gICAgICBkZWcgPSBNYXRoLnJvdW5kKHRoaXMuYWN0aXZlRGF0ZS5nZXRIb3VycygpICogKDM2MCAvICgyNCAvIDIpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZyA9IE1hdGgucm91bmQodGhpcy5hY3RpdmVEYXRlLmdldE1pbnV0ZXMoKSAqICgzNjAgLyA2MCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgJ3RyYW5zZm9ybSc6IGByb3RhdGUoJHtkZWd9ZGVnKWAsXG4gICAgICAnaGVpZ2h0JzogYCR7cmFkaXVzfSVgLFxuICAgICAgJ21hcmdpbi10b3AnOiBgJHs1MCAtIHJhZGl1c30lYFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIG1vdXNlTW92ZUxpc3RlbmVyOiBhbnk7XG4gIHByaXZhdGUgbW91c2VVcExpc3RlbmVyOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9sb2NhbGU6IERhdGVMb2NhbGUsIHByaXZhdGUgX3V0aWw6IERhdGVVdGlsKSB7XG4gICAgdGhpcy5tb3VzZU1vdmVMaXN0ZW5lciA9IChldmVudDogYW55KSA9PiB7IHRoaXMuX2hhbmRsZU1vdXNlbW92ZShldmVudCk7IH07XG4gICAgdGhpcy5tb3VzZVVwTGlzdGVuZXIgPSAoKSA9PiB7IHRoaXMuX2hhbmRsZU1vdXNldXAoKTsgfTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLmFjdGl2ZURhdGUgPSB0aGlzLl9hY3RpdmVEYXRlIHx8IHRoaXMuX3V0aWwudG9kYXkoKTtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cblxuICAvKiogSGFuZGxlcyBtb3VzZWRvd24gZXZlbnRzIG9uIHRoZSBjbG9jayBib2R5LiAqL1xuICBfaGFuZGxlTW91c2Vkb3duKGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLnNldFRpbWUoZXZlbnQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMubW91c2VNb3ZlTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXBMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm1vdXNlVXBMaXN0ZW5lcik7XG4gIH1cblxuICBfaGFuZGxlTW91c2Vtb3ZlKGV2ZW50OiBhbnkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VGltZShldmVudCk7XG4gIH1cblxuICBfaGFuZGxlTW91c2V1cCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm1vdXNlTW92ZUxpc3RlbmVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5tb3VzZVVwTGlzdGVuZXIpO1xuICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICB9XG5cbiAgLyoqIEluaXRpYWxpemVzIHRoaXMgY2xvY2sgdmlldy4gKi9cbiAgcHJpdmF0ZSBfaW5pdCgpIHtcbiAgICB0aGlzLl9ob3Vycy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX21pbnV0ZXMubGVuZ3RoID0gMDtcblxuICAgIGxldCBob3VyTmFtZXMgPSB0aGlzLl9sb2NhbGUuZ2V0SG91ck5hbWVzKCk7XG4gICAgbGV0IG1pbnV0ZU5hbWVzID0gdGhpcy5fbG9jYWxlLmdldE1pbnV0ZU5hbWVzKCk7XG5cbiAgICBpZiAodGhpcy50d2VsdmVob3VyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChob3VyTmFtZXMubGVuZ3RoIC8gMikgKyAxOyBpKyspIHtcbiAgICAgICAgbGV0IHJhZGlhbiA9IGkgLyA2ICogTWF0aC5QSTtcbiAgICAgICAgbGV0IHJhZGl1cyA9IENMT0NLX09VVEVSX1JBRElVUztcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhpICsgMSwgMCwgMCwgMCk7XG4gICAgICAgIGxldCBlbmFibGVkID0gdGhpcy5fdXRpbC5pc0Z1bGxEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgdGhpcy5faG91cnMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgZGlzcGxheVZhbHVlOiBpID09PSAwID8gJzAwJyA6IGhvdXJOYW1lc1tpXSxcbiAgICAgICAgICBlbmFibGVkOiBlbmFibGVkLFxuICAgICAgICAgIHRvcDogQ0xPQ0tfUkFESVVTIC0gTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyAtIENMT0NLX1RJQ0tfUkFESVVTLFxuICAgICAgICAgIGxlZnQ6IENMT0NLX1JBRElVUyArIE1hdGguc2luKHJhZGlhbikgKiByYWRpdXMgLSBDTE9DS19USUNLX1JBRElVUyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG91ck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYWRpYW4gPSBpIC8gNiAqIE1hdGguUEk7XG4gICAgICAgIGxldCBvdXRlciA9IGkgPiAwICYmIGkgPCAxMyxcbiAgICAgICAgICByYWRpdXMgPSBvdXRlciA/IENMT0NLX09VVEVSX1JBRElVUyA6IENMT0NLX0lOTkVSX1JBRElVUztcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhpICsgMSwgMCwgMCwgMCk7XG4gICAgICAgIGxldCBlbmFibGVkID0gdGhpcy5fdXRpbC5pc0Z1bGxEYXRlV2l0aGluUmFuZ2UoZGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICAgICAgdGhpcy5faG91cnMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgZGlzcGxheVZhbHVlOiBpID09PSAwID8gJzAwJyA6IGhvdXJOYW1lc1tpXSxcbiAgICAgICAgICBlbmFibGVkOiBlbmFibGVkLFxuICAgICAgICAgIHRvcDogQ0xPQ0tfUkFESVVTIC0gTWF0aC5jb3MocmFkaWFuKSAqIHJhZGl1cyAtIENMT0NLX1RJQ0tfUkFESVVTLFxuICAgICAgICAgIGxlZnQ6IENMT0NLX1JBRElVUyArIE1hdGguc2luKHJhZGlhbikgKiByYWRpdXMgLSBDTE9DS19USUNLX1JBRElVUyxcbiAgICAgICAgICBmb250U2l6ZTogaSA+IDAgJiYgaSA8IDEzID8gJycgOiAnODAlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbnV0ZU5hbWVzLmxlbmd0aDsgaSArPSA1KSB7XG4gICAgICBsZXQgcmFkaWFuID0gaSAvIDMwICogTWF0aC5QSTtcbiAgICAgIGxldCBkYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlLmdldFRpbWUoKSk7XG4gICAgICBkYXRlLnNldE1pbnV0ZXMoaSwgMCwgMCk7XG4gICAgICBsZXQgZW5hYmxlZCA9IHRoaXMuX3V0aWwuaXNGdWxsRGF0ZVdpdGhpblJhbmdlKGRhdGUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICB0aGlzLl9taW51dGVzLnB1c2goe1xuICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgZGlzcGxheVZhbHVlOiBpID09PSAwID8gJzAwJyA6IG1pbnV0ZU5hbWVzW2ldLFxuICAgICAgICBlbmFibGVkOiBlbmFibGVkLFxuICAgICAgICB0b3A6IENMT0NLX1JBRElVUyAtIE1hdGguY29zKHJhZGlhbikgKiBDTE9DS19PVVRFUl9SQURJVVMgLSBDTE9DS19USUNLX1JBRElVUyxcbiAgICAgICAgbGVmdDogQ0xPQ0tfUkFESVVTICsgTWF0aC5zaW4ocmFkaWFuKSAqIENMT0NLX09VVEVSX1JBRElVUyAtIENMT0NLX1RJQ0tfUkFESVVTLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBUaW1lXG4gICAqIEBwYXJhbSBldmVudFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRUaW1lKGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgdHJpZ2dlciA9IHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICBsZXQgdHJpZ2dlclJlY3QgPSB0cmlnZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB3aWR0aCA9IHRyaWdnZXIub2Zmc2V0V2lkdGg7XG4gICAgbGV0IGhlaWdodCA9IHRyaWdnZXIub2Zmc2V0SGVpZ2h0O1xuICAgIGxldCBwYWdlWCA9IGV2ZW50LnBhZ2VYICE9PSB1bmRlZmluZWQgPyBldmVudC5wYWdlWCA6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgbGV0IHBhZ2VZID0gZXZlbnQucGFnZVkgIT09IHVuZGVmaW5lZCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICBsZXQgeCA9ICh3aWR0aCAvIDIpIC0gKHBhZ2VYIC0gdHJpZ2dlclJlY3QubGVmdCAtIHdpbmRvdy5wYWdlWE9mZnNldCk7XG4gICAgbGV0IHkgPSAoaGVpZ2h0IC8gMikgLSAocGFnZVkgLSB0cmlnZ2VyUmVjdC50b3AgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgIGxldCByYWRpYW4gPSBNYXRoLmF0YW4yKC14LCB5KTtcbiAgICBsZXQgdW5pdCA9IE1hdGguUEkgLyAodGhpcy5faG91clZpZXcgPyA2IDogKHRoaXMuaW50ZXJ2YWwgPyAoMzAgLyB0aGlzLmludGVydmFsKSA6IDMwKSk7XG4gICAgbGV0IHogPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgbGV0IG91dGVyID0gdGhpcy5faG91clZpZXcgJiYgeiA+ICgod2lkdGggKiAoQ0xPQ0tfT1VURVJfUkFESVVTIC8gMTAwKSkgK1xuICAgICAgKHdpZHRoICogKENMT0NLX0lOTkVSX1JBRElVUyAvIDEwMCkpKSAvIDI7XG4gICAgbGV0IHZhbHVlID0gMDtcblxuICAgIGlmIChyYWRpYW4gPCAwKSB7IHJhZGlhbiA9IE1hdGguUEkgKiAyICsgcmFkaWFuOyB9XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHJhZGlhbiAvIHVuaXQpO1xuICAgIHJhZGlhbiA9IHZhbHVlICogdW5pdDtcblxuICAgIGxldCBkYXRlID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlLmdldFRpbWUoKSk7XG4gICAgaWYgKHRoaXMuX2hvdXJWaWV3KSB7XG4gICAgICBpZiAodGhpcy50d2VsdmVob3VyKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IDAgPyAxMiA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMikgeyB2YWx1ZSA9IDA7IH1cbiAgICAgICAgdmFsdWUgPSBvdXRlciA/ICh2YWx1ZSA9PT0gMCA/IDEyIDogdmFsdWUpIDogdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyAxMjtcbiAgICAgIH1cbiAgICAgIGRhdGUuc2V0SG91cnModmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCkgeyB2YWx1ZSAqPSB0aGlzLmludGVydmFsOyB9XG4gICAgICBpZiAodmFsdWUgPT09IDYwKSB7IHZhbHVlID0gMDsgfVxuICAgICAgZGF0ZS5zZXRNaW51dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVEYXRlID0gdGhpcy5fdXRpbC5jbGFtcERhdGUoZGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB0aGlzLmFjdGl2ZURhdGVDaGFuZ2UuZW1pdCh0aGlzLmFjdGl2ZURhdGUpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUsIE92ZXJsYXlNb2R1bGUsIFBvcnRhbE1vZHVsZSwgQTExeU1vZHVsZSB9IGZyb20gJy4uL2NvcmUvaW5kZXgnO1xuaW1wb3J0IHsgTWQyRGF0ZXBpY2tlciwgTWQyRGF0ZXBpY2tlckNvbnRlbnQgfSBmcm9tICcuL2RhdGVwaWNrZXInO1xuaW1wb3J0IHsgTWQyRGF0ZXBpY2tlclRvZ2dsZSB9IGZyb20gJy4vZGF0ZXBpY2tlci10b2dnbGUnO1xuaW1wb3J0IHsgTWQyQ2FsZW5kYXIgfSBmcm9tICcuL2NhbGVuZGFyJztcbmltcG9ydCB7IE1kMk1vbnRoVmlldyB9IGZyb20gJy4vbW9udGgtdmlldyc7XG5pbXBvcnQgeyBNZDJZZWFyVmlldyB9IGZyb20gJy4veWVhci12aWV3JztcbmltcG9ydCB7IE1kMkNhbGVuZGFyQm9keSB9IGZyb20gJy4vY2FsZW5kYXItYm9keSc7XG5pbXBvcnQgeyBNZDJDbG9jayB9IGZyb20gJy4vY2xvY2snO1xuaW1wb3J0IHsgRGF0ZUxvY2FsZSB9IGZyb20gJy4vZGF0ZS1sb2NhbGUnO1xuaW1wb3J0IHsgRGF0ZVV0aWwgfSBmcm9tICcuL2RhdGUtdXRpbCc7XG5cblxuZXhwb3J0ICogZnJvbSAnLi9kYXRlcGlja2VyJztcbmV4cG9ydCAqIGZyb20gJy4vbW9udGgtdmlldyc7XG5leHBvcnQgKiBmcm9tICcuL3llYXItdmlldyc7XG5leHBvcnQgKiBmcm9tICcuL2NhbGVuZGFyLWJvZHknO1xuZXhwb3J0ICogZnJvbSAnLi9jbG9jayc7XG5leHBvcnQgKiBmcm9tICcuL2RhdGUtbG9jYWxlJztcbmV4cG9ydCAqIGZyb20gJy4vZGF0ZS11dGlsJztcblxuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgUG9ydGFsTW9kdWxlLFxuICAgIFN0eWxlTW9kdWxlLFxuICAgIEExMXlNb2R1bGUsXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBNZDJEYXRlcGlja2VyLFxuICAgIE1kMkRhdGVwaWNrZXJUb2dnbGUsXG4gICAgTWQyQ2FsZW5kYXIsXG4gICAgTWQyQ2FsZW5kYXJCb2R5LFxuICAgIE1kMkNhbGVuZGFyLFxuICAgIE1kMk1vbnRoVmlldyxcbiAgICBNZDJZZWFyVmlldyxcbiAgICBNZDJDYWxlbmRhckJvZHksXG4gICAgTWQyQ2xvY2ssXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIE1kMkRhdGVwaWNrZXIsXG4gICAgTWQyRGF0ZXBpY2tlckNvbnRlbnQsXG4gICAgTWQyRGF0ZXBpY2tlclRvZ2dsZSxcbiAgICBNZDJDYWxlbmRhcixcbiAgICBNZDJNb250aFZpZXcsXG4gICAgTWQyWWVhclZpZXcsXG4gICAgTWQyQ2FsZW5kYXJCb2R5LFxuICAgIE1kMkNsb2NrLFxuICBdLFxuICBwcm92aWRlcnM6IFtEYXRlTG9jYWxlLCBEYXRlVXRpbF0sXG4gIGVudHJ5Q29tcG9uZW50czogW1xuICAgIE1kMkRhdGVwaWNrZXJDb250ZW50XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgTWQyRGF0ZXBpY2tlck1vZHVsZSB7IH1cbiIsIi8qKlxuICogRXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCB0aGUgKmVudW1lcmFibGUqIGFuZCAqb3duKiBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzLFxuICogc2ltaWxhciB0byBPYmplY3QuYXNzaWduLlxuICpcbiAqIEBwYXJhbSBkZXN0IFRoZSBvYmplY3Qgd2hpY2ggd2lsbCBoYXZlIHByb3BlcnRpZXMgY29waWVkIHRvIGl0LlxuICogQHBhcmFtIHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzIGZyb20gd2hpY2ggcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZE9iamVjdChkZXN0OiBhbnksIC4uLnNvdXJjZXM6IGFueVtdKTogYW55IHtcbiAgaWYgKGRlc3QgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPdXRwdXQsXG4gIElucHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE9wdGlvbmFsLFxuICBTa2lwU2VsZixcbiAgVmlld0NoaWxkLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgT25EZXN0cm95LFxuICBEaXJlY3RpdmUsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFRlbXBsYXRlUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIHN0eWxlLFxuICB0cmlnZ2VyLFxuICBzdGF0ZSxcbiAgdHJhbnNpdGlvbixcbiAgYW5pbWF0ZSxcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBFU0NBUEUsXG4gIE92ZXJsYXksXG4gIE92ZXJsYXlTdGF0ZSxcbiAgT3ZlcmxheVJlZixcbiAgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmVcbn0gZnJvbSAnLi4vY29yZS9pbmRleCc7XG5pbXBvcnQgeyBleHRlbmRPYmplY3QgfSBmcm9tICcuLi9jb3JlL3V0aWwvb2JqZWN0LWV4dGVuZCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5leHBvcnQgdHlwZSBEaWFsb2dWaXNpYmlsaXR5ID0gJ2luaXRpYWwnIHwgJ3Zpc2libGUnIHwgJ2hpZGRlbic7XG5leHBvcnQgdHlwZSBEaWFsb2dSb2xlID0gJ2RpYWxvZycgfCAnYWxlcnRkaWFsb2cnO1xuXG5leHBvcnQgY2xhc3MgTWQyRGlhbG9nQ29uZmlnIHtcbiAgcm9sZT86IERpYWxvZ1JvbGUgPSAnZGlhbG9nJztcbiAgZGlzYWJsZUNsb3NlPzogYm9vbGVhbiA9IGZhbHNlO1xufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWQyRGlhbG9nUG9ydGFsXScgfSlcbmV4cG9ydCBjbGFzcyBNZDJEaWFsb2dQb3J0YWwgZXh0ZW5kcyBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LCB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7XG4gICAgc3VwZXIodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpO1xuICB9XG59XG5cbi8qKlxuICogVGl0bGUgb2YgYSBkaWFsb2cgZWxlbWVudC4gU3RheXMgZml4ZWQgdG8gdGhlIHRvcCBvZiB0aGUgZGlhbG9nIHdoZW4gc2Nyb2xsaW5nLlxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdtZDItZGlhbG9nLXRpdGxlJyB9KVxuZXhwb3J0IGNsYXNzIE1kMkRpYWxvZ1RpdGxlIHsgfVxuXG4vKipcbiAqIFNjcm9sbGFibGUgY29udGVudCBjb250YWluZXIgb2YgYSBkaWFsb2cuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ21kMi1kaWFsb2ctY29udGVudCcgfSlcbmV4cG9ydCBjbGFzcyBNZDJEaWFsb2dDb250ZW50IHsgfVxuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgdGhlIGJvdHRvbSBhY3Rpb24gYnV0dG9ucyBpbiBhIGRpYWxvZy5cbiAqIFN0YXlzIGZpeGVkIHRvIHRoZSBib3R0b20gd2hlbiBzY3JvbGxpbmcuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ21kMi1kaWFsb2ctZm9vdGVyLCBtZDItZGlhbG9nLWFjdGlvbnMnIH0pXG5leHBvcnQgY2xhc3MgTWQyRGlhbG9nQWN0aW9ucyB7IH1cblxuQENvbXBvbmVudCh7XG4gIFxuICBzZWxlY3RvcjogJ21kMi1kaWFsb2cnLFxuICB0ZW1wbGF0ZVVybDogJ2RpYWxvZy5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2RpYWxvZy5zY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ2NvbmZpZz8ucm9sZScsXG4gIH0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgIHN0YXRlKCd2b2lkJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwLjMpJyB9KSksXG4gICAgICBzdGF0ZSgnaW5pdGlhbCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMC4zKScgfSkpLFxuICAgICAgc3RhdGUoJ3Zpc2libGUnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEpJyB9KSksXG4gICAgICBzdGF0ZSgnaGlkZGVuJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwLjMpJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IHZpc2libGUnLCBhbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSknKSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IGhpZGRlbicsIGFuaW1hdGUoJzE1MG1zIGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSknKSksXG4gICAgXSlcbiAgXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgZXhwb3J0QXM6ICdtZDJEaWFsb2cnXG59KVxuZXhwb3J0IGNsYXNzIE1kMkRpYWxvZyBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBfb3BlbkRpYWxvZ3NBdFRoaXNMZXZlbDogQXJyYXk8YW55PiA9IFtdO1xuICBwcml2YXRlIF9ib3VuZEtleWRvd24gPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gIHByaXZhdGUgX3BhbmVsT3BlbiA9IGZhbHNlO1xuICBwcml2YXRlIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmID0gbnVsbDtcbiAgcHJpdmF0ZSBfYmFja2Ryb3BTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgY29uZmlnOiBNZDJEaWFsb2dDb25maWc7XG5cbiAgLyoqIFByb3BlcnR5IHdhdGNoZWQgYnkgdGhlIGFuaW1hdGlvbiBmcmFtZXdvcmsgdG8gc2hvdyBvciBoaWRlIHRoZSBkaWFsb2cgKi9cbiAgX3Zpc2liaWxpdHk6IERpYWxvZ1Zpc2liaWxpdHkgPSAnaW5pdGlhbCc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwcml2YXRlIF9wYXJlbnREaWFsb2c6IE1kMkRpYWxvZykgeyB9XG5cbiAgQE91dHB1dCgpIG9uT3BlbjogRXZlbnRFbWl0dGVyPE1kMkRpYWxvZz4gPSBuZXcgRXZlbnRFbWl0dGVyPE1kMkRpYWxvZz4oKTtcbiAgQE91dHB1dCgpIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxNZDJEaWFsb2c+ID0gbmV3IEV2ZW50RW1pdHRlcjxNZDJEaWFsb2c+KCk7XG5cbiAgLyoqIFRoZSBwb3J0YWwgdG8gc2VuZCB0aGUgZGlhbG9nIGNvbnRlbnQgdGhyb3VnaCAqL1xuICBAVmlld0NoaWxkKE1kMkRpYWxvZ1BvcnRhbCkgX3BvcnRhbDogTWQyRGlhbG9nUG9ydGFsO1xuXG4gIEBJbnB1dCgndGl0bGUnKSBkaWFsb2dUaXRsZTogc3RyaW5nO1xuXG4gIG5nT25EZXN0cm95KCkgeyB0aGlzLmRlc3Ryb3lQYW5lbCgpOyB9XG5cbiAgZ2V0IF9vcGVuRGlhbG9ncygpOiBBcnJheTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RGlhbG9nID8gdGhpcy5fcGFyZW50RGlhbG9nLl9vcGVuRGlhbG9ncyA6IHRoaXMuX29wZW5EaWFsb2dzQXRUaGlzTGV2ZWw7XG4gIH1cblxuICAvKiogT3BlbiB0aGUgZGlhbG9nICovXG4gIG9wZW4oY29uZmlnPzogTWQyRGlhbG9nQ29uZmlnKTogUHJvbWlzZTxNZDJEaWFsb2c+IHtcbiAgICB0aGlzLmNvbmZpZyA9IF9hcHBseUNvbmZpZ0RlZmF1bHRzKGNvbmZpZyk7XG4gICAgaWYgKHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZTxNZDJEaWFsb2c+KHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godGhpcy5fcG9ydGFsKTtcbiAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG5cbiAgICBpZiAoIXRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCAmJiAhdGhpcy5fcGFyZW50RGlhbG9nKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcGVuRGlhbG9ncy5wdXNoKHRoaXMpO1xuICAgIHRoaXMuX3BhbmVsT3BlbiA9IHRydWU7XG4gICAgdGhpcy5fdmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlPE1kMkRpYWxvZz4odGhpcyk7XG4gIH1cblxuICAvKiogQ2xvc2UgdGhlIGRpYWxvZyAqL1xuICBjbG9zZSgpOiBQcm9taXNlPE1kMkRpYWxvZz4ge1xuICAgIHRoaXMuX3Zpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB0aGlzLl9wYW5lbE9wZW4gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMuX29wZW5EaWFsb2dzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5fb3BlbkRpYWxvZ3Muc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gbm8gb3BlbiBkaWFsb2dzIGFyZSBsZWZ0LCBjYWxsIG5leHQgb24gYWZ0ZXJBbGxDbG9zZWQgU3ViamVjdFxuICAgICAgaWYgKCF0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kS2V5ZG93bik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmU8TWQyRGlhbG9nPih0aGlzKTtcbiAgfVxuXG4gIC8qKiBSZW1vdmVzIHRoZSBwYW5lbCBmcm9tIHRoZSBET00uICovXG4gIGRlc3Ryb3lQYW5lbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICBfb25QYW5lbERvbmUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3BhbmVsT3Blbikge1xuICAgICAgdGhpcy5vbk9wZW4uZW1pdCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbkNsb3NlLmVtaXQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQgdG9wRGlhbG9nID0gdGhpcy5fb3BlbkRpYWxvZ3NbdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmIHRvcERpYWxvZyAmJlxuICAgICAgIXRvcERpYWxvZy5jb25maWcuZGlzYWJsZUNsb3NlKSB7XG4gICAgICB0b3BEaWFsb2cuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zdWJzY3JpYmVUb0JhY2tkcm9wKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb25maWcuZGlzYWJsZUNsb3NlKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+XG4gICAgICAgIHRoaXMuY2xvc2UoKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgIGxldCBjb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICBjb25maWcucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAuZ2xvYmFsKClcbiAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpXG4gICAgICAgIC5jZW50ZXJWZXJ0aWNhbGx5KCk7XG4gICAgICBjb25maWcuaGFzQmFja2Ryb3AgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jbGVhblVwU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgZGlhbG9nIGNvbmZpZy5cbiAqIEBwYXJhbSBkaWFsb2dDb25maWcgQ29uZmlnIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybnMgVGhlIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2FwcGx5Q29uZmlnRGVmYXVsdHMoZGlhbG9nQ29uZmlnOiBNZDJEaWFsb2dDb25maWcpOiBNZDJEaWFsb2dDb25maWcge1xuICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZDJEaWFsb2dDb25maWcoKSwgZGlhbG9nQ29uZmlnKTtcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgT3ZlcmxheU1vZHVsZSwgTWRDb21tb25Nb2R1bGUgfSBmcm9tICcuLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IFBsYXRmb3JtTW9kdWxlIH0gZnJvbSAnLi4vY29yZS9wbGF0Zm9ybS9pbmRleCc7XG5pbXBvcnQge1xuICBNZDJEaWFsb2csXG4gIE1kMkRpYWxvZ1RpdGxlLFxuICBNZDJEaWFsb2dDb250ZW50LFxuICBNZDJEaWFsb2dBY3Rpb25zLFxuICBNZDJEaWFsb2dQb3J0YWxcbn0gZnJvbSAnLi9kaWFsb2cnO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE92ZXJsYXlNb2R1bGUsIE1kQ29tbW9uTW9kdWxlLCBQbGF0Zm9ybU1vZHVsZV0sXG4gIGV4cG9ydHM6IFtcbiAgICBNZDJEaWFsb2csXG4gICAgTWQyRGlhbG9nVGl0bGUsXG4gICAgTWQyRGlhbG9nQ29udGVudCxcbiAgICBNZDJEaWFsb2dBY3Rpb25zLFxuICAgIE1kMkRpYWxvZ1BvcnRhbFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBNZDJEaWFsb2csXG4gICAgTWQyRGlhbG9nVGl0bGUsXG4gICAgTWQyRGlhbG9nQ29udGVudCxcbiAgICBNZDJEaWFsb2dBY3Rpb25zLFxuICAgIE1kMkRpYWxvZ1BvcnRhbFxuICBdXG59KVxuZXhwb3J0IGNsYXNzIE1kMkRpYWxvZ01vZHVsZSB7IH1cblxuXG5leHBvcnQgKiBmcm9tICcuL2RpYWxvZyc7XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW21kMi1tZW51LWNvbnRlbnRdJyxcbiAgaG9zdDogeyAncm9sZSc6ICdtZW51JyB9LFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICBzdHlsZVVybHM6IFsnbWVudS5zY3NzJ10sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIE1kMk1lbnVDb250ZW50IHsgfVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW21kMi1tZW51LWl0ZW1dJyxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ21lbnVpdGVtJ1xuICB9LFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIE1kMk1lbnVJdGVtIHsgfVxuIiwiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBSZW5kZXJlcixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttZDItbWVudS10cmlnZ2VyXScsXG4gIGhvc3Q6IHtcbiAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAnKGNsaWNrKSc6ICdfdG9nZ2xlTWVudSgpJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICdtZDJNZW51VHJpZ2dlcidcbn0pXG5leHBvcnQgY2xhc3MgTWQyTWVudVRyaWdnZXIge1xuXG4gIHByaXZhdGUgX2hhbmRsZUNsaWNrOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyKSB7IH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5faGFuZGxlQ2xpY2sgPSB0aGlzLl9yZW5kZXJlci5saXN0ZW5HbG9iYWwoJ2RvY3VtZW50JywgJ2NsaWNrJywgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9oYXNDaGlsZE1lbnUoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlTWVudSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5faGFuZGxlQ2xpY2sgPSBudWxsO1xuICB9XG5cbiAgX3RvZ2dsZU1lbnUoKSB7XG4gICAgaWYgKHRoaXMuX2hhc0NsYXNzKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSwgJ29wZW4nKSkge1xuICAgICAgdGhpcy5fY2xvc2VNZW51KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wZW5NZW51KCk7XG4gICAgfVxuICB9XG5cbiAgX29wZW5NZW51KCkge1xuICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdvcGVuJyk7XG4gICAgbGV0IHNpYmxpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNpYmxpbmdFbGVtZW50cyh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgIHNpYmxpbmdFbGVtZW50cy5mb3JFYWNoKChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuICAgICAgdGhpcy5fY2xvc2VDaGlsZHJlbk1lbnUoZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgX2Nsb3NlTWVudSgpIHtcbiAgICB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuICAgIHRoaXMuX2Nsb3NlQ2hpbGRyZW5NZW51KHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gIH1cblxuICBfY2xvc2VDaGlsZHJlbk1lbnUoZWxlbWVudDogRWxlbWVudCkge1xuICAgIFtdLmZvckVhY2guY2FsbChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5vcGVuJyksIChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BlbicpO1xuICAgIH0pO1xuICB9XG5cbiAgX2dldEhvc3RFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgX2dldFBhcmVudEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIF9nZXRTaWJsaW5nRWxlbWVudHMoZWxlbWVudDogRWxlbWVudCkge1xuICAgIGxldCBzaWJsaW5nRWxlbWVudHM6IEFycmF5PE5vZGU+ID0gW107XG4gICAgbGV0IGVsID0gZWxlbWVudC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgZm9yICg7IGVsOyBlbCA9IGVsLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSAmJiBlbCAhPT0gZWxlbWVudCkge1xuICAgICAgICBzaWJsaW5nRWxlbWVudHMucHVzaChlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaWJsaW5nRWxlbWVudHM7XG4gIH1cblxuICBfZ2V0Q2xvc2VzdEVsZW1lbnQoZWxlbWVudDogRWxlbWVudCwgdGFyZ2V0OiBzdHJpbmcpOiBFbGVtZW50IHtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudEVsOiBFbGVtZW50O1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICBwYXJlbnRFbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChwYXJlbnRFbCAmJiBwYXJlbnRFbC5oYXNBdHRyaWJ1dGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gcGFyZW50RWw7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gcGFyZW50RWw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2hhc0NsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID4gLTE7XG4gIH1cblxuICBfaGFzQ2hpbGRNZW51KGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgZWwgPSB0aGlzLl9nZXRDbG9zZXN0RWxlbWVudChldmVudC50YXJnZXQsICdtZDItbWVudS10cmlnZ2VyJyk7XG4gICAgaWYgKGVsICYmIGVsID09PSB0aGlzLl9nZXRIb3N0RWxlbWVudCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBlbCA9IHRoaXMuX2dldENsb3Nlc3RFbGVtZW50KGV2ZW50LnRhcmdldCwgJ21kMi1tZW51LWl0ZW0nKTtcbiAgICAgIGlmIChlbCAmJiBlbC5xdWVyeVNlbGVjdG9yQWxsKCdbbWQyLW1lbnUtY29udGVudF0nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG4gIE5nTW9kdWxlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBNZDJNZW51Q29udGVudCB9IGZyb20gJy4vbWVudS1jb250ZW50JztcbmltcG9ydCB7IE1kMk1lbnVJdGVtIH0gZnJvbSAnLi9tZW51LWl0ZW0nO1xuaW1wb3J0IHsgTWQyTWVudVRyaWdnZXIgfSBmcm9tICcuL21lbnUtdHJpZ2dlcic7XG5leHBvcnQgeyBNZDJNZW51Q29udGVudCB9IGZyb20gJy4vbWVudS1jb250ZW50JztcbmV4cG9ydCB7IE1kMk1lbnVJdGVtIH0gZnJvbSAnLi9tZW51LWl0ZW0nO1xuZXhwb3J0IHsgTWQyTWVudVRyaWdnZXIgfSBmcm9tICcuL21lbnUtdHJpZ2dlcic7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW21kMi1tZW51XScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIHN0eWxlVXJsczogWydtZW51LnNjc3MnXSxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbn0pXG5leHBvcnQgY2xhc3MgTWQyTWVudSB7IH1cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtNZDJNZW51LCBNZDJNZW51Q29udGVudCwgTWQyTWVudUl0ZW0sIE1kMk1lbnVUcmlnZ2VyXSxcbiAgZGVjbGFyYXRpb25zOiBbTWQyTWVudSwgTWQyTWVudUNvbnRlbnQsIE1kMk1lbnVJdGVtLCBNZDJNZW51VHJpZ2dlcl0sXG59KVxuZXhwb3J0IGNsYXNzIE1kMk1lbnVNb2R1bGUgeyB9XG4iLCJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBOZ01vZHVsZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgdGFiIGhhcyBjaGFuZ2VkLiAqL1xuZXhwb3J0IGNsYXNzIE1kMlRhYkNoYW5nZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWI6IE1kMlRhYiwgcHVibGljIGluZGV4OiBudW1iZXIpIHsgfVxufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWQyVHJhbnNjbHVkZV0nIH0pXG5leHBvcnQgY2xhc3MgTWQyVHJhbnNjbHVkZSB7XG5cbiAgcHJpdmF0ZSBfbWQyVHJhbnNjbHVkZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld1JlZjogVmlld0NvbnRhaW5lclJlZikgeyB9XG5cbiAgQElucHV0KClcbiAgZ2V0IG1kMlRyYW5zY2x1ZGUoKSB7IHJldHVybiB0aGlzLl9tZDJUcmFuc2NsdWRlOyB9XG4gIHNldCBtZDJUcmFuc2NsdWRlKHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgdGhpcy5fbWQyVHJhbnNjbHVkZSA9IHRlbXBsYXRlUmVmO1xuICAgIGlmICh0ZW1wbGF0ZVJlZikge1xuICAgICAgdGhpcy52aWV3UmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0ZW1wbGF0ZVJlZik7XG4gICAgfVxuICB9XG5cbn1cblxuQENvbXBvbmVudCh7XG4gIFxuICBzZWxlY3RvcjogJ21kMi10YWInLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzc10nOiAnY2xhc3MnLFxuICAgICdbY2xhc3MuYWN0aXZlXSc6ICdhY3RpdmUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgTWQyVGFiIHtcblxuICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuXG4gIEBJbnB1dCgpIGFjdGl2ZTogYm9vbGVhbjtcblxuICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICBASW5wdXQoKSBjbGFzczogc3RyaW5nO1xuXG4gIGxhYmVsUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG59XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttZDItdGFiLWxhYmVsXScgfSlcbmV4cG9ydCBjbGFzcyBNZDJUYWJMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgdGFiOiBNZDJUYWIpIHtcbiAgICB0YWIubGFiZWxSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQyLXRhYnMnLFxuICB0ZW1wbGF0ZVVybDogJ3RhYnMuaHRtbCcsXG4gIHN0eWxlVXJsczogWyd0YWJzLnNjc3MnXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3NdJzogJ2NsYXNzJyxcbiAgICAnKHdpbmRvdzpyZXNpemUpJzogJ29uV2luZG93UmVzaXplKCknXG4gIH0sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTWQyVGFicyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oTWQyVGFiKSB0YWJzOiBRdWVyeUxpc3Q8TWQyVGFiPjtcblxuICBwcml2YXRlIF9pc0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2ZvY3VzSW5kZXg6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX3NlbGVjdGVkSW5kZXg6IG51bWJlciA9IDA7XG4gIF9zaG91bGRQYWdpbmF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBfb2Zmc2V0TGVmdDogbnVtYmVyID0gMDtcbiAgX2lua0JhckxlZnQ6IHN0cmluZyA9ICcwJztcbiAgX2lua0JhcldpZHRoOiBzdHJpbmcgPSAnMCc7XG5cbiAgQElucHV0KCkgY2xhc3M6IHN0cmluZztcblxuICBASW5wdXQoKVxuICBnZXQgc2VsZWN0ZWRJbmRleCgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH1cbiAgc2V0IHNlbGVjdGVkSW5kZXgodmFsdWU6IGFueSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHZhbHVlID0gcGFyc2VJbnQodmFsdWUpOyB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9zZWxlY3RlZEluZGV4KSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdmFsdWU7XG4gICAgICB0aGlzLmFkanVzdE9mZnNldCh2YWx1ZSk7XG4gICAgICB0aGlzLl91cGRhdGVJbmtCYXIoKTtcbiAgICAgIGlmICh0aGlzLnRhYnMpIHtcbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicy50b0FycmF5KCk7XG4gICAgICAgIGlmICghdGFic1t2YWx1ZV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICB0YWJzLmZvckVhY2godGFiID0+IHRhYi5hY3RpdmUgPSBmYWxzZSk7XG4gICAgICAgICAgdGFic1t2YWx1ZV0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleENoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgZm9jdXNJbmRleCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZm9jdXNJbmRleDsgfVxuICBzZXQgZm9jdXNJbmRleCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fZm9jdXNJbmRleCA9IHZhbHVlO1xuICAgIHRoaXMuYWRqdXN0T2Zmc2V0KHZhbHVlKTtcbiAgfVxuXG4gIGdldCBlbGVtZW50KCkge1xuICAgIGNvbnN0IGVsZW1lbnRzOiBhbnkgPSB7XG4gICAgICByb290OiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCxcbiAgICAgIHdyYXBwZXI6IG51bGwsXG4gICAgICBjYW52YXM6IG51bGwsXG4gICAgICBwYWdpbmc6IG51bGwsXG4gICAgICB0YWJzOiBudWxsXG4gICAgfTtcbiAgICBlbGVtZW50cy53cmFwcGVyID0gZWxlbWVudHMucm9vdC5xdWVyeVNlbGVjdG9yKCcubWQyLXRhYnMtaGVhZGVyLXdyYXBwZXInKTtcbiAgICBlbGVtZW50cy5jYW52YXMgPSBlbGVtZW50cy53cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5tZDItdGFicy1jYW52YXMnKTtcbiAgICBlbGVtZW50cy5wYWdpbmcgPSBlbGVtZW50cy5jYW52YXMucXVlcnlTZWxlY3RvcignLm1kMi10YWJzLWhlYWRlcicpO1xuICAgIGVsZW1lbnRzLnRhYnMgPSBlbGVtZW50cy5wYWdpbmcucXVlcnlTZWxlY3RvckFsbCgnLm1kMi10YWItbGFiZWwnKTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICBAT3V0cHV0KCkgY2hhbmdlOiBFdmVudEVtaXR0ZXI8TWQyVGFiQ2hhbmdlPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWQyVGFiQ2hhbmdlPigpO1xuICBAT3V0cHV0KCkgc2VsZWN0ZWRJbmRleENoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBDb250ZW50IEluaXRcbiAgICovXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvbigpO1xuICAgIH0sIDApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicy50b0FycmF5KCk7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGFicy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRhYnMuZm9yRWFjaCh0YWIgPT4gdGFiLmFjdGl2ZSA9IGZhbHNlKTtcbiAgICAgICAgdGFic1t0aGlzLnNlbGVjdGVkSW5kZXhdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRqdXN0T2Zmc2V0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaW5kZXggPSB0YWJzLmZpbmRJbmRleCgodDogYW55KSA9PiB0LmFjdGl2ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICB0YWJzWzBdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZUlua0JhcigpO1xuICAgIH0sIDApO1xuICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmcm9tIHRoZSBzZWxlY3RlZCB0YWIgZm9yIHRoZSBpbmstYmFyLlxuICAgKi9cbiAgcHJpdmF0ZSBfdXBkYXRlSW5rQmFyKCk6IHZvaWQge1xuICAgIGxldCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnRzLnRhYnNbdGhpcy5zZWxlY3RlZEluZGV4XSkgeyByZXR1cm47IH1cbiAgICBsZXQgdGFiID0gZWxlbWVudHMudGFic1t0aGlzLnNlbGVjdGVkSW5kZXhdO1xuICAgIHRoaXMuX2lua0JhckxlZnQgPSB0YWIub2Zmc2V0TGVmdCArICdweCc7XG4gICAgdGhpcy5faW5rQmFyV2lkdGggPSB0YWIub2Zmc2V0V2lkdGggKyAncHgnO1xuICB9XG5cbiAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhbiBvcHRpb24uICovXG4gIF9lbWl0Q2hhbmdlRXZlbnQoKTogdm9pZCB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICB0aGlzLmNoYW5nZS5lbWl0KG5ldyBNZDJUYWJDaGFuZ2UodGhpcy50YWJzLnRvQXJyYXkoKVtpbmRleF0sIGluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXMgbmV4dCBUYWJcbiAgICovXG4gIGZvY3VzTmV4dFRhYigpIHsgdGhpcy5pbmNyZW1lbnRJbmRleCgxKTsgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyBwcmV2aW91cyBUYWJcbiAgICovXG4gIGZvY3VzUHJldmlvdXNUYWIoKSB7IHRoaXMuaW5jcmVtZW50SW5kZXgoLTEpOyB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIFdoZWVsIHNjcm9sbFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIHNjcm9sbChldmVudDogYW55KSB7XG4gICAgaWYgKCF0aGlzLl9zaG91bGRQYWdpbmF0ZSkgeyByZXR1cm47IH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuX29mZnNldExlZnQgPSB0aGlzLmZpeE9mZnNldCh0aGlzLl9vZmZzZXRMZWZ0IC0gZXZlbnQud2hlZWxEZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogTmV4dCBQYWdlXG4gICAqL1xuICBuZXh0UGFnZSgpIHtcbiAgICBsZXQgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnQ7XG4gICAgbGV0IHZpZXdwb3J0V2lkdGggPSBlbGVtZW50cy5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICB0b3RhbFdpZHRoID0gdmlld3BvcnRXaWR0aCArIHRoaXMuX29mZnNldExlZnQsXG4gICAgICBpOiBudW1iZXIsIHRhYjogYW55O1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy50YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YWIgPSBlbGVtZW50cy50YWJzW2ldO1xuICAgICAgaWYgKHRhYi5vZmZzZXRMZWZ0ICsgdGFiLm9mZnNldFdpZHRoID4gdG90YWxXaWR0aCkgeyBicmVhazsgfVxuICAgIH1cbiAgICB0aGlzLl9vZmZzZXRMZWZ0ID0gdGhpcy5maXhPZmZzZXQodGFiLm9mZnNldExlZnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIFBhZ2VcbiAgICovXG4gIHByZXZpb3VzUGFnZSgpIHtcbiAgICBsZXQgaTogbnVtYmVyLCB0YWI6IGFueSwgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMudGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFiID0gZWxlbWVudHMudGFic1tpXTtcbiAgICAgIGlmICh0YWIub2Zmc2V0TGVmdCArIHRhYi5vZmZzZXRXaWR0aCA+PSB0aGlzLl9vZmZzZXRMZWZ0KSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHRoaXMuX29mZnNldExlZnQgPSB0aGlzLmZpeE9mZnNldCh0YWIub2Zmc2V0TGVmdCArXG4gICAgICB0YWIub2Zmc2V0V2lkdGggLSBlbGVtZW50cy5jYW52YXMuY2xpZW50V2lkdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIFdpbmRvdyBSZXNpemVcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICB0aGlzLl9vZmZzZXRMZWZ0ID0gdGhpcy5maXhPZmZzZXQodGhpcy5fb2Zmc2V0TGVmdCk7XG4gICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuIHBhZ2UgQmFja1xuICAgKi9cbiAgY2FuUGFnZUJhY2soKSB7IHJldHVybiB0aGlzLl9vZmZzZXRMZWZ0ID4gMDsgfVxuXG4gIC8qKlxuICAgKiBDYW4gcGFnZSBQcmV2aW91c1xuICAgKi9cbiAgY2FuUGFnZUZvcndhcmQoKSB7XG4gICAgbGV0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50O1xuICAgIGxldCBsYXN0VGFiID0gZWxlbWVudHMudGFic1tlbGVtZW50cy50YWJzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBsYXN0VGFiICYmIGxhc3RUYWIub2Zmc2V0TGVmdCArIGxhc3RUYWIub2Zmc2V0V2lkdGggPiBlbGVtZW50cy5jYW52YXMuY2xpZW50V2lkdGggK1xuICAgICAgdGhpcy5fb2Zmc2V0TGVmdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgUGFnaW5hdGlvblxuICAgKi9cbiAgdXBkYXRlUGFnaW5hdGlvbigpIHtcbiAgICBsZXQgY2FudmFzV2lkdGggPSB0aGlzLmVsZW1lbnQucm9vdC5jbGllbnRXaWR0aDtcbiAgICBsZXQgdGFiczogYW55W10gPSB0aGlzLmVsZW1lbnQudGFicyA/IHRoaXMuZWxlbWVudC50YWJzIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW52YXNXaWR0aCAtPSB0YWJzW2ldLm9mZnNldFdpZHRoO1xuICAgIH1cbiAgICB0aGlzLl9zaG91bGRQYWdpbmF0ZSA9IGNhbnZhc1dpZHRoIDwgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgRm9jdXMgVGFiXG4gICAqIEBwYXJhbSBpbmNcbiAgICovXG4gIGluY3JlbWVudEluZGV4KGluYzogYW55KSB7XG4gICAgbGV0IG5ld0luZGV4OiBudW1iZXIsXG4gICAgICBpbmRleCA9IHRoaXMuZm9jdXNJbmRleDtcbiAgICBmb3IgKG5ld0luZGV4ID0gaW5kZXggKyBpbmM7XG4gICAgICB0aGlzLnRhYnMudG9BcnJheSgpW25ld0luZGV4XSAmJiB0aGlzLnRhYnMudG9BcnJheSgpW25ld0luZGV4XS5kaXNhYmxlZDtcbiAgICAgIG5ld0luZGV4ICs9IGluYykgeyB9XG4gICAgaWYgKHRoaXMudGFicy50b0FycmF5KClbbmV3SW5kZXhdKSB7XG4gICAgICB0aGlzLmZvY3VzSW5kZXggPSBuZXdJbmRleDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IE9mZnNldCBvZiBUYWJcbiAgICogQHBhcmFtIGluZGV4XG4gICAqL1xuICBhZGp1c3RPZmZzZXQoaW5kZXg6IG51bWJlcikge1xuICAgIGxldCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnRzLnRhYnNbaW5kZXhdKSB7IHJldHVybjsgfVxuICAgIGxldCB0YWIgPSBlbGVtZW50cy50YWJzW2luZGV4XSxcbiAgICAgIGxlZnQgPSB0YWIub2Zmc2V0TGVmdCxcbiAgICAgIHJpZ2h0ID0gdGFiLm9mZnNldFdpZHRoICsgbGVmdDtcbiAgICB0aGlzLl9vZmZzZXRMZWZ0ID0gTWF0aC5tYXgodGhpcy5fb2Zmc2V0TGVmdCxcbiAgICAgIHRoaXMuZml4T2Zmc2V0KHJpZ2h0IC0gZWxlbWVudHMuY2FudmFzLmNsaWVudFdpZHRoICsgMzIgKiAyKSk7XG4gICAgdGhpcy5fb2Zmc2V0TGVmdCA9IE1hdGgubWluKHRoaXMuX29mZnNldExlZnQsIHRoaXMuZml4T2Zmc2V0KGxlZnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggT2Zmc2V0IG9mIFRhYlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiB2YWx1ZVxuICAgKi9cbiAgZml4T2Zmc2V0KHZhbHVlOiBhbnkpIHtcbiAgICBsZXQgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50cy50YWJzLmxlbmd0aCB8fCAhdGhpcy5fc2hvdWxkUGFnaW5hdGUpIHsgcmV0dXJuIDA7IH1cbiAgICBsZXQgbGFzdFRhYiA9IGVsZW1lbnRzLnRhYnNbZWxlbWVudHMudGFicy5sZW5ndGggLSAxXSxcbiAgICAgIHRvdGFsV2lkdGggPSBsYXN0VGFiLm9mZnNldExlZnQgKyBsYXN0VGFiLm9mZnNldFdpZHRoO1xuICAgIHZhbHVlID0gTWF0aC5taW4odG90YWxXaWR0aCAtIGVsZW1lbnRzLmNhbnZhcy5jbGllbnRXaWR0aCwgdmFsdWUpO1xuICAgIHZhbHVlID0gTWF0aC5tYXgoMCwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBNRDJfVEFCU19ESVJFQ1RJVkVTOiBhbnlbXSA9IFtNZDJUYWJMYWJlbCwgTWQyVGFicywgTWQyVGFiXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IE1EMl9UQUJTX0RJUkVDVElWRVMsXG4gIGRlY2xhcmF0aW9uczogW01kMlRyYW5zY2x1ZGUsIE1kMlRhYkxhYmVsLCBNZDJUYWJzLCBNZDJUYWJdLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJUYWJzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBjb2VyY2VCb29sZWFuUHJvcGVydHksXG4gIExFRlRfQVJST1csXG4gIFJJR0hUX0FSUk9XLFxuICBCQUNLU1BBQ0UsXG4gIERFTEVURSxcbiAgVEFCLFxuICBFU0NBUEVcbn0gZnJvbSAnLi4vY29yZS9jb3JlJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcblxubGV0IG5leHRJZCA9IDA7XG5cbmV4cG9ydCBjbGFzcyBUYWcge1xuICB0ZXh0OiBzdHJpbmc7XG4gIHZhbHVlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioc291cmNlOiBhbnksIHRleHRLZXk6IHN0cmluZywgdmFsdWVLZXk6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy52YWx1ZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLnRleHQgPSBzb3VyY2VbdGV4dEtleV07XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVLZXkgPyBzb3VyY2VbdmFsdWVLZXldIDogc291cmNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUQyX1RBR1NfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWQyVGFncyksXG4gIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgXG4gIHNlbGVjdG9yOiAnbWQyLXRhZ3MnLFxuICB0ZW1wbGF0ZVVybDogJ3RhZ3MuaHRtbCcsXG4gIHN0eWxlVXJsczogWyd0YWdzLnNjc3MnXSxcbiAgaG9zdDoge1xuICAgICdyb2xlJzogJ3RhZ3MnLFxuICAgICdbaWRdJzogJ2lkJyxcbiAgICAnW2NsYXNzLmZvY3VzXSc6ICdfaW5wdXRGb2N1c2VkIHx8IF9zZWxlY3RlZFRhZyA+PSAwJyxcbiAgICAnW2NsYXNzLm1kMi10YWdzLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgJ1t0YWJpbmRleF0nOiAnZGlzYWJsZWQgPyAtMSA6IHRhYmluZGV4JyxcbiAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gIH0sXG4gIHByb3ZpZGVyczogW01EMl9UQUdTX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICBleHBvcnRBczogJ21kMlRhZ3MnXG59KVxuXG5leHBvcnQgY2xhc3MgTWQyVGFncyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmKSB7IH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7IHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlOyB9XG5cbiAgQE91dHB1dCgpIGNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBwcml2YXRlIF92YWx1ZTogYW55ID0gJyc7XG4gIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2lzSW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSBub29wO1xuICBwcml2YXRlIF9vbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcblxuICBwcml2YXRlIF90YWdzOiBBcnJheTxhbnk+ID0gW107XG4gIF9saXN0OiBBcnJheTxUYWc+ID0gW107XG4gIF9pdGVtczogQXJyYXk8VGFnPiA9IFtdO1xuXG4gIF9mb2N1c2VkVGFnOiBudW1iZXIgPSAwO1xuICBfc2VsZWN0ZWRUYWc6IG51bWJlciA9IC0xO1xuICBfaW5wdXRWYWx1ZTogc3RyaW5nID0gJyc7XG4gIF9pbnB1dEZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBub0JsdXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSAnbWQyLXRhZ3MtJyArICgrK25leHRJZCk7XG4gIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nID0gJyc7XG4gIEBJbnB1dCgnbWQyLXRhZy10ZXh0JykgdGV4dEtleTogc3RyaW5nID0gJ3RleHQnO1xuICBASW5wdXQoJ21kMi10YWctdmFsdWUnKSB2YWx1ZUtleTogc3RyaW5nID0gbnVsbDtcblxuICBASW5wdXQoKVxuICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfVxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XG5cbiAgQElucHV0KCdtZDItdGFncycpXG4gIHNldCB0YWdzKHZhbHVlOiBBcnJheTxhbnk+KSB7IHRoaXMuX3RhZ3MgPSB2YWx1ZTsgfVxuXG4gIEBJbnB1dCgpXG4gIGdldCB2YWx1ZSgpOiBhbnkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHsgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7IH1cblxuICAvKipcbiAgICogc2V0dXAgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwcml2YXRlIHNldFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNlbEl0bSA9IHRoaXMuX3RhZ3MuZmluZCgodDogYW55KSA9PiB0aGlzLmVxdWFscyh0aGlzLnZhbHVlS2V5ID9cbiAgICAgICAgICAgIHRbdGhpcy52YWx1ZUtleV0gOiB0LCB2YWx1ZVtpXSkpO1xuICAgICAgICAgIGlmIChzZWxJdG0pIHsgdGhpcy5faXRlbXMucHVzaChuZXcgVGFnKHNlbEl0bSwgdGhpcy50ZXh0S2V5LCB0aGlzLnZhbHVlS2V5KSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHR3byB2YXJzIG9yIG9iamVjdHNcbiAgICogQHBhcmFtIG8xIGNvbXBhcmUgZmlyc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSBvMiBjb21wYXJlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiBib29sZWFuIGNvbXBhcmF0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHJpdmF0ZSBlcXVhbHMobzE6IGFueSwgbzI6IGFueSkge1xuICAgIGlmIChvMSA9PT0gbzIpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKG8xICE9PSBvMSAmJiBvMiAhPT0gbzIpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBsZXQgdDEgPSB0eXBlb2YgbzEsIHQyID0gdHlwZW9mIG8yLCBrZXk6IGFueSwga2V5U2V0OiBhbnk7XG4gICAgaWYgKHQxID09PSB0MiAmJiB0MSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGtleVNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKGtleSBpbiBvMSkge1xuICAgICAgICBpZiAoIXRoaXMuZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBrZXlTZXRba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBvMikge1xuICAgICAgICBpZiAoIShrZXkgaW4ga2V5U2V0KSAmJiBrZXkuY2hhckF0KDApICE9PSAnJCcgJiYgbzJba2V5XSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgaXNNZW51VmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKCh0aGlzLl9pbnB1dEZvY3VzZWQgfHwgdGhpcy5ub0JsdXIpICYmIHRoaXMuX2lucHV0VmFsdWUgJiZcbiAgICAgIHRoaXMuX2xpc3QgJiYgdGhpcy5fbGlzdC5sZW5ndGgpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSBzY3JvbGwgb2YgdGFncyBzdWdnZXN0aW9uIG1lbnVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlU2Nyb2xsKCkge1xuICAgIGlmICh0aGlzLl9mb2N1c2VkVGFnIDwgMCkgeyByZXR1cm47IH1cbiAgICBsZXQgbWVudUNvbnRhaW5lciA9IHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWQyLXRhZ3MtbWVudScpO1xuICAgIGlmICghbWVudUNvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICAgIGxldCBjaG9pY2VzID0gbWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcubWQyLW9wdGlvbicpO1xuICAgIGlmIChjaG9pY2VzLmxlbmd0aCA8IDEpIHsgcmV0dXJuOyB9XG5cbiAgICBsZXQgaGlnaGxpZ2h0ZWQ6IGFueSA9IGNob2ljZXNbdGhpcy5fZm9jdXNlZFRhZ107XG4gICAgaWYgKCFoaWdobGlnaHRlZCkgeyByZXR1cm47IH1cblxuICAgIGxldCB0b3A6IG51bWJlciA9IGhpZ2hsaWdodGVkLm9mZnNldFRvcCArIGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIG1lbnVDb250YWluZXIuc2Nyb2xsVG9wO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IG1lbnVDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgaWYgKHRvcCA+IGhlaWdodCkge1xuICAgICAgbWVudUNvbnRhaW5lci5zY3JvbGxUb3AgKz0gdG9wIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodG9wIDwgaGlnaGxpZ2h0ZWQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBtZW51Q29udGFpbmVyLnNjcm9sbFRvcCAtPSBoaWdobGlnaHRlZC5jbGllbnRIZWlnaHQgLSB0b3A7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGlucHV0IGtleSBsaXN0ZW5lclxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICovXG4gIF9oYW5kbGVJbnB1dEtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBCYWNrc3BhY2VcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gOCAmJiAhdGhpcy5faW5wdXRWYWx1ZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCAmJiB0aGlzLl9zZWxlY3RlZFRhZyA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RBbmRGb2N1c1RhZ1NhZmUodGhpcy5faXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoICYmIHRoaXMuX3NlbGVjdGVkVGFnID4gLTEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmRTZWxlY3RBZGphY2VudFRhZyh0aGlzLl9zZWxlY3RlZFRhZyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbCBLZXlcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gNDYgJiYgIXRoaXMuX2lucHV0VmFsdWUpIHsgcmV0dXJuOyB9XG4gICAgLy8gTGVmdCAvIFJpZ2h0IEFycm93XG4gICAgaWYgKChldmVudC5rZXlDb2RlID09PSAzNyB8fCBldmVudC5rZXlDb2RlID09PSAzOSkgJiYgIXRoaXMuX2lucHV0VmFsdWUpIHsgcmV0dXJuOyB9XG4gICAgLy8gRG93biBBcnJvd1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmlzTWVudVZpc2libGUpIHsgcmV0dXJuOyB9XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9mb2N1c2VkVGFnID0gKHRoaXMuX2ZvY3VzZWRUYWcgPT09IHRoaXMuX2xpc3QubGVuZ3RoIC0gMSkgP1xuICAgICAgICAwIDogTWF0aC5taW4odGhpcy5fZm9jdXNlZFRhZyArIDEsIHRoaXMuX2xpc3QubGVuZ3RoIC0gMSk7XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVcCBBcnJvd1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAzOCkge1xuICAgICAgaWYgKCF0aGlzLmlzTWVudVZpc2libGUpIHsgcmV0dXJuOyB9XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9mb2N1c2VkVGFnID0gKHRoaXMuX2ZvY3VzZWRUYWcgPT09IDApID9cbiAgICAgICAgdGhpcy5fbGlzdC5sZW5ndGggLSAxIDogTWF0aC5tYXgoMCwgdGhpcy5fZm9jdXNlZFRhZyAtIDEpO1xuICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGFiIEtleVxuICAgIGlmIChldmVudC5rZXlDb2RlID09PSA5KSB7IHJldHVybjsgfVxuICAgIC8vIEVudGVyIC8gU3BhY2VcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgIGlmICghdGhpcy5faW5wdXRWYWx1ZSB8fCAhdGhpcy5pc01lbnVWaXNpYmxlKSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IHJldHVybjsgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2FkZFRhZyhldmVudCwgdGhpcy5fZm9jdXNlZFRhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEVzY2FwZSBLZXlcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFZhbHVlKSB7IHRoaXMuX2lucHV0VmFsdWUgPSAnJzsgfVxuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkVGFnID49IDApIHsgdGhpcy5faGFuZGxlRm9jdXMoKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyByZXNldCBzZWxlY3RlZCB0YWdcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRUYWcgPj0gMCkgeyB0aGlzLnJlc2V0c2VsZWN0ZWRUYWcoKTsgfVxuICAgIC8vIGZpbHRlclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJNYXRjaGVzKCk7XG4gICAgfSwgMTApO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5faW5wdXRWYWx1ZSkgeyByZXR1cm47IH1cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgQkFDS1NQQUNFOlxuICAgICAgY2FzZSBERUxFVEU6XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFRhZyA8IDApIHsgcmV0dXJuOyB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5kU2VsZWN0QWRqYWNlbnRUYWcodGhpcy5fc2VsZWN0ZWRUYWcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUQUI6XG4gICAgICBjYXNlIEVTQ0FQRTpcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkVGFnIDwgMCkgeyByZXR1cm47IH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlRm9jdXMoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkVGFnIDwgMCkgeyB0aGlzLl9zZWxlY3RlZFRhZyA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgfVxuICAgICAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoKSB7IHRoaXMuc2VsZWN0QW5kRm9jdXNUYWdTYWZlKHRoaXMuX3NlbGVjdGVkVGFnIC0gMSk7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRUYWcgPj0gdGhpcy5faXRlbXMubGVuZ3RoKSB7IHRoaXMuX3NlbGVjdGVkVGFnID0gLTE7IH1cbiAgICAgICAgdGhpcy5zZWxlY3RBbmRGb2N1c1RhZ1NhZmUodGhpcy5fc2VsZWN0ZWRUYWcgKyAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVBbmRTZWxlY3RBZGphY2VudFRhZyhpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHNlbEluZGV4ID0gdGhpcy5nZXRBZGphY2VudFRhZ0luZGV4KGluZGV4KTtcbiAgICB0aGlzLnJlbW92ZVRhZyhpbmRleCk7XG4gICAgdGhpcy5zZWxlY3RBbmRGb2N1c1RhZ1NhZmUoc2VsSW5kZXgpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldHNlbGVjdGVkVGFnKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkVGFnID0gLTE7XG4gIH1cblxuICBwcml2YXRlIGdldEFkamFjZW50VGFnSW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIGxldCBsZW4gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiAobGVuID09PSAwKSA/IC0xIDpcbiAgICAgIChpbmRleCA9PT0gbGVuKSA/IGluZGV4IC0gMSA6IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZCB0YWdcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSBpbmRleCBpbmRleCBvZiB0aGUgc3BlY2lmaWMgdGFnXG4gICAqL1xuICBfYWRkVGFnKGV2ZW50OiBFdmVudCwgaW5kZXg6IG51bWJlcikge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faXRlbXMucHVzaCh0aGlzLl9saXN0W2luZGV4XSk7XG4gICAgdGhpcy5faW5wdXRWYWx1ZSA9ICcnO1xuICAgIHRoaXMudXBkYXRlVmFsdWUoKTtcbiAgfVxuXG4gIF9yZW1vdmVUYWdBbmRGb2N1c0lucHV0KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhpbmRleCk7XG4gICAgdGhpcy5faGFuZGxlRm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgdGFnXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVUYWcoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy51cGRhdGVWYWx1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB2YWx1ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZSgpIHtcbiAgICB0aGlzLl92YWx1ZSA9IG5ldyBBcnJheTxhbnk+KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fdmFsdWUucHVzaCh0aGlzLl9pdGVtc1tpXS52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fdmFsdWUpO1xuICAgIHRoaXMuY2hhbmdlLmVtaXQodGhpcy5fdmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZWxlY3RBbmRGb2N1c1RhZ1NhZmUgPSBmdW5jdGlvbiAoaW5kZXg6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZWxlY3RUYWcoLTEpO1xuICAgICAgdGhpcy5faGFuZGxlRm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuX2hhbmRsZUZvY3VzKCk7IH1cbiAgICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLl9pdGVtcy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLl9zZWxlY3RUYWcoaW5kZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZWxlY3QgdGFnXG4gICAqIEBwYXJhbSBpbmRleCBvZiBzZWxlY3QgdGFnXG4gICAqL1xuICBfc2VsZWN0VGFnKGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoaW5kZXggPj0gLTEgJiYgaW5kZXggPD0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZFRhZyA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgX2hhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKCk7XG4gICAgdGhpcy5yZXNldHNlbGVjdGVkVGFnKCk7XG4gIH1cblxuICBfb25JbnB1dEZvY3VzKCkge1xuICAgIHRoaXMuX2lucHV0Rm9jdXNlZCA9IHRydWU7XG4gICAgdGhpcy5yZXNldHNlbGVjdGVkVGFnKCk7XG4gIH1cblxuICBfb25JbnB1dEJsdXIoKSB7XG4gICAgdGhpcy5faW5wdXRGb2N1c2VkID0gZmFsc2U7XG4gIH1cblxuICBfbGlzdEVudGVyKCkgeyB0aGlzLm5vQmx1ciA9IHRydWU7IH1cblxuICBfbGlzdExlYXZlKCkgeyB0aGlzLm5vQmx1ciA9IGZhbHNlOyB9XG5cbiAgLyoqXG4gICAqIHVwZGF0ZSBzdWdnZXN0aW9uIG1lbnUgd2l0aCBmaWx0ZXJcbiAgICogQHBhcmFtIHF1ZXJ5XG4gICAqL1xuICBwcml2YXRlIGZpbHRlck1hdGNoZXMoKSB7XG4gICAgbGV0IHRlbXBMaXN0ID0gdGhpcy5fdGFncy5tYXAoKHRhZzogYW55KSA9PiBuZXcgVGFnKHRhZywgdGhpcy50ZXh0S2V5LCB0aGlzLnZhbHVlS2V5KSk7XG4gICAgdGhpcy5fbGlzdCA9IHRlbXBMaXN0LmZpbHRlcigodDogVGFnKSA9PlxuICAgICAgKG5ldyBSZWdFeHAodGhpcy5faW5wdXRWYWx1ZSwgJ2lnJykudGVzdCh0LnRleHQpICYmXG4gICAgICAgICF0aGlzLl9pdGVtcy5maW5kKChpOiBUYWcpID0+IHQudGV4dCA9PT0gaS50ZXh0KSkpO1xuICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2ZvY3VzZWRUYWcgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2VsSXRtID0gdGhpcy5fdGFncy5maW5kKCh0OiBhbnkpID0+IHRoaXMuZXF1YWxzKHRoaXMudmFsdWVLZXkgP1xuICAgICAgICAgICAgdFt0aGlzLnZhbHVlS2V5XSA6IHQsIHZhbHVlW2ldKSk7XG4gICAgICAgICAgaWYgKHNlbEl0bSkgeyB0aGlzLl9pdGVtcy5wdXNoKG5ldyBUYWcoc2VsSXRtLCB0aGlzLnRleHRLZXksIHRoaXMudmFsdWVLZXkpKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KSB7IHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBmbjsgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHsgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjsgfVxuXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNZDJBdXRvY29tcGxldGVNb2R1bGUgfSBmcm9tICcuLi9hdXRvY29tcGxldGUvaW5kZXgnO1xuaW1wb3J0IHsgTWQyVGFncyB9IGZyb20gJy4vdGFncyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vdGFncyc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBNZDJBdXRvY29tcGxldGVNb2R1bGVdLFxuICBleHBvcnRzOiBbTWQyVGFnc10sXG4gIGRlY2xhcmF0aW9uczogW01kMlRhZ3NdLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJUYWdzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBJbmplY3RhYmxlLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBWaWV3RW5jYXBzdWxhdGlvbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBPdmVybGF5LFxuICBPdmVybGF5U3RhdGUsXG4gIE92ZXJsYXlSZWYsXG4gIENvbXBvbmVudFBvcnRhbCxcbn0gZnJvbSAnLi4vY29yZS9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBUb2FzdCB7XG4gIGlkOiBudW1iZXI7XG4gIGlzVmlzaWJsZTogYm9vbGVhbjtcbiAgY29uc3RydWN0b3IocHVibGljIG1lc3NhZ2U6IHN0cmluZykgeyB9XG59XG5cbmV4cG9ydCBjbGFzcyBNZDJUb2FzdENvbmZpZyB7XG4gIGR1cmF0aW9uOiBudW1iZXIgPSAzMDAwO1xuICB2aWV3Q29udGFpbmVyUmVmPzogVmlld0NvbnRhaW5lclJlZiA9IG51bGw7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZDJUb2FzdCB7XG4gIHByaXZhdGUgaW5kZXg6IG51bWJlciA9IDA7XG5cbiAgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWY7XG4gIF90b2FzdEluc3RhbmNlOiBNZDJUb2FzdENvbXBvbmVudDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwcml2YXRlIF9jb25maWc6IE1kMlRvYXN0Q29uZmlnKSB7IH1cblxuICAvKipcbiAgICogdG9hc3QgbWVzc2FnZVxuICAgKiBAcGFyYW0gdG9hc3Qgc3RyaW5nIG9yIG9iamVjdCB3aXRoIG1lc3NhZ2UgYW5kIG90aGVyIHByb3BlcnRpZXMgb2YgdG9hc3RcbiAgICovXG4gIHRvYXN0KG1lc3NhZ2U6IHN0cmluZywgZHVyYXRpb24/OiBudW1iZXIpIHtcbiAgICB0aGlzLnNob3cobWVzc2FnZSwgZHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIHNob3cgdG9hc3RcbiAgICogQHBhcmFtIHRvYXN0T2JqIHN0cmluZyBvciBvYmplY3Qgd2l0aCBtZXNzYWdlIGFuZCBvdGhlciBwcm9wZXJ0aWVzIG9mIHRvYXN0XG4gICAqL1xuICBzaG93KG1lc3NhZ2U6IHN0cmluZywgZHVyYXRpb24/OiBudW1iZXIpIHtcbiAgICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudHJpbSgpKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGR1cmF0aW9uKSB7IHRoaXMuX2NvbmZpZy5kdXJhdGlvbiA9IGR1cmF0aW9uOyB9XG5cbiAgICBsZXQgdG9hc3Q6IFRvYXN0O1xuICAgIHRvYXN0ID0gbmV3IFRvYXN0KG1lc3NhZ2UpO1xuXG4gICAgaWYgKHRvYXN0KSB7XG4gICAgICBpZiAoIXRoaXMuX3RvYXN0SW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlVG9hc3QoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0VG9hc3RNZXNzYWdlKHRvYXN0KTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIHRoZSB0b2FzdCB0byBkaXNwbGF5ICovXG4gIHByaXZhdGUgX2NyZWF0ZVRvYXN0KCk6IHZvaWQge1xuICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICBsZXQgcG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZDJUb2FzdENvbXBvbmVudCwgdGhpcy5fY29uZmlnLnZpZXdDb250YWluZXJSZWYpO1xuICAgIHRoaXMuX3RvYXN0SW5zdGFuY2UgPSB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaChwb3J0YWwpLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqIENyZWF0ZSB0aGUgb3ZlcmxheSBjb25maWcgYW5kIHBvc2l0aW9uIHN0cmF0ZWd5ICovXG4gIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICBsZXQgY29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgLmdsb2JhbCgpXG4gICAgICAgIC50b3AoJzAnKS5yaWdodCgnMCcpO1xuXG4gICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICAvKiogRGlzcG9zZXMgdGhlIGN1cnJlbnQgdG9hc3QgYW5kIHRoZSBvdmVybGF5IGl0IGlzIGF0dGFjaGVkIHRvICovXG4gIHByaXZhdGUgX2Rpc3Bvc2VUb2FzdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICB0aGlzLl90b2FzdEluc3RhbmNlID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSB0b2FzdCBtZXNzYWdlIGFuZCByZXBvc2l0aW9ucyB0aGUgb3ZlcmxheSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBtZXNzYWdlIGxlbmd0aCAqL1xuICBwcml2YXRlIF9zZXRUb2FzdE1lc3NhZ2UodG9hc3Q6IFRvYXN0KSB7XG4gICAgdG9hc3QuaWQgPSArK3RoaXMuaW5kZXg7XG4gICAgdGhpcy5fdG9hc3RJbnN0YW5jZS5hZGRUb2FzdCh0b2FzdCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyVG9hc3QodG9hc3QuaWQpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kdXJhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogY2xlYXIgc3BlY2lmaWMgdG9hc3RcbiAgICogQHBhcmFtIHRvYXN0SWRcbiAgICovXG4gIHByaXZhdGUgY2xlYXJUb2FzdCh0b2FzdElkOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fdG9hc3RJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fdG9hc3RJbnN0YW5jZS5yZW1vdmVUb2FzdCh0b2FzdElkKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3RvYXN0SW5zdGFuY2UuaGFzVG9hc3QoKSkgeyB0aGlzLl9kaXNwb3NlVG9hc3QoKTsgfVxuICAgICAgfSwgMjUwKTtcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjbGVhciBhbGwgdG9hc3RzXG4gICAqL1xuICBjbGVhckFsbFRvYXN0cygpIHtcbiAgICBpZiAodGhpcy5fdG9hc3RJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fdG9hc3RJbnN0YW5jZS5yZW1vdmVBbGxUb2FzdHMoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3RvYXN0SW5zdGFuY2UuaGFzVG9hc3QoKSkgeyB0aGlzLl9kaXNwb3NlVG9hc3QoKTsgfVxuICAgICAgfSwgMjUwKTtcblxuICAgIH1cbiAgfVxuXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21kMi10b2FzdCcsXG4gIHRlbXBsYXRlVXJsOiAndG9hc3QuaHRtbCcsXG4gIHN0eWxlVXJsczogWyd0b2FzdC5zY3NzJ10sXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIE1kMlRvYXN0Q29tcG9uZW50IHtcbiAgdG9hc3RzOiBUb2FzdFtdID0gW107XG4gIG1heFNob3duID0gNTtcblxuICAvKipcbiAgICogYWRkIHRvYXN0XG4gICAqIEBwYXJhbSB0b2FzdCB0b2FzdCBvYmplY3Qgd2l0aCBhbGwgcGFyYW1ldGVyc1xuICAgKi9cbiAgYWRkVG9hc3QodG9hc3Q6IFRvYXN0KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0b2FzdC5pc1Zpc2libGUgPSB0cnVlO1xuICAgIH0sIDEpO1xuICAgIHRoaXMudG9hc3RzLnB1c2godG9hc3QpO1xuICAgIGlmICh0aGlzLnRvYXN0cy5sZW5ndGggPiB0aGlzLm1heFNob3duKSB7XG4gICAgICB0aGlzLnRvYXN0c1swXS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRvYXN0cy5zcGxpY2UoMCwgKHRoaXMudG9hc3RzLmxlbmd0aCAtIHRoaXMubWF4U2hvd24pKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSB0b2FzdFxuICAgKiBAcGFyYW0gdG9hc3RJZCBudW1iZXIgb2YgdG9hc3QgaWRcbiAgICovXG4gIHJlbW92ZVRvYXN0KHRvYXN0SWQ6IG51bWJlcikge1xuICAgIHRoaXMudG9hc3RzLmZvckVhY2goKHQ6IGFueSkgPT4geyBpZiAodC5pZCA9PT0gdG9hc3RJZCkgeyB0LmlzVmlzaWJsZSA9IGZhbHNlOyB9IH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50b2FzdHMgPSB0aGlzLnRvYXN0cy5maWx0ZXIoKHRvYXN0KSA9PiB7IHJldHVybiB0b2FzdC5pZCAhPT0gdG9hc3RJZDsgfSk7XG4gICAgfSwgMjUwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYWxsIHRvYXN0c1xuICAgKiBAcGFyYW0gdG9hc3RJZCBudW1iZXIgb2YgdG9hc3QgaWRcbiAgICovXG4gIHJlbW92ZUFsbFRvYXN0cygpIHtcbiAgICB0aGlzLnRvYXN0cy5mb3JFYWNoKCh0OiBhbnkpID0+IHsgdC5pc1Zpc2libGUgPSBmYWxzZTsgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRvYXN0cyA9IFtdO1xuICAgIH0sIDI1MCk7XG4gIH1cblxuICAvKipcbiAgICogY2hlY2sgaGFzIGFueSB0b2FzdFxuICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICovXG4gIGhhc1RvYXN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy50b2FzdHMubGVuZ3RoID4gMDsgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE92ZXJsYXlNb2R1bGUsIE1kQ29tbW9uTW9kdWxlIH0gZnJvbSAnLi4vY29yZS9pbmRleCc7XG5pbXBvcnQgeyBQbGF0Zm9ybU1vZHVsZSB9IGZyb20gJy4uL2NvcmUvcGxhdGZvcm0vaW5kZXgnO1xuaW1wb3J0IHsgTWQyVG9hc3QsIE1kMlRvYXN0Q29uZmlnLCBNZDJUb2FzdENvbXBvbmVudCB9IGZyb20gJy4vdG9hc3QnO1xuXG5leHBvcnQgKiBmcm9tICcuL3RvYXN0JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIE1kQ29tbW9uTW9kdWxlLFxuICAgIFBsYXRmb3JtTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtNZDJUb2FzdENvbXBvbmVudCwgTWRDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtNZDJUb2FzdENvbXBvbmVudF0sXG4gIGVudHJ5Q29tcG9uZW50czogW01kMlRvYXN0Q29tcG9uZW50XSxcbiAgcHJvdmlkZXJzOiBbTWQyVG9hc3QsIE1kMlRvYXN0Q29uZmlnXSxcbn0pXG5leHBvcnQgY2xhc3MgTWQyVG9hc3RNb2R1bGUgeyB9XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIERpcmVjdGl2ZSxcbiAgSW5wdXQsXG4gIEVsZW1lbnRSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIE5nWm9uZSxcbiAgT3B0aW9uYWwsXG4gIE9uRGVzdHJveSxcbiAgUmVuZGVyZXIyLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgVmlld0VuY2Fwc3VsYXRpb24sXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgc3R5bGUsXG4gIHRyaWdnZXIsXG4gIHN0YXRlLFxuICB0cmFuc2l0aW9uLFxuICBhbmltYXRlLFxuICBBbmltYXRpb25FdmVudCxcbn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBPdmVybGF5LFxuICBPdmVybGF5U3RhdGUsXG4gIE92ZXJsYXlSZWYsXG4gIENvbXBvbmVudFBvcnRhbCxcbiAgT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uLFxufSBmcm9tICcuLi9jb3JlL2luZGV4JztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGlyIH0gZnJvbSAnLi4vY29yZS9ydGwvZGlyJztcbmltcG9ydCB7IFBsYXRmb3JtIH0gZnJvbSAnLi4vY29yZS9wbGF0Zm9ybS9pbmRleCc7XG5pbXBvcnQgeyBTY3JvbGxEaXNwYXRjaGVyIH0gZnJvbSAnLi4vY29yZS9vdmVybGF5L3Njcm9sbC9zY3JvbGwtZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICcuLi9jb3JlL2NvZXJjaW9uL2Jvb2xlYW4tcHJvcGVydHknO1xuXG5leHBvcnQgdHlwZSBUb29sdGlwUG9zaXRpb24gPSAnbGVmdCcgfCAncmlnaHQnIHwgJ2Fib3ZlJyB8ICdiZWxvdycgfCAnYmVmb3JlJyB8ICdhZnRlcic7XG5cbi8qKiBUaW1lIGluIG1zIHRvIGRlbGF5IGJlZm9yZSBjaGFuZ2luZyB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5IHRvIGhpZGRlbiAqL1xuZXhwb3J0IGNvbnN0IFRPVUNIRU5EX0hJREVfREVMQVkgPSAxNTAwO1xuXG4vKiogVGltZSBpbiBtcyB0byB0aHJvdHRsZSByZXBvc2l0aW9uaW5nIGFmdGVyIHNjcm9sbCBldmVudHMuICovXG5leHBvcnQgY29uc3QgU0NST0xMX1RIUk9UVExFX01TID0gMjA7XG5cbi8qKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHVzZXIgc3VwcGxpZWQgYW4gaW52YWxpZCB0b29sdGlwIHBvc2l0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93TWQyVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUb29sdGlwIHBvc2l0aW9uIFwiJHtwb3NpdGlvbn1cIiBpcyBpbnZhbGlkLmApO1xufVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGF0dGFjaGVzIGEgbWF0ZXJpYWwgZGVzaWduIHRvb2x0aXAgdG8gdGhlIGhvc3QgZWxlbWVudC4gQW5pbWF0ZXMgdGhlIHNob3dpbmcgYW5kXG4gKiBoaWRpbmcgb2YgYSB0b29sdGlwIHByb3ZpZGVkIHBvc2l0aW9uIChkZWZhdWx0cyB0byBiZWxvdyB0aGUgZWxlbWVudCkuXG4gKlxuICogaHR0cHM6Ly9tYXRlcmlhbC5nb29nbGUuY29tL2NvbXBvbmVudHMvdG9vbHRpcHMuaHRtbFxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdG9vbHRpcF0nLFxuICBob3N0OiB7XG4gICAgJyhsb25ncHJlc3MpJzogJ3Nob3coKScsXG4gICAgJyh0b3VjaGVuZCknOiAnaGlkZSgnICsgVE9VQ0hFTkRfSElERV9ERUxBWSArICcpJyxcbiAgfSxcbiAgZXhwb3J0QXM6ICdtZDJUb29sdGlwJyxcbn0pXG5leHBvcnQgY2xhc3MgTWQyVG9vbHRpcCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmO1xuICBfdG9vbHRpcEluc3RhbmNlOiBNZDJUb29sdGlwQ29tcG9uZW50O1xuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBUb29sdGlwUG9zaXRpb24gPSAnYmVsb3cnO1xuICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBBbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGVsZW1lbnQgKi9cbiAgQElucHV0KCd0b29sdGlwLXBvc2l0aW9uJylcbiAgZ2V0IHBvc2l0aW9uKCk6IFRvb2x0aXBQb3NpdGlvbiB7IHJldHVybiB0aGlzLl9wb3NpdGlvbjsgfVxuICBzZXQgcG9zaXRpb24odmFsdWU6IFRvb2x0aXBQb3NpdGlvbikge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG5cbiAgICAgIC8vIFRPRE8oYW5kcmV3anMpOiBXaGVuIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQsIGRvIG5vdCBkZXN0cm95XG4gICAgICAvLyB0aGUgdG9vbHRpcC5cbiAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVRvb2x0aXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogRGlzYWJsZXMgdGhlIGRpc3BsYXkgb2YgdGhlIHRvb2x0aXAuICovXG4gIEBJbnB1dCgndG9vbHRpcERpc2FibGVkJylcbiAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH1cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuXG4gICAgLy8gSWYgdG9vbHRpcCBpcyBkaXNhYmxlZCwgaGlkZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuaGlkZSgwKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIHNob3dpbmcgdGhlIHRvb2x0aXAgYWZ0ZXIgc2hvdyBpcyBjYWxsZWQgKi9cbiAgQElucHV0KCd0b29sdGlwLWRlbGF5Jykgc2hvd0RlbGF5ID0gMDtcblxuICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIGhpZGluZyB0aGUgdG9vbHRpcCBhZnRlciBoaWRlIGlzIGNhbGxlZCAqL1xuICBASW5wdXQoJ3Rvb2x0aXAtaGlkZS1kZWxheScpIGhpZGVEZWxheSA9IDA7XG5cbiAgcHJpdmF0ZSBfbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKiBUaGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgKi9cbiAgQElucHV0KCd0b29sdGlwJykgZ2V0IG1lc3NhZ2UoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlOyB9XG4gIHNldCBtZXNzYWdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc2V0VG9vbHRpcE1lc3NhZ2UodGhpcy5fbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3Njcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgX3BsYXRmb3JtOiBQbGF0Zm9ybSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcikge1xuXG4gICAgLy8gVGhlIG1vdXNlIGV2ZW50cyBzaG91bGRuJ3QgYmUgYm91bmQgb24gaU9TIGRldmljZXMsIGJlY2F1c2VcbiAgICAvLyB0aGV5IGNhbiBwcmV2ZW50IHRoZSBmaXJzdCB0YXAgZnJvbSBmaXJpbmcgaXRzIGNsaWNrIGV2ZW50LlxuICAgIGlmICghX3BsYXRmb3JtLklPUykge1xuICAgICAgX3JlbmRlcmVyLmxpc3RlbihfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicsICgpID0+IHRoaXMuc2hvdygpKTtcbiAgICAgIF9yZW5kZXJlci5saXN0ZW4oX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnLCAoKSA9PiB0aGlzLmhpZGUoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRvb2x0aXAgd2hlbiBkZXN0cm95ZWQuXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTaG93cyB0aGUgdG9vbHRpcCBhZnRlciB0aGUgZGVsYXkgaW4gbXMsIGRlZmF1bHRzIHRvIHRvb2x0aXAtZGVsYXktc2hvdyBvciAwbXMgaWYgbm8gaW5wdXQgKi9cbiAgc2hvdyhkZWxheTogbnVtYmVyID0gdGhpcy5zaG93RGVsYXkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5fbWVzc2FnZSB8fCAhdGhpcy5fbWVzc2FnZS50cmltKCkpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoIXRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fY3JlYXRlVG9vbHRpcCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldFRvb2x0aXBNZXNzYWdlKHRoaXMuX21lc3NhZ2UpO1xuICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5zaG93KHRoaXMuX3Bvc2l0aW9uLCBkZWxheSk7XG4gIH1cblxuICAvKiogSGlkZXMgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIGRlbGF5IGluIG1zLCBkZWZhdWx0cyB0byB0b29sdGlwLWRlbGF5LWhpZGUgb3IgMG1zIGlmIG5vIGlucHV0ICovXG4gIGhpZGUoZGVsYXk6IG51bWJlciA9IHRoaXMuaGlkZURlbGF5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmhpZGUoZGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTaG93cy9oaWRlcyB0aGUgdG9vbHRpcCAqL1xuICB0b2dnbGUoKTogdm9pZCB7XG4gICAgdGhpcy5faXNUb29sdGlwVmlzaWJsZSgpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRvb2x0aXAgaXMgY3VycmVudGx5IHZpc2libGUgdG8gdGhlIHVzZXIgKi9cbiAgX2lzVG9vbHRpcFZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fdG9vbHRpcEluc3RhbmNlICYmIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKTtcbiAgfVxuXG4gIC8qKiBDcmVhdGUgdGhlIHRvb2x0aXAgdG8gZGlzcGxheSAqL1xuICBwcml2YXRlIF9jcmVhdGVUb29sdGlwKCk6IHZvaWQge1xuICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICBsZXQgcG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZDJUb29sdGlwQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UgPSB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaChwb3J0YWwpLmluc3RhbmNlO1xuXG4gICAgLy8gRGlzcG9zZSB0aGUgb3ZlcmxheSB3aGVuIGZpbmlzaGVkIHRoZSBzaG93biB0b29sdGlwLlxuICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5hZnRlckhpZGRlbigpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBDaGVjayBmaXJzdCBpZiB0aGUgdG9vbHRpcCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgdGhyb3VnaCB0aGlzIGNvbXBvbmVudHMgZGVzdHJveS5cbiAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVRvb2x0aXAoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29uZmlnIGFuZCBwb3NpdGlvbiBzdHJhdGVneSAqL1xuICBwcml2YXRlIF9jcmVhdGVPdmVybGF5KCk6IHZvaWQge1xuICAgIGxldCBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW4oKTtcbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9nZXRPdmVybGF5UG9zaXRpb24oKTtcblxuICAgIC8vIENyZWF0ZSBjb25uZWN0ZWQgcG9zaXRpb24gc3RyYXRlZ3kgdGhhdCBsaXN0ZW5zIGZvciBzY3JvbGwgZXZlbnRzIHRvIHJlcG9zaXRpb24uXG4gICAgLy8gQWZ0ZXIgcG9zaXRpb24gY2hhbmdlcyBvY2N1ciBhbmQgdGhlIG92ZXJsYXkgaXMgY2xpcHBlZCBieSBhIHBhcmVudCBzY3JvbGxhYmxlIHRoZW5cbiAgICAvLyBjbG9zZSB0aGUgdG9vbHRpcC5cbiAgICBsZXQgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudFJlZiwgb3JpZ2luLCBwb3NpdGlvbik7XG4gICAgc3RyYXRlZ3kud2l0aFNjcm9sbGFibGVDb250YWluZXJzKHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuZ2V0U2Nyb2xsQ29udGFpbmVycyh0aGlzLl9lbGVtZW50UmVmKSk7XG4gICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoKGNoYW5nZTogYW55KSA9PiB7XG4gICAgICBpZiAoY2hhbmdlLnNjcm9sbGFibGVWaWV3UHJvcGVydGllcy5pc092ZXJsYXlDbGlwcGVkICYmXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSAmJiB0aGlzLl90b29sdGlwSW5zdGFuY2UuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgdGhpcy5oaWRlKDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGNvbmZpZyA9IG5ldyBPdmVybGF5U3RhdGUoKTtcblxuICAgIGNvbmZpZy5kaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICBjb25maWcucG9zaXRpb25TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIGNvbmZpZy5zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKHtcbiAgICAgIHNjcm9sbFRocm90dGxlOiBTQ1JPTExfVEhST1RUTEVfTVNcbiAgICB9KTtcblxuICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICB9XG5cbiAgLyoqIERpc3Bvc2VzIHRoZSBjdXJyZW50IHRvb2x0aXAgYW5kIHRoZSBvdmVybGF5IGl0IGlzIGF0dGFjaGVkIHRvICovXG4gIHByaXZhdGUgX2Rpc3Bvc2VUb29sdGlwKCk6IHZvaWQge1xuICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSA9IG51bGw7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgb3JpZ2luIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcG9zaXRpb24gcHJlZmVyZW5jZSAqL1xuICBfZ2V0T3JpZ2luKCk6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJyB8fCB0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uID09ICdhYm92ZScgPyAndG9wJyA6ICdib3R0b20nIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNEaXJlY3Rpb25MdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnbGVmdCcgfHxcbiAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2JlZm9yZScgJiYgaXNEaXJlY3Rpb25MdHIgfHxcbiAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiAhaXNEaXJlY3Rpb25MdHIpIHtcbiAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ3JpZ2h0JyB8fFxuICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYWZ0ZXInICYmIGlzRGlyZWN0aW9uTHRyIHx8XG4gICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmICFpc0RpcmVjdGlvbkx0cikge1xuICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgfVxuXG4gICAgdGhyb3dNZDJUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodGhpcy5wb3NpdGlvbik7XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgb3ZlcmxheSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIHByZWZlcmVuY2UgKi9cbiAgX2dldE92ZXJsYXlQb3NpdGlvbigpOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYWJvdmUnKSB7XG4gICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJyB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnbGVmdCcgfHxcbiAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2JlZm9yZScgJiYgaXNMdHIgfHxcbiAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiAhaXNMdHIpIHtcbiAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ3JpZ2h0JyB8fFxuICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYWZ0ZXInICYmIGlzTHRyIHx8XG4gICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmICFpc0x0cikge1xuICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgIH1cblxuICAgIHRocm93TWQyVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHRoaXMucG9zaXRpb24pO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgdGhlIHRvb2x0aXAgbWVzc2FnZSBhbmQgcmVwb3NpdGlvbnMgdGhlIG92ZXJsYXkgYWNjb3JkaW5nIHRvIHRoZSBuZXcgbWVzc2FnZSBsZW5ndGggKi9cbiAgcHJpdmF0ZSBfc2V0VG9vbHRpcE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgLy8gTXVzdCB3YWl0IGZvciB0aGUgbWVzc2FnZSB0byBiZSBwYWludGVkIHRvIHRoZSB0b29sdGlwIHNvIHRoYXQgdGhlIG92ZXJsYXkgY2FuIHByb3Blcmx5XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSB0ZXh0LlxuICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuX21hcmtGb3JDaGVjaygpO1xuXG4gICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVG9vbHRpcFZpc2liaWxpdHkgPSAnaW5pdGlhbCcgfCAndmlzaWJsZScgfCAnaGlkZGVuJztcblxuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB0aGUgdG9vbHRpcCdzIGNvbnRlbnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbkBDb21wb25lbnQoe1xuICBcbiAgc2VsZWN0b3I6ICdtZDItdG9vbHRpcCcsXG4gIHRlbXBsYXRlVXJsOiAndG9vbHRpcC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ3Rvb2x0aXAuc2NzcyddLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignc3RhdGUnLCBbXG4gICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKSxcbiAgICAgIHN0YXRlKCdpbml0aWFsJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgc3RhdGUoJ3Zpc2libGUnLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEpJyB9KSksXG4gICAgICBzdGF0ZSgnaGlkZGVuJywgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiB2aXNpYmxlJywgYW5pbWF0ZSgnMTUwbXMgY3ViaWMtYmV6aWVyKDAuMCwgMC4wLCAwLjIsIDEpJykpLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiBoaWRkZW4nLCBhbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpJykpLFxuICAgIF0pXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW3N0eWxlLnpvb21dJzogJ192aXNpYmlsaXR5ID09PSBcInZpc2libGVcIiA/IDEgOiBudWxsJyxcbiAgICAnKGJvZHk6Y2xpY2spJzogJ3RoaXMuX2hhbmRsZUJvZHlJbnRlcmFjdGlvbigpJ1xuICB9LFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIE1kMlRvb2x0aXBDb21wb25lbnQge1xuICAvKiogTWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSB0b29sdGlwICovXG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICAvKiogVGhlIHRpbWVvdXQgSUQgb2YgYW55IGN1cnJlbnQgdGltZXIgc2V0IHRvIHNob3cgdGhlIHRvb2x0aXAgKi9cbiAgX3Nob3dUaW1lb3V0SWQ6IG51bWJlcjtcblxuICAvKiogVGhlIHRpbWVvdXQgSUQgb2YgYW55IGN1cnJlbnQgdGltZXIgc2V0IHRvIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgX2hpZGVUaW1lb3V0SWQ6IG51bWJlcjtcblxuICAvKiogUHJvcGVydHkgd2F0Y2hlZCBieSB0aGUgYW5pbWF0aW9uIGZyYW1ld29yayB0byBzaG93IG9yIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgX3Zpc2liaWxpdHk6IFRvb2x0aXBWaXNpYmlsaXR5ID0gJ2luaXRpYWwnO1xuXG4gIC8qKiBXaGV0aGVyIGludGVyYWN0aW9ucyBvbiB0aGUgcGFnZSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgKi9cbiAgX2Nsb3NlT25JbnRlcmFjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgdHJhbnNmb3JtIG9yaWdpbiB1c2VkIGluIHRoZSBhbmltYXRpb24gZm9yIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9vbHRpcCAqL1xuICBfdHJhbnNmb3JtT3JpZ2luOiBzdHJpbmcgPSAnYm90dG9tJztcblxuICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdGhlIHZpZXcgKi9cbiAgcHJpdmF0ZSBfb25IaWRlOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKCBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpciwgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICAvKipcbiAgICogU2hvd3MgdGhlIHRvb2x0aXAgd2l0aCBhbiBhbmltYXRpb24gb3JpZ2luYXRpbmcgZnJvbSB0aGUgcHJvdmlkZWQgb3JpZ2luXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBQb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC5cbiAgICogQHBhcmFtIGRlbGF5IEFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGRlbGF5IHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAqL1xuICBzaG93KHBvc2l0aW9uOiBUb29sdGlwUG9zaXRpb24sIGRlbGF5OiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgaGlkZSBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICBpZiAodGhpcy5faGlkZVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lb3V0SWQpO1xuICAgIH1cblxuICAgIC8vIEJvZHkgaW50ZXJhY3Rpb25zIHNob3VsZCBjYW5jZWwgdGhlIHRvb2x0aXAgaWYgdGhlcmUgaXMgYSBkZWxheSBpbiBzaG93aW5nLlxuICAgIHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IHRydWU7XG5cbiAgICB0aGlzLl9zZXRUcmFuc2Zvcm1PcmlnaW4ocG9zaXRpb24pO1xuICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cbiAgICAgIC8vIElmIHRoaXMgd2FzIHNldCB0byB0cnVlIGltbWVkaWF0ZWx5LCB0aGVuIGEgYm9keSBjbGljayB0aGF0IHRyaWdnZXJzIHNob3coKSB3b3VsZFxuICAgICAgLy8gdHJpZ2dlciBpbnRlcmFjdGlvbiBhbmQgY2xvc2UgdGhlIHRvb2x0aXAgcmlnaHQgYWZ0ZXIgaXQgd2FzIGRpc3BsYXllZC5cbiAgICAgIHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAvLyBNYXJrIGZvciBjaGVjayBzbyBpZiBhbnkgcGFyZW50IGNvbXBvbmVudCBoYXMgc2V0IHRoZVxuICAgICAgLy8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgdG8gT25QdXNoIGl0IHdpbGwgYmUgY2hlY2tlZCBhbnl3YXlzXG4gICAgICB0aGlzLl9tYXJrRm9yQ2hlY2soKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZSwgMCk7XG4gICAgfSwgZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZ2lucyB0aGUgYW5pbWF0aW9uIHRvIGhpZGUgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIHByb3ZpZGVkIGRlbGF5IGluIG1zLlxuICAgKiBAcGFyYW0gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgKi9cbiAgaGlkZShkZWxheTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQ2FuY2VsIHRoZSBkZWxheWVkIHNob3cgaWYgaXQgaXMgc2NoZWR1bGVkXG4gICAgaWYgKHRoaXMuX3Nob3dUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93VGltZW91dElkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oaWRlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl92aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICB0aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24gPSBmYWxzZTtcblxuICAgICAgLy8gTWFyayBmb3IgY2hlY2sgc28gaWYgYW55IHBhcmVudCBjb21wb25lbnQgaGFzIHNldCB0aGVcbiAgICAgIC8vIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IHRvIE9uUHVzaCBpdCB3aWxsIGJlIGNoZWNrZWQgYW55d2F5c1xuICAgICAgdGhpcy5fbWFya0ZvckNoZWNrKCk7XG4gICAgfSwgZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdmlld1xuICAgKi9cbiAgYWZ0ZXJIaWRkZW4oKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX29uSGlkZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIGJlaW5nIGRpc3BsYXllZFxuICAgKi9cbiAgaXNWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmlsaXR5ID09PSAndmlzaWJsZSc7XG4gIH1cblxuICAvKiogU2V0cyB0aGUgdG9vbHRpcCB0cmFuc2Zvcm0gb3JpZ2luIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcCBwb3NpdGlvbiAqL1xuICBfc2V0VHJhbnNmb3JtT3JpZ2luKHZhbHVlOiBUb29sdGlwUG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0x0ciA9ICF0aGlzLl9kaXIgfHwgdGhpcy5fZGlyLnZhbHVlID09ICdsdHInO1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgJ2JlZm9yZSc6IHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IGlzTHRyID8gJ3JpZ2h0JyA6ICdsZWZ0JzsgYnJlYWs7XG4gICAgICBjYXNlICdhZnRlcic6IHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IGlzTHRyID8gJ2xlZnQnIDogJ3JpZ2h0JzsgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzogdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3JpZ2h0JzsgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6IHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0JzsgYnJlYWs7XG4gICAgICBjYXNlICdhYm92ZSc6IHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdib3R0b20nOyBicmVhaztcbiAgICAgIGNhc2UgJ2JlbG93JzogdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3RvcCc7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3dNZDJUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIF9hZnRlclZpc2liaWxpdHlBbmltYXRpb24oZTogQW5pbWF0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoZS50b1N0YXRlID09PSAnaGlkZGVuJyAmJiAhdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgdGhpcy5fb25IaWRlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJhY3Rpb25zIG9uIHRoZSBIVE1MIGJvZHkgc2hvdWxkIGNsb3NlIHRoZSB0b29sdGlwIGltbWVkaWF0ZWx5IGFzIGRlZmluZWQgaW4gdGhlXG4gICAqIG1hdGVyaWFsIGRlc2lnbiBzcGVjLlxuICAgKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sI3Rvb2x0aXBzLWludGVyYWN0aW9uXG4gICAqL1xuICBfaGFuZGxlQm9keUludGVyYWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIHRoaXMuaGlkZSgwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgdGhhdCB0aGUgdG9vbHRpcCBuZWVkcyB0byBiZSBjaGVja2VkIGluIHRoZSBuZXh0IGNoYW5nZSBkZXRlY3Rpb24gcnVuLlxuICAgKiBNYWlubHkgdXNlZCBmb3IgcmVuZGVyaW5nIHRoZSBpbml0aWFsIHRleHQgYmVmb3JlIHBvc2l0aW9uaW5nIGEgdG9vbHRpcCwgd2hpY2hcbiAgICogY2FuIGJlIHByb2JsZW1hdGljIGluIGNvbXBvbmVudHMgd2l0aCBPblB1c2ggY2hhbmdlIGRldGVjdGlvbi5cbiAgICovXG4gIF9tYXJrRm9yQ2hlY2soKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPdmVybGF5TW9kdWxlLCBNZENvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGV9IGZyb20gJy4uL2NvcmUvaW5kZXgnO1xuaW1wb3J0IHtNZDJUb29sdGlwLCBNZDJUb29sdGlwQ29tcG9uZW50fSBmcm9tICcuL3Rvb2x0aXAnO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtPdmVybGF5TW9kdWxlLCBNZENvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGVdLFxuICBleHBvcnRzOiBbTWQyVG9vbHRpcCwgTWQyVG9vbHRpcENvbXBvbmVudCwgTWRDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtNZDJUb29sdGlwLCBNZDJUb29sdGlwQ29tcG9uZW50XSxcbiAgZW50cnlDb21wb25lbnRzOiBbTWQyVG9vbHRpcENvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIE1kMlRvb2x0aXBNb2R1bGUge31cblxuXG5leHBvcnQgKiBmcm9tICcuL3Rvb2x0aXAnO1xuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtcbiAgTWRSaXBwbGVNb2R1bGUsXG4gIFJ0bE1vZHVsZSxcbiAgUG9ydGFsTW9kdWxlLFxuICBPdmVybGF5TW9kdWxlLFxuICBBMTF5TW9kdWxlLFxuICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICBNZE5hdGl2ZURhdGVNb2R1bGUsXG59IGZyb20gJy4vY29yZS9pbmRleCc7XG5cbmltcG9ydCB7IE1kMkFjY29yZGlvbk1vZHVsZSB9IGZyb20gJy4vYWNjb3JkaW9uL2luZGV4JztcbmltcG9ydCB7IE1kMkF1dG9jb21wbGV0ZU1vZHVsZSB9IGZyb20gJy4vYXV0b2NvbXBsZXRlL2luZGV4JztcbmltcG9ydCB7IE1kMkNoaXBzTW9kdWxlIH0gZnJvbSAnLi9jaGlwcy9jaGlwcyc7XG5pbXBvcnQgeyBNZDJDb2xsYXBzZU1vZHVsZSB9IGZyb20gJy4vY29sbGFwc2UvaW5kZXgnO1xuaW1wb3J0IHsgTWQyQ29sb3JwaWNrZXJNb2R1bGUgfSBmcm9tICcuL2NvbG9ycGlja2VyL2luZGV4JztcbmltcG9ydCB7IE1kMkRhdGFUYWJsZU1vZHVsZSB9IGZyb20gJy4vZGF0YS10YWJsZS9kYXRhLXRhYmxlJztcbmltcG9ydCB7IE1kMkRhdGVwaWNrZXJNb2R1bGUgfSBmcm9tICcuL2RhdGVwaWNrZXIvaW5kZXgnO1xuaW1wb3J0IHsgTWQyRGlhbG9nTW9kdWxlIH0gZnJvbSAnLi9kaWFsb2cvaW5kZXgnO1xuaW1wb3J0IHsgTWQyTWVudU1vZHVsZSB9IGZyb20gJy4vbWVudS9tZW51JztcbmltcG9ydCB7IE1kMlNlbGVjdE1vZHVsZSB9IGZyb20gJy4vc2VsZWN0L2luZGV4JztcbmltcG9ydCB7IE1kMlRhYnNNb2R1bGUgfSBmcm9tICcuL3RhYnMvdGFicyc7XG5pbXBvcnQgeyBNZDJUYWdzTW9kdWxlIH0gZnJvbSAnLi90YWdzL2luZGV4JztcbmltcG9ydCB7IE1kMlRvYXN0TW9kdWxlIH0gZnJvbSAnLi90b2FzdC9pbmRleCc7XG5pbXBvcnQgeyBNZDJUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi90b29sdGlwL2luZGV4JztcblxuaW1wb3J0IHsgUGxhdGZvcm1Nb2R1bGUgfSBmcm9tICcuL2NvcmUvcGxhdGZvcm0vaW5kZXgnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICcuL2NvcmUvc3R5bGUvaW5kZXgnO1xuXG5jb25zdCBNRDJfTU9EVUxFUyA9IFtcbiAgTWQyQWNjb3JkaW9uTW9kdWxlLFxuICBNZDJBdXRvY29tcGxldGVNb2R1bGUsXG4gIE1kMkNoaXBzTW9kdWxlLFxuICBNZDJDb2xsYXBzZU1vZHVsZSxcbiAgTWQyQ29sb3JwaWNrZXJNb2R1bGUsXG4gIE1kMkRhdGFUYWJsZU1vZHVsZSxcbiAgTWQyRGF0ZXBpY2tlck1vZHVsZSxcbiAgTWQyRGlhbG9nTW9kdWxlLFxuICBNZDJNZW51TW9kdWxlLFxuICBNZFJpcHBsZU1vZHVsZSxcbiAgTWQyU2VsZWN0TW9kdWxlLFxuICBNZDJUYWJzTW9kdWxlLFxuICBNZDJUYWdzTW9kdWxlLFxuICBNZDJUb2FzdE1vZHVsZSxcbiAgTWQyVG9vbHRpcE1vZHVsZSxcbiAgT3ZlcmxheU1vZHVsZSxcbiAgUG9ydGFsTW9kdWxlLFxuICBSdGxNb2R1bGUsXG4gIFN0eWxlTW9kdWxlLFxuICBBMTF5TW9kdWxlLFxuICBQbGF0Zm9ybU1vZHVsZSxcbiAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgTWROYXRpdmVEYXRlTW9kdWxlLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogTUQyX01PRFVMRVMsXG4gIGV4cG9ydHM6IE1EMl9NT0RVTEVTLFxufSlcbmV4cG9ydCBjbGFzcyBNZDJNb2R1bGUgeyB9XG4iXSwibmFtZXMiOlsiSW5qZWN0aW9uVG9rZW4iLCJEaXJlY3RpdmUiLCJPcHRpb25hbCIsIkluamVjdCIsIkVsZW1lbnRSZWYiLCJOZ01vZHVsZSIsImlzRGV2TW9kZSIsIkRPQ1VNRU5UIiwiRXZlbnRFbWl0dGVyIiwiSW5wdXQiLCJPdXRwdXQiLCJIb3N0QmluZGluZyIsIkluamVjdGFibGUiLCJTdWJqZWN0IiwiZGVib3VuY2VUaW1lIiwiU3Vic2NyaXB0aW9uIiwiYXVkaXRUaW1lIiwibWVyZ2UiLCJmcm9tRXZlbnQiLCJOZ1pvbmUiLCJTa2lwU2VsZiIsIlJlbmRlcmVyMiIsInRzbGliXzEuX19leHRlbmRzIiwiQ29tcG9uZW50IiwiVmlld0VuY2Fwc3VsYXRpb24iLCJDb21tb25Nb2R1bGUiLCJUZW1wbGF0ZVJlZiIsIlZpZXdDb250YWluZXJSZWYiLCJDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiQXBwbGljYXRpb25SZWYiLCJJbmplY3RvciIsImZpcnN0IiwiSGFtbWVyR2VzdHVyZUNvbmZpZyIsIm9mIiwidHJpZ2dlciIsInN0YXRlIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwiYW5pbWF0ZSIsIlBpcGUiLCJOR19WQUxVRV9BQ0NFU1NPUiIsImZvcndhcmRSZWYiLCJGb3Jtc01vZHVsZSIsIm5leHRJZCIsIlZpZXdDaGlsZCIsIkhvc3RMaXN0ZW5lciIsIlJlbmRlcmVyIiwiTmdDb250cm9sIiwiU2VsZiIsIl91bmlxdWVJZENvdW50ZXIiLCJzdGFydFdpdGgiLCJmaWx0ZXIiLCJDaGFuZ2VEZXRlY3RvclJlZiIsIkF0dHJpYnV0ZSIsIkNvbnRlbnRDaGlsZHJlbiIsIkl0ZXJhYmxlRGlmZmVycyIsIkRFRkFVTFRfTU9OVEhfTkFNRVMiLCJERUZBVUxUX0RBVEVfTkFNRVMiLCJyYW5nZSIsIkRFRkFVTFRfREFZX09GX1dFRUtfTkFNRVMiLCJmYWRlSW5Db250ZW50Iiwia2V5ZnJhbWVzIiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJOR19WQUxJREFUT1JTIiwiVmFsaWRhdG9ycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBRUEsTUFBYSwyQkFBMkIsR0FBRyxJQUFJQSxtQkFBYyxDQUFVLHVCQUF1QixDQUFDLENBQUM7Ozs7Ozs7OztBQU9oRyxnREFBcUQsTUFBYyxFQUFFLFFBQWdCO01BQ25GLE9BQU8sS0FBSyxDQUFDLFdBQVEsTUFBTSxxRUFBaUU7V0FDM0UseUJBQXNCLFFBQVEsQ0FBQyxXQUFXLEVBQUUsZ0JBQVksQ0FBQSxDQUFDLENBQUM7R0FDNUU7Ozs7QUFHRCxNQUFhLHFCQUFxQixHQUFHLGltQ0EyRHZCLENBQUM7Ozs7QUFHZixNQUFhLG9CQUFvQixHQUFHLHNpQ0EyRHZCLENBQUM7Ozs7O01BS1osMkJBQ21ELG1CQUE0QixFQUM3RSxVQUFzQjtVQUV0QixJQUFJLENBQUMsbUJBQW1CLEVBQUU7Y0FDeEIsTUFBTSxvQ0FBb0MsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztXQUN0RjtPQUNGOztrQkFURkMsY0FBUyxTQUFDLEVBQUMsUUFBUSxFQUFFLHFCQUFxQixFQUFDOzs7OztvREFHdkNDLGFBQVEsWUFBSUMsV0FBTSxTQUFDLDJCQUEyQjtzQkE5SUpDLGVBQVU7Ozs4QkFBekQ7Ozs7OztNQTBKRSwwQkFDbUQsbUJBQTRCLEVBQzdFLFVBQXNCO1VBRXRCLElBQUksbUJBQW1CLEVBQUU7Y0FDdkIsTUFB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